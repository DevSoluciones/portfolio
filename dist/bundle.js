!function(t){var n={};function c(e){if(n[e])return n[e].exports;var l=n[e]={i:e,l:!1,exports:{}};return t[e].call(l.exports,l,l.exports,c),l.l=!0,l.exports}c.m=t,c.c=n,c.d=function(t,n,e){c.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:e})},c.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},c.t=function(t,n){if(1&n&&(t=c(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.__esModule)return t;var e=Object.create(null);if(c.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var l in t)c.d(e,l,function(n){return t[n]}.bind(null,l));return e},c.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return c.d(n,"a",n),n},c.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},c.p="",c(c.s=2)}([function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v3.4.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2019-05-01T21:04Z\n */\n( function( global, factory ) {\n\n\t"use strict";\n\n\tif (  true && typeof module.exports === "object" ) {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require("jquery")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( "jQuery requires a window with a document" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {\n\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n// enough that all such attempts are guarded in a try block.\n"use strict";\n\nvar arr = [];\n\nvar document = window.document;\n\nvar getProto = Object.getPrototypeOf;\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call( Object );\n\nvar support = {};\n\nvar isFunction = function isFunction( obj ) {\n\n      // Support: Chrome <=57, Firefox <=52\n      // In some browsers, typeof returns "function" for HTML <object> elements\n      // (i.e., `typeof document.createElement( "object" ) === "function"`).\n      // We don\'t want to classify *any* DOM node as a function.\n      return typeof obj === "function" && typeof obj.nodeType !== "number";\n  };\n\n\nvar isWindow = function isWindow( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t};\n\n\n\n\n\tvar preservedScriptAttributes = {\n\t\ttype: true,\n\t\tsrc: true,\n\t\tnonce: true,\n\t\tnoModule: true\n\t};\n\n\tfunction DOMEval( code, node, doc ) {\n\t\tdoc = doc || document;\n\n\t\tvar i, val,\n\t\t\tscript = doc.createElement( "script" );\n\n\t\tscript.text = code;\n\t\tif ( node ) {\n\t\t\tfor ( i in preservedScriptAttributes ) {\n\n\t\t\t\t// Support: Firefox 64+, Edge 18+\n\t\t\t\t// Some browsers don\'t support the "nonce" property on scripts.\n\t\t\t\t// On the other hand, just using `getAttribute` is not enough as\n\t\t\t\t// the `nonce` attribute is reset to an empty string whenever it\n\t\t\t\t// becomes browsing-context connected.\n\t\t\t\t// See https://github.com/whatwg/html/issues/2369\n\t\t\t\t// See https://html.spec.whatwg.org/#nonce-attributes\n\t\t\t\t// The `node.getAttribute` check was added for the sake of\n\t\t\t\t// `jQuery.globalEval` so that it can fake a nonce-containing node\n\t\t\t\t// via an object.\n\t\t\t\tval = node[ i ] || node.getAttribute && node.getAttribute( i );\n\t\t\t\tif ( val ) {\n\t\t\t\t\tscript.setAttribute( i, val );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t}\n\n\nfunction toType( obj ) {\n\tif ( obj == null ) {\n\t\treturn obj + "";\n\t}\n\n\t// Support: Android <=2.3 only (functionish RegExp)\n\treturn typeof obj === "object" || typeof obj === "function" ?\n\t\tclass2type[ toString.call( obj ) ] || "object" :\n\t\ttypeof obj;\n}\n/* global Symbol */\n// Defining this global in .eslintrc.json would create a danger of using the global\n// unguarded in another place, it seems safer to define global only for this module\n\n\n\nvar\n\tversion = "3.4.1",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor \'enhanced\'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android <=4.0 only\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\n\t\t// Return all the elements in a clean array\n\t\tif ( num == null ) {\n\t\t\treturn slice.call( this );\n\t\t}\n\n\t\t// Return just the one element from the set\n\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array\'s method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === "boolean" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== "object" && !isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent Object.prototype pollution\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( name === "__proto__" || target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we\'re merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\n\t\t\t\t\tsrc = target[ name ];\n\n\t\t\t\t\t// Ensure proper type for the source value\n\t\t\t\t\tif ( copyIsArray && !Array.isArray( src ) ) {\n\t\t\t\t\t\tclone = [];\n\t\t\t\t\t} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {\n\t\t\t\t\t\tclone = {};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src;\n\t\t\t\t\t}\n\t\t\t\t\tcopyIsArray = false;\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don\'t bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: "jQuery" + ( version + Math.random() ).replace( /\\D/g, "" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisPlainObject: function( obj ) {\n\t\tvar proto, Ctor;\n\n\t\t// Detect obvious negatives\n\t\t// Use toString instead of jQuery.type to catch host objects\n\t\tif ( !obj || toString.call( obj ) !== "[object Object]" ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tproto = getProto( obj );\n\n\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\tif ( !proto ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\tCtor = hasOwn.call( proto, "constructor" ) && proto.constructor;\n\t\treturn typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code, options ) {\n\t\tDOMEval( code, { nonce: options && options.nonce } );\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android <=4.0 only\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t"" :\n\t\t\t( text + "" ).replace( rtrim, "" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === "string" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t// push.apply(_, arraylike) throws on ancient WebKit\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\nif ( typeof Symbol === "function" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n\n// Populate the class2type map\njQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),\nfunction( i, name ) {\n\tclass2type[ "[object " + name + "]" ] = name.toLowerCase();\n} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn\'t used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && "length" in obj && obj.length,\n\t\ttype = toType( obj );\n\n\tif ( isFunction( obj ) || isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === "array" || length === 0 ||\n\t\ttypeof length === "number" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.3.4\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://js.foundation/\n *\n * Date: 2019-04-08\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = "sizzle" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tnonnativeSelectorCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it\'s faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = "[\\\\x20\\\\t\\\\r\\\\n\\\\f]",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = "(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = "\\\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +\n\t\t// Operator (capture 2)\n\t\t"*([*^$|!~]?=)" + whitespace +\n\t\t// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"\n\t\t"*(?:\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\"|(" + identifier + "))|)" + whitespace +\n\t\t"*\\\\]",\n\n\tpseudos = ":(" + identifier + ")(?:\\\\((" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t"(\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\")|" +\n\t\t// 2. simple (capture 6)\n\t\t"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|" + attributes + ")*)|" +\n\t\t// 3. anything else (capture 2)\n\t\t".*" +\n\t\t")\\\\)|)",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + "+", "g" ),\n\trtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)" + whitespace + "+$", "g" ),\n\n\trcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),\n\trcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),\n\trdescend = new RegExp( whitespace + "|>" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( "^" + identifier + "$" ),\n\n\tmatchExpr = {\n\t\t"ID": new RegExp( "^#(" + identifier + ")" ),\n\t\t"CLASS": new RegExp( "^\\\\.(" + identifier + ")" ),\n\t\t"TAG": new RegExp( "^(" + identifier + "|[*])" ),\n\t\t"ATTR": new RegExp( "^" + attributes ),\n\t\t"PSEUDO": new RegExp( "^" + pseudos ),\n\t\t"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(" + whitespace +\n\t\t\t"*(even|odd|(([+-]|)(\\\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +\n\t\t\t"*(\\\\d+)|))" + whitespace + "*\\\\)|)", "i" ),\n\t\t"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(" +\n\t\t\twhitespace + "*((?:-\\\\d)?\\\\d*)" + whitespace + "*\\\\)|)(?=[^-]|$)", "i" )\n\t},\n\n\trhtml = /HTML$/i,\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( "\\\\\\\\([\\\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = "0x" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +"0x"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === "\\0" ) {\n\t\t\t\treturn "\\uFFFD";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + "\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn "\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a "Permission Denied"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tinDisabledFieldset = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";\n\t\t},\n\t\t{ dir: "parentNode", next: "legend" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can\'t trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== "string" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a "get*By*" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don\'t exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!nonnativeSelectorCache[ selector + " " ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) &&\n\n\t\t\t\t// Support: IE 8 only\n\t\t\t\t// Exclude object elements\n\t\t\t\t(nodeType !== 1 || context.nodeName.toLowerCase() !== "object") ) {\n\n\t\t\t\tnewSelector = selector;\n\t\t\t\tnewContext = context;\n\n\t\t\t\t// qSA considers elements outside a scoping root when evaluating child or\n\t\t\t\t// descendant combinators, which is not what we want.\n\t\t\t\t// In such cases, we work around the behavior by prefixing every selector in the\n\t\t\t\t// list with an ID selector referencing the scope context.\n\t\t\t\t// Thanks to Andrew Dupont for this technique.\n\t\t\t\tif ( nodeType === 1 && rdescend.test( selector ) ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( "id" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( "id", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = "#" + nid + " " + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( "," );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t);\n\t\t\t\t\treturn results;\n\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\tnonnativeSelectorCache( selector, true );\n\t\t\t\t} finally {\n\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\tcontext.removeAttribute( "id" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, "$1" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + " " ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + " " ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement("fieldset");\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split("|"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === "input" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === "input" || name === "button") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( "form" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a "form" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( "label" in elem ) {\n\t\t\t\t\tif ( "label" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\tinDisabledFieldset( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can\'t be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn\'t\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( "label" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== "undefined" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\tvar namespace = elem.namespaceURI,\n\t\tdocElem = (elem.ownerDocument || elem).documentElement;\n\n\t// Support: IE <=8\n\t// Assume HTML when documentElement doesn\'t yet exist, such as inside loading iframes\n\t// https://bugs.jquery.com/ticket/4833\n\treturn !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)\n\tif ( preferredDoc !== document &&\n\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( "unload", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( "onunload", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( el ) {\n\t\tel.className = "i";\n\t\treturn !el.getAttribute("className");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName("*") returns only elements\n\tsupport.getElementsByTagName = assert(function( el ) {\n\t\tel.appendChild( document.createComment("") );\n\t\treturn !el.getElementsByTagName("*").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don\'t pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter["ID"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute("id") === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find["ID"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== "undefined" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter["ID"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== "undefined" &&\n\t\t\t\t\telem.getAttributeNode("id");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find["ID"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== "undefined" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode("id");\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode("id");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find["TAG"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== "undefined" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don\'t have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === "*" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( el ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE\'s treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = "<a id=\'" + expando + "\'></a>" +\n\t\t\t\t"<select id=\'" + expando + "-\\r\\\\\' msallowcapture=\'\'>" +\n\t\t\t\t"<option selected=\'\'></option></select>";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but "safe" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll("[msallowcapture^=\'\']").length ) {\n\t\t\t\trbuggyQSA.push( "[*^$]=" + whitespace + "*(?:\'\'|\\"\\")" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and "value" are not treated correctly\n\t\t\tif ( !el.querySelectorAll("[selected]").length ) {\n\t\t\t\trbuggyQSA.push( "\\\\[" + whitespace + "*(?:value|" + booleans + ")" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {\n\t\t\t\trbuggyQSA.push("~=");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll(":checked").length ) {\n\t\t\t\trbuggyQSA.push(":checked");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {\n\t\t\t\trbuggyQSA.push(".#.+[+~]");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( el ) {\n\t\t\tel.innerHTML = "<a href=\'\' disabled=\'disabled\'></a>" +\n\t\t\t\t"<select disabled=\'disabled\'><option/></select>";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement("input");\n\t\t\tinput.setAttribute( "type", "hidden" );\n\t\t\tel.appendChild( input ).setAttribute( "name", "D" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll("[name=d]").length ) {\n\t\t\t\trbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll(":enabled").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( ":enabled", ":disabled" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE\'s :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll(":disabled").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( ":enabled", ":disabled" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll("*,:x");\n\t\t\trbuggyQSA.push(",.*:");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( el ) {\n\t\t\t// Check to see if it\'s possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, "*" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, "[s!=\'\']:x" );\n\t\t\trbuggyMatches.push( "!=", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!nonnativeSelectorCache[ expr + " " ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9\'s matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tnonnativeSelectorCache( expr, true );\n\t\t}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don\'t get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn (sel + "").replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( "Syntax error, unrecognized expression: " + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = "",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === "string" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t">": { dir: "parentNode", first: true },\n\t\t" ": { dir: "parentNode" },\n\t\t"+": { dir: "previousSibling", first: true },\n\t\t"~": { dir: "previousSibling" }\n\t},\n\n\tpreFilter: {\n\t\t"ATTR": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === "~=" ) {\n\t\t\t\tmatch[3] = " " + match[3] + " ";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t"CHILD": function( match ) {\n\t\t\t/* matches from matchExpr["CHILD"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === "nth" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t"PSEUDO": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr["CHILD"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || "";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t"TAG": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === "*" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t"CLASS": function( className ) {\n\t\t\tvar pattern = classCache[ className + " " ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );\n\t\t\t\t});\n\t\t},\n\n\t\t"ATTR": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === "!=";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += "";\n\n\t\t\t\treturn operator === "=" ? result === check :\n\t\t\t\t\toperator === "!=" ? result !== check :\n\t\t\t\t\toperator === "^=" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === "*=" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === "$=" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t"CHILD": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== "nth",\n\t\t\t\tforward = type.slice( -4 ) !== "last",\n\t\t\t\tofType = what === "of-type";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? "nextSibling" : "previousSibling",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven\'t yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === "only" && !start && "nextSibling";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t"PSEUDO": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( "unsupported pseudo: " + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, "", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t"not": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, "$1" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don\'t keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t"has": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t"contains": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// "Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element\'s language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by "-".\n\t\t// The matching of C against the element\'s language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name."\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t"lang": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || "") ) {\n\t\t\t\tSizzle.error( "unsupported lang: " + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t"target": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t"root": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t"focus": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t"enabled": createDisabledPseudo( false ),\n\t\t"disabled": createDisabledPseudo( true ),\n\n\t\t"checked": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);\n\t\t},\n\n\t\t"selected": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t"empty": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t"parent": function( elem ) {\n\t\t\treturn !Expr.pseudos["empty"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t"header": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t"input": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t"button": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === "input" && elem.type === "button" || name === "button";\n\t\t},\n\n\t\t"text": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === "input" &&\n\t\t\t\telem.type === "text" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"\n\t\t\t\t( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t"first": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t"last": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t"even": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t"odd": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ?\n\t\t\t\targument + length :\n\t\t\t\targument > length ?\n\t\t\t\t\tlength :\n\t\t\t\t\targument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos["nth"] = Expr.pseudos["eq"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + " " ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don\'t consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, " " )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we\'re just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = "";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === "parentNode",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can\'t set arbitrary data on XML nodes, so they don\'t benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we\'re done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[" "],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })\n\t\t\t\t\t).replace( rtrim, "$1" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = "0",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find["TAG"]( "*", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn\'t visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a "00" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + " " ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle\'s compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === "function" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&\n\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split("").sort( sortOrder ).join("") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren\'t passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( el ) {\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement("fieldset") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property "interpolation"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( el ) {\n\tel.innerHTML = "<a href=\'#\'></a>";\n\treturn el.firstChild.getAttribute("href") === "#" ;\n}) ) {\n\taddHandle( "type|href|height|width", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute("value")\nif ( !support.attributes || !assert(function( el ) {\n\tel.innerHTML = "<input/>";\n\tel.firstChild.setAttribute( "value", "" );\n\treturn el.firstChild.getAttribute( "value" ) === "";\n}) ) {\n\taddHandle( "value", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === "input" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( el ) {\n\treturn el.getAttribute("disabled") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\n\n// Deprecated\njQuery.expr[ ":" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\njQuery.escapeSelector = Sizzle.escape;\n\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\n\n\nfunction nodeName( elem, name ) {\n\n  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\n};\nvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\n\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\t}\n\n\t// Single element\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\t}\n\n\t// Arraylike of elements (jQuery, arguments, Array)\n\tif ( typeof qualifier !== "string" ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t} );\n\t}\n\n\t// Filtered directly for both simple and complex selectors\n\treturn jQuery.filter( qualifier, elements, not );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = ":not(" + expr + ")";\n\t}\n\n\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t}\n\n\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\treturn elem.nodeType === 1;\n\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i, ret,\n\t\t\tlen = this.length,\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== "string" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tret = this.pushStack( [] );\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $("p:first").is("p:last") won\'t return true for a doc with two "p".\n\t\t\ttypeof selector === "string" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(""), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === "string" ) {\n\t\t\tif ( selector[ 0 ] === "<" &&\n\t\t\t\tselector[ selector.length - 1 ] === ">" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\ttargets = typeof selectors !== "string" && jQuery( selectors );\n\n\t\t// Positional selectors never match, since there\'s no _selection_ context\n\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\n\t\t\t\t\t\t// Don\'t pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === "string" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, "parentNode" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn dir( elem, "parentNode", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, "nextSibling" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, "previousSibling" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, "nextSibling" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, "previousSibling" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn dir( elem, "nextSibling", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn dir( elem, "previousSibling", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\tif ( typeof elem.contentDocument !== "undefined" ) {\n\t\t\treturn elem.contentDocument;\n\t\t}\n\n\t\t// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n\t\t// Treat the template element as a regular one in browsers that\n\t\t// don\'t support it.\n\t\tif ( nodeName( elem, "template" ) ) {\n\t\t\telem = elem.content || elem;\n\t\t}\n\n\t\treturn jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== "Until" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === "string" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * "fired" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest "memorized"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === "string" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = locked || options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn\'t re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we\'re done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we\'re done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = "";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && toType( arg ) !== "string" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = "";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = "";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\nfunction Identity( v ) {\n\treturn v;\n}\nfunction Thrower( ex ) {\n\tthrow ex;\n}\n\nfunction adoptValue( value, resolve, reject, noValue ) {\n\tvar method;\n\n\ttry {\n\n\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\tif ( value && isFunction( ( method = value.promise ) ) ) {\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\n\t\t// Other thenables\n\t\t} else if ( value && isFunction( ( method = value.then ) ) ) {\n\t\t\tmethod.call( value, resolve, reject );\n\n\t\t// Other non-thenables\n\t\t} else {\n\n\t\t\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n\t\t\t// * false: [ value ].slice( 0 ) => resolve( value )\n\t\t\t// * true: [ value ].slice( 1 ) => resolve()\n\t\t\tresolve.apply( undefined, [ value ].slice( noValue ) );\n\t\t}\n\n\t// For Promises/A+, convert exceptions into rejections\n\t// Since jQuery.when doesn\'t unwrap thenables, we can skip the extra checks appearing in\n\t// Deferred#then to conditionally suppress rejection.\n\t} catch ( value ) {\n\n\t\t// Support: Android 4.0 only\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\treject.apply( undefined, [ value ] );\n\t}\n}\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t[ "notify", "progress", jQuery.Callbacks( "memory" ),\n\t\t\t\t\tjQuery.Callbacks( "memory" ), 2 ],\n\t\t\t\t[ "resolve", "done", jQuery.Callbacks( "once memory" ),\n\t\t\t\t\tjQuery.Callbacks( "once memory" ), 0, "resolved" ],\n\t\t\t\t[ "reject", "fail", jQuery.Callbacks( "once memory" ),\n\t\t\t\t\tjQuery.Callbacks( "once memory" ), 1, "rejected" ]\n\t\t\t],\n\t\t\tstate = "pending",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t"catch": function( fn ) {\n\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + "With" ](\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( "Thenable self-resolution" );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\tthen = returned &&\n\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t( typeof returned === "object" ||\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === "function" ) &&\n\t\t\t\t\t\t\t\t\t\treturned.then;\n\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\tif ( isFunction( then ) ) {\n\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it\'s otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 5 ];\n\n\t\t\t// promise.progress = list.add\n\t\t\t// promise.done = list.add\n\t\t\t// promise.fail = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(\n\t\t\t\t\tfunction() {\n\n\t\t\t\t\t\t// state = "resolved" (i.e., fulfilled)\n\t\t\t\t\t\t// state = "rejected"\n\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\n\t\t\t\t\t// rejected_handlers.disable\n\t\t\t\t\t// fulfilled_handlers.disable\n\t\t\t\t\ttuples[ 3 - i ][ 3 ].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock,\n\n\t\t\t\t\t// progress_handlers.lock\n\t\t\t\t\ttuples[ 0 ][ 3 ].lock\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// progress_handlers.fire\n\t\t\t// fulfilled_handlers.fire\n\t\t\t// rejected_handlers.fire\n\t\t\tlist.add( tuple[ 3 ].fire );\n\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\tdeferred[ tuple[ 0 ] + "With" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( singleValue ) {\n\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array( i ),\n\t\t\tresolveValues = slice.call( arguments ),\n\n\t\t\t// the master Deferred\n\t\t\tmaster = jQuery.Deferred(),\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function( i ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\tif ( remaining <= 1 ) {\n\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,\n\t\t\t\t!remaining );\n\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\tif ( master.state() === "pending" ||\n\t\t\t\tisFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\n\t\t\t\treturn master.then();\n\t\t\t}\n\t\t}\n\n\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\twhile ( i-- ) {\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n\t\t}\n\n\t\treturn master.promise();\n\t}\n} );\n\n\n// These usually indicate a programmer mistake during development,\n// warn about them ASAP rather than swallowing them by default.\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\njQuery.Deferred.exceptionHook = function( error, stack ) {\n\n\t// Support: IE 8 - 9 only\n\t// Console exists when dev tools are open, which can happen at any time\n\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\twindow.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );\n\t}\n};\n\n\n\n\njQuery.readyException = function( error ) {\n\twindow.setTimeout( function() {\n\t\tthrow error;\n\t} );\n};\n\n\n\n\n// The deferred used on DOM ready\nvar readyList = jQuery.Deferred();\n\njQuery.fn.ready = function( fn ) {\n\n\treadyList\n\t\t.then( fn )\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch( function( error ) {\n\t\t\tjQuery.readyException( error );\n\t\t} );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we\'re already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\t}\n} );\n\njQuery.ready.then = readyList.then;\n\n// The ready event handler and self cleanup method\nfunction completed() {\n\tdocument.removeEventListener( "DOMContentLoaded", completed );\n\twindow.removeEventListener( "load", completed );\n\tjQuery.ready();\n}\n\n// Catch cases where $(document).ready() is called\n// after the browser event has already occurred.\n// Support: IE <=9 - 10 only\n// Older IE sometimes signals "interactive" too soon\nif ( document.readyState === "complete" ||\n\t( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {\n\n\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\twindow.setTimeout( jQuery.ready );\n\n} else {\n\n\t// Use the handy event callback\n\tdocument.addEventListener( "DOMContentLoaded", completed );\n\n\t// A fallback to window.onload, that will always work\n\twindow.addEventListener( "load", completed );\n}\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it\'s a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( toType( key ) === "object" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\tvalue :\n\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( chainable ) {\n\t\treturn elems;\n\t}\n\n\t// Gets\n\tif ( bulk ) {\n\t\treturn fn.call( elems );\n\t}\n\n\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n};\n\n\n// Matches dashed string for camelizing\nvar rmsPrefix = /^-ms-/,\n\trdashAlpha = /-([a-z])/g;\n\n// Used by camelCase as callback to replace()\nfunction fcamelCase( all, letter ) {\n\treturn letter.toUpperCase();\n}\n\n// Convert dashed to camelCase; used by the css and data modules\n// Support: IE <=9 - 11, Edge 12 - 15\n// Microsoft forgot to hump their vendor prefix (#9572)\nfunction camelCase( string ) {\n\treturn string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );\n}\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tcache: function( owner ) {\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\t// Always use camelCase key (gh-2257)\n\t\tif ( typeof data === "string" ) {\n\t\t\tcache[ camelCase( data ) ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ camelCase( prop ) ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];\n\t},\n\taccess: function( owner, key, value ) {\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the "read" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === "string" ) && value === undefined ) ) {\n\n\t\t\treturn this.get( owner, key );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the "set" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key !== undefined ) {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( Array.isArray( key ) ) {\n\n\t\t\t\t// If key is an array of keys...\n\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\tkey = key.map( camelCase );\n\t\t\t} else {\n\t\t\t\tkey = camelCase( key );\n\n\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\tkey = key in cache ?\n\t\t\t\t\t[ key ] :\n\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t}\n\n\t\t\ti = key.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there\'s no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <=35 - 45\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module\'s maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support "private" and "user" data.\n//\t4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction getData( data ) {\n\tif ( data === "true" ) {\n\t\treturn true;\n\t}\n\n\tif ( data === "false" ) {\n\t\treturn false;\n\t}\n\n\tif ( data === "null" ) {\n\t\treturn null;\n\t}\n\n\t// Only convert to a number if it doesn\'t change the string\n\tif ( data === +data + "" ) {\n\t\treturn +data;\n\t}\n\n\tif ( rbrace.test( data ) ) {\n\t\treturn JSON.parse( data );\n\t}\n\n\treturn data;\n}\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === "string" ) {\n\t\t\ttry {\n\t\t\t\tdata = getData( data );\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn\'t changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( "data-" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, "hasDataAttrs", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === "object" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to "discover" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn\'t exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each( function() {\n\n\t\t\t\t// We always store the camelCased key\n\t\t\t\tdataUser.set( this, key, value );\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || "fx" ) + "queue";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || Array.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || "fx";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === "inprogress" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === "fx" ) {\n\t\t\t\tqueue.unshift( "inprogress" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + "queueHooks";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( "once memory" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + "queue", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== "string" ) {\n\t\t\tdata = type;\n\t\t\ttype = "fx";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === "fx" && queue[ 0 ] !== "inprogress" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || "fx", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== "string" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || "fx";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + "queueHooks" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );\n\n\nvar cssExpand = [ "Top", "Right", "Bottom", "Left" ];\n\nvar documentElement = document.documentElement;\n\n\n\n\tvar isAttached = function( elem ) {\n\t\t\treturn jQuery.contains( elem.ownerDocument, elem );\n\t\t},\n\t\tcomposed = { composed: true };\n\n\t// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only\n\t// Check attachment across shadow DOM boundaries when possible (gh-3504)\n\t// Support: iOS 10.0-10.2 only\n\t// Early iOS 10 versions support `attachShadow` but not `getRootNode`,\n\t// leading to errors. We need to check for `getRootNode`.\n\tif ( documentElement.getRootNode ) {\n\t\tisAttached = function( elem ) {\n\t\t\treturn jQuery.contains( elem.ownerDocument, elem ) ||\n\t\t\t\telem.getRootNode( composed ) === elem.ownerDocument;\n\t\t};\n\t}\nvar isHiddenWithinTree = function( elem, el ) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === "none" ||\n\t\t\telem.style.display === "" &&\n\n\t\t\t// Otherwise, check computed style\n\t\t\t// Support: Firefox <=43 - 45\n\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t// in the document.\n\t\t\tisAttached( elem ) &&\n\n\t\t\tjQuery.css( elem, "display" ) === "none";\n\t};\n\nvar swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted, scale,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() {\n\t\t\t\treturn tween.cur();\n\t\t\t} :\n\t\t\tfunction() {\n\t\t\t\treturn jQuery.css( elem, prop, "" );\n\t\t\t},\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = elem.nodeType &&\n\t\t\t( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Support: Firefox <=54\n\t\t// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n\t\tinitial = initial / 2;\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\twhile ( maxIterations-- ) {\n\n\t\t\t// Evaluate and update our best guess (doubling guesses that zero out).\n\t\t\t// Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\t\t\tif ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {\n\t\t\t\tmaxIterations = 0;\n\t\t\t}\n\t\t\tinitialInUnit = initialInUnit / scale;\n\n\t\t}\n\n\t\tinitialInUnit = initialInUnit * 2;\n\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\n\n\nvar defaultDisplayMap = {};\n\nfunction getDefaultDisplay( elem ) {\n\tvar temp,\n\t\tdoc = elem.ownerDocument,\n\t\tnodeName = elem.nodeName,\n\t\tdisplay = defaultDisplayMap[ nodeName ];\n\n\tif ( display ) {\n\t\treturn display;\n\t}\n\n\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\tdisplay = jQuery.css( temp, "display" );\n\n\ttemp.parentNode.removeChild( temp );\n\n\tif ( display === "none" ) {\n\t\tdisplay = "block";\n\t}\n\tdefaultDisplayMap[ nodeName ] = display;\n\n\treturn display;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\t// Determine new display value for elements that need to change\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t// inline or about-to-be-restored)\n\t\t\tif ( display === "none" ) {\n\t\t\t\tvalues[ index ] = dataPriv.get( elem, "display" ) || null;\n\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\telem.style.display = "";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {\n\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( display !== "none" ) {\n\t\t\t\tvalues[ index ] = "none";\n\n\t\t\t\t// Remember what we\'re overwriting\n\t\t\t\tdataPriv.set( elem, "display", display );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of the elements in a second loop to avoid constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\tif ( values[ index ] != null ) {\n\t\t\telements[ index ].style.display = values[ index ];\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend( {\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === "boolean" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i );\n\nvar rscriptType = ( /^$|^module$|\\/(?:java|ecma)script/i );\n\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\n\t// Support: IE <=9 only\n\toption: [ 1, "<select multiple=\'multiple\'>", "</select>" ],\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, "<table>", "</table>" ],\n\tcol: [ 2, "<table><colgroup>", "</colgroup></table>" ],\n\ttr: [ 2, "<table><tbody>", "</tbody></table>" ],\n\ttd: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],\n\n\t_default: [ 0, "", "" ]\n};\n\n// Support: IE <=9 only\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE <=9 - 11 only\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\tvar ret;\n\n\tif ( typeof context.getElementsByTagName !== "undefined" ) {\n\t\tret = context.getElementsByTagName( tag || "*" );\n\n\t} else if ( typeof context.querySelectorAll !== "undefined" ) {\n\t\tret = context.querySelectorAll( tag || "*" );\n\n\t} else {\n\t\tret = [];\n\t}\n\n\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\n\t\treturn jQuery.merge( [ context ], ret );\n\t}\n\n\treturn ret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t"globalEval",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], "globalEval" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, attached, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( toType( elem ) === "object" ) {\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( "div" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\ttmp.textContent = "";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = "";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tattached = isAttached( elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), "script" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( attached ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || "" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( "div" ) ),\n\t\tinput = document.createElement( "input" );\n\n\t// Support: Android 4.0 - 4.3 only\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( "type", "radio" );\n\tinput.setAttribute( "checked", "checked" );\n\tinput.setAttribute( "name", "t" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Android <=4.1 only\n\t// Older WebKit doesn\'t clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE <=11 only\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = "<textarea>x</textarea>";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n} )();\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE <=9 - 11+\n// focus() and blur() are asynchronous, except when they are no-op.\n// So expect focus to be synchronous when the element is already active,\n// and blur to be synchronous when the element is not already active.\n// (focus and blur are always synchronous in other supported browsers,\n// this just defines when we can count on it).\nfunction expectSync( elem, type ) {\n\treturn ( elem === safeActiveElement() ) === ( type === "focus" );\n}\n\n// Support: IE <=9 only\n// Accessing document.activeElement can throw unexpectedly\n// https://bugs.jquery.com/ticket/13393\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === "object" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== "string" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === "string" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards\' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Don\'t attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\tif ( selector ) {\n\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element\'s event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || "" ).match( rnothtmlwhite ) || [ "" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( "." )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we\'re the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element\'s handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || "" ).match( rnothtmlwhite ) || [ "" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( "(^|\\\\.)" + namespaces.join( "\\\\.(?:.*\\\\.|)" ) + "(\\\\.|$)" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === "**" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it\'s no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, "handle events" );\n\t\t}\n\t},\n\n\tdispatch: function( nativeEvent ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tvar event = jQuery.event.fix( nativeEvent );\n\n\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\targs = new Array( arguments.length ),\n\t\t\thandlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\n\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// If the event is namespaced, then each handler is only invoked if it is\n\t\t\t\t// specially universal or its namespaces are a superset of the event\'s.\n\t\t\t\tif ( !event.rnamespace || handleObj.namespace === false ||\n\t\t\t\t\tevent.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\tif ( delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!( event.type === "click" && event.button >= 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don\'t check non-elements (#13208)\n\t\t\t\t// Don\'t process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {\n\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don\'t conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + " ";\n\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tcur = this;\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\taddProp: function( name, hook ) {\n\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget: isFunction( hook ) ?\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t}\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\tset: function( value ) {\n\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: value\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t},\n\n\tfix: function( originalEvent ) {\n\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\toriginalEvent :\n\t\t\tnew jQuery.Event( originalEvent );\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tclick: {\n\n\t\t\t// Utilize native event to ensure correct state for checkable inputs\n\t\t\tsetup: function( data ) {\n\n\t\t\t\t// For mutual compressibility with _default, replace `this` access with a local var.\n\t\t\t\t// `|| data` is dead code meant only to preserve the variable through minification.\n\t\t\t\tvar el = this || data;\n\n\t\t\t\t// Claim the first handler\n\t\t\t\tif ( rcheckableType.test( el.type ) &&\n\t\t\t\t\tel.click && nodeName( el, "input" ) ) {\n\n\t\t\t\t\t// dataPriv.set( el, "click", ... )\n\t\t\t\t\tleverageNative( el, "click", returnTrue );\n\t\t\t\t}\n\n\t\t\t\t// Return false to allow normal processing in the caller\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\ttrigger: function( data ) {\n\n\t\t\t\t// For mutual compressibility with _default, replace `this` access with a local var.\n\t\t\t\t// `|| data` is dead code meant only to preserve the variable through minification.\n\t\t\t\tvar el = this || data;\n\n\t\t\t\t// Force setup before triggering a click\n\t\t\t\tif ( rcheckableType.test( el.type ) &&\n\t\t\t\t\tel.click && nodeName( el, "input" ) ) {\n\n\t\t\t\t\tleverageNative( el, "click" );\n\t\t\t\t}\n\n\t\t\t\t// Return non-false to allow normal event-path propagation\n\t\t\t\treturn true;\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, suppress native .click() on links\n\t\t\t// Also prevent it if we\'re currently inside a leveraged native-event stack\n\t\t\t_default: function( event ) {\n\t\t\t\tvar target = event.target;\n\t\t\t\treturn rcheckableType.test( target.type ) &&\n\t\t\t\t\ttarget.click && nodeName( target, "input" ) &&\n\t\t\t\t\tdataPriv.get( target, "click" ) ||\n\t\t\t\t\tnodeName( target, "a" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn\'t alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Ensure the presence of an event listener that handles manually-triggered\n// synthetic events by interrupting progress until reinvoked in response to\n// *native* events that it fires directly, ensuring that state changes have\n// already occurred before other listeners are invoked.\nfunction leverageNative( el, type, expectSync ) {\n\n\t// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add\n\tif ( !expectSync ) {\n\t\tif ( dataPriv.get( el, type ) === undefined ) {\n\t\t\tjQuery.event.add( el, type, returnTrue );\n\t\t}\n\t\treturn;\n\t}\n\n\t// Register the controller as a special universal handler for all event namespaces\n\tdataPriv.set( el, type, false );\n\tjQuery.event.add( el, type, {\n\t\tnamespace: false,\n\t\thandler: function( event ) {\n\t\t\tvar notAsync, result,\n\t\t\t\tsaved = dataPriv.get( this, type );\n\n\t\t\tif ( ( event.isTrigger & 1 ) && this[ type ] ) {\n\n\t\t\t\t// Interrupt processing of the outer synthetic .trigger()ed event\n\t\t\t\t// Saved data should be false in such cases, but might be a leftover capture object\n\t\t\t\t// from an async native handler (gh-4350)\n\t\t\t\tif ( !saved.length ) {\n\n\t\t\t\t\t// Store arguments for use when handling the inner native event\n\t\t\t\t\t// There will always be at least one argument (an event object), so this array\n\t\t\t\t\t// will not be confused with a leftover capture object.\n\t\t\t\t\tsaved = slice.call( arguments );\n\t\t\t\t\tdataPriv.set( this, type, saved );\n\n\t\t\t\t\t// Trigger the native event and capture its result\n\t\t\t\t\t// Support: IE <=9 - 11+\n\t\t\t\t\t// focus() and blur() are asynchronous\n\t\t\t\t\tnotAsync = expectSync( this, type );\n\t\t\t\t\tthis[ type ]();\n\t\t\t\t\tresult = dataPriv.get( this, type );\n\t\t\t\t\tif ( saved !== result || notAsync ) {\n\t\t\t\t\t\tdataPriv.set( this, type, false );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = {};\n\t\t\t\t\t}\n\t\t\t\t\tif ( saved !== result ) {\n\n\t\t\t\t\t\t// Cancel the outer synthetic event\n\t\t\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\treturn result.value;\n\t\t\t\t\t}\n\n\t\t\t\t// If this is an inner synthetic event for an event with a bubbling surrogate\n\t\t\t\t// (focus or blur), assume that the surrogate already propagated from triggering the\n\t\t\t\t// native event and prevent that from happening again here.\n\t\t\t\t// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the\n\t\t\t\t// bubbling surrogate propagates *after* the non-bubbling base), but that seems\n\t\t\t\t// less bad than duplication.\n\t\t\t\t} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t}\n\n\t\t\t// If this is a native event triggered above, everything is now in order\n\t\t\t// Fire an inner synthetic event with the original arguments\n\t\t\t} else if ( saved.length ) {\n\n\t\t\t\t// ...and capture the result\n\t\t\t\tdataPriv.set( this, type, {\n\t\t\t\t\tvalue: jQuery.event.trigger(\n\n\t\t\t\t\t\t// Support: IE <=9 - 11+\n\t\t\t\t\t\t// Extend with the prototype to reset the above stopImmediatePropagation()\n\t\t\t\t\t\tjQuery.extend( saved[ 0 ], jQuery.Event.prototype ),\n\t\t\t\t\t\tsaved.slice( 1 ),\n\t\t\t\t\t\tthis\n\t\t\t\t\t)\n\t\t\t\t} );\n\n\t\t\t\t// Abort handling of the native event\n\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t}\n\t\t}\n\t} );\n}\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This "if" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the \'new\' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t\t// Create target properties\n\t\t// Support: Safari <=6 - 7 only\n\t\t// Target should not be a text node (#504, #13143)\n\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\tsrc.target.parentNode :\n\t\t\tsrc.target;\n\n\t\tthis.currentTarget = src.currentTarget;\n\t\tthis.relatedTarget = src.relatedTarget;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn\'t have one\n\tthis.timeStamp = src && src.timeStamp || Date.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\njQuery.each( {\n\taltKey: true,\n\tbubbles: true,\n\tcancelable: true,\n\tchangedTouches: true,\n\tctrlKey: true,\n\tdetail: true,\n\teventPhase: true,\n\tmetaKey: true,\n\tpageX: true,\n\tpageY: true,\n\tshiftKey: true,\n\tview: true,\n\t"char": true,\n\tcode: true,\n\tcharCode: true,\n\tkey: true,\n\tkeyCode: true,\n\tbutton: true,\n\tbuttons: true,\n\tclientX: true,\n\tclientY: true,\n\toffsetX: true,\n\toffsetY: true,\n\tpointerId: true,\n\tpointerType: true,\n\tscreenX: true,\n\tscreenY: true,\n\ttargetTouches: true,\n\ttoElement: true,\n\ttouches: true,\n\n\twhich: function( event ) {\n\t\tvar button = event.button;\n\n\t\t// Add which for key events\n\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\n\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t}\n\n\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\n\t\t\tif ( button & 1 ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ( button & 2 ) {\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\tif ( button & 4 ) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn event.which;\n\t}\n}, jQuery.event.addProp );\n\njQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {\n\tjQuery.event.special[ type ] = {\n\n\t\t// Utilize native event if possible so blur/focus sequence is correct\n\t\tsetup: function() {\n\n\t\t\t// Claim the first handler\n\t\t\t// dataPriv.set( this, "focus", ... )\n\t\t\t// dataPriv.set( this, "blur", ... )\n\t\t\tleverageNative( this, type, expectSync );\n\n\t\t\t// Return false to allow normal processing in the caller\n\t\t\treturn false;\n\t\t},\n\t\ttrigger: function() {\n\n\t\t\t// Force setup before trigger\n\t\t\tleverageNative( this, type );\n\n\t\t\t// Return non-false to allow normal event-path propagation\n\t\t\treturn true;\n\t\t},\n\n\t\tdelegateType: delegateType\n\t};\n} );\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: "mouseover",\n\tmouseleave: "mouseout",\n\tpointerenter: "pointerover",\n\tpointerleave: "pointerout"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + "." + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === "object" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === "function" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\n\t/* eslint-disable max-len */\n\n\t// See https://github.com/eslint/eslint/issues/3229\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\n\t/* eslint-enable */\n\n\t// Support: IE <=10 - 11, Edge 12 - 13 only\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked="checked" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\n// Prefer a tbody over its parent table for containing new rows\nfunction manipulationTarget( elem, content ) {\n\tif ( nodeName( elem, "table" ) &&\n\t\tnodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {\n\n\t\treturn jQuery( elem ).children( "tbody" )[ 0 ] || elem;\n\t}\n\n\treturn elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tif ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {\n\t\telem.type = elem.type.slice( 5 );\n\t} else {\n\t\telem.removeAttribute( "type" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.access( src );\n\t\tpdataCur = dataPriv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === "input" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === "input" || nodeName === "textarea" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = concat.apply( [], args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tvalueIsFunction = isFunction( value );\n\n\t// We can\'t cloneNode fragments that contain checked, in WebKit\n\tif ( valueIsFunction ||\n\t\t\t( l > 1 && typeof value === "string" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, "script" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, "script" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || "" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, "globalEval" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won\'t run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl && !node.noModule ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src, {\n\t\t\t\t\t\t\t\t\tnonce: node.nonce || node.getAttribute( "nonce" )\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && isAttached( node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, "script" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html.replace( rxhtmlTag, "<$1></$2>" );\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = isAttached( elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, "script" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, "script" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove\'s overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = "";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === "string" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: "append",\n\tprependTo: "prepend",\n\tinsertBefore: "before",\n\tinsertAfter: "after",\n\treplaceAll: "replaceWith"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\nvar rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\nvar rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );\n\n\n\n( function() {\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they\'re executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\n\t\t// This is a singleton, we need to execute it only once\n\t\tif ( !div ) {\n\t\t\treturn;\n\t\t}\n\n\t\tcontainer.style.cssText = "position:absolute;left:-11111px;width:60px;" +\n\t\t\t"margin-top:1px;padding:0;border:0";\n\t\tdiv.style.cssText =\n\t\t\t"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +\n\t\t\t"margin:auto;border:1px;padding:1px;" +\n\t\t\t"width:60%;top:1%";\n\t\tdocumentElement.appendChild( container ).appendChild( div );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== "1%";\n\n\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\treliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;\n\n\t\t// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n\t\t// Some styles come back with percentage values, even though they shouldn\'t\n\t\tdiv.style.right = "60%";\n\t\tpixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;\n\n\t\t// Support: IE 9 - 11 only\n\t\t// Detect misreporting of content dimensions for box-sizing:border-box elements\n\t\tboxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;\n\n\t\t// Support: IE 9 only\n\t\t// Detect overflow:scroll screwiness (gh-3699)\n\t\t// Support: Chrome <=64\n\t\t// Don\'t get tricked when zoom affects offsetWidth (gh-4029)\n\t\tdiv.style.position = "absolute";\n\t\tscrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;\n\n\t\tdocumentElement.removeChild( container );\n\n\t\t// Nullify the div so it wouldn\'t be stored in the memory and\n\t\t// it will also be a sign that checks already performed\n\t\tdiv = null;\n\t}\n\n\tfunction roundPixelMeasures( measure ) {\n\t\treturn Math.round( parseFloat( measure ) );\n\t}\n\n\tvar pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,\n\t\treliableMarginLeftVal,\n\t\tcontainer = document.createElement( "div" ),\n\t\tdiv = document.createElement( "div" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE <=9 - 11 only\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = "content-box";\n\tdiv.cloneNode( true ).style.backgroundClip = "";\n\tsupport.clearCloneStyle = div.style.backgroundClip === "content-box";\n\n\tjQuery.extend( support, {\n\t\tboxSizingReliable: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelBoxStyles: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelBoxStylesVal;\n\t\t},\n\t\tpixelPosition: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn reliableMarginLeftVal;\n\t\t},\n\t\tscrollboxSize: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn scrollboxSizeVal;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\n\t\t// Support: Firefox 51+\n\t\t// Retrieving style before computed somehow\n\t\t// fixes an issue with getting wrong values\n\t\t// on detached elements\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// getPropertyValue is needed for:\n\t//   .css(\'filter\') (IE 9 only, #12537)\n\t//   .css(\'--customProperty) (#3144)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\n\t\tif ( ret === "" && !isAttached( elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// A tribute to the "awesome hack by Dean Edwards"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\tif ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + "" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we\'ll check on the first run if it\'s really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it\'s not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar cssPrefixes = [ "Webkit", "Moz", "ms" ],\n\temptyStyle = document.createElement( "div" ).style,\n\tvendorProps = {};\n\n// Return a vendor-prefixed property or undefined\nfunction vendorPropName( name ) {\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\n// Return a potentially-mapped jQuery.cssProps or vendor prefixed property\nfunction finalPropName( name ) {\n\tvar final = jQuery.cssProps[ name ] || vendorProps[ name ];\n\n\tif ( final ) {\n\t\treturn final;\n\t}\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\treturn vendorProps[ name ] = vendorPropName( name ) || name;\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except "table", "table-cell", or "table-caption"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trcustomProp = /^--/,\n\tcssShow = { position: "absolute", visibility: "hidden", display: "block" },\n\tcssNormalTransform = {\n\t\tletterSpacing: "0",\n\t\tfontWeight: "400"\n\t};\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined "subtract", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :\n\t\tvalue;\n}\n\nfunction boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {\n\tvar i = dimension === "width" ? 1 : 0,\n\t\textra = 0,\n\t\tdelta = 0;\n\n\t// Adjustment may not be necessary\n\tif ( box === ( isBorderBox ? "border" : "content" ) ) {\n\t\treturn 0;\n\t}\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin\n\t\tif ( box === "margin" ) {\n\t\t\tdelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\t// If we get here with a content-box, we\'re seeking "padding" or "border" or "margin"\n\t\tif ( !isBorderBox ) {\n\n\t\t\t// Add padding\n\t\t\tdelta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );\n\n\t\t\t// For "border" or "margin", add border\n\t\t\tif ( box !== "padding" ) {\n\t\t\t\tdelta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );\n\n\t\t\t// But still keep track of it otherwise\n\t\t\t} else {\n\t\t\t\textra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );\n\t\t\t}\n\n\t\t// If we get here with a border-box (content + padding + border), we\'re seeking "content" or\n\t\t// "padding" or "margin"\n\t\t} else {\n\n\t\t\t// For "content", subtract padding\n\t\t\tif ( box === "content" ) {\n\t\t\t\tdelta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// For "content" or "padding", subtract border\n\t\t\tif ( box !== "margin" ) {\n\t\t\t\tdelta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Account for positive content-box scroll gutter when requested by providing computedVal\n\tif ( !isBorderBox && computedVal >= 0 ) {\n\n\t\t// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n\t\t// Assuming integer scroll gutter, subtract the rest and round down\n\t\tdelta += Math.max( 0, Math.ceil(\n\t\t\telem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\tcomputedVal -\n\t\t\tdelta -\n\t\t\textra -\n\t\t\t0.5\n\n\t\t// If offsetWidth/offsetHeight is unknown, then we can\'t determine content-box scroll gutter\n\t\t// Use an explicit zero to avoid NaN (gh-3964)\n\t\t) ) || 0;\n\t}\n\n\treturn delta;\n}\n\nfunction getWidthOrHeight( elem, dimension, extra ) {\n\n\t// Start with computed style\n\tvar styles = getStyles( elem ),\n\n\t\t// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).\n\t\t// Fake content-box until we know it\'s needed to know the true value.\n\t\tboxSizingNeeded = !support.boxSizingReliable() || extra,\n\t\tisBorderBox = boxSizingNeeded &&\n\t\t\tjQuery.css( elem, "boxSizing", false, styles ) === "border-box",\n\t\tvalueIsBorderBox = isBorderBox,\n\n\t\tval = curCSS( elem, dimension, styles ),\n\t\toffsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );\n\n\t// Support: Firefox <=54\n\t// Return a confounding non-pixel value or feign ignorance, as appropriate.\n\tif ( rnumnonpx.test( val ) ) {\n\t\tif ( !extra ) {\n\t\t\treturn val;\n\t\t}\n\t\tval = "auto";\n\t}\n\n\n\t// Fall back to offsetWidth/offsetHeight when value is "auto"\n\t// This happens for inline elements with no explicit setting (gh-3571)\n\t// Support: Android <=4.1 - 4.3 only\n\t// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n\t// Support: IE 9-11 only\n\t// Also use offsetWidth/offsetHeight for when box sizing is unreliable\n\t// We use getClientRects() to check for hidden/disconnected.\n\t// In those cases, the computed value can be trusted to be border-box\n\tif ( ( !support.boxSizingReliable() && isBorderBox ||\n\t\tval === "auto" ||\n\t\t!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&\n\t\telem.getClientRects().length ) {\n\n\t\tisBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";\n\n\t\t// Where available, offsetWidth/offsetHeight approximate border box dimensions.\n\t\t// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the\n\t\t// retrieved value as a content box dimension.\n\t\tvalueIsBorderBox = offsetProp in elem;\n\t\tif ( valueIsBorderBox ) {\n\t\t\tval = elem[ offsetProp ];\n\t\t}\n\t}\n\n\t// Normalize "" and auto\n\tval = parseFloat( val ) || 0;\n\n\t// Adjust for the element\'s box model\n\treturn ( val +\n\t\tboxModelAdjustment(\n\t\t\telem,\n\t\t\tdimension,\n\t\t\textra || ( isBorderBox ? "border" : "content" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles,\n\n\t\t\t// Provide the current computed size to request scroll gutter calculation (gh-3589)\n\t\t\tval\n\t\t)\n\t) + "px";\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, "opacity" );\n\t\t\t\t\treturn ret === "" ? "1" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don\'t automatically add "px" to these possibly-unitless properties\n\tcssNumber: {\n\t\t"animationIterationCount": true,\n\t\t"columnCount": true,\n\t\t"fillOpacity": true,\n\t\t"flexGrow": true,\n\t\t"flexShrink": true,\n\t\t"fontWeight": true,\n\t\t"gridArea": true,\n\t\t"gridColumn": true,\n\t\t"gridColumnEnd": true,\n\t\t"gridColumnStart": true,\n\t\t"gridRow": true,\n\t\t"gridRowEnd": true,\n\t\t"gridRowStart": true,\n\t\t"lineHeight": true,\n\t\t"opacity": true,\n\t\t"order": true,\n\t\t"orphans": true,\n\t\t"widows": true,\n\t\t"zIndex": true,\n\t\t"zoom": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don\'t set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we\'re working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name ),\n\t\t\tstyle = elem.style;\n\n\t\t// Make sure that we\'re working with the right name. We don\'t\n\t\t// want to query the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we\'re setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert "+=" or "-=" to relative numbers (#7345)\n\t\t\tif ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = "number";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren\'t set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\t// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append\n\t\t\t// "px" to a few hardcoded values.\n\t\t\tif ( type === "number" && !isCustomProp ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );\n\t\t\t}\n\n\t\t\t// background-* props affect original clone\'s values\n\t\t\tif ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {\n\t\t\t\tstyle[ name ] = "inherit";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( "set" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tif ( isCustomProp ) {\n\t\t\t\t\tstyle.setProperty( name, value );\n\t\t\t\t} else {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && "get" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name );\n\n\t\t// Make sure that we\'re working with the right name. We don\'t\n\t\t// want to modify the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && "get" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert "normal" to computed value\n\t\tif ( val === "normal" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === "" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ "height", "width" ], function( i, dimension ) {\n\tjQuery.cssHooks[ dimension ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, "display" ) ) &&\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, dimension, extra );\n\t\t\t\t\t\t} ) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, dimension, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = getStyles( elem ),\n\n\t\t\t\t// Only read styles.position if the test has a chance to fail\n\t\t\t\t// to avoid forcing a reflow.\n\t\t\t\tscrollboxSizeBuggy = !support.scrollboxSize() &&\n\t\t\t\t\tstyles.position === "absolute",\n\n\t\t\t\t// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)\n\t\t\t\tboxSizingNeeded = scrollboxSizeBuggy || extra,\n\t\t\t\tisBorderBox = boxSizingNeeded &&\n\t\t\t\t\tjQuery.css( elem, "boxSizing", false, styles ) === "border-box",\n\t\t\t\tsubtract = extra ?\n\t\t\t\t\tboxModelAdjustment(\n\t\t\t\t\t\telem,\n\t\t\t\t\t\tdimension,\n\t\t\t\t\t\textra,\n\t\t\t\t\t\tisBorderBox,\n\t\t\t\t\t\tstyles\n\t\t\t\t\t) :\n\t\t\t\t\t0;\n\n\t\t\t// Account for unreliable border-box dimensions by comparing offset* to computed and\n\t\t\t// faking a content-box to get border and padding (gh-3699)\n\t\t\tif ( isBorderBox && scrollboxSizeBuggy ) {\n\t\t\t\tsubtract -= Math.ceil(\n\t\t\t\t\telem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\t\t\tparseFloat( styles[ dimension ] ) -\n\t\t\t\t\tboxModelAdjustment( elem, dimension, "border", false, styles ) -\n\t\t\t\t\t0.5\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || "px" ) !== "px" ) {\n\n\t\t\t\telem.style[ dimension ] = value;\n\t\t\t\tvalue = jQuery.css( elem, dimension );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, "marginLeft" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t\t) + "px";\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: "",\n\tpadding: "",\n\tborder: "Width"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === "string" ? value.split( " " ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( prefix !== "margin" ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as "10px" are parsed to Float;\n\t\t\t// complex values such as "rotate(1rad)" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, "" );\n\n\t\t\t// Empty strings, null, undefined and "auto" are converted to 0.\n\t\t\treturn !result || result === "auto" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 && (\n\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ||\n\t\t\t\t\ttween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9 only\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: "swing"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, inProgress,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\nfunction schedule() {\n\tif ( inProgress ) {\n\t\tif ( document.hidden === false && window.requestAnimationFrame ) {\n\t\t\twindow.requestAnimationFrame( schedule );\n\t\t} else {\n\t\t\twindow.setTimeout( schedule, jQuery.fx.interval );\n\t\t}\n\n\t\tjQuery.fx.tick();\n\t}\n}\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = Date.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ "margin" + which ] = attrs[ "padding" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We\'re done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\tisBox = "width" in props || "height" in props,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\tdataShow = dataPriv.get( elem, "fxshow" );\n\n\t// Queue-skipping animations hijack the fx hooks\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, "fx" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, "fx" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Detect show/hide animations\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.test( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === "toggle";\n\t\t\tif ( value === ( hidden ? "hide" : "show" ) ) {\n\n\t\t\t\t// Pretend to be hidden if this is a "show" and\n\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\tif ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\n\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\t// Bail out if this is a no-op like .hide().hide()\n\tpropTween = !jQuery.isEmptyObject( props );\n\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\treturn;\n\t}\n\n\t// Restrict "overflow" and "display" styles during box animations\n\tif ( isBox && elem.nodeType === 1 ) {\n\n\t\t// Support: IE <=9 - 11, Edge 12 - 15\n\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t// from identically-valued overflowX and overflowY and Edge just mirrors\n\t\t// the overflowX value there.\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\trestoreDisplay = dataShow && dataShow.display;\n\t\tif ( restoreDisplay == null ) {\n\t\t\trestoreDisplay = dataPriv.get( elem, "display" );\n\t\t}\n\t\tdisplay = jQuery.css( elem, "display" );\n\t\tif ( display === "none" ) {\n\t\t\tif ( restoreDisplay ) {\n\t\t\t\tdisplay = restoreDisplay;\n\t\t\t} else {\n\n\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\tdisplay = jQuery.css( elem, "display" );\n\t\t\t\tshowHide( [ elem ] );\n\t\t\t}\n\t\t}\n\n\t\t// Animate inline elements as inline-block\n\t\tif ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {\n\t\t\tif ( jQuery.css( elem, "float" ) === "none" ) {\n\n\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\tif ( !propTween ) {\n\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\trestoreDisplay = display === "none" ? "" : display;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstyle.display = "inline-block";\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = "hidden";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// Implement show/hide animations\n\tpropTween = false;\n\tfor ( prop in orig ) {\n\n\t\t// General show/hide setup for this element animation\n\t\tif ( !propTween ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( "hidden" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );\n\t\t\t}\n\n\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` "reverses"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\n\t\t\t// Show elements before animating them\n\t\t\tif ( hidden ) {\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t}\n\n\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\tanim.done( function() {\n\n\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t// The final step of a "hide" animation is actually hiding the element\n\t\t\t\tif ( !hidden ) {\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t\tdataPriv.remove( elem, "fxshow" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Per-property setup\n\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\tif ( !( prop in dataShow ) ) {\n\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\tif ( hidden ) {\n\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\tpropTween.start = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( Array.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && "expand" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won\'t overwrite existing keys.\n\t\t\t// Reusing \'index\' because we have the correct "name"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don\'t match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t// Archaic crash bug won\'t allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\t// If there\'s more to do, yield\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t}\n\n\t\t\t// If this was an empty animation, synthesize a final progress notification\n\t\t\tif ( !length ) {\n\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t}\n\n\t\t\t// Resolve the animation and report its conclusion\n\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\treturn false;\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tresult.stop.bind( result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\t// Attach callbacks from options\n\tanimation\n\t\t.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\treturn animation;\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweeners: {\n\t\t"*": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ "*" ];\n\t\t} else {\n\t\t\tprops = props.match( rnothtmlwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tisFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !isFunction( easing ) && easing\n\t};\n\n\t// Go to the end state if fx are off\n\tif ( jQuery.fx.off ) {\n\t\topt.duration = 0;\n\n\t} else {\n\t\tif ( typeof opt.duration !== "number" ) {\n\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\n\t\t\t} else {\n\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize opt.queue - true/undefined/null -> "fx"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = "fx";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won\'t be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, "finish" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== "string" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || "fx", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + "queueHooks",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn\'t forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || "fx";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + "queue" ],\n\t\t\t\thooks = data[ type + "queueHooks" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === "boolean" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( "show" ),\n\tslideUp: genFx( "hide" ),\n\tslideToggle: genFx( "toggle" ),\n\tfadeIn: { opacity: "show" },\n\tfadeOut: { opacity: "hide" },\n\tfadeToggle: { opacity: "toggle" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = Date.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Run the timer and safely remove it when done (allowing for external removal)\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tjQuery.fx.start();\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( inProgress ) {\n\t\treturn;\n\t}\n\n\tinProgress = true;\n\tschedule();\n};\n\njQuery.fx.stop = function() {\n\tinProgress = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || "fx";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( "input" ),\n\t\tselect = document.createElement( "select" ),\n\t\topt = select.appendChild( document.createElement( "option" ) );\n\n\tinput.type = "checkbox";\n\n\t// Support: Android <=4.3 only\n\t// Default value for a checkbox should be "on"\n\tsupport.checkOn = input.value !== "";\n\n\t// Support: IE <=11 only\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: IE <=11 only\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( "input" );\n\tinput.value = "t";\n\tinput.type = "radio";\n\tsupport.radioValue = input.value === "t";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don\'t get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === "undefined" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// Attribute hooks are determined by the lowercase version\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && "set" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + "" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === "radio" &&\n\t\t\t\t\tnodeName( elem, "input" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( "type", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name,\n\t\t\ti = 0,\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle,\n\t\t\tlowercaseName = name.toLowerCase();\n\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tlowercaseName :\n\t\t\t\tnull;\n\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don\'t get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && "set" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t// elem.tabIndex doesn\'t always return the\n\t\t\t\t// correct value when it hasn\'t been explicitly set\n\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, "tabindex" );\n\n\t\t\t\tif ( tabindex ) {\n\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\telem.href\n\t\t\t\t) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t"for": "htmlFor",\n\t\t"class": "className"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\n// eslint rule "no-unused-expressions" is disabled for this code\n// since it considers such accessions noop\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: "off" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: "off" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t"tabIndex",\n\t"readOnly",\n\t"maxLength",\n\t"cellSpacing",\n\t"cellPadding",\n\t"rowSpan",\n\t"colSpan",\n\t"useMap",\n\t"frameBorder",\n\t"contentEditable"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n\tfunction stripAndCollapse( value ) {\n\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\treturn tokens.join( " " );\n\t}\n\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( "class" ) || "";\n}\n\nfunction classesToArray( value ) {\n\tif ( Array.isArray( value ) ) {\n\t\treturn value;\n\t}\n\tif ( typeof value === "string" ) {\n\t\treturn value.match( rnothtmlwhite ) || [];\n\t}\n\treturn [];\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( " " + clazz + " " ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + " ";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( "class", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( "class", "" );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( " " + clazz + " " ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( " " + clazz + " ", " " );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( "class", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value,\n\t\t\tisValidValue = type === "string" || Array.isArray( value );\n\n\t\tif ( typeof stateVal === "boolean" && isValidValue ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( isValidValue ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = classesToArray( value );\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === "boolean" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, "__className__", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we\'re passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( "class",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t"" :\n\t\t\t\t\t\tdataPriv.get( this, "__className__" ) || ""\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = " " + selector + " ";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, valueIsFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t"get" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, "value" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\t// Handle most common string cases\n\t\t\t\tif ( typeof ret === "string" ) {\n\t\t\t\t\treturn ret.replace( rreturn, "" );\n\t\t\t\t}\n\n\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\treturn ret == null ? "" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvalueIsFunction = isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as ""; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = "";\n\n\t\t\t} else if ( typeof val === "number" ) {\n\t\t\t\tval += "";\n\n\t\t\t} else if ( Array.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? "" : value + "";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, "value" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option, i,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === "select-one",\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length;\n\n\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\ti = max;\n\n\t\t\t\t} else {\n\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t}\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t// IE8-9 doesn\'t update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don\'t return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!nodeName( option.parentNode, "optgroup" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don\'t need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ "radio", "checkbox" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( Array.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( "value" ) === null ? "on" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\nsupport.focusin = "onfocusin" in window;\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\tstopPropagationCallback = function( e ) {\n\t\te.stopPropagation();\n\t};\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special, lastElement,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, "type" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];\n\n\t\tcur = lastElement = tmp = elem = elem || document;\n\n\t\t// Don\'t do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we\'re not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( "." ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( "." );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( ":" ) < 0 && "on" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === "object" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( "." );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( "(^|\\\\.)" + namespaces.join( "\\\\.(?:.*\\\\.|)" ) + "(\\\\.|$)" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tlastElement = cur;\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, "handle" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t// Don\'t do default actions on window, that\'s where global variables be (#6170)\n\t\t\t\tif ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {\n\n\t\t\t\t\t// Don\'t re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.addEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\telem[ type ]();\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.removeEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\n// Support: Firefox <=44\n// Firefox doesn\'t have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdataPriv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\nvar location = window.location;\n\nvar nonce = Date.now();\n\nvar rquery = ( /\\?/ );\n\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml;\n\tif ( !data || typeof data !== "string" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE 9 - 11 only\n\t// IE throws on parseFromString with invalid input.\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {\n\t\tjQuery.error( "Invalid XML: " + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( Array.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && toType( obj ) === "object" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, valueOrFunction ) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = isFunction( valueOrFunction ) ?\n\t\t\t\tvalueOrFunction() :\n\t\t\t\tvalueOrFunction;\n\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + "=" +\n\t\t\t\tencodeURIComponent( value == null ? "" : value );\n\t\t};\n\n\tif ( a == null ) {\n\t\treturn "";\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the "old" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( "&" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for "elements" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, "elements" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} )\n\t\t.filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( ":disabled" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( ":disabled" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} )\n\t\t.map( function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\tif ( val == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( Array.isArray( val ) ) {\n\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, "\\r\\n" ) };\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn { name: elem.name, value: val.replace( rCRLF, "\\r\\n" ) };\n\t\t} ).get();\n\t}\n} );\n\n\nvar\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol "*" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to "*" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol "*" can be used\n\t * 3) selection will start with transport dataType and THEN go to "*" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = "*/".concat( "*" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( "a" );\n\toriginAnchor.href = location.href;\n\n// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to "*"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== "string" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = "*";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === "+" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || "*";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === "string" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );\n}\n\n// A special extend for ajax options\n// that takes "flat" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === "*" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );\n\t\t}\n\t}\n\n\t// Check if we\'re dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There\'s only work to do if current dataType is non-auto\n\t\t\tif ( current === "*" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== "*" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + " " + current ] || converters[ "* " + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( " " );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + " " + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ "* " + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: "parsererror",\n\t\t\t\t\t\t\t\terror: conv ? e : "No conversion from " + prev + " to " + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: "success", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: "GET",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: "application/x-www-form-urlencoded; charset=UTF-8",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t"*": allTypes,\n\t\t\ttext: "text/plain",\n\t\t\thtml: "text/html",\n\t\t\txml: "application/xml, text/xml",\n\t\t\tjson: "application/json, text/javascript"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: "responseXML",\n\t\t\ttext: "responseText",\n\t\t\tjson: "responseJSON"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall "*") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t"* text": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t"text html": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t"text json": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t"text xml": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn\'t be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn\'t be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === "object" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( "once memory" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = "canceled",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() + " " ] =\n\t\t\t\t\t\t\t\t\t( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )\n\t\t\t\t\t\t\t\t\t\t.concat( match[ 2 ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() + " " ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match.join( ", " );\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( completed ) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + "" )\n\t\t\t.replace( rprotocol, location.protocol + "//" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];\n\n\t\t// A cross-domain request is in order when the origin doesn\'t match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( "a" );\n\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 15\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t// e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t// Anchor\'s host property isn\'t correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + "//" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== "string" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( completed ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don\'t fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( "ajaxStart" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we\'re toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\t// Remove hash to simplify url manipulation\n\t\tcacheURL = s.url.replace( rhash, "" );\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// Remember the hash so we can put it back\n\t\t\tuncached = s.url.slice( cacheURL.length );\n\n\t\t\t// If data is available and should be processed, append data to url\n\t\t\tif ( s.data && ( s.processData || typeof s.data === "string" ) ) {\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;\n\n\t\t\t\t// #9682: remove data so that it\'s not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add or update anti-cache param if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, "$1" );\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;\n\t\t\t}\n\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\ts.url = cacheURL + uncached;\n\n\t\t// Change \'%20\' to \'+\' if this is encoded form body content (gh-2658)\n\t\t} else if ( s.data && s.processData &&\n\t\t\t( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {\n\t\t\ts.data = s.data.replace( r20, "+" );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( "Content-Type", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t"Accept",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :\n\t\t\t\ts.accepts[ "*" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = "abort";\n\n\t\t// Install callbacks on deferreds\n\t\tcompleteDeferred.add( s.complete );\n\t\tjqXHR.done( s.success );\n\t\tjqXHR.fail( s.error );\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, "No Transport" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( "timeout" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcompleted = false;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\tif ( completed ) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Propagate others as results\n\t\t\t\tdone( -1, e );\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Ignore repeat invocations\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcompleted = true;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || "";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( "Last-Modified" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( "etag" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === "HEAD" ) {\n\t\t\t\t\tstatusText = "nocontent";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = "notmodified";\n\n\t\t\t\t// If we have data, let\'s convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = "error";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + "";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( "ajaxStop" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, "json" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, "script" );\n\t}\n} );\n\njQuery.each( [ "get", "post" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\n\njQuery._evalUrl = function( url, options ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: "GET",\n\t\tdataType: "script",\n\t\tcache: true,\n\t\tasync: false,\n\t\tglobal: false,\n\n\t\t// Only evaluate the response if it is successful (gh-4126)\n\t\t// dataFilter is not invoked for failure responses, so using it instead\n\t\t// of the default converter is kludgy but it works.\n\t\tconverters: {\n\t\t\t"text script": function() {}\n\t\t},\n\t\tdataFilter: function( response ) {\n\t\t\tjQuery.globalEval( response, options );\n\t\t}\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( this[ 0 ] ) {\n\t\t\tif ( isFunction( html ) ) {\n\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t}\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar htmlIsFunction = isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function( selector ) {\n\t\tthis.parent( selector ).not( "body" ).each( function() {\n\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\n\njQuery.expr.pseudos.hidden = function( elem ) {\n\treturn !jQuery.expr.pseudos.visible( elem );\n};\njQuery.expr.pseudos.visible = function( elem ) {\n\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n};\n\n\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won\'t change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {\n\t\t\t\t\theaders[ "X-Requested-With" ] = "XMLHttpRequest";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.ontimeout =\n\t\t\t\t\t\t\t\t\txhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === "abort" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === "error" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== "number" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, "error" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || "text" ) !== "text"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== "string" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );\n\n\t\t\t\t// Support: IE 9 only\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( "abort" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// #14683: Only rethrow if this hasn\'t been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n\tif ( s.crossDomain ) {\n\t\ts.contents.script = false;\n\t}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: "text/javascript, application/javascript, " +\n\t\t\t"application/ecmascript, application/x-ecmascript"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t"text script": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache\'s special case and crossDomain\njQuery.ajaxPrefilter( "script", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = "GET";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( "script", function( s ) {\n\n\t// This transport only deals with cross domain or forced-by-attrs requests\n\tif ( s.crossDomain || s.scriptAttrs ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( "<script>" )\n\t\t\t\t\t.attr( s.scriptAttrs || {} )\n\t\t\t\t\t.prop( { charset: s.scriptCharset, src: s.url } )\n\t\t\t\t\t.on( "load error", callback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === "error" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: "callback",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t"url" :\n\t\t\ttypeof s.data === "string" &&\n\t\t\t\t( s.contentType || "" )\n\t\t\t\t\t.indexOf( "application/x-www-form-urlencoded" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && "data"\n\t\t);\n\n\t// Handle iff the expected data type is "jsonp" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ "script json" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + " was not called" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = "json";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn\'t exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn\'t screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn "script";\n\t}\n} );\n\n\n\n\n// Support: Safari 8 only\n// In Safari 8 documents created via document.implementation.createHTMLDocument\n// collapse sibling forms: the second one becomes a child of the first one.\n// Because of that, this security measure has to be disabled in Safari 8.\n// https://bugs.webkit.org/show_bug.cgi?id=137337\nsupport.createHTMLDocument = ( function() {\n\tvar body = document.implementation.createHTMLDocument( "" ).body;\n\tbody.innerHTML = "<form></form><form></form>";\n\treturn body.childNodes.length === 2;\n} )();\n\n\n// Argument "data" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( typeof data !== "string" ) {\n\t\treturn [];\n\t}\n\tif ( typeof context === "boolean" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\n\tvar base, parsed, scripts;\n\n\tif ( !context ) {\n\n\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t// by using document.implementation\n\t\tif ( support.createHTMLDocument ) {\n\t\t\tcontext = document.implementation.createHTMLDocument( "" );\n\n\t\t\t// Set the base href for the created document\n\t\t\t// so any parsed elements with URLs\n\t\t\t// are based on the document\'s URL (gh-2965)\n\t\t\tbase = context.createElement( "base" );\n\t\t\tbase.href = document.location.href;\n\t\t\tcontext.head.appendChild( base );\n\t\t} else {\n\t\t\tcontext = document;\n\t\t}\n\t}\n\n\tparsed = rsingleTag.exec( data );\n\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( " " );\n\n\tif ( off > -1 ) {\n\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it\'s a function\n\tif ( isFunction( params ) ) {\n\n\t\t// We assume that it\'s the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === "object" ) {\n\t\ttype = "POST";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If "type" variable is undefined, then "GET" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || "GET",\n\t\t\tdataType: "html",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE \'Permission Denied\' errors\n\t\t\t\tjQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets "data", "status", "jqXHR"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets "jqXHR", "status", "error"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [\n\t"ajaxStart",\n\t"ajaxStop",\n\t"ajaxComplete",\n\t"ajaxError",\n\t"ajaxSuccess",\n\t"ajaxSend"\n], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.expr.pseudos.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, "position" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === "static" ) {\n\t\t\telem.style.position = "relative";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, "top" );\n\t\tcurCSSLeft = jQuery.css( elem, "left" );\n\t\tcalculatePosition = ( position === "absolute" || position === "fixed" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( "using" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\n\t// offset() relates an element\'s border box to the document origin\n\toffset: function( options ) {\n\n\t\t// Preserve chaining for setter\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar rect, win,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !elem ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a\n\t\t// disconnected node in IE throws an error\n\t\tif ( !elem.getClientRects().length ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\t// Get document-relative position by adding viewport scroll to viewport-relative gBCR\n\t\trect = elem.getBoundingClientRect();\n\t\twin = elem.ownerDocument.defaultView;\n\t\treturn {\n\t\t\ttop: rect.top + win.pageYOffset,\n\t\t\tleft: rect.left + win.pageXOffset\n\t\t};\n\t},\n\n\t// position() relates an element\'s margin box to its offset parent\'s padding box\n\t// This corresponds to the behavior of CSS absolute positioning\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset, doc,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// position:fixed elements are offset from the viewport, which itself always has zero offset\n\t\tif ( jQuery.css( elem, "position" ) === "fixed" ) {\n\n\t\t\t// Assume position:fixed implies availability of getBoundingClientRect\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\t\t\toffset = this.offset();\n\n\t\t\t// Account for the *real* offset parent, which can be the document or its root element\n\t\t\t// when a statically positioned element is identified\n\t\t\tdoc = elem.ownerDocument;\n\t\t\toffsetParent = elem.offsetParent || doc.documentElement;\n\t\t\twhile ( offsetParent &&\n\t\t\t\t( offsetParent === doc.body || offsetParent === doc.documentElement ) &&\n\t\t\t\tjQuery.css( offsetParent, "position" ) === "static" ) {\n\n\t\t\t\toffsetParent = offsetParent.parentNode;\n\t\t\t}\n\t\t\tif ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {\n\n\t\t\t\t// Incorporate borders into its offset, since they are outside its content origin\n\t\t\t\tparentOffset = jQuery( offsetParent ).offset();\n\t\t\t\tparentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );\n\t\t\t\tparentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );\n\t\t\t}\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {\n\tvar top = "pageYOffset" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\n\t\t\t// Coalesce documents and windows\n\t\t\tvar win;\n\t\t\tif ( isWindow( elem ) ) {\n\t\t\t\twin = elem;\n\t\t\t} else if ( elem.nodeType === 9 ) {\n\t\t\t\twin = elem.defaultView;\n\t\t\t}\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ "top", "left" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + "px" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: "height", Width: "width" }, function( name, type ) {\n\tjQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },\n\t\tfunction( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( isWindow( elem ) ) {\n\n\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\treturn funcName.indexOf( "outer" ) === 0 ?\n\t\t\t\t\t\telem[ "inner" + name ] :\n\t\t\t\t\t\telem.document.documentElement[ "client" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ "scroll" + name ], doc[ "scroll" + name ],\n\t\t\t\t\t\telem.body[ "offset" + name ], doc[ "offset" + name ],\n\t\t\t\t\t\tdoc[ "client" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t};\n\t} );\n} );\n\n\njQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +\n\t"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +\n\t"change select submit keydown keypress keyup contextmenu" ).split( " " ),\n\tfunction( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n} );\n\njQuery.fn.extend( {\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\n\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, "**" ) :\n\t\t\tthis.off( types, selector || "**", fn );\n\t}\n} );\n\n// Bind a function to a context, optionally partially applying any\n// arguments.\n// jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n// However, it is not slated for removal any time soon\njQuery.proxy = function( fn, context ) {\n\tvar tmp, args, proxy;\n\n\tif ( typeof context === "string" ) {\n\t\ttmp = fn[ context ];\n\t\tcontext = fn;\n\t\tfn = tmp;\n\t}\n\n\t// Quick check to determine if target is callable, in the spec\n\t// this throws a TypeError, but we will just return undefined.\n\tif ( !isFunction( fn ) ) {\n\t\treturn undefined;\n\t}\n\n\t// Simulated bind\n\targs = slice.call( arguments, 2 );\n\tproxy = function() {\n\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t};\n\n\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\treturn proxy;\n};\n\njQuery.holdReady = function( hold ) {\n\tif ( hold ) {\n\t\tjQuery.readyWait++;\n\t} else {\n\t\tjQuery.ready( true );\n\t}\n};\njQuery.isArray = Array.isArray;\njQuery.parseJSON = JSON.parse;\njQuery.nodeName = nodeName;\njQuery.isFunction = isFunction;\njQuery.isWindow = isWindow;\njQuery.camelCase = camelCase;\njQuery.type = toType;\n\njQuery.now = Date.now;\n\njQuery.isNumeric = function( obj ) {\n\n\t// As of jQuery 3.0, isNumeric is limited to\n\t// strings and numbers (primitives or objects)\n\t// that can be coerced to finite numbers (gh-2662)\n\tvar type = jQuery.type( obj );\n\treturn ( type === "number" || type === "string" ) &&\n\n\t\t// parseFloat NaNs numeric-cast false positives ("")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals ("0x...")\n\t\t// subtraction forces infinities to NaN\n\t\t!isNaN( obj - parseFloat( obj ) );\n};\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( true ) {\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\treturn jQuery;\n\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( !noGlobal ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n} );\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzPzExNTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNLEtBQTBCOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFlBQVk7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxrQkFBa0Isa0NBQWtDO0FBQ3BELEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLFlBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixJQUFJOztBQUVwQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRLDZCQUE2QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGVBQWU7O0FBRWYsU0FBUzs7QUFFVDtBQUNBLFFBQVEsaUNBQWlDO0FBQ3pDLFFBQVEsb0JBQW9CO0FBQzVCLFFBQVEsc0NBQXNDO0FBQzlDLFFBQVE7QUFDUixFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYSxFQUFFO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFVBQVU7QUFDM0Usc0NBQXNDLDJCQUEyQjtBQUNqRTtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSx1RUFBdUU7QUFDbkY7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDJEQUEyRDs7QUFFM0Q7QUFDQTtBQUNBLG9GQUFvRjs7QUFFcEY7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxpREFBaUQ7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsVUFBVSx3Q0FBd0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQSxDQUFDOzs7O0FBSUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsUUFBUSxHQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUEsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsMEJBQTBCLHdCQUF3Qjs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsMENBQTBDO0FBQzFDLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLHNDQUFzQztBQUM5RSxvQ0FBb0MsdUNBQXVDO0FBQzNFLG9DQUFvQyxzQ0FBc0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQyxxQ0FBcUM7QUFDckMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsYUFBYTtBQUNwQyxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOzs7QUFHQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87QUFDZjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnQkFBZ0I7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7O0FBRVg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxjQUFjOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVDQUF1QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQXVEO0FBQzlFOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLCtDQUErQztBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsY0FBYyxxQ0FBcUM7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLCtCQUErQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLHFDQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLFNBQVMsOEJBQThCO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFdBQVc7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxjQUFjLFdBQVc7QUFDeEUsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQSxzQkFBc0IsY0FBYyxzQkFBc0IsZ0JBQWdCO0FBQzFFLGdCQUFnQixXQUFXLFlBQVk7QUFDdkMsY0FBYztBQUNkOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBK0Q7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGlEQUFpRCwwQkFBMEI7QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUEsUUFBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLGdCQUFnQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsU0FBUztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsU0FBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0JBQWtCO0FBQzVCLFdBQVcsa0JBQWtCO0FBQzdCLGNBQWM7QUFDZCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFFBQVEsbUJBQW1CO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUEsSUFBSTtBQUNKOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFLO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQ0FBcUM7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7QUFDTDs7QUFFQSxXQUFXO0FBQ1gsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBLHNCQUFzQjtBQUN0QiwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLGFBQWEsdUNBQXVDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxjQUFjLHNEQUFzRDtBQUNwRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLGNBQWMsbUNBQW1DO0FBQ2pELGVBQWUsNkRBQTZEO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLLElBQTBDO0FBQy9DLENBQUMsaUNBQWtCLEVBQUUsbUNBQUU7QUFDdkI7QUFDQSxFQUFFO0FBQUEsb0dBQUU7QUFDSjs7Ozs7QUFLQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0EsQ0FBQyIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYzLjQuMVxuICogaHR0cHM6Ly9qcXVlcnkuY29tL1xuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTktMDUtMDFUMjE6MDRaXG4gKi9cbiggZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxuXHRcdC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXG5cdFx0Ly8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBoYXZlIGEgYHdpbmRvd2Agd2l0aCBhIGBkb2N1bWVudGBcblx0XHQvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cblx0XHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxuXHRcdC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcblx0XHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cblx0XHRcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcblx0XHRcdGZ1bmN0aW9uKCB3ICkge1xuXHRcdFx0XHRpZiAoICF3LmRvY3VtZW50ICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFjdG9yeSggdyApO1xuXHRcdFx0fTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwgKTtcblx0fVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSApKCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIEVkZ2UgPD0gMTIgLSAxMyssIEZpcmVmb3ggPD0xOCAtIDQ1KywgSUUgMTAgLSAxMSwgU2FmYXJpIDUuMSAtIDkrLCBpT1MgNiAtIDkuMVxuLy8gdGhyb3cgZXhjZXB0aW9ucyB3aGVuIG5vbi1zdHJpY3QgY29kZSAoZS5nLiwgQVNQLk5FVCA0LjUpIGFjY2Vzc2VzIHN0cmljdCBtb2RlXG4vLyBhcmd1bWVudHMuY2FsbGVlLmNhbGxlciAodHJhYy0xMzMzNSkuIEJ1dCBhcyBvZiBqUXVlcnkgMy4wICgyMDE2KSwgc3RyaWN0IG1vZGUgc2hvdWxkIGJlIGNvbW1vblxuLy8gZW5vdWdoIHRoYXQgYWxsIHN1Y2ggYXR0ZW1wdHMgYXJlIGd1YXJkZWQgaW4gYSB0cnkgYmxvY2suXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGFyciA9IFtdO1xuXG52YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgY29uY2F0ID0gYXJyLmNvbmNhdDtcblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xuXG52YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24oIG9iaiApIHtcblxuICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9NTcsIEZpcmVmb3ggPD01MlxuICAgICAgLy8gSW4gc29tZSBicm93c2VycywgdHlwZW9mIHJldHVybnMgXCJmdW5jdGlvblwiIGZvciBIVE1MIDxvYmplY3Q+IGVsZW1lbnRzXG4gICAgICAvLyAoaS5lLiwgYHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9iamVjdFwiICkgPT09IFwiZnVuY3Rpb25cImApLlxuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBjbGFzc2lmeSAqYW55KiBET00gbm9kZSBhcyBhIGZ1bmN0aW9uLlxuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9PSBcIm51bWJlclwiO1xuICB9O1xuXG5cbnZhciBpc1dpbmRvdyA9IGZ1bmN0aW9uIGlzV2luZG93KCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0fTtcblxuXG5cblxuXHR2YXIgcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyA9IHtcblx0XHR0eXBlOiB0cnVlLFxuXHRcdHNyYzogdHJ1ZSxcblx0XHRub25jZTogdHJ1ZSxcblx0XHRub01vZHVsZTogdHJ1ZVxuXHR9O1xuXG5cdGZ1bmN0aW9uIERPTUV2YWwoIGNvZGUsIG5vZGUsIGRvYyApIHtcblx0XHRkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG5cblx0XHR2YXIgaSwgdmFsLFxuXHRcdFx0c2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblxuXHRcdHNjcmlwdC50ZXh0ID0gY29kZTtcblx0XHRpZiAoIG5vZGUgKSB7XG5cdFx0XHRmb3IgKCBpIGluIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA2NCssIEVkZ2UgMTgrXG5cdFx0XHRcdC8vIFNvbWUgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgXCJub25jZVwiIHByb3BlcnR5IG9uIHNjcmlwdHMuXG5cdFx0XHRcdC8vIE9uIHRoZSBvdGhlciBoYW5kLCBqdXN0IHVzaW5nIGBnZXRBdHRyaWJ1dGVgIGlzIG5vdCBlbm91Z2ggYXNcblx0XHRcdFx0Ly8gdGhlIGBub25jZWAgYXR0cmlidXRlIGlzIHJlc2V0IHRvIGFuIGVtcHR5IHN0cmluZyB3aGVuZXZlciBpdFxuXHRcdFx0XHQvLyBiZWNvbWVzIGJyb3dzaW5nLWNvbnRleHQgY29ubmVjdGVkLlxuXHRcdFx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9odG1sL2lzc3Vlcy8yMzY5XG5cdFx0XHRcdC8vIFNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNub25jZS1hdHRyaWJ1dGVzXG5cdFx0XHRcdC8vIFRoZSBgbm9kZS5nZXRBdHRyaWJ1dGVgIGNoZWNrIHdhcyBhZGRlZCBmb3IgdGhlIHNha2Ugb2Zcblx0XHRcdFx0Ly8gYGpRdWVyeS5nbG9iYWxFdmFsYCBzbyB0aGF0IGl0IGNhbiBmYWtlIGEgbm9uY2UtY29udGFpbmluZyBub2RlXG5cdFx0XHRcdC8vIHZpYSBhbiBvYmplY3QuXG5cdFx0XHRcdHZhbCA9IG5vZGVbIGkgXSB8fCBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZSggaSApO1xuXHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKCBpLCB2YWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRkb2MuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0ICkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG5cdH1cblxuXG5mdW5jdGlvbiB0b1R5cGUoIG9iaiApIHtcblx0aWYgKCBvYmogPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seSAoZnVuY3Rpb25pc2ggUmVnRXhwKVxuXHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwoIG9iaiApIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0dHlwZW9mIG9iajtcbn1cbi8qIGdsb2JhbCBTeW1ib2wgKi9cbi8vIERlZmluaW5nIHRoaXMgZ2xvYmFsIGluIC5lc2xpbnRyYy5qc29uIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8gZGVmaW5lIGdsb2JhbCBvbmx5IGZvciB0aGlzIG1vZHVsZVxuXG5cblxudmFyXG5cdHZlcnNpb24gPSBcIjMuNC4xXCIsXG5cblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHQvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1Bcblx0cnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2c7XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cblx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0aWYgKCBudW0gPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdHJldHVybiBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFpc0Z1bmN0aW9uKCB0YXJnZXQgKSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmICggKCBvcHRpb25zID0gYXJndW1lbnRzWyBpIF0gKSAhPSBudWxsICkge1xuXG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBPYmplY3QucHJvdG90eXBlIHBvbGx1dGlvblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggbmFtZSA9PT0gXCJfX3Byb3RvX19cIiB8fCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29weSApIHx8XG5cdFx0XHRcdFx0KCBjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG5cdFx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cblx0XHRcdFx0XHQvLyBFbnN1cmUgcHJvcGVyIHR5cGUgZm9yIHRoZSBzb3VyY2UgdmFsdWVcblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICYmICFBcnJheS5pc0FycmF5KCBzcmMgKSApIHtcblx0XHRcdFx0XHRcdGNsb25lID0gW107XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggIWNvcHlJc0FycmF5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgKSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHt9O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIHByb3RvLCBDdG9yO1xuXG5cdFx0Ly8gRGV0ZWN0IG9idmlvdXMgbmVnYXRpdmVzXG5cdFx0Ly8gVXNlIHRvU3RyaW5nIGluc3RlYWQgb2YgalF1ZXJ5LnR5cGUgdG8gY2F0Y2ggaG9zdCBvYmplY3RzXG5cdFx0aWYgKCAhb2JqIHx8IHRvU3RyaW5nLmNhbGwoIG9iaiApICE9PSBcIltvYmplY3QgT2JqZWN0XVwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHByb3RvID0gZ2V0UHJvdG8oIG9iaiApO1xuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxuXHRcdGlmICggIXByb3RvICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIHByb3RvdHlwZSBhcmUgcGxhaW4gaWZmIHRoZXkgd2VyZSBjb25zdHJ1Y3RlZCBieSBhIGdsb2JhbCBPYmplY3QgZnVuY3Rpb25cblx0XHRDdG9yID0gaGFzT3duLmNhbGwoIHByb3RvLCBcImNvbnN0cnVjdG9yXCIgKSAmJiBwcm90by5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBmblRvU3RyaW5nLmNhbGwoIEN0b3IgKSA9PT0gT2JqZWN0RnVuY3Rpb25TdHJpbmc7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgbmFtZTtcblxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSwgb3B0aW9ucyApIHtcblx0XHRET01FdmFsKCBjb2RlLCB7IG5vbmNlOiBvcHRpb25zICYmIG9wdGlvbnMubm9uY2UgfSApO1xuXHR9LFxuXG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xuXHRcdHZhciBsZW5ndGgsIGkgPSAwO1xuXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XCJcIiA6XG5cdFx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGNvbmNhdC5hcHBseSggW10sIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaCggXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KCBcIiBcIiApLFxuZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufSApO1xuXG5mdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXG5cdC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcblx0Ly8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuXHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcblx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuXHR2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcblx0XHR0eXBlID0gdG9UeXBlKCBvYmogKTtcblxuXHRpZiAoIGlzRnVuY3Rpb24oIG9iaiApIHx8IGlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG52YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMy40XG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanMuZm91bmRhdGlvbi9cbiAqXG4gKiBEYXRlOiAyMDE5LTA0LTA4XG4gKi9cbihmdW5jdGlvbiggd2luZG93ICkge1xuXG52YXIgaSxcblx0c3VwcG9ydCxcblx0RXhwcixcblx0Z2V0VGV4dCxcblx0aXNYTUwsXG5cdHRva2VuaXplLFxuXHRjb21waWxlLFxuXHRzZWxlY3QsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0c2V0RG9jdW1lbnQsXG5cdGRvY3VtZW50LFxuXHRkb2NFbGVtLFxuXHRkb2N1bWVudElzSFRNTCxcblx0cmJ1Z2d5UVNBLFxuXHRyYnVnZ3lNYXRjaGVzLFxuXHRtYXRjaGVzLFxuXHRjb250YWlucyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG5cdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRub25uYXRpdmVTZWxlY3RvckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdC8vIGh0dHBzOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcblx0aW5kZXhPZiA9IGZ1bmN0aW9uKCBsaXN0LCBlbGVtICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IGxpc3QubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCBsaXN0W2ldID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxuXHRpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXDAtXFxcXHhhMF0pK1wiLFxuXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgK1xuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyZGVzY2VuZCA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcInw+XCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaHRtbCA9IC9IVE1MJC9pLFxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXG5cdC8vIENTUyBlc2NhcGVzXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98KFwiICsgd2hpdGVzcGFjZSArIFwiKXwuKVwiLCBcImlnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XG5cdFx0Ly8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI0XG5cdFx0Ly8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXCIweFwiXG5cdFx0cmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xuXHRcdFx0ZXNjYXBlZCA6XG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdC8vIEJNUCBjb2RlcG9pbnRcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRcdC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxuXHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2NvbW1vbi1zZXJpYWxpemluZy1pZGlvbXNcblx0cmNzc2VzY2FwZSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxcMC1cXHgxZlxceDdmLVxcdUZGRkZcXHctXS9nLFxuXHRmY3NzZXNjYXBlID0gZnVuY3Rpb24oIGNoLCBhc0NvZGVQb2ludCApIHtcblx0XHRpZiAoIGFzQ29kZVBvaW50ICkge1xuXG5cdFx0XHQvLyBVKzAwMDAgTlVMTCBiZWNvbWVzIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVJcblx0XHRcdGlmICggY2ggPT09IFwiXFwwXCIgKSB7XG5cdFx0XHRcdHJldHVybiBcIlxcdUZGRkRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcblx0XHRcdHJldHVybiBjaC5zbGljZSggMCwgLTEgKSArIFwiXFxcXFwiICsgY2guY2hhckNvZGVBdCggY2gubGVuZ3RoIC0gMSApLnRvU3RyaW5nKCAxNiApICsgXCIgXCI7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXIgcG90ZW50aWFsbHktc3BlY2lhbCBBU0NJSSBjaGFyYWN0ZXJzIGdldCBiYWNrc2xhc2gtZXNjYXBlZFxuXHRcdHJldHVybiBcIlxcXFxcIiArIGNoO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXNcblx0Ly8gU2VlIHNldERvY3VtZW50KClcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9LFxuXG5cdGluRGlzYWJsZWRGaWVsZHNldCA9IGFkZENvbWJpbmF0b3IoXG5cdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZmllbGRzZXRcIjtcblx0XHR9LFxuXHRcdHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG5cdCk7XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdChhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXG5cdFx0aWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcblx0XHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0fVxuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcblx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAobSA9IG1hdGNoWzFdKSApIHtcblxuXHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdC8vIENsYXNzIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHQhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSkgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA4IG9ubHlcblx0XHRcdFx0Ly8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcblx0XHRcdFx0KG5vZGVUeXBlICE9PSAxIHx8IGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIikgKSB7XG5cblx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cblx0XHRcdFx0Ly8gcVNBIGNvbnNpZGVycyBlbGVtZW50cyBvdXRzaWRlIGEgc2NvcGluZyByb290IHdoZW4gZXZhbHVhdGluZyBjaGlsZCBvclxuXHRcdFx0XHQvLyBkZXNjZW5kYW50IGNvbWJpbmF0b3JzLCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50LlxuXHRcdFx0XHQvLyBJbiBzdWNoIGNhc2VzLCB3ZSB3b3JrIGFyb3VuZCB0aGUgYmVoYXZpb3IgYnkgcHJlZml4aW5nIGV2ZXJ5IHNlbGVjdG9yIGluIHRoZVxuXHRcdFx0XHQvLyBsaXN0IHdpdGggYW4gSUQgc2VsZWN0b3IgcmVmZXJlbmNpbmcgdGhlIHNjb3BlIGNvbnRleHQuXG5cdFx0XHRcdC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHRlY2huaXF1ZS5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gMSAmJiByZGVzY2VuZC50ZXN0KCBzZWxlY3RvciApICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRpZiAoIChuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkpICkge1xuXHRcdFx0XHRcdFx0bmlkID0gbmlkLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKG5pZCA9IGV4cGFuZG8pICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbaV0gPSBcIiNcIiArIG5pZCArIFwiIFwiICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSggc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcblx0XHR9XG5cdFx0cmV0dXJuIChjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGVsICk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBlbC5wYXJlbnROb2RlICkge1xuXHRcdFx0ZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWwgKTtcblx0XHR9XG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRlbCA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAqL1xuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcblx0dmFyIGFyciA9IGF0dHJzLnNwbGl0KFwifFwiKSxcblx0XHRpID0gYXJyLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRFeHByLmF0dHJIYW5kbGVbIGFycltpXSBdID0gaGFuZGxlcjtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAqL1xuZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xuXHR2YXIgY3VyID0gYiAmJiBhLFxuXHRcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRhLnNvdXJjZUluZGV4IC0gYi5zb3VyY2VJbmRleDtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLm5leHRTaWJsaW5nKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIDplbmFibGVkLzpkaXNhYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBkaXNhYmxlZCB0cnVlIGZvciA6ZGlzYWJsZWQ7IGZhbHNlIGZvciA6ZW5hYmxlZFxuICovXG5mdW5jdGlvbiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZGlzYWJsZWQgKSB7XG5cblx0Ly8gS25vd24gOmRpc2FibGVkIGZhbHNlIHBvc2l0aXZlczogZmllbGRzZXRbZGlzYWJsZWRdID4gbGVnZW5kOm50aC1vZi10eXBlKG4rMikgOmNhbi1kaXNhYmxlXG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE9ubHkgY2VydGFpbiBlbGVtZW50cyBjYW4gbWF0Y2ggOmVuYWJsZWQgb3IgOmRpc2FibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZW5hYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWRpc2FibGVkXG5cdFx0aWYgKCBcImZvcm1cIiBpbiBlbGVtICkge1xuXG5cdFx0XHQvLyBDaGVjayBmb3IgaW5oZXJpdGVkIGRpc2FibGVkbmVzcyBvbiByZWxldmFudCBub24tZGlzYWJsZWQgZWxlbWVudHM6XG5cdFx0XHQvLyAqIGxpc3RlZCBmb3JtLWFzc29jaWF0ZWQgZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBmaWVsZHNldFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NhdGVnb3J5LWxpc3RlZFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtZmUtZGlzYWJsZWRcblx0XHRcdC8vICogb3B0aW9uIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LW9wdGlvbi1kaXNhYmxlZFxuXHRcdFx0Ly8gQWxsIHN1Y2ggZWxlbWVudHMgaGF2ZSBhIFwiZm9ybVwiIHByb3BlcnR5LlxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgJiYgZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Ly8gT3B0aW9uIGVsZW1lbnRzIGRlZmVyIHRvIGEgcGFyZW50IG9wdGdyb3VwIGlmIHByZXNlbnRcblx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5wYXJlbnROb2RlLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDYgLSAxMVxuXHRcdFx0XHQvLyBVc2UgdGhlIGlzRGlzYWJsZWQgc2hvcnRjdXQgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGRpc2FibGVkIGZpZWxkc2V0IGFuY2VzdG9yc1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pc0Rpc2FibGVkID09PSBkaXNhYmxlZCB8fFxuXG5cdFx0XHRcdFx0Ly8gV2hlcmUgdGhlcmUgaXMgbm8gaXNEaXNhYmxlZCwgY2hlY2sgbWFudWFsbHlcblx0XHRcdFx0XHQvKiBqc2hpbnQgLVcwMTggKi9cblx0XHRcdFx0XHRlbGVtLmlzRGlzYWJsZWQgIT09ICFkaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0aW5EaXNhYmxlZEZpZWxkc2V0KCBlbGVtICkgPT09IGRpc2FibGVkO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cblx0XHQvLyBUcnkgdG8gd2lubm93IG91dCBlbGVtZW50cyB0aGF0IGNhbid0IGJlIGRpc2FibGVkIGJlZm9yZSB0cnVzdGluZyB0aGUgZGlzYWJsZWQgcHJvcGVydHkuXG5cdFx0Ly8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XG5cdFx0Ly8gZXZlbiBleGlzdCBvbiB0aGVtLCBsZXQgYWxvbmUgaGF2ZSBhIGJvb2xlYW4gdmFsdWUuXG5cdFx0fSBlbHNlIGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHR2YXIgaixcblx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XG5cblx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VlZFsgKGogPSBtYXRjaEluZGV4ZXNbaV0pIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG59XG5cbi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG5zdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuLyoqXG4gKiBEZXRlY3RzIFhNTCBub2Rlc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAqL1xuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5hbWVzcGFjZSA9IGVsZW0ubmFtZXNwYWNlVVJJLFxuXHRcdGRvY0VsZW0gPSAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PThcblx0Ly8gQXNzdW1lIEhUTUwgd2hlbiBkb2N1bWVudEVsZW1lbnQgZG9lc24ndCB5ZXQgZXhpc3QsIHN1Y2ggYXMgaW5zaWRlIGxvYWRpbmcgaWZyYW1lc1xuXHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNDgzM1xuXHRyZXR1cm4gIXJodG1sLnRlc3QoIG5hbWVzcGFjZSB8fCBkb2NFbGVtICYmIGRvY0VsZW0ubm9kZU5hbWUgfHwgXCJIVE1MXCIgKTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgc3ViV2luZG93LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcblx0aWYgKCBwcmVmZXJyZWREb2MgIT09IGRvY3VtZW50ICYmXG5cdFx0KHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3KSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMSwgRWRnZVxuXHRcdGlmICggc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggc3ViV2luZG93LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0c3ViV2luZG93LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWVsLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcblx0fSk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIlwiKSApO1xuXHRcdHJldHVybiAhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBJRCBmaWx0ZXIgYW5kIGZpbmRcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gZWxlbSA/IFsgZWxlbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBub2RlLCBpLCBlbGVtcyxcblx0XHRcdFx0XHRlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHQvLyBWZXJpZnkgdGhlIGlkIGF0dHJpYnV0ZVxuXHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG5cdFx0XHRcdFx0ZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBpZCApO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtc1tpKytdKSApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cblx0XHRcdFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG5cdFx0XHRpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG5cdFx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0XHQvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJsaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIi4jLitbK35dXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmRpc2FibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZWwucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZWwsIFwiKlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZWwsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRhZG93bi5jb250YWlucyggYnVwICkgOlxuXHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0KSk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRpZiAoIGIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGIgPSBiLnBhcmVudE5vZGUpICkge1xuXHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG5cdFx0XHQxO1xuXG5cdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0aWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0KCFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUpICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdGlmICggYSA9PT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9IDpcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cdFx0XHRyZXR1cm4gYSA9PT0gZG9jdW1lbnQgPyAtMSA6XG5cdFx0XHRcdGIgPT09IGRvY3VtZW50ID8gMSA6XG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblxuXHRcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0d2hpbGUgKCBhcFtpXSA9PT0gYnBbaV0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXHRcdFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHRhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0aWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdCFub25uYXRpdmVTZWxlY3RvckNhY2hlWyBleHByICsgXCIgXCIgXSAmJlxuXHRcdCggIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdCggZXhwciApICkgJiZcblx0XHQoICFyYnVnZ3lRU0EgICAgIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cblx0XHR0cnkge1xuXHRcdFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xuXG5cdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG5cdFx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcblx0XHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRub25uYXRpdmVTZWxlY3RvckNhY2hlKCBleHByLCB0cnVlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcbn07XG5cblNpenpsZS5lc2NhcGUgPSBmdW5jdGlvbiggc2VsICkge1xuXHRyZXR1cm4gKHNlbCArIFwiXCIpLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0cmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRzb3J0SW5wdXQgPSBudWxsO1xuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG4gKi9cbmdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbm9kZSxcblx0XHRyZXQgPSBcIlwiLFxuXHRcdGkgPSAwLFxuXHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRpZiAoICFub2RlVHlwZSApIHtcblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKG5vZGUgPSBlbGVtW2krK10pICkge1xuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cdFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuXHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHR9XG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHQvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuXHRcdFx0bWF0Y2hbM10gPSAoIG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzJdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWzNdID0gXCIgXCIgKyBtYXRjaFszXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzFdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cdFx0XHRcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG5cdFx0XHRcdGlmICggIW1hdGNoWzNdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWzRdID0gKyggbWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAoIG1hdGNoWzNdID09PSBcImV2ZW5cIiB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApICk7XG5cdFx0XHRcdG1hdGNoWzVdID0gKyggKCBtYXRjaFs3XSArIG1hdGNoWzhdICkgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKTtcblxuXHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QoIG1hdGNoWzBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0bWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cdFx0XHRcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG5cdFx0XHRcdChleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSkgJiZcblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdChleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGgpICkge1xuXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmlsdGVyOiB7XG5cblx0XHRcIlRBR1wiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcblx0XHRcdHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQocGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkpICYmXG5cdFx0XHRcdGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdCggdHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIgKTtcblx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcblx0XHRcdFx0XHRcdGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHRuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxuXHRcdFx0XHRcdFx0ZGlmZiA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0XHRcdGlmICggc2ltcGxlICkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGRpciApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gbm9kZVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0bm9kZSA9IHBhcmVudDtcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcblx0XHRcdFx0XHRcdFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsrZGlmZiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuXHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG5cdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuXHRcdFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xuXHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXHRcdFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcblx0XHRcdFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WzBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0XHRpbnB1dFswXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG5cdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0XCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG5cdFx0fSxcblxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGZhbHNlICksXG5cdFx0XCJkaXNhYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggdHJ1ZSApLFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkKSB8fCAobm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcblx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnRzXG5cdFx0XCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1tcImVtcHR5XCJdKCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRcImhlYWRlclwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblxuXHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG5cdFx0XHRcdGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0XCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0pLFxuXG5cdFx0XCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSksXG5cblx0XHRcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwibHRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgP1xuXHRcdFx0XHRhcmd1bWVudCArIGxlbmd0aCA6XG5cdFx0XHRcdGFyZ3VtZW50ID4gbGVuZ3RoID9cblx0XHRcdFx0XHRsZW5ndGggOlxuXHRcdFx0XHRcdGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1tcIm50aFwiXSA9IEV4cHIucHNldWRvc1tcImVxXCJdO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbn1cbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG59XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbnRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG5cdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggY2FjaGVkICkge1xuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XG5cdH1cblxuXHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRncm91cHMgPSBbXTtcblx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFswXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdH1cblx0XHRcdGdyb3Vwcy5wdXNoKCAodG9rZW5zID0gW10pICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApXG5cdFx0XHR9KTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoIChtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkpICYmICghcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdChtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSkpICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdHJldHVybiBwYXJzZU9ubHkgP1xuXHRcdHNvRmFyLmxlbmd0aCA6XG5cdFx0c29GYXIgP1xuXHRcdFx0U2l6emxlLmVycm9yKCBzZWxlY3RvciApIDpcblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufTtcblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1tpXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRza2lwID0gY29tYmluYXRvci5uZXh0LFxuXHRcdGtleSA9IHNraXAgfHwgZGlyLFxuXHRcdGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGtleSA9PT0gXCJwYXJlbnROb2RlXCIsXG5cdFx0ZG9uZU5hbWUgPSBkb25lKys7XG5cblx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xuXHRcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKGVsZW1bIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSB8fCAob3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHNraXAgJiYgc2tpcCA9PT0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtID0gZWxlbVsgZGlyIF0gfHwgZWxlbTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIChvbGRDYWNoZSA9IHVuaXF1ZUNhY2hlWyBrZXkgXSkgJiZcblx0XHRcdFx0XHRcdFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIGtleSBdID0gbmV3Q2FjaGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdGlmICggKG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG5cdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbaV0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbMF07XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0U2l6emxlKCBzZWxlY3RvciwgY29udGV4dHNbaV0sIHJlc3VsdHMgKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcblx0dmFyIGVsZW0sXG5cdFx0bmV3VW5tYXRjaGVkID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcblx0XHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXCIqXCIsIGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cblx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0ZWxlbXMsXG5cblx0XHRcdG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFtpXSBdID0gIShtYXRjaGVySW5bIHBvc3RNYXBbaV0gXSA9IGVsZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKG1hdGNoZXJJbltpXSA9IGVsZW0pICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIChtYXRjaGVyT3V0ID0gW10pLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXG5cdFx0XHRcdFx0XHQodGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbaV0pID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1swXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcblx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cblx0XHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuXHRcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZiggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgcmV0ID0gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcblx0XHRcdFx0KGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cdFx0XHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdGNoZWNrQ29udGV4dCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2ldLnR5cGUgXSkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbaV0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1tqXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG5cdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3Rvcihcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG5cdFx0XHRcdFx0XHR0b2tlbnMuc2xpY2UoIDAsIGkgLSAxICkuY29uY2F0KHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9KVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKHRva2VucyA9IHRva2Vucy5zbGljZSggaiApKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcblx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kW1wiVEFHXCJdKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcblx0XHRcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuXHRcdFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdFx0XHRcdFx0XHR4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCkgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXG5cdFx0XHRcdGlmICggYnlTZXQgKSB7XG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtKSApIHtcblx0XHRcdFx0XHRcdG1hdGNoZWRDb3VudC0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3Rcblx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0Ly8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXG5cdFx0XHQvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuXHRcdFx0Ly8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuXHRcdFx0Ly8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcIjAwXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXG5cdFx0XHQvLyBudW1lcmljYWxseSB6ZXJvLlxuXHRcdFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gc2V0TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggISh1bm1hdGNoZWRbaV0gfHwgc2V0TWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2V0TWF0Y2hlZFtpXSA9IHBvcC5jYWxsKCByZXN1bHRzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xuXHRcdFx0XHRcdHNldE1hdGNoZWQgPSBjb25kZW5zZSggc2V0TWF0Y2hlZCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZXRNYXRjaGVkICk7XG5cblx0XHRcdFx0Ly8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG5cdFx0XHRcdGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuXHRcdFx0XHRcdCggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkge1xuXG5cdFx0XHRcdFx0U2l6emxlLnVuaXF1ZVNvcnQoIHJlc3VsdHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1bm1hdGNoZWQ7XG5cdFx0fTtcblxuXHRyZXR1cm4gYnlTZXQgP1xuXHRcdG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxuXHRcdHN1cGVyTWF0Y2hlcjtcbn1cblxuY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0dmFyIGksXG5cdFx0c2V0TWF0Y2hlcnMgPSBbXSxcblx0XHRlbGVtZW50TWF0Y2hlcnMgPSBbXSxcblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCAhY2FjaGVkICkge1xuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFtpXSApO1xuXHRcdFx0aWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0c2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZSggc2VsZWN0b3IsIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApICk7XG5cblx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufTtcblxuLyoqXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICovXG5zZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuXHRcdG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoIChzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yKSApO1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG5cdC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXCJJRFwiICYmXG5cdFx0XHRcdGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiYgRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kW1wiSURcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbMF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdCkpICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oXCJcIikgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG5cdHJldHVybiBlbC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpICkgJiAxO1xufSk7XG5cbi8vIFN1cHBvcnQ6IElFPDhcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG4vLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiIDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0eXBlXCIgPyAxIDogMiApO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcbmlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRyZXR1cm4gZWwuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT0gbnVsbDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIGJvb2xlYW5zLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHZhbDtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtWyBuYW1lIF0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdH0pO1xufVxuXG5yZXR1cm4gU2l6emxlO1xuXG59KSggd2luZG93ICk7XG5cblxuXG5qUXVlcnkuZmluZCA9IFNpenpsZTtcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcblxuLy8gRGVwcmVjYXRlZFxualF1ZXJ5LmV4cHJbIFwiOlwiIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG5qUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xualF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xualF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xualF1ZXJ5LmVzY2FwZVNlbGVjdG9yID0gU2l6emxlLmVzY2FwZTtcblxuXG5cblxudmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuXHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdHZhciBtYXRjaGVkID0gW107XG5cblx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxuXG5cbmZ1bmN0aW9uIG5vZGVOYW1lKCBlbGVtLCBuYW1lICkge1xuXG4gIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG59O1xudmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pICk7XG5cblxuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gU2luZ2xlIGVsZW1lbnRcblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEZpbHRlcmVkIGRpcmVjdGx5IGZvciBib3RoIHNpbXBsZSBhbmQgY29tcGxleCBzZWxlY3RvcnNcblx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0aWYgKCBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdH0gKSApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIHJldCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggW10gKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggcmV0ICkgOiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0gKTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0Ly8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsgMiBdICk7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XG5cblx0XHQvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XG5cdFx0aWYgKCAhcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cblx0XHRcdFx0XHRcdHRhcmdldHMuaW5kZXgoIGN1ciApID4gLTEgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5jb250ZW50RG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHksIGlPUyA3IG9ubHksIEFuZHJvaWQgQnJvd3NlciA8PTQuMyBvbmx5XG5cdFx0Ly8gVHJlYXQgdGhlIHRlbXBsYXRlIGVsZW1lbnQgYXMgYSByZWd1bGFyIG9uZSBpbiBicm93c2VycyB0aGF0XG5cdFx0Ly8gZG9uJ3Qgc3VwcG9ydCBpdC5cblx0XHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRlbXBsYXRlXCIgKSApIHtcblx0XHRcdGVsZW0gPSBlbGVtLmNvbnRlbnQgfHwgZWxlbTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG5cdH07XG59ICk7XG52YXIgcm5vdGh0bWx3aGl0ZSA9ICggL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nICk7XG5cblxuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0gKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuXHRcdG1lbW9yeSxcblxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cblx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0bG9ja2VkLFxuXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cblx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHF1ZXVlID0gW10sXG5cblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0bG9ja2VkID0gbG9ja2VkIHx8IG9wdGlvbnMub25jZTtcblxuXHRcdFx0Ly8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXG5cdFx0XHQvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXG5cdFx0XHRmaXJlZCA9IGZpcmluZyA9IHRydWU7XG5cdFx0XHRmb3IgKCA7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSApIHtcblx0XHRcdFx0bWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdFx0d2hpbGUgKCArK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuXHRcdFx0XHRcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXG5cdFx0XHRcdFx0XHRvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcblx0XHRcdGlmICggIW9wdGlvbnMubWVtb3J5ICkge1xuXHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXG5cdFx0XHRpZiAoIGxvY2tlZCApIHtcblxuXHRcdFx0XHQvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXG5cdFx0XHRcdGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGlzdCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCggZnVuY3Rpb24gYWRkKCBhcmdzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiB0b1R5cGUoIGFyZyApICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0XHRcdGFkZCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9ICkoIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cblx0XHRcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuXHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdHJldHVybiBmbiA/XG5cdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XG5cdFx0XHRcdFx0bGlzdC5sZW5ndGggPiAwO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxuXHRcdFx0Ly8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHQvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlXG5cdFx0XHQvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuXHRcdFx0Ly8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGlmICggIW1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCAhbG9ja2VkICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0cXVldWUucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5mdW5jdGlvbiBJZGVudGl0eSggdiApIHtcblx0cmV0dXJuIHY7XG59XG5mdW5jdGlvbiBUaHJvd2VyKCBleCApIHtcblx0dGhyb3cgZXg7XG59XG5cbmZ1bmN0aW9uIGFkb3B0VmFsdWUoIHZhbHVlLCByZXNvbHZlLCByZWplY3QsIG5vVmFsdWUgKSB7XG5cdHZhciBtZXRob2Q7XG5cblx0dHJ5IHtcblxuXHRcdC8vIENoZWNrIGZvciBwcm9taXNlIGFzcGVjdCBmaXJzdCB0byBwcml2aWxlZ2Ugc3luY2hyb25vdXMgYmVoYXZpb3Jcblx0XHRpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUucHJvbWlzZSApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUgKS5kb25lKCByZXNvbHZlICkuZmFpbCggcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciB0aGVuYWJsZXNcblx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnRoZW4gKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlLCByZXNvbHZlLCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIG5vbi10aGVuYWJsZXNcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb250cm9sIGByZXNvbHZlYCBhcmd1bWVudHMgYnkgbGV0dGluZyBBcnJheSNzbGljZSBjYXN0IGJvb2xlYW4gYG5vVmFsdWVgIHRvIGludGVnZXI6XG5cdFx0XHQvLyAqIGZhbHNlOiBbIHZhbHVlIF0uc2xpY2UoIDAgKSA9PiByZXNvbHZlKCB2YWx1ZSApXG5cdFx0XHQvLyAqIHRydWU6IFsgdmFsdWUgXS5zbGljZSggMSApID0+IHJlc29sdmUoKVxuXHRcdFx0cmVzb2x2ZS5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0uc2xpY2UoIG5vVmFsdWUgKSApO1xuXHRcdH1cblxuXHQvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcblx0Ly8gU2luY2UgalF1ZXJ5LndoZW4gZG9lc24ndCB1bndyYXAgdGhlbmFibGVzLCB3ZSBjYW4gc2tpcCB0aGUgZXh0cmEgY2hlY2tzIGFwcGVhcmluZyBpblxuXHQvLyBEZWZlcnJlZCN0aGVuIHRvIGNvbmRpdGlvbmFsbHkgc3VwcHJlc3MgcmVqZWN0aW9uLlxuXHR9IGNhdGNoICggdmFsdWUgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG5cdFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuXHRcdHJlamVjdC5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0gKTtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGNhbGxiYWNrcyxcblx0XHRcdFx0Ly8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSwgMiBdLFxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDAsIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMSwgXCJyZWplY3RlZFwiIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJjYXRjaFwiOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByb21pc2UudGhlbiggbnVsbCwgZm4gKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdHBpcGU6IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBpc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHR2YXIgbWF4RGVwdGggPSAwO1xuXHRcdFx0XHRcdGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkLCB0aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGVuID0gcmV0dXJuZWQgJiZcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQudGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhlbiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNwZWNpYWwgcHJvY2Vzc29ycyAobm90aWZ5KSBqdXN0IHdhaXQgZm9yIHJlc29sdXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heERlcHRoKys7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IElkZW50aXR5ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgcmV0dXJuZWQgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCApKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MgPSBzcGVjaWFsID9cblx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCArIDEgPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBUaHJvd2VyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyBlIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcblx0XHRcdFx0XHRcdFx0Ly8gUmUtcmVzb2x2ZSBwcm9taXNlcyBpbW1lZGlhdGVseSB0byBkb2RnZSBmYWxzZSByZWplY3Rpb24gZnJvbVxuXHRcdFx0XHRcdFx0XHQvLyBzdWJzZXF1ZW50IGVycm9yc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIHN0YWNrLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHByb2Nlc3MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUHJvZ3Jlc3MgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIubm90aWZ5V2l0aFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAxIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvbkZ1bGZpbGxlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uRnVsZmlsbGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5XG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUmVqZWN0ZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0VGhyb3dlclxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDUgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlamVjdGVkXCJcblx0XHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMyBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAyIF0ubG9jayxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmxvY2tcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcblx0XHR2YXJcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcblx0XHRcdGkgPSByZW1haW5pbmcsXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IEFycmF5KCBpICksXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cblx0XHRcdC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWRcblx0XHRcdG1hc3RlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZUNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRtYXN0ZXIucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHQvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcblx0XHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIG1hc3Rlci5kb25lKCB1cGRhdGVGdW5jKCBpICkgKS5yZXNvbHZlLCBtYXN0ZXIucmVqZWN0LFxuXHRcdFx0XHQhcmVtYWluaW5nICk7XG5cblx0XHRcdC8vIFVzZSAudGhlbigpIHRvIHVud3JhcCBzZWNvbmRhcnkgdGhlbmFibGVzIChjZi4gZ2gtMzAwMClcblx0XHRcdGlmICggbWFzdGVyLnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG5cdFx0XHRcdGlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xuXG5cdFx0XHRcdHJldHVybiBtYXN0ZXIudGhlbigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCByZXNvbHZlVmFsdWVzWyBpIF0sIHVwZGF0ZUZ1bmMoIGkgKSwgbWFzdGVyLnJlamVjdCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYXN0ZXIucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXG4vLyB3YXJuIGFib3V0IHRoZW0gQVNBUCByYXRoZXIgdGhhbiBzd2FsbG93aW5nIHRoZW0gYnkgZGVmYXVsdC5cbnZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xuXG5qUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKCBlcnJvciwgc3RhY2sgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgOCAtIDkgb25seVxuXHQvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxuXHRpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xuXHRcdHdpbmRvdy5jb25zb2xlLndhcm4oIFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIgKyBlcnJvci5tZXNzYWdlLCBlcnJvci5zdGFjaywgc3RhY2sgKTtcblx0fVxufTtcblxuXG5cblxualF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oIGVycm9yICkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gKTtcbn07XG5cblxuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0cmVhZHlMaXN0XG5cdFx0LnRoZW4oIGZuIClcblxuXHRcdC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXG5cdFx0Ly8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXG5cdFx0Ly8gcmVnaXN0cmF0aW9uLlxuXHRcdC5jYXRjaCggZnVuY3Rpb24oIGVycm9yICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xuXHRcdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxuLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcbi8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxuLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5pZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuXHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0d2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG59IGVsc2Uge1xuXG5cdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXG5cdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG59XG5cblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggdG9UeXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblxuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Zm4oXG5cdFx0XHRcdFx0ZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuXHRcdFx0XHRcdHZhbHVlIDpcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggY2hhaW5hYmxlICkge1xuXHRcdHJldHVybiBlbGVtcztcblx0fVxuXG5cdC8vIEdldHNcblx0aWYgKCBidWxrICkge1xuXHRcdHJldHVybiBmbi5jYWxsKCBlbGVtcyApO1xuXHR9XG5cblx0cmV0dXJuIGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcblxuXG4vLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcbnZhciBybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW2Etel0pL2c7XG5cbi8vIFVzZWQgYnkgY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuZnVuY3Rpb24gZmNhbWVsQ2FzZSggYWxsLCBsZXR0ZXIgKSB7XG5cdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcbn1cblxuLy8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuLy8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuLy8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuZnVuY3Rpb24gY2FtZWxDYXNlKCBzdHJpbmcgKSB7XG5cdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xufVxudmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0Ly8gQWNjZXB0cyBvbmx5OlxuXHQvLyAgLSBOb2RlXG5cdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcblx0Ly8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcblx0Ly8gIC0gT2JqZWN0XG5cdC8vICAgIC0gQW55XG5cdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIERhdGEoKSB7XG5cdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbn1cblxuRGF0YS51aWQgPSAxO1xuXG5EYXRhLnByb3RvdHlwZSA9IHtcblxuXHRjYWNoZTogZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG5cdFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHR2YWx1ZSA9IHt9O1xuXG5cdFx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRcdGlmICggYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0XHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG5cdFx0XHRcdC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG5cdFx0XHRcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Y2FjaGVbIGNhbWVsQ2FzZSggZGF0YSApIF0gPSB2YWx1ZTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRcdGZvciAoIHByb3AgaW4gZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVbIGNhbWVsQ2FzZSggcHJvcCApIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XG5cblx0XHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGNhbWVsQ2FzZSgga2V5ICkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG5cdFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG5cdFx0Ly9cblx0XHQvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcblx0XHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG5cdFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuXHRcdC8vXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHQoICgga2V5ICYmIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmdldCggb3duZXIsIGtleSApO1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG5cdFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcblx0XHQvL1xuXHRcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG5cdFx0Ly8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG5cdFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcblx0fSxcblx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHR2YXIgaSxcblx0XHRcdGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0aWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGtleSApICkge1xuXG5cdFx0XHRcdC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzZXQgY2FtZWxDYXNlIGtleXMsIHNvIHJlbW92ZSB0aGF0LlxuXHRcdFx0XHRrZXkgPSBrZXkubWFwKCBjYW1lbENhc2UgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleSA9IGNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRrZXkgPSBrZXkgaW4gY2FjaGUgP1xuXHRcdFx0XHRcdFsga2V5IF0gOlxuXHRcdFx0XHRcdCgga2V5Lm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10gKTtcblx0XHRcdH1cblxuXHRcdFx0aSA9IGtleS5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIGtleVsgaSBdIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIHRoZXJlJ3Mgbm8gbW9yZSBkYXRhXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxuXHRcdFx0Ly8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcblx0XHRcdC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXG5cdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XG5cdH1cbn07XG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbmZ1bmN0aW9uIGdldERhdGEoIGRhdGEgKSB7XG5cdGlmICggZGF0YSA9PT0gXCJ0cnVlXCIgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwiZmFsc2VcIiApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwibnVsbFwiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0aWYgKCBkYXRhID09PSArZGF0YSArIFwiXCIgKSB7XG5cdFx0cmV0dXJuICtkYXRhO1xuXHR9XG5cblx0aWYgKCByYnJhY2UudGVzdCggZGF0YSApICkge1xuXHRcdHJldHVybiBKU09OLnBhcnNlKCBkYXRhICk7XG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0dmFyIG5hbWU7XG5cblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQmXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBnZXREYXRhKCBkYXRhICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0gY2FtZWxDYXNlKCBuYW1lLnNsaWNlKCA1ICkgKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZGF0YTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gVGhlIGtleSB3aWxsIGFsd2F5cyBiZSBjYW1lbENhc2VkIGluIERhdGFcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIGRhdGEuLi5cblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHN0b3JlIHRoZSBjYW1lbENhc2VkIGtleVxuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGF0YVVzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcXVldWU7XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cXVldWUgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0Ly8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuXHRcdFx0aWYgKCBkYXRhICkge1xuXHRcdFx0XHRpZiAoICFxdWV1ZSB8fCBBcnJheS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9IClcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWyAwIF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0gKTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59ICk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuXG5cdHZhciBpc0F0dGFjaGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblx0XHR9LFxuXHRcdGNvbXBvc2VkID0geyBjb21wb3NlZDogdHJ1ZSB9O1xuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCssIGlPUyAxMC4wIC0gMTAuMiBvbmx5XG5cdC8vIENoZWNrIGF0dGFjaG1lbnQgYWNyb3NzIHNoYWRvdyBET00gYm91bmRhcmllcyB3aGVuIHBvc3NpYmxlIChnaC0zNTA0KVxuXHQvLyBTdXBwb3J0OiBpT1MgMTAuMC0xMC4yIG9ubHlcblx0Ly8gRWFybHkgaU9TIDEwIHZlcnNpb25zIHN1cHBvcnQgYGF0dGFjaFNoYWRvd2AgYnV0IG5vdCBgZ2V0Um9vdE5vZGVgLFxuXHQvLyBsZWFkaW5nIHRvIGVycm9ycy4gV2UgbmVlZCB0byBjaGVjayBmb3IgYGdldFJvb3ROb2RlYC5cblx0aWYgKCBkb2N1bWVudEVsZW1lbnQuZ2V0Um9vdE5vZGUgKSB7XG5cdFx0aXNBdHRhY2hlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRSb290Tm9kZSggY29tcG9zZWQgKSA9PT0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdH07XG5cdH1cbnZhciBpc0hpZGRlbldpdGhpblRyZWUgPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XG5cblx0XHQvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRlbGVtID0gZWwgfHwgZWxlbTtcblxuXHRcdC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG5cdFx0cmV0dXJuIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHxcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJlxuXG5cdFx0XHQvLyBPdGhlcndpc2UsIGNoZWNrIGNvbXB1dGVkIHN0eWxlXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDMgLSA0NVxuXHRcdFx0Ly8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGNhbiBoYXZlIGNvbXB1dGVkIGRpc3BsYXk6IG5vbmUsIHNvIGZpcnN0IGNvbmZpcm0gdGhhdCBlbGVtIGlzXG5cdFx0XHQvLyBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHRpc0F0dGFjaGVkKCBlbGVtICkgJiZcblxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCI7XG5cdH07XG5cbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suYXBwbHkoIGVsZW0sIGFyZ3MgfHwgW10gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCwgc2NhbGUsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uY3VyKCk7XG5cdFx0XHR9IDpcblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXCJcIiApO1xuXHRcdFx0fSxcblx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRpbml0aWFsSW5Vbml0ID0gZWxlbS5ub2RlVHlwZSAmJlxuXHRcdFx0KCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cblx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHRcdC8vIEhhbHZlIHRoZSBpdGVyYXRpb24gdGFyZ2V0IHZhbHVlIHRvIHByZXZlbnQgaW50ZXJmZXJlbmNlIGZyb20gQ1NTIHVwcGVyIGJvdW5kcyAoZ2gtMjE0NClcblx0XHRpbml0aWFsID0gaW5pdGlhbCAvIDI7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdHdoaWxlICggbWF4SXRlcmF0aW9ucy0tICkge1xuXG5cdFx0XHQvLyBFdmFsdWF0ZSBhbmQgdXBkYXRlIG91ciBiZXN0IGd1ZXNzIChkb3VibGluZyBndWVzc2VzIHRoYXQgemVybyBvdXQpLlxuXHRcdFx0Ly8gRmluaXNoIGlmIHRoZSBzY2FsZSBlcXVhbHMgb3IgY3Jvc3NlcyAxIChtYWtpbmcgdGhlIG9sZCpuZXcgcHJvZHVjdCBub24tcG9zaXRpdmUpLlxuXHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXHRcdFx0aWYgKCAoIDEgLSBzY2FsZSApICogKCAxIC0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCB8fCAwLjUgKSApIDw9IDAgKSB7XG5cdFx0XHRcdG1heEl0ZXJhdGlvbnMgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblxuXHRcdH1cblxuXHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0ICogMjtcblx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxuXG5cbnZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApIHtcblx0dmFyIHRlbXAsXG5cdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcblx0XHRkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF07XG5cblx0aWYgKCBkaXNwbGF5ICkge1xuXHRcdHJldHVybiBkaXNwbGF5O1xuXHR9XG5cblx0dGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApO1xuXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXCJkaXNwbGF5XCIgKTtcblxuXHR0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRlbXAgKTtcblxuXHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdGRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdH1cblx0ZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Ly8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxuXHRcdFx0Ly8gY2hlY2sgaXMgcmVxdWlyZWQgaW4gdGhpcyBmaXJzdCBsb29wIHVubGVzcyB3ZSBoYXZlIGEgbm9uZW1wdHkgZGlzcGxheSB2YWx1ZSAoZWl0aGVyXG5cdFx0XHQvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG5cdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICkgfHwgbnVsbDtcblx0XHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xuXHRcdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBcIm5vbmVcIjtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXG5cdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJkaXNwbGF5XCIsIGRpc3BsYXkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCB2YWx1ZXNbIGluZGV4IF0gIT0gbnVsbCApIHtcblx0XHRcdGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW5XaXRoaW5UcmVlKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcbnZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcblxudmFyIHJ0YWdOYW1lID0gKCAvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopL2kgKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8Xm1vZHVsZSR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxudmFyIHdyYXBNYXAgPSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0b3B0aW9uOiBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF0sXG5cblx0Ly8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcblx0Ly8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuXHQvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXG5cdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxud3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICgjMTUxNTEpXG5cdHZhciByZXQ7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIHtcblx0XHRyZXQgPSBbXTtcblx0fVxuXG5cdGlmICggdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIG5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0ZWxlbXNbIGkgXSxcblx0XHRcdFwiZ2xvYmFsRXZhbFwiLFxuXHRcdFx0IXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuXG52YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQgKSB7XG5cdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgYXR0YWNoZWQsIGosXG5cdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRub2RlcyA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxuXHRcdFx0aWYgKCB0b1R5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGF0dGFjaGVkID0gaXNBdHRhY2hlZCggZWxlbSApO1xuXG5cdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0aWYgKCBhdHRhY2hlZCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdH1cblxuXHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdG1wWyBqKysgXSApICkge1xuXHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZnJhZ21lbnQ7XG59XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKSxcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcblx0Ly8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKCMxMTIxNylcblx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XG5cblx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgb25seVxuXHQvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcblx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxuXHRkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XG5cdHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xufSApKCk7XG5cblxudmFyXG5cdHJrZXlFdmVudCA9IC9ea2V5Lyxcblx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay8sXG5cdHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuLy8gZm9jdXMoKSBhbmQgYmx1cigpIGFyZSBhc3luY2hyb25vdXMsIGV4Y2VwdCB3aGVuIHRoZXkgYXJlIG5vLW9wLlxuLy8gU28gZXhwZWN0IGZvY3VzIHRvIGJlIHN5bmNocm9ub3VzIHdoZW4gdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBhY3RpdmUsXG4vLyBhbmQgYmx1ciB0byBiZSBzeW5jaHJvbm91cyB3aGVuIHRoZSBlbGVtZW50IGlzIG5vdCBhbHJlYWR5IGFjdGl2ZS5cbi8vIChmb2N1cyBhbmQgYmx1ciBhcmUgYWx3YXlzIHN5bmNocm9ub3VzIGluIG90aGVyIHN1cHBvcnRlZCBicm93c2Vycyxcbi8vIHRoaXMganVzdCBkZWZpbmVzIHdoZW4gd2UgY2FuIGNvdW50IG9uIGl0KS5cbmZ1bmN0aW9uIGV4cGVjdFN5bmMoIGVsZW0sIHR5cGUgKSB7XG5cdHJldHVybiAoIGVsZW0gPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgKSA9PT0gKCB0eXBlID09PSBcImZvY3VzXCIgKTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIEFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiB0aHJvdyB1bmV4cGVjdGVkbHlcbi8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM5M1xuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuZnVuY3Rpb24gb24oIGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSApIHtcblx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0b24oIGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXG5cdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0b3JpZ0ZuID0gZm47XG5cdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fTtcblxuXHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdH1cblx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHR9ICk7XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxuXHRcdGlmICggIWVsZW1EYXRhICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcblx0XHQvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcblx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yICk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IHt9O1xuXHRcdH1cblx0XHRpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuXHRcdFx0XHRcdHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdHZhciBqLCBvcmlnQ291bnQsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBuYXRpdmVFdmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdHZhciBldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICk7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkoIGFyZ3VtZW50cy5sZW5ndGggKSxcblx0XHRcdGhhbmRsZXJzID0gKCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xuXHRcdH1cblxuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGUgZXZlbnQgaXMgbmFtZXNwYWNlZCwgdGhlbiBlYWNoIGhhbmRsZXIgaXMgb25seSBpbnZva2VkIGlmIGl0IGlzXG5cdFx0XHRcdC8vIHNwZWNpYWxseSB1bml2ZXJzYWwgb3IgaXRzIG5hbWVzcGFjZXMgYXJlIGEgc3VwZXJzZXQgb2YgdGhlIGV2ZW50J3MuXG5cdFx0XHRcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgaGFuZGxlT2JqLm5hbWVzcGFjZSA9PT0gZmFsc2UgfHxcblx0XHRcdFx0XHRldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgaGFuZGxlT2JqLCBzZWwsIG1hdGNoZWRIYW5kbGVycywgbWF0Y2hlZFNlbGVjdG9ycyxcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OVxuXHRcdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXG5cdFx0XHRjdXIubm9kZVR5cGUgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQyXG5cdFx0XHQvLyBTdXBwcmVzcyBzcGVjLXZpb2xhdGluZyBjbGlja3MgaW5kaWNhdGluZyBhIG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uICh0cmFjLTM4NjEpXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudC10eXBlLWNsaWNrXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHQvLyAuLi5idXQgbm90IGFycm93IGtleSBcImNsaWNrc1wiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXG5cdFx0XHQhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgZXZlbnQuYnV0dG9uID49IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgY3VyLmRpc2FibGVkID09PSB0cnVlICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzID0gW107XG5cdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9ycyA9IHt9O1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkSGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0Y3VyID0gdGhpcztcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdGFkZFByb3A6IGZ1bmN0aW9uKCBuYW1lLCBob29rICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuXHRcdFx0Z2V0OiBpc0Z1bmN0aW9uKCBob29rICkgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGhvb2soIHRoaXMub3JpZ2luYWxFdmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50WyBuYW1lIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBuYW1lLCB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggb3JpZ2luYWxFdmVudCApIHtcblx0XHRyZXR1cm4gb3JpZ2luYWxFdmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRvcmlnaW5hbEV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gVXRpbGl6ZSBuYXRpdmUgZXZlbnQgdG8gZW5zdXJlIGNvcnJlY3Qgc3RhdGUgZm9yIGNoZWNrYWJsZSBpbnB1dHNcblx0XHRcdHNldHVwOiBmdW5jdGlvbiggZGF0YSApIHtcblxuXHRcdFx0XHQvLyBGb3IgbXV0dWFsIGNvbXByZXNzaWJpbGl0eSB3aXRoIF9kZWZhdWx0LCByZXBsYWNlIGB0aGlzYCBhY2Nlc3Mgd2l0aCBhIGxvY2FsIHZhci5cblx0XHRcdFx0Ly8gYHx8IGRhdGFgIGlzIGRlYWQgY29kZSBtZWFudCBvbmx5IHRvIHByZXNlcnZlIHRoZSB2YXJpYWJsZSB0aHJvdWdoIG1pbmlmaWNhdGlvbi5cblx0XHRcdFx0dmFyIGVsID0gdGhpcyB8fCBkYXRhO1xuXG5cdFx0XHRcdC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdC8vIGRhdGFQcml2LnNldCggZWwsIFwiY2xpY2tcIiwgLi4uIClcblx0XHRcdFx0XHRsZXZlcmFnZU5hdGl2ZSggZWwsIFwiY2xpY2tcIiwgcmV0dXJuVHJ1ZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmV0dXJuIGZhbHNlIHRvIGFsbG93IG5vcm1hbCBwcm9jZXNzaW5nIGluIHRoZSBjYWxsZXJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gRm9yY2Ugc2V0dXAgYmVmb3JlIHRyaWdnZXJpbmcgYSBjbGlja1xuXHRcdFx0XHRpZiAoIHJjaGVja2FibGVUeXBlLnRlc3QoIGVsLnR5cGUgKSAmJlxuXHRcdFx0XHRcdGVsLmNsaWNrICYmIG5vZGVOYW1lKCBlbCwgXCJpbnB1dFwiICkgKSB7XG5cblx0XHRcdFx0XHRsZXZlcmFnZU5hdGl2ZSggZWwsIFwiY2xpY2tcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmV0dXJuIG5vbi1mYWxzZSB0byBhbGxvdyBub3JtYWwgZXZlbnQtcGF0aCBwcm9wYWdhdGlvblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBzdXBwcmVzcyBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdC8vIEFsc28gcHJldmVudCBpdCBpZiB3ZSdyZSBjdXJyZW50bHkgaW5zaWRlIGEgbGV2ZXJhZ2VkIG5hdGl2ZS1ldmVudCBzdGFja1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblx0XHRcdFx0cmV0dXJuIHJjaGVja2FibGVUeXBlLnRlc3QoIHRhcmdldC50eXBlICkgJiZcblx0XHRcdFx0XHR0YXJnZXQuY2xpY2sgJiYgbm9kZU5hbWUoIHRhcmdldCwgXCJpbnB1dFwiICkgJiZcblx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRhcmdldCwgXCJjbGlja1wiICkgfHxcblx0XHRcdFx0XHRub2RlTmFtZSggdGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIEVuc3VyZSB0aGUgcHJlc2VuY2Ugb2YgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCBoYW5kbGVzIG1hbnVhbGx5LXRyaWdnZXJlZFxuLy8gc3ludGhldGljIGV2ZW50cyBieSBpbnRlcnJ1cHRpbmcgcHJvZ3Jlc3MgdW50aWwgcmVpbnZva2VkIGluIHJlc3BvbnNlIHRvXG4vLyAqbmF0aXZlKiBldmVudHMgdGhhdCBpdCBmaXJlcyBkaXJlY3RseSwgZW5zdXJpbmcgdGhhdCBzdGF0ZSBjaGFuZ2VzIGhhdmVcbi8vIGFscmVhZHkgb2NjdXJyZWQgYmVmb3JlIG90aGVyIGxpc3RlbmVycyBhcmUgaW52b2tlZC5cbmZ1bmN0aW9uIGxldmVyYWdlTmF0aXZlKCBlbCwgdHlwZSwgZXhwZWN0U3luYyApIHtcblxuXHQvLyBNaXNzaW5nIGV4cGVjdFN5bmMgaW5kaWNhdGVzIGEgdHJpZ2dlciBjYWxsLCB3aGljaCBtdXN0IGZvcmNlIHNldHVwIHRocm91Z2ggalF1ZXJ5LmV2ZW50LmFkZFxuXHRpZiAoICFleHBlY3RTeW5jICkge1xuXHRcdGlmICggZGF0YVByaXYuZ2V0KCBlbCwgdHlwZSApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBlbCwgdHlwZSwgcmV0dXJuVHJ1ZSApO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZWdpc3RlciB0aGUgY29udHJvbGxlciBhcyBhIHNwZWNpYWwgdW5pdmVyc2FsIGhhbmRsZXIgZm9yIGFsbCBldmVudCBuYW1lc3BhY2VzXG5cdGRhdGFQcml2LnNldCggZWwsIHR5cGUsIGZhbHNlICk7XG5cdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCB7XG5cdFx0bmFtZXNwYWNlOiBmYWxzZSxcblx0XHRoYW5kbGVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgbm90QXN5bmMsIHJlc3VsdCxcblx0XHRcdFx0c2F2ZWQgPSBkYXRhUHJpdi5nZXQoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0aWYgKCAoIGV2ZW50LmlzVHJpZ2dlciAmIDEgKSAmJiB0aGlzWyB0eXBlIF0gKSB7XG5cblx0XHRcdFx0Ly8gSW50ZXJydXB0IHByb2Nlc3Npbmcgb2YgdGhlIG91dGVyIHN5bnRoZXRpYyAudHJpZ2dlcigpZWQgZXZlbnRcblx0XHRcdFx0Ly8gU2F2ZWQgZGF0YSBzaG91bGQgYmUgZmFsc2UgaW4gc3VjaCBjYXNlcywgYnV0IG1pZ2h0IGJlIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3Rcblx0XHRcdFx0Ly8gZnJvbSBhbiBhc3luYyBuYXRpdmUgaGFuZGxlciAoZ2gtNDM1MClcblx0XHRcdFx0aWYgKCAhc2F2ZWQubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgYXJndW1lbnRzIGZvciB1c2Ugd2hlbiBoYW5kbGluZyB0aGUgaW5uZXIgbmF0aXZlIGV2ZW50XG5cdFx0XHRcdFx0Ly8gVGhlcmUgd2lsbCBhbHdheXMgYmUgYXQgbGVhc3Qgb25lIGFyZ3VtZW50IChhbiBldmVudCBvYmplY3QpLCBzbyB0aGlzIGFycmF5XG5cdFx0XHRcdFx0Ly8gd2lsbCBub3QgYmUgY29uZnVzZWQgd2l0aCBhIGxlZnRvdmVyIGNhcHR1cmUgb2JqZWN0LlxuXHRcdFx0XHRcdHNhdmVkID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBzYXZlZCApO1xuXG5cdFx0XHRcdFx0Ly8gVHJpZ2dlciB0aGUgbmF0aXZlIGV2ZW50IGFuZCBjYXB0dXJlIGl0cyByZXN1bHRcblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcblx0XHRcdFx0XHQvLyBmb2N1cygpIGFuZCBibHVyKCkgYXJlIGFzeW5jaHJvbm91c1xuXHRcdFx0XHRcdG5vdEFzeW5jID0gZXhwZWN0U3luYyggdGhpcywgdHlwZSApO1xuXHRcdFx0XHRcdHRoaXNbIHR5cGUgXSgpO1xuXHRcdFx0XHRcdHJlc3VsdCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXHRcdFx0XHRcdGlmICggc2F2ZWQgIT09IHJlc3VsdCB8fCBub3RBc3luYyApIHtcblx0XHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwgZmFsc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzdWx0ID0ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc2F2ZWQgIT09IHJlc3VsdCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSBvdXRlciBzeW50aGV0aWMgZXZlbnRcblx0XHRcdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHQudmFsdWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoaXMgaXMgYW4gaW5uZXIgc3ludGhldGljIGV2ZW50IGZvciBhbiBldmVudCB3aXRoIGEgYnViYmxpbmcgc3Vycm9nYXRlXG5cdFx0XHRcdC8vIChmb2N1cyBvciBibHVyKSwgYXNzdW1lIHRoYXQgdGhlIHN1cnJvZ2F0ZSBhbHJlYWR5IHByb3BhZ2F0ZWQgZnJvbSB0cmlnZ2VyaW5nIHRoZVxuXHRcdFx0XHQvLyBuYXRpdmUgZXZlbnQgYW5kIHByZXZlbnQgdGhhdCBmcm9tIGhhcHBlbmluZyBhZ2FpbiBoZXJlLlxuXHRcdFx0XHQvLyBUaGlzIHRlY2huaWNhbGx5IGdldHMgdGhlIG9yZGVyaW5nIHdyb25nIHcuci50LiB0byBgLnRyaWdnZXIoKWAgKGluIHdoaWNoIHRoZVxuXHRcdFx0XHQvLyBidWJibGluZyBzdXJyb2dhdGUgcHJvcGFnYXRlcyAqYWZ0ZXIqIHRoZSBub24tYnViYmxpbmcgYmFzZSksIGJ1dCB0aGF0IHNlZW1zXG5cdFx0XHRcdC8vIGxlc3MgYmFkIHRoYW4gZHVwbGljYXRpb24uXG5cdFx0XHRcdH0gZWxzZSBpZiAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fSApLmRlbGVnYXRlVHlwZSApIHtcblx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgbmF0aXZlIGV2ZW50IHRyaWdnZXJlZCBhYm92ZSwgZXZlcnl0aGluZyBpcyBub3cgaW4gb3JkZXJcblx0XHRcdC8vIEZpcmUgYW4gaW5uZXIgc3ludGhldGljIGV2ZW50IHdpdGggdGhlIG9yaWdpbmFsIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggc2F2ZWQubGVuZ3RoICkge1xuXG5cdFx0XHRcdC8vIC4uLmFuZCBjYXB0dXJlIHRoZSByZXN1bHRcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCB7XG5cdFx0XHRcdFx0dmFsdWU6IGpRdWVyeS5ldmVudC50cmlnZ2VyKFxuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcblx0XHRcdFx0XHRcdC8vIEV4dGVuZCB3aXRoIHRoZSBwcm90b3R5cGUgdG8gcmVzZXQgdGhlIGFib3ZlIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG5cdFx0XHRcdFx0XHRqUXVlcnkuZXh0ZW5kKCBzYXZlZFsgMCBdLCBqUXVlcnkuRXZlbnQucHJvdG90eXBlICksXG5cdFx0XHRcdFx0XHRzYXZlZC5zbGljZSggMSApLFxuXHRcdFx0XHRcdFx0dGhpc1xuXHRcdFx0XHRcdClcblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdC8vIEFib3J0IGhhbmRsaW5nIG9mIHRoZSBuYXRpdmUgZXZlbnRcblx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG59XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0Ly8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHRcdC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuXHRcdHRoaXMudGFyZ2V0ID0gKCBzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMgKSA/XG5cdFx0XHRzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxuXHRcdFx0c3JjLnRhcmdldDtcblxuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuXHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHNyYy5yZWxhdGVkVGFyZ2V0O1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xualF1ZXJ5LmVhY2goIHtcblx0YWx0S2V5OiB0cnVlLFxuXHRidWJibGVzOiB0cnVlLFxuXHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcblx0Y3RybEtleTogdHJ1ZSxcblx0ZGV0YWlsOiB0cnVlLFxuXHRldmVudFBoYXNlOiB0cnVlLFxuXHRtZXRhS2V5OiB0cnVlLFxuXHRwYWdlWDogdHJ1ZSxcblx0cGFnZVk6IHRydWUsXG5cdHNoaWZ0S2V5OiB0cnVlLFxuXHR2aWV3OiB0cnVlLFxuXHRcImNoYXJcIjogdHJ1ZSxcblx0Y29kZTogdHJ1ZSxcblx0Y2hhckNvZGU6IHRydWUsXG5cdGtleTogdHJ1ZSxcblx0a2V5Q29kZTogdHJ1ZSxcblx0YnV0dG9uOiB0cnVlLFxuXHRidXR0b25zOiB0cnVlLFxuXHRjbGllbnRYOiB0cnVlLFxuXHRjbGllbnRZOiB0cnVlLFxuXHRvZmZzZXRYOiB0cnVlLFxuXHRvZmZzZXRZOiB0cnVlLFxuXHRwb2ludGVySWQ6IHRydWUsXG5cdHBvaW50ZXJUeXBlOiB0cnVlLFxuXHRzY3JlZW5YOiB0cnVlLFxuXHRzY3JlZW5ZOiB0cnVlLFxuXHR0YXJnZXRUb3VjaGVzOiB0cnVlLFxuXHR0b0VsZW1lbnQ6IHRydWUsXG5cdHRvdWNoZXM6IHRydWUsXG5cblx0d2hpY2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICYmIHJrZXlFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQuY2hhckNvZGUgIT0gbnVsbCA/IGV2ZW50LmNoYXJDb2RlIDogZXZlbnQua2V5Q29kZTtcblx0XHR9XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG5cdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgcm1vdXNlRXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0aWYgKCBidXR0b24gJiAxICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiAyICkge1xuXHRcdFx0XHRyZXR1cm4gMztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiA0ICkge1xuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LndoaWNoO1xuXHR9XG59LCBqUXVlcnkuZXZlbnQuYWRkUHJvcCApO1xuXG5qUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggdHlwZSwgZGVsZWdhdGVUeXBlICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdID0ge1xuXG5cdFx0Ly8gVXRpbGl6ZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDbGFpbSB0aGUgZmlyc3QgaGFuZGxlclxuXHRcdFx0Ly8gZGF0YVByaXYuc2V0KCB0aGlzLCBcImZvY3VzXCIsIC4uLiApXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiYmx1clwiLCAuLi4gKVxuXHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIHRoaXMsIHR5cGUsIGV4cGVjdFN5bmMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIGZhbHNlIHRvIGFsbG93IG5vcm1hbCBwcm9jZXNzaW5nIGluIHRoZSBjYWxsZXJcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlclxuXHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIG5vbi1mYWxzZSB0byBhbGxvdyBub3JtYWwgZXZlbnQtcGF0aCBwcm9wYWdhdGlvblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdGRlbGVnYXRlVHlwZTogZGVsZWdhdGVUeXBlXG5cdH07XG59ICk7XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG5qUXVlcnkuZWFjaCgge1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAoIHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSApICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxudmFyXG5cblx0LyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvMzIyOVxuXHRyeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopW14+XSopXFwvPi9naSxcblxuXHQvKiBlc2xpbnQtZW5hYmxlICovXG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTMgb25seVxuXHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuXHQvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7XG5cbi8vIFByZWZlciBhIHRib2R5IG92ZXIgaXRzIHBhcmVudCB0YWJsZSBmb3IgY29udGFpbmluZyBuZXcgcm93c1xuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdG5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApICkge1xuXG5cdFx0cmV0dXJuIGpRdWVyeSggZWxlbSApLmNoaWxkcmVuKCBcInRib2R5XCIgKVsgMCBdIHx8IGVsZW07XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKCBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSAhPT0gbnVsbCApICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0aWYgKCAoIGVsZW0udHlwZSB8fCBcIlwiICkuc2xpY2UoIDAsIDUgKSA9PT0gXCJ0cnVlL1wiICkge1xuXHRcdGVsZW0udHlwZSA9IGVsZW0udHlwZS5zbGljZSggNSApO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBcInR5cGVcIiApO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgcGRhdGFDdXIsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRpZiAoIGRhdGFQcml2Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHBkYXRhT2xkID0gZGF0YVByaXYuYWNjZXNzKCBzcmMgKTtcblx0XHRwZGF0YUN1ciA9IGRhdGFQcml2LnNldCggZGVzdCwgcGRhdGFPbGQgKTtcblx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdGRlbGV0ZSBwZGF0YUN1ci5oYW5kbGU7XG5cdFx0XHRwZGF0YUN1ci5ldmVudHMgPSB7fTtcblxuXHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0dWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3MoIHNyYyApO1xuXHRcdHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCgge30sIHVkYXRhT2xkICk7XG5cblx0XHRkYXRhVXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdH1cbn1cblxuLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXG5mdW5jdGlvbiBmaXhJbnB1dCggc3JjLCBkZXN0ICkge1xuXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG5cdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXHRcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcblx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xuXG5cdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0YXJncyA9IGNvbmNhdC5hcHBseSggW10sIGFyZ3MgKTtcblxuXHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuXHRcdGlOb0Nsb25lID0gbCAtIDEsXG5cdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gfHxcblx0XHRcdCggbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdHJldHVybiBjb2xsZWN0aW9uLmVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdHZhciBzZWxmID0gY29sbGVjdGlvbi5lcSggaW5kZXggKTtcblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdH1cblx0XHRcdGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggbCApIHtcblx0XHRmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xuXHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdH1cblxuXHRcdC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuXHRcdGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcblx0XHRcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcblx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuXHRcdFx0Ly8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG5cdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoIzgwNzApLlxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRub2RlID0gZnJhZ21lbnQ7XG5cblx0XHRcdFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcblx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYWxsYmFjay5jYWxsKCBjb2xsZWN0aW9uWyBpIF0sIG5vZGUsIGkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdC8vIFJlZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0alF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xuXG5cdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IHNjcmlwdHNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdCFkYXRhUHJpdi5hY2Nlc3MoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgJiYgKCBub2RlLnR5cGUgfHwgXCJcIiApLnRvTG93ZXJDYXNlKCkgICE9PSBcIm1vZHVsZVwiICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5Ll9ldmFsVXJsICYmICFub2RlLm5vTW9kdWxlICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5fZXZhbFVybCggbm9kZS5zcmMsIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5vbmNlOiBub2RlLm5vbmNlIHx8IG5vZGUuZ2V0QXR0cmlidXRlKCBcIm5vbmNlXCIgKVxuXHRcdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0RE9NRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSwgbm9kZSwgZG9jICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHR2YXIgbm9kZSxcblx0XHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBpc0F0dGFjaGVkKCBub2RlICkgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHR9XG5cdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRyZXR1cm4gaHRtbC5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0aW5QYWdlID0gaXNBdHRhY2hlZCggZWxlbSApO1xuXG5cdFx0Ly8gRml4IElFIGNsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cHM6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcblx0XHRcdGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0XHRpZiAoICggZGF0YSA9IGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSApICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yICk7XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSB0aGlzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlciggdmFsdWUgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlnbm9yZWQgPSBbXTtcblxuXHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIG5vbi1pZ25vcmVkIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmICggalF1ZXJ5LmluQXJyYXkoIHRoaXMsIGlnbm9yZWQgKSA8IDAgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG5cdFx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRcdHBhcmVudC5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gRm9yY2UgY2FsbGJhY2sgaW52b2NhdGlvblxuXHRcdH0sIGlnbm9yZWQgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCgge1xuXHRhcHBlbmRUbzogXCJhcHBlbmRcIixcblx0cHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuXHRpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuXHRyZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGVsZW1zLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG5cdFx0XHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xuXHRcdFx0alF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSApO1xudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHksIEZpcmVmb3ggPD0zMCAoIzE1MDk4LCAjMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0dmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cblx0XHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcblx0XHRcdHZpZXcgPSB3aW5kb3c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuXHR9O1xuXG52YXIgcmJveFN0eWxlID0gbmV3IFJlZ0V4cCggY3NzRXhwYW5kLmpvaW4oIFwifFwiICksIFwiaVwiICk7XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXG5cdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuXHRmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcblxuXHRcdC8vIFRoaXMgaXMgYSBzaW5nbGV0b24sIHdlIG5lZWQgdG8gZXhlY3V0ZSBpdCBvbmx5IG9uY2Vcblx0XHRpZiAoICFkaXYgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7d2lkdGg6NjBweDtcIiArXG5cdFx0XHRcIm1hcmdpbi10b3A6MXB4O3BhZGRpbmc6MDtib3JkZXI6MFwiO1xuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6c2Nyb2xsO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcIndpZHRoOjYwJTt0b3A6MSVcIjtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYgKTtcblx0XHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDQ0XG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5tYXJnaW5MZWZ0ICkgPT09IDEyO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgU2FmYXJpIDw9OS4xIC0gMTAuMSwgaU9TIDw9Ny4wIC0gOS4zXG5cdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0ZGl2LnN0eWxlLnJpZ2h0ID0gXCI2MCVcIjtcblx0XHRwaXhlbEJveFN0eWxlc1ZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUucmlnaHQgKSA9PT0gMzY7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHRcdC8vIERldGVjdCBtaXNyZXBvcnRpbmcgb2YgY29udGVudCBkaW1lbnNpb25zIGZvciBib3gtc2l6aW5nOmJvcmRlci1ib3ggZWxlbWVudHNcblx0XHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUud2lkdGggKSA9PT0gMzY7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHQvLyBEZXRlY3Qgb3ZlcmZsb3c6c2Nyb2xsIHNjcmV3aW5lc3MgKGdoLTM2OTkpXG5cdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9NjRcblx0XHQvLyBEb24ndCBnZXQgdHJpY2tlZCB3aGVuIHpvb20gYWZmZWN0cyBvZmZzZXRXaWR0aCAoZ2gtNDAyOSlcblx0XHRkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cdFx0c2Nyb2xsYm94U2l6ZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2Lm9mZnNldFdpZHRoIC8gMyApID09PSAxMjtcblxuXHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHQvLyBOdWxsaWZ5IHRoZSBkaXYgc28gaXQgd291bGRuJ3QgYmUgc3RvcmVkIGluIHRoZSBtZW1vcnkgYW5kXG5cdFx0Ly8gaXQgd2lsbCBhbHNvIGJlIGEgc2lnbiB0aGF0IGNoZWNrcyBhbHJlYWR5IHBlcmZvcm1lZFxuXHRcdGRpdiA9IG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiByb3VuZFBpeGVsTWVhc3VyZXMoIG1lYXN1cmUgKSB7XG5cdFx0cmV0dXJuIE1hdGgucm91bmQoIHBhcnNlRmxvYXQoIG1lYXN1cmUgKSApO1xuXHR9XG5cblx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBzY3JvbGxib3hTaXplVmFsLCBwaXhlbEJveFN0eWxlc1ZhbCxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXHRcdHBpeGVsQm94U3R5bGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxCb3hTdHlsZXNWYWw7XG5cdFx0fSxcblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHR9LFxuXHRcdHNjcm9sbGJveFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBzY3JvbGxib3hTaXplVmFsO1xuXHRcdH1cblx0fSApO1xufSApKCk7XG5cblxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNTErXG5cdFx0Ly8gUmV0cmlldmluZyBzdHlsZSBiZWZvcmUgY29tcHV0ZWQgc29tZWhvd1xuXHRcdC8vIGZpeGVzIGFuIGlzc3VlIHdpdGggZ2V0dGluZyB3cm9uZyB2YWx1ZXNcblx0XHQvLyBvbiBkZXRhY2hlZCBlbGVtZW50c1xuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgbmVlZGVkIGZvcjpcblx0Ly8gICAuY3NzKCdmaWx0ZXInKSAoSUUgOSBvbmx5LCAjMTI1MzcpXG5cdC8vICAgLmNzcygnLS1jdXN0b21Qcm9wZXJ0eSkgKCMzMTQ0KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWlzQXR0YWNoZWQoIGVsZW0gKSApIHtcblx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcblx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuXHRcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcblx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIXN1cHBvcnQucGl4ZWxCb3hTdHlsZXMoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcmJveFN0eWxlLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyIGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCIgXSxcblx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKS5zdHlsZSxcblx0dmVuZG9yUHJvcHMgPSB7fTtcblxuLy8gUmV0dXJuIGEgdmVuZG9yLXByZWZpeGVkIHByb3BlcnR5IG9yIHVuZGVmaW5lZFxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XG5cblx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuXHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG59XG5cbi8vIFJldHVybiBhIHBvdGVudGlhbGx5LW1hcHBlZCBqUXVlcnkuY3NzUHJvcHMgb3IgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiBmaW5hbFByb3BOYW1lKCBuYW1lICkge1xuXHR2YXIgZmluYWwgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXSB8fCB2ZW5kb3JQcm9wc1sgbmFtZSBdO1xuXG5cdGlmICggZmluYWwgKSB7XG5cdFx0cmV0dXJuIGZpbmFsO1xuXHR9XG5cdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdHJldHVybiBuYW1lO1xuXHR9XG5cdHJldHVybiB2ZW5kb3JQcm9wc1sgbmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB8fCBuYW1lO1xufVxuXG5cbnZhclxuXG5cdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcblx0Ly8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdHJjdXN0b21Qcm9wID0gL14tLS8sXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9O1xuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXG5cdC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cblx0Ly8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XG5cdHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAyIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgYm94LCBpc0JvcmRlckJveCwgc3R5bGVzLCBjb21wdXRlZFZhbCApIHtcblx0dmFyIGkgPSBkaW1lbnNpb24gPT09IFwid2lkdGhcIiA/IDEgOiAwLFxuXHRcdGV4dHJhID0gMCxcblx0XHRkZWx0YSA9IDA7XG5cblx0Ly8gQWRqdXN0bWVudCBtYXkgbm90IGJlIG5lY2Vzc2FyeVxuXHRpZiAoIGJveCA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApICkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXG5cdFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luXG5cdFx0aWYgKCBib3ggPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBib3ggKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGNvbnRlbnQtYm94LCB3ZSdyZSBzZWVraW5nIFwicGFkZGluZ1wiIG9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIlxuXHRcdGlmICggIWlzQm9yZGVyQm94ICkge1xuXG5cdFx0XHQvLyBBZGQgcGFkZGluZ1xuXHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEZvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCIsIGFkZCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gQnV0IHN0aWxsIGtlZXAgdHJhY2sgb2YgaXQgb3RoZXJ3aXNlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRleHRyYSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGJvcmRlci1ib3ggKGNvbnRlbnQgKyBwYWRkaW5nICsgYm9yZGVyKSwgd2UncmUgc2Vla2luZyBcImNvbnRlbnRcIiBvclxuXHRcdC8vIFwicGFkZGluZ1wiIG9yIFwibWFyZ2luXCJcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBGb3IgXCJjb250ZW50XCIsIHN1YnRyYWN0IHBhZGRpbmdcblx0XHRcdGlmICggYm94ID09PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiBvciBcInBhZGRpbmdcIiwgc3VidHJhY3QgYm9yZGVyXG5cdFx0XHRpZiAoIGJveCAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBY2NvdW50IGZvciBwb3NpdGl2ZSBjb250ZW50LWJveCBzY3JvbGwgZ3V0dGVyIHdoZW4gcmVxdWVzdGVkIGJ5IHByb3ZpZGluZyBjb21wdXRlZFZhbFxuXHRpZiAoICFpc0JvcmRlckJveCAmJiBjb21wdXRlZFZhbCA+PSAwICkge1xuXG5cdFx0Ly8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGlzIGEgcm91bmRlZCBzdW0gb2YgY29udGVudCwgcGFkZGluZywgc2Nyb2xsIGd1dHRlciwgYW5kIGJvcmRlclxuXHRcdC8vIEFzc3VtaW5nIGludGVnZXIgc2Nyb2xsIGd1dHRlciwgc3VidHJhY3QgdGhlIHJlc3QgYW5kIHJvdW5kIGRvd25cblx0XHRkZWx0YSArPSBNYXRoLm1heCggMCwgTWF0aC5jZWlsKFxuXHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdGNvbXB1dGVkVmFsIC1cblx0XHRcdGRlbHRhIC1cblx0XHRcdGV4dHJhIC1cblx0XHRcdDAuNVxuXG5cdFx0Ly8gSWYgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGlzIHVua25vd24sIHRoZW4gd2UgY2FuJ3QgZGV0ZXJtaW5lIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXJcblx0XHQvLyBVc2UgYW4gZXhwbGljaXQgemVybyB0byBhdm9pZCBOYU4gKGdoLTM5NjQpXG5cdFx0KSApIHx8IDA7XG5cdH1cblxuXHRyZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBjb21wdXRlZCBzdHlsZVxuXHR2YXIgc3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cblx0XHQvLyBUbyBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LCBvbmx5IGZldGNoIGJveFNpemluZyBpZiB3ZSBuZWVkIGl0IChnaC00MzIyKS5cblx0XHQvLyBGYWtlIGNvbnRlbnQtYm94IHVudGlsIHdlIGtub3cgaXQncyBuZWVkZWQgdG8ga25vdyB0aGUgdHJ1ZSB2YWx1ZS5cblx0XHRib3hTaXppbmdOZWVkZWQgPSAhc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IGV4dHJhLFxuXHRcdGlzQm9yZGVyQm94ID0gYm94U2l6aW5nTmVlZGVkICYmXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCxcblxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgZGltZW5zaW9uLCBzdHlsZXMgKSxcblx0XHRvZmZzZXRQcm9wID0gXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKTtcblxuXHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcblx0Ly8gUmV0dXJuIGEgY29uZm91bmRpbmcgbm9uLXBpeGVsIHZhbHVlIG9yIGZlaWduIGlnbm9yYW5jZSwgYXMgYXBwcm9wcmlhdGUuXG5cdGlmICggcm51bW5vbnB4LnRlc3QoIHZhbCApICkge1xuXHRcdGlmICggIWV4dHJhICkge1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9XG5cdFx0dmFsID0gXCJhdXRvXCI7XG5cdH1cblxuXG5cdC8vIEZhbGwgYmFjayB0byBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgd2hlbiB2YWx1ZSBpcyBcImF1dG9cIlxuXHQvLyBUaGlzIGhhcHBlbnMgZm9yIGlubGluZSBlbGVtZW50cyB3aXRoIG5vIGV4cGxpY2l0IHNldHRpbmcgKGdoLTM1NzEpXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgLSA0LjMgb25seVxuXHQvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIG1pc3JlcG9ydGVkIGlubGluZSBkaW1lbnNpb25zIChnaC0zNjAyKVxuXHQvLyBTdXBwb3J0OiBJRSA5LTExIG9ubHlcblx0Ly8gQWxzbyB1c2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciB3aGVuIGJveCBzaXppbmcgaXMgdW5yZWxpYWJsZVxuXHQvLyBXZSB1c2UgZ2V0Q2xpZW50UmVjdHMoKSB0byBjaGVjayBmb3IgaGlkZGVuL2Rpc2Nvbm5lY3RlZC5cblx0Ly8gSW4gdGhvc2UgY2FzZXMsIHRoZSBjb21wdXRlZCB2YWx1ZSBjYW4gYmUgdHJ1c3RlZCB0byBiZSBib3JkZXItYm94XG5cdGlmICggKCAhc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpICYmIGlzQm9yZGVyQm94IHx8XG5cdFx0dmFsID09PSBcImF1dG9cIiB8fFxuXHRcdCFwYXJzZUZsb2F0KCB2YWwgKSAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImlubGluZVwiICkgJiZcblx0XHRlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG5cdFx0Ly8gV2hlcmUgYXZhaWxhYmxlLCBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgYXBwcm94aW1hdGUgYm9yZGVyIGJveCBkaW1lbnNpb25zLlxuXHRcdC8vIFdoZXJlIG5vdCBhdmFpbGFibGUgKGUuZy4sIFNWRyksIGFzc3VtZSB1bnJlbGlhYmxlIGJveC1zaXppbmcgYW5kIGludGVycHJldCB0aGVcblx0XHQvLyByZXRyaWV2ZWQgdmFsdWUgYXMgYSBjb250ZW50IGJveCBkaW1lbnNpb24uXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IG9mZnNldFByb3AgaW4gZWxlbTtcblx0XHRpZiAoIHZhbHVlSXNCb3JkZXJCb3ggKSB7XG5cdFx0XHR2YWwgPSBlbGVtWyBvZmZzZXRQcm9wIF07XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIFwiXCIgYW5kIGF1dG9cblx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcblxuXHQvLyBBZGp1c3QgZm9yIHRoZSBlbGVtZW50J3MgYm94IG1vZGVsXG5cdHJldHVybiAoIHZhbCArXG5cdFx0Ym94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0ZWxlbSxcblx0XHRcdGRpbWVuc2lvbixcblx0XHRcdGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSxcblx0XHRcdHZhbHVlSXNCb3JkZXJCb3gsXG5cdFx0XHRzdHlsZXMsXG5cblx0XHRcdC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgY29tcHV0ZWQgc2l6ZSB0byByZXF1ZXN0IHNjcm9sbCBndXR0ZXIgY2FsY3VsYXRpb24gKGdoLTM1ODkpXG5cdFx0XHR2YWxcblx0XHQpXG5cdCkgKyBcInB4XCI7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIjogdHJ1ZSxcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImdyaWRBcmVhXCI6IHRydWUsXG5cdFx0XCJncmlkQ29sdW1uXCI6IHRydWUsXG5cdFx0XCJncmlkQ29sdW1uRW5kXCI6IHRydWUsXG5cdFx0XCJncmlkQ29sdW1uU3RhcnRcIjogdHJ1ZSxcblx0XHRcImdyaWRSb3dcIjogdHJ1ZSxcblx0XHRcImdyaWRSb3dFbmRcIjogdHJ1ZSxcblx0XHRcImdyaWRSb3dTdGFydFwiOiB0cnVlLFxuXHRcdFwibGluZUhlaWdodFwiOiB0cnVlLFxuXHRcdFwib3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwib3JkZXJcIjogdHJ1ZSxcblx0XHRcIm9ycGhhbnNcIjogdHJ1ZSxcblx0XHRcIndpZG93c1wiOiB0cnVlLFxuXHRcdFwiekluZGV4XCI6IHRydWUsXG5cdFx0XCJ6b29tXCI6IHRydWVcblx0fSxcblxuXHQvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG5cdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcblx0Y3NzUHJvcHM6IHt9LFxuXG5cdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG5cdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXG5cdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0dmFyIHJldCwgdHlwZSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gcXVlcnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gYWRqdXN0Q1NTKCBlbGVtLCBuYW1lLCByZXQgKTtcblxuXHRcdFx0XHQvLyBGaXhlcyBidWcgIzkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0Ly8gVGhlIGlzQ3VzdG9tUHJvcCBjaGVjayBjYW4gYmUgcmVtb3ZlZCBpbiBqUXVlcnkgNC4wIHdoZW4gd2Ugb25seSBhdXRvLWFwcGVuZFxuXHRcdFx0Ly8gXCJweFwiIHRvIGEgZmV3IGhhcmRjb2RlZCB2YWx1ZXMuXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgJiYgIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdFx0dmFsdWUgKz0gcmV0ICYmIHJldFsgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8XG5cdFx0XHRcdCggdmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRpZiAoIGlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdFx0XHRzdHlsZS5zZXRQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gbW9kaWZ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcblx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xuXHRcdGlmICggZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEgKSB7XG5cdFx0XHRudW0gPSBwYXJzZUZsb2F0KCB2YWwgKTtcblx0XHRcdHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZSggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggaSwgZGltZW5zaW9uICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIGRpbWVuc2lvbiBdID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmXG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCtcblx0XHRcdFx0XHQvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuXHRcdFx0XHRcdC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0XHRcdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHRcdFx0XHRcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0XHRcdFx0XHQoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICkgP1xuXHRcdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyxcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cblx0XHRcdFx0Ly8gT25seSByZWFkIHN0eWxlcy5wb3NpdGlvbiBpZiB0aGUgdGVzdCBoYXMgYSBjaGFuY2UgdG8gZmFpbFxuXHRcdFx0XHQvLyB0byBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LlxuXHRcdFx0XHRzY3JvbGxib3hTaXplQnVnZ3kgPSAhc3VwcG9ydC5zY3JvbGxib3hTaXplKCkgJiZcblx0XHRcdFx0XHRzdHlsZXMucG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIixcblxuXHRcdFx0XHQvLyBUbyBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LCBvbmx5IGZldGNoIGJveFNpemluZyBpZiB3ZSBuZWVkIGl0IChnaC0zOTkxKVxuXHRcdFx0XHRib3hTaXppbmdOZWVkZWQgPSBzY3JvbGxib3hTaXplQnVnZ3kgfHwgZXh0cmEsXG5cdFx0XHRcdGlzQm9yZGVyQm94ID0gYm94U2l6aW5nTmVlZGVkICYmXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSA/XG5cdFx0XHRcdFx0Ym94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRcdGRpbWVuc2lvbixcblx0XHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdFx0aXNCb3JkZXJCb3gsXG5cdFx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0XHQpIDpcblx0XHRcdFx0XHQwO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB1bnJlbGlhYmxlIGJvcmRlci1ib3ggZGltZW5zaW9ucyBieSBjb21wYXJpbmcgb2Zmc2V0KiB0byBjb21wdXRlZCBhbmRcblx0XHRcdC8vIGZha2luZyBhIGNvbnRlbnQtYm94IHRvIGdldCBib3JkZXIgYW5kIHBhZGRpbmcgKGdoLTM2OTkpXG5cdFx0XHRpZiAoIGlzQm9yZGVyQm94ICYmIHNjcm9sbGJveFNpemVCdWdneSApIHtcblx0XHRcdFx0c3VidHJhY3QgLT0gTWF0aC5jZWlsKFxuXHRcdFx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRcdFx0cGFyc2VGbG9hdCggc3R5bGVzWyBkaW1lbnNpb24gXSApIC1cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgXCJib3JkZXJcIiwgZmFsc2UsIHN0eWxlcyApIC1cblx0XHRcdFx0XHQwLjVcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBkaW1lbnNpb24gXSA9IHZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIGRpbWVuc2lvbiApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0KSArIFwicHhcIjtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKCB7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggcHJlZml4ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fVxufSApO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0Ly8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcblx0XHRcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cblx0XHRcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblxuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0XHRqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSB8fFxuXHRcdFx0XHRcdHR3ZWVuLmVsZW0uc3R5bGVbIGZpbmFsUHJvcE5hbWUoIHR3ZWVuLnByb3AgKSBdICE9IG51bGwgKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fSxcblx0X2RlZmF1bHQ6IFwic3dpbmdcIlxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIGluUHJvZ3Jlc3MsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRpZiAoIGRvY3VtZW50LmhpZGRlbiA9PT0gZmFsc2UgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcblx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHNjaGVkdWxlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBzY2hlZHVsZSwgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdFx0fVxuXG5cdFx0alF1ZXJ5LmZ4LnRpY2soKTtcblx0fVxufVxuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0gRGF0ZS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGkgPSAwLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG5cdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIGhvb2tzLCBvbGRmaXJlLCBwcm9wVHdlZW4sIHJlc3RvcmVEaXNwbGF5LCBkaXNwbGF5LFxuXHRcdGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cblx0Ly8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLnRlc3QoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcInNob3dcIiBhbmRcblx0XHRcdFx0Ly8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cblx0XHRcdFx0Ly8gSWdub3JlIGFsbCBvdGhlciBuby1vcCBzaG93L2hpZGUgZGF0YVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXG5cdHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcHMgKTtcblx0aWYgKCAhcHJvcFR3ZWVuICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVzdHJpY3QgXCJvdmVyZmxvd1wiIGFuZCBcImRpc3BsYXlcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXG5cdGlmICggaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcblx0XHQvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WSBhbmQgRWRnZSBqdXN0IG1pcnJvcnNcblx0XHQvLyB0aGUgb3ZlcmZsb3dYIHZhbHVlIHRoZXJlLlxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG5cdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xuXHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdH1cblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSApIHtcblx0XHRcdFx0ZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSB8fCByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFuaW1hdGUgaW5saW5lIGVsZW1lbnRzIGFzIGlubGluZS1ibG9ja1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJpbmxpbmVcIiB8fCBkaXNwbGF5ID09PSBcImlubGluZS1ibG9ja1wiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0XHQvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRcdFx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0ZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG5cdFx0XHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGRpc3BsYXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdHByb3BUd2VlbiA9IGZhbHNlO1xuXHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cblx0XHQvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxuXHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7IGRpc3BsYXk6IHJlc3RvcmVEaXNwbGF5IH0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXG5cdFx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdFx0Ly8gVGhlIGZpbmFsIHN0ZXAgb2YgYSBcImhpZGVcIiBhbmltYXRpb24gaXMgYWN0dWFsbHkgaGlkaW5nIHRoZSBlbGVtZW50XG5cdFx0XHRcdGlmICggIWhpZGRlbiApIHtcblx0XHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBQZXItcHJvcGVydHkgc2V0dXBcblx0XHRwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0cHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdFx0cHJvcFR3ZWVuLnN0YXJ0ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBjYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdC8vIElmIHRoZXJlJ3MgbW9yZSB0byBkbywgeWllbGRcblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBhbiBlbXB0eSBhbmltYXRpb24sIHN5bnRoZXNpemUgYSBmaW5hbCBwcm9ncmVzcyBub3RpZmljYXRpb25cblx0XHRcdGlmICggIWxlbmd0aCApIHtcblx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNvbHZlIHRoZSBhbmltYXRpb24gYW5kIHJlcG9ydCBpdHMgY29uY2x1c2lvblxuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0c3BlY2lhbEVhc2luZzoge30sXG5cdFx0XHRcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuXHRcdFx0fSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdHJlc3VsdC5zdG9wLmJpbmQoIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdC8vIEF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdGFuaW1hdGlvblxuXHRcdC5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0cmV0dXJuIGFuaW1hdGlvbjtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRpc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZlxuXHRpZiAoIGpRdWVyeS5meC5vZmYgKSB7XG5cdFx0b3B0LmR1cmF0aW9uID0gMDtcblxuXHR9IGVsc2Uge1xuXHRcdGlmICggdHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdGlmICggb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgKSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0gRGF0ZS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblxuXHRcdC8vIFJ1biB0aGUgdGltZXIgYW5kIHNhZmVseSByZW1vdmUgaXQgd2hlbiBkb25lIChhbGxvd2luZyBmb3IgZXh0ZXJuYWwgcmVtb3ZhbClcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRqUXVlcnkuZnguc3RhcnQoKTtcbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpblByb2dyZXNzID0gdHJ1ZTtcblx0c2NoZWR1bGUoKTtcbn07XG5cbmpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdGluUHJvZ3Jlc3MgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbi8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9ICk7XG59O1xuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMyBvbmx5XG5cdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSApKCk7XG5cblxudmFyIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLFxuXHRcdFx0aSA9IDAsXG5cblx0XHRcdC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gY29udGFpbiBub24tSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcblx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcblxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciByZXQsIGhhbmRsZSxcblx0XHRcdGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRpZiAoICFpc1hNTCApIHtcblxuXHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gcmV0O1xuXHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRsb3dlcmNhc2VOYW1lIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IGhhbmRsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0gKTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdFx0XHQvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGVcblx0XHRcdFx0Ly8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG5cdFx0XHRcdC8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE0MTExNjIzMzM0Ny9odHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuXHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRpZiAoIHRhYmluZGV4ICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXJzZUludCggdGFiaW5kZXgsIDEwICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJlxuXHRcdFx0XHRcdGVsZW0uaHJlZlxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9XG59ICk7XG5cbi8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4vLyBvbiB0aGUgb3B0aW9uXG4vLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuLy8gZXNsaW50IHJ1bGUgXCJuby11bnVzZWQtZXhwcmVzc2lvbnNcIiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjb2RlXG4vLyBzaW5jZSBpdCBjb25zaWRlcnMgc3VjaCBhY2Nlc3Npb25zIG5vb3BcbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0XHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSApO1xuXG5cblxuXG5cdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlIGFjY29yZGluZyB0byBIVE1MIHNwZWNcblx0Ly8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS1hc2NpaS13aGl0ZXNwYWNlXG5cdGZ1bmN0aW9uIHN0cmlwQW5kQ29sbGFwc2UoIHZhbHVlICkge1xuXHRcdHZhciB0b2tlbnMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHRcdHJldHVybiB0b2tlbnMuam9pbiggXCIgXCIgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIGdldENsYXNzKCBlbGVtICkge1xuXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApIHtcblx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0fVxuXHRyZXR1cm4gW107XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhenogKyBcIiBcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKCBcImNsYXNzXCIsIFwiXCIgKTtcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlLFxuXHRcdFx0aXNWYWxpZFZhbHVlID0gdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIGlzVmFsaWRWYWx1ZSApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuXHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xuXG5cdFx0XHRpZiAoIGlzVmFsaWRWYWx1ZSApIHtcblxuXHRcdFx0XHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHRpID0gMDtcblx0XHRcdFx0c2VsZiA9IGpRdWVyeSggdGhpcyApO1xuXHRcdFx0XHRjbGFzc05hbWVzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRcdFx0d2hpbGUgKCAoIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0aWYgKCBjbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIixcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lLCBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBnZXRDbGFzcyggZWxlbSApICkgKyBcIiBcIiApLmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBycmV0dXJuID0gL1xcci9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCB2YWx1ZUlzRnVuY3Rpb24sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmXG5cdFx0XHRcdFx0XCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSApICE9PSB1bmRlZmluZWRcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRpZiAoIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldC5yZXBsYWNlKCBycmV0dXJuLCBcIlwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcblx0XHRcdFx0cmV0dXJuIHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdHZhciB2YWw7XG5cblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHZhbCA9IGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXCJ2YWx1ZVwiICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbDtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHR2YWxIb29rczoge1xuXHRcdG9wdGlvbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSBvbmx5XG5cdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuXHRcdFx0XHRcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRzdHJpcEFuZENvbGxhcHNlKCBqUXVlcnkudGV4dCggZWxlbSApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLCBpLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIixcblx0XHRcdFx0XHR2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG5cdFx0XHRcdFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCBpbmRleCA8IDAgKSB7XG5cdFx0XHRcdFx0aSA9IG1heDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGkgPSBvbmUgPyBpbmRleCA6IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0Ly8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG5cdFx0XHRcdFx0aWYgKCAoIG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCApICYmXG5cblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdFx0XHQhb3B0aW9uLmRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8XG5cdFx0XHRcdFx0XHRcdFx0IW5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cblxuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldCggb3B0aW9uICksIHZhbHVlcyApID4gLTFcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdG9wdGlvblNldCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcblx0XHRcdFx0aWYgKCAhb3B0aW9uU2V0ICkge1xuXHRcdFx0XHRcdGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5qUXVlcnkuZWFjaCggWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoIGVsZW0gKS52YWwoKSwgdmFsdWUgKSA+IC0xICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuXG5zdXBwb3J0LmZvY3VzaW4gPSBcIm9uZm9jdXNpblwiIGluIHdpbmRvdztcblxuXG52YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXG5cdHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24oIGUgKSB7XG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0fTtcblxualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmV2ZW50LCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cblx0XHR2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLCBsYXN0RWxlbWVudCxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCggXCIuXCIgKSA6IFtdO1xuXG5cdFx0Y3VyID0gbGFzdEVsZW1lbnQgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKCBcIi5cIiApID4gLTEgKSB7XG5cblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdH1cblx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoIFwiOlwiICkgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKTtcblx0XHRldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApIDpcblx0XHRcdG51bGw7XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcblx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0ZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG5cdFx0XHRbIGV2ZW50IF0gOlxuXHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cblx0XHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXG5cdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0dG1wID0gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBjdXIgPSBldmVudFBhdGhbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRsYXN0RWxlbWVudCA9IGN1cjtcblx0XHRcdGV2ZW50LnR5cGUgPSBpID4gMSA/XG5cdFx0XHRcdGJ1YmJsZVR5cGUgOlxuXHRcdFx0XHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cblx0XHRcdC8vIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSAoIGRhdGFQcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdICYmXG5cdFx0XHRcdGRhdGFQcml2LmdldCggY3VyLCBcImhhbmRsZVwiICk7XG5cdFx0XHRpZiAoIGhhbmRsZSApIHtcblx0XHRcdFx0aGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTmF0aXZlIGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuXHRcdFx0aWYgKCBoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGFjY2VwdERhdGEoIGN1ciApICkge1xuXHRcdFx0XHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG5cdFx0XHRpZiAoICggIXNwZWNpYWwuX2RlZmF1bHQgfHxcblx0XHRcdFx0c3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZXZlbnRQYXRoLnBvcCgpLCBkYXRhICkgPT09IGZhbHNlICkgJiZcblx0XHRcdFx0YWNjZXB0RGF0YSggZWxlbSApICkge1xuXG5cdFx0XHRcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG5cdFx0XHRcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcblx0XHRcdFx0aWYgKCBvbnR5cGUgJiYgaXNGdW5jdGlvbiggZWxlbVsgdHlwZSBdICkgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmVcblx0Ly8gVXNlZCBvbmx5IGZvciBgZm9jdXMoaW4gfCBvdXQpYCBldmVudHNcblx0c2ltdWxhdGU6IGZ1bmN0aW9uKCB0eXBlLCBlbGVtLCBldmVudCApIHtcblx0XHR2YXIgZSA9IGpRdWVyeS5leHRlbmQoXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCksXG5cdFx0XHRldmVudCxcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0aXNTaW11bGF0ZWQ6IHRydWVcblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblx0fVxuXG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSApO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxuLy8gU3VwcG9ydDogRmlyZWZveCA8PTQ0XG4vLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xuLy9cbi8vIFN1cHBvcnQ6IENocm9tZSA8PTQ4IC0gNDksIFNhZmFyaSA8PTkuMCAtIDkuMVxuLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG4vLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XG5pZiAoICFzdXBwb3J0LmZvY3VzaW4gKSB7XG5cdGpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cblx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuXHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSApO1xuXHRcdH07XG5cblx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZG9jLCBmaXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9ICk7XG59XG52YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cbnZhciBub25jZSA9IERhdGUubm93KCk7XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbDtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxuXHR0cnkge1xuXHRcdHhtbCA9ICggbmV3IHdpbmRvdy5ET01QYXJzZXIoKSApLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHhtbCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhclxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iaiApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoXG5cdFx0XHRcdFx0cHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiICkgKyBcIl1cIixcblx0XHRcdFx0XHR2LFxuXHRcdFx0XHRcdHRyYWRpdGlvbmFsLFxuXHRcdFx0XHRcdGFkZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgdG9UeXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZU9yRnVuY3Rpb24gKSB7XG5cblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgdXNlIGl0cyByZXR1cm4gdmFsdWVcblx0XHRcdHZhciB2YWx1ZSA9IGlzRnVuY3Rpb24oIHZhbHVlT3JGdW5jdGlvbiApID9cblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uKCkgOlxuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb247XG5cblx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgK1xuXHRcdFx0XHRlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcblx0XHR9O1xuXG5cdGlmICggYSA9PSBudWxsICkge1xuXHRcdHJldHVybiBcIlwiO1xuXHR9XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0gKVxuXHRcdC5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHR9IClcblx0XHQubWFwKCBmdW5jdGlvbiggaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0gKS5nZXQoKTtcblx0fVxufSApO1xuXG5cbnZhclxuXHRyMjAgPSAvJTIwL2csXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRyYW50aUNhY2hlID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cblx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuXHQvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblx0b3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggZnVuYyApICkge1xuXG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHR3aGlsZSAoICggZGF0YVR5cGUgPSBkYXRhVHlwZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcblx0XHRcdFx0aWYgKCBkYXRhVHlwZVsgMCBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkucHVzaCggZnVuYyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cblx0dmFyIGluc3BlY3RlZCA9IHt9LFxuXHRcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG5cdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuXHRcdHZhciBzZWxlY3RlZDtcblx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXHRcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG5cdFx0XHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9XG5cblx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcIipcIiBdICYmIGluc3BlY3QoIFwiKlwiICk7XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzICM5ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGtleSwgZGVlcCxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LVR5cGVcIiApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC9cXGJ4bWxcXGIvLFxuXHRcdFx0aHRtbDogL1xcYmh0bWwvLFxuXHRcdFx0anNvbjogL1xcYmpzb25cXGIvXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IEpTT04ucGFyc2UsXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblxuXHRcdFx0Ly8gVXJsIGNsZWFudXAgdmFyXG5cdFx0XHR1cmxBbmNob3IsXG5cblx0XHRcdC8vIFJlcXVlc3Qgc3RhdGUgKGJlY29tZXMgZmFsc2UgdXBvbiBzZW5kIGFuZCB0cnVlIHVwb24gY29tcGxldGlvbilcblx0XHRcdGNvbXBsZXRlZCxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG5cdFx0XHRmaXJlR2xvYmFscyxcblxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblxuXHRcdFx0Ly8gdW5jYWNoZWQgcGFydCBvZiB0aGUgdXJsXG5cdFx0XHR1bmNhY2hlZCxcblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cblx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmXG5cdFx0XHRcdCggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSArIFwiIFwiIF0gPVxuXHRcdFx0XHRcdFx0XHRcdFx0KCByZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSArIFwiIFwiIF0gfHwgW10gKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuY29uY2F0KCBtYXRjaFsgMiBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSArIFwiIFwiIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoLmpvaW4oIFwiLCBcIiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSA9XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFja3MgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICk7XG5cblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0gKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSwgRWRnZSAxMiAtIDE1XG5cdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxuXHRcdFx0Ly8gZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSBvbmx5XG5cdFx0XHRcdC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cblx0XHRcdFx0XHR1cmxBbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxBbmNob3IuaG9zdDtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuXHRcdFx0XHQvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdC8vIFJlbW92ZSBoYXNoIHRvIHNpbXBsaWZ5IHVybCBtYW5pcHVsYXRpb25cblx0XHRjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2UoIHJoYXNoLCBcIlwiICk7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIGhhc2ggc28gd2UgY2FuIHB1dCBpdCBiYWNrXG5cdFx0XHR1bmNhY2hlZCA9IHMudXJsLnNsaWNlKCBjYWNoZVVSTC5sZW5ndGggKTtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUgYW5kIHNob3VsZCBiZSBwcm9jZXNzZWQsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgJiYgKCBzLnByb2Nlc3NEYXRhIHx8IHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgKSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YTtcblxuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvciB1cGRhdGUgYW50aS1jYWNoZSBwYXJhbSBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcmFudGlDYWNoZSwgXCIkMVwiICk7XG5cdFx0XHRcdHVuY2FjaGVkID0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArICggbm9uY2UrKyApICsgdW5jYWNoZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcblx0XHRcdHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcblxuXHRcdC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxuXHRcdH0gZWxzZSBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXG5cdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCApIHtcblx0XHRcdHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xuXHRcdFx0XHRcdCggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmXG5cdFx0XHQoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IGNvbXBsZXRlZCApICkge1xuXG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Y29tcGxldGVEZWZlcnJlZC5hZGQoIHMuY29tcGxldGUgKTtcblx0XHRqcVhIUi5kb25lKCBzLnN1Y2Nlc3MgKTtcblx0XHRqcVhIUi5mYWlsKCBzLmVycm9yICk7XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybiBqcVhIUjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIFJldGhyb3cgcG9zdC1jb21wbGV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xuXHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbXBsZXRlZCA9IHRydWU7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkxhc3QtTW9kaWZpZWRcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiZXRhZ1wiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgbm8gY29udGVudFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cblx0XHRcdFx0Ly8gaWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuXHRcdFx0XHRcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuXHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cdFx0XHRcdFx0aXNTdWNjZXNzID0gIWVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RvcFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG5cdFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCggdXJsICkgJiYgdXJsICkgKTtcblx0fTtcbn0gKTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoIHtcblx0XHR1cmw6IHVybCxcblxuXHRcdC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAoIzExMjY0KVxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0Y2FjaGU6IHRydWUsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cblx0XHQvLyBPbmx5IGV2YWx1YXRlIHRoZSByZXNwb25zZSBpZiBpdCBpcyBzdWNjZXNzZnVsIChnaC00MTI2KVxuXHRcdC8vIGRhdGFGaWx0ZXIgaXMgbm90IGludm9rZWQgZm9yIGZhaWx1cmUgcmVzcG9uc2VzLCBzbyB1c2luZyBpdCBpbnN0ZWFkXG5cdFx0Ly8gb2YgdGhlIGRlZmF1bHQgY29udmVydGVyIGlzIGtsdWRneSBidXQgaXQgd29ya3MuXG5cdFx0Y29udmVydGVyczoge1xuXHRcdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbigpIHt9XG5cdFx0fSxcblx0XHRkYXRhRmlsdGVyOiBmdW5jdGlvbiggcmVzcG9uc2UgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggcmVzcG9uc2UsIG9wdGlvbnMgKTtcblx0XHR9XG5cdH0gKTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGh0bWxJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBodG1sSXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFwiYm9keVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcbn07XG5cblxuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnRpbWVvdXQgPVxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggMCwgXCJlcnJvclwiICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IHhoci5vbnRpbWVvdXQgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xuXHR9XG59ICk7XG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gb3IgZm9yY2VkLWJ5LWF0dHJzIHJlcXVlc3RzXG5cdGlmICggcy5jcm9zc0RvbWFpbiB8fCBzLnNjcmlwdEF0dHJzICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiIClcblx0XHRcdFx0XHQuYXR0ciggcy5zY3JpcHRBdHRycyB8fCB7fSApXG5cdFx0XHRcdFx0LnByb3AoIHsgY2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LCBzcmM6IHMudXJsIH0gKVxuXHRcdFx0XHRcdC5vbiggXCJsb2FkIGVycm9yXCIsIGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZSsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0gKTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCAmJlxuXHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0gaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcblx0XHRcdGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG5zdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XG5cdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICkuYm9keTtcblx0Ym9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG5cdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xufSApKCk7XG5cblxuLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXG5cdHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cblx0aWYgKCAhY29udGV4dCApIHtcblxuXHRcdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHRcdC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XG5cdFx0XHQvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuXHRcdFx0Ly8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTCAoZ2gtMjk2NSlcblx0XHRcdGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiYmFzZVwiICk7XG5cdFx0XHRiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuXHRcdFx0Y29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudDtcblx0XHR9XG5cdH1cblxuXHRwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcblx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBpc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoIHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuXHRcdFx0Ly8gTWFrZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGV4cGxpY2l0IHNpbmNlXG5cdFx0XHQvLyB1c2VyIGNhbiBvdmVycmlkZSBpdCB0aHJvdWdoIGFqYXhTZXR1cCBtZXRob2Rcblx0XHRcdHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcblx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdGRhdGE6IHBhcmFtc1xuXHRcdH0gKS5kb25lKCBmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeSggXCI8ZGl2PlwiICkuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0Ly8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXG5cdFx0Ly8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxuXHRcdC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcblx0XHR9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG4vLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xualF1ZXJ5LmVhY2goIFtcblx0XCJhamF4U3RhcnRcIixcblx0XCJhamF4U3RvcFwiLFxuXHRcImFqYXhDb21wbGV0ZVwiLFxuXHRcImFqYXhFcnJvclwiLFxuXHRcImFqYXhTdWNjZXNzXCIsXG5cdFwiYWpheFNlbmRcIlxuXSwgZnVuY3Rpb24oIGksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSApO1xuXG5cblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9ICkubGVuZ3RoO1xufTtcblxuXG5cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cblx0XHRcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCgge30sIGN1ck9mZnNldCApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0Ly8gb2Zmc2V0KCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgYm9yZGVyIGJveCB0byB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBQcmVzZXJ2ZSBjaGFpbmluZyBmb3Igc2V0dGVyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHR2YXIgcmVjdCwgd2luLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHplcm9zIGZvciBkaXNjb25uZWN0ZWQgYW5kIGhpZGRlbiAoZGlzcGxheTogbm9uZSkgZWxlbWVudHMgKGdoLTIzMTApXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYVxuXHRcdC8vIGRpc2Nvbm5lY3RlZCBub2RlIGluIElFIHRocm93cyBhbiBlcnJvclxuXHRcdGlmICggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHR9XG5cblx0XHQvLyBHZXQgZG9jdW1lbnQtcmVsYXRpdmUgcG9zaXRpb24gYnkgYWRkaW5nIHZpZXdwb3J0IHNjcm9sbCB0byB2aWV3cG9ydC1yZWxhdGl2ZSBnQkNSXG5cdFx0cmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0d2luID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHJlY3QudG9wICsgd2luLnBhZ2VZT2Zmc2V0LFxuXHRcdFx0bGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0XG5cdFx0fTtcblx0fSxcblxuXHQvLyBwb3NpdGlvbigpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIG1hcmdpbiBib3ggdG8gaXRzIG9mZnNldCBwYXJlbnQncyBwYWRkaW5nIGJveFxuXHQvLyBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBiZWhhdmlvciBvZiBDU1MgYWJzb2x1dGUgcG9zaXRpb25pbmdcblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsIGRvYyxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG5cdFx0Ly8gcG9zaXRpb246Zml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHRoZSB2aWV3cG9ydCwgd2hpY2ggaXRzZWxmIGFsd2F5cyBoYXMgemVybyBvZmZzZXRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdC8vIEFzc3VtZSBwb3NpdGlvbjpmaXhlZCBpbXBsaWVzIGF2YWlsYWJpbGl0eSBvZiBnZXRCb3VuZGluZ0NsaWVudFJlY3Rcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblxuXHRcdFx0Ly8gQWNjb3VudCBmb3IgdGhlICpyZWFsKiBvZmZzZXQgcGFyZW50LCB3aGljaCBjYW4gYmUgdGhlIGRvY3VtZW50IG9yIGl0cyByb290IGVsZW1lbnRcblx0XHRcdC8vIHdoZW4gYSBzdGF0aWNhbGx5IHBvc2l0aW9uZWQgZWxlbWVudCBpcyBpZGVudGlmaWVkXG5cdFx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSBlbGVtLm9mZnNldFBhcmVudCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiZcblx0XHRcdFx0KCBvZmZzZXRQYXJlbnQgPT09IGRvYy5ib2R5IHx8IG9mZnNldFBhcmVudCA9PT0gZG9jLmRvY3VtZW50RWxlbWVudCApICYmXG5cdFx0XHRcdGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQgIT09IGVsZW0gJiYgb2Zmc2V0UGFyZW50Lm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIEluY29ycG9yYXRlIGJvcmRlcnMgaW50byBpdHMgb2Zmc2V0LCBzaW5jZSB0aGV5IGFyZSBvdXRzaWRlIGl0cyBjb250ZW50IG9yaWdpblxuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBqUXVlcnkoIG9mZnNldFBhcmVudCApLm9mZnNldCgpO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHQvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuXHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcblx0Ly8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuXHQvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXG5cdC8vXG5cdC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuXHQvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cblx0Ly9cblx0Ly8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXG5cdFx0XHQvLyBDb2FsZXNjZSBkb2N1bWVudHMgYW5kIHdpbmRvd3Ncblx0XHRcdHZhciB3aW47XG5cdFx0XHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW07XG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtLmRlZmF1bHRWaWV3O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9O1xufSApO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmkgPD03IC0gOS4xLCBDaHJvbWUgPD0zNyAtIDQ5XG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBCbGluayBidWc6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU4OTM0N1xuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSApO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sXG5cdFx0ZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cblx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vICQoIHdpbmRvdyApLm91dGVyV2lkdGgvSGVpZ2h0IHJldHVybiB3L2ggaW5jbHVkaW5nIHNjcm9sbGJhcnMgKGdoLTE3MjkpXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoIFwib3V0ZXJcIiApID09PSAwID9cblx0XHRcdFx0XHRcdGVsZW1bIFwiaW5uZXJcIiArIG5hbWUgXSA6XG5cdFx0XHRcdFx0XHRlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSApO1xuXHRcdH07XG5cdH0gKTtcbn0gKTtcblxuXG5qUXVlcnkuZWFjaCggKCBcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiICkuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG5cdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fVxufSApO1xuXG5cblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblxuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHR0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcblx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuLy8gYXJndW1lbnRzLlxuLy8galF1ZXJ5LnByb3h5IGlzIGRlcHJlY2F0ZWQgdG8gcHJvbW90ZSBzdGFuZGFyZHMgKHNwZWNpZmljYWxseSBGdW5jdGlvbiNiaW5kKVxuLy8gSG93ZXZlciwgaXQgaXMgbm90IHNsYXRlZCBmb3IgcmVtb3ZhbCBhbnkgdGltZSBzb29uXG5qUXVlcnkucHJveHkgPSBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRjb250ZXh0ID0gZm47XG5cdFx0Zm4gPSB0bXA7XG5cdH1cblxuXHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRpZiAoICFpc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHQvLyBTaW11bGF0ZWQgYmluZFxuXHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdH07XG5cblx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdHJldHVybiBwcm94eTtcbn07XG5cbmpRdWVyeS5ob2xkUmVhZHkgPSBmdW5jdGlvbiggaG9sZCApIHtcblx0aWYgKCBob2xkICkge1xuXHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0fSBlbHNlIHtcblx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0fVxufTtcbmpRdWVyeS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xualF1ZXJ5Lm5vZGVOYW1lID0gbm9kZU5hbWU7XG5qUXVlcnkuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5qUXVlcnkuaXNXaW5kb3cgPSBpc1dpbmRvdztcbmpRdWVyeS5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG5qUXVlcnkudHlwZSA9IHRvVHlwZTtcblxualF1ZXJ5Lm5vdyA9IERhdGUubm93O1xuXG5qUXVlcnkuaXNOdW1lcmljID0gZnVuY3Rpb24oIG9iaiApIHtcblxuXHQvLyBBcyBvZiBqUXVlcnkgMy4wLCBpc051bWVyaWMgaXMgbGltaXRlZCB0b1xuXHQvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG5cdC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG5cdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXHRyZXR1cm4gKCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgKSAmJlxuXG5cdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpXG5cdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdCFpc05hTiggb2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKTtcbn07XG5cblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSApO1xufVxuXG5cblxuXG52YXJcblxuXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XyQgPSB3aW5kb3cuJDtcblxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy4kID0gXyQ7XG5cdH1cblxuXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeTtcbn07XG5cbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4vLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXG5pZiAoICFub0dsb2JhbCApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5cblxuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n')},function(module,exports){eval('module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, "loaded", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, "id", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2NlZDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n')},function(t,n,c){c(3),c(4),c(5),t.exports=c(6)},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * what-input - A global utility for tracking the current input method (mouse, keyboard or touch).\n * @version v5.1.3\n * @link https://github.com/ten1seven/what-input\n * @license MIT\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif (( false ? undefined : _typeof(exports)) === 'object' && ( false ? undefined : _typeof(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}\n})(undefined, function () {\n\treturn (/******/function (modules) {\n\t\t\t// webpackBootstrap\n\t\t\t/******/ // The module cache\n\t\t\t/******/var installedModules = {};\n\n\t\t\t/******/ // The require function\n\t\t\t/******/function __webpack_require__(moduleId) {\n\n\t\t\t\t/******/ // Check if module is in cache\n\t\t\t\t/******/if (installedModules[moduleId])\n\t\t\t\t\t/******/return installedModules[moduleId].exports;\n\n\t\t\t\t/******/ // Create a new module (and put it into the cache)\n\t\t\t\t/******/var module = installedModules[moduleId] = {\n\t\t\t\t\t/******/exports: {},\n\t\t\t\t\t/******/id: moduleId,\n\t\t\t\t\t/******/loaded: false\n\t\t\t\t\t/******/ };\n\n\t\t\t\t/******/ // Execute the module function\n\t\t\t\t/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t\t\t\t/******/ // Flag the module as loaded\n\t\t\t\t/******/module.loaded = true;\n\n\t\t\t\t/******/ // Return the exports of the module\n\t\t\t\t/******/return module.exports;\n\t\t\t\t/******/\n\t\t\t}\n\n\t\t\t/******/ // expose the modules object (__webpack_modules__)\n\t\t\t/******/__webpack_require__.m = modules;\n\n\t\t\t/******/ // expose the module cache\n\t\t\t/******/__webpack_require__.c = installedModules;\n\n\t\t\t/******/ // __webpack_public_path__\n\t\t\t/******/__webpack_require__.p = \"\";\n\n\t\t\t/******/ // Load entry module and return exports\n\t\t\t/******/return __webpack_require__(0);\n\t\t\t/******/\n\t\t}(\n\t\t/************************************************************************/\n\t\t/******/[\n\t\t/* 0 */\n\t\t/***/function (module, exports) {\n\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function () {\n\t\t\t\t/*\n     * bail out if there is no document or window\n     * (i.e. in a node/non-DOM environment)\n     *\n     * Return a stubbed API instead\n     */\n\t\t\t\tif (typeof document === 'undefined' || typeof window === 'undefined') {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t// always return \"initial\" because no interaction will ever be detected\n\t\t\t\t\t\task: function ask() {\n\t\t\t\t\t\t\treturn 'initial';\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// always return null\n\t\t\t\t\t\telement: function element() {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// no-op\n\t\t\t\t\t\tignoreKeys: function ignoreKeys() {},\n\n\t\t\t\t\t\t// no-op\n\t\t\t\t\t\tspecificKeys: function specificKeys() {},\n\n\t\t\t\t\t\t// no-op\n\t\t\t\t\t\tregisterOnChange: function registerOnChange() {},\n\n\t\t\t\t\t\t// no-op\n\t\t\t\t\t\tunRegisterOnChange: function unRegisterOnChange() {}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t/*\n     * variables\n     */\n\n\t\t\t\t// cache document.documentElement\n\t\t\t\tvar docElem = document.documentElement;\n\n\t\t\t\t// currently focused dom element\n\t\t\t\tvar currentElement = null;\n\n\t\t\t\t// last used input type\n\t\t\t\tvar currentInput = 'initial';\n\n\t\t\t\t// last used input intent\n\t\t\t\tvar currentIntent = currentInput;\n\n\t\t\t\t// check for sessionStorage support\n\t\t\t\t// then check for session variables and use if available\n\t\t\t\ttry {\n\t\t\t\t\tif (window.sessionStorage.getItem('what-input')) {\n\t\t\t\t\t\tcurrentInput = window.sessionStorage.getItem('what-input');\n\t\t\t\t\t}\n\n\t\t\t\t\tif (window.sessionStorage.getItem('what-intent')) {\n\t\t\t\t\t\tcurrentIntent = window.sessionStorage.getItem('what-intent');\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {}\n\n\t\t\t\t// event buffer timer\n\t\t\t\tvar eventTimer = null;\n\n\t\t\t\t// form input types\n\t\t\t\tvar formInputs = ['input', 'select', 'textarea'];\n\n\t\t\t\t// empty array for holding callback functions\n\t\t\t\tvar functionList = [];\n\n\t\t\t\t// list of modifier keys commonly used with the mouse and\n\t\t\t\t// can be safely ignored to prevent false keyboard detection\n\t\t\t\tvar ignoreMap = [16, // shift\n\t\t\t\t17, // control\n\t\t\t\t18, // alt\n\t\t\t\t91, // Windows key / left Apple cmd\n\t\t\t\t93 // Windows menu / right Apple cmd\n\t\t\t\t];\n\n\t\t\t\tvar specificMap = [];\n\n\t\t\t\t// mapping of events to input types\n\t\t\t\tvar inputMap = {\n\t\t\t\t\tkeydown: 'keyboard',\n\t\t\t\t\tkeyup: 'keyboard',\n\t\t\t\t\tmousedown: 'mouse',\n\t\t\t\t\tmousemove: 'mouse',\n\t\t\t\t\tMSPointerDown: 'pointer',\n\t\t\t\t\tMSPointerMove: 'pointer',\n\t\t\t\t\tpointerdown: 'pointer',\n\t\t\t\t\tpointermove: 'pointer',\n\t\t\t\t\ttouchstart: 'touch'\n\n\t\t\t\t\t// boolean: true if touch buffer is active\n\t\t\t\t};var isBuffering = false;\n\n\t\t\t\t// boolean: true if the page is being scrolled\n\t\t\t\tvar isScrolling = false;\n\n\t\t\t\t// store current mouse position\n\t\t\t\tvar mousePos = {\n\t\t\t\t\tx: null,\n\t\t\t\t\ty: null\n\n\t\t\t\t\t// map of IE 10 pointer events\n\t\t\t\t};var pointerMap = {\n\t\t\t\t\t2: 'touch',\n\t\t\t\t\t3: 'touch', // treat pen like touch\n\t\t\t\t\t4: 'mouse'\n\n\t\t\t\t\t// check support for passive event listeners\n\t\t\t\t};var supportsPassive = false;\n\n\t\t\t\ttry {\n\t\t\t\t\tvar opts = Object.defineProperty({}, 'passive', {\n\t\t\t\t\t\tget: function get() {\n\t\t\t\t\t\t\tsupportsPassive = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\twindow.addEventListener('test', null, opts);\n\t\t\t\t} catch (e) {}\n\n\t\t\t\t/*\n     * set up\n     */\n\n\t\t\t\tvar setUp = function setUp() {\n\t\t\t\t\t// add correct mouse wheel event mapping to `inputMap`\n\t\t\t\t\tinputMap[detectWheel()] = 'mouse';\n\n\t\t\t\t\taddListeners();\n\t\t\t\t\tdoUpdate('input');\n\t\t\t\t\tdoUpdate('intent');\n\t\t\t\t};\n\n\t\t\t\t/*\n     * events\n     */\n\n\t\t\t\tvar addListeners = function addListeners() {\n\t\t\t\t\t// `pointermove`, `MSPointerMove`, `mousemove` and mouse wheel event binding\n\t\t\t\t\t// can only demonstrate potential, but not actual, interaction\n\t\t\t\t\t// and are treated separately\n\t\t\t\t\tvar options = supportsPassive ? { passive: true } : false;\n\n\t\t\t\t\t// pointer events (mouse, pen, touch)\n\t\t\t\t\tif (window.PointerEvent) {\n\t\t\t\t\t\twindow.addEventListener('pointerdown', setInput);\n\t\t\t\t\t\twindow.addEventListener('pointermove', setIntent);\n\t\t\t\t\t} else if (window.MSPointerEvent) {\n\t\t\t\t\t\twindow.addEventListener('MSPointerDown', setInput);\n\t\t\t\t\t\twindow.addEventListener('MSPointerMove', setIntent);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// mouse events\n\t\t\t\t\t\twindow.addEventListener('mousedown', setInput);\n\t\t\t\t\t\twindow.addEventListener('mousemove', setIntent);\n\n\t\t\t\t\t\t// touch events\n\t\t\t\t\t\tif ('ontouchstart' in window) {\n\t\t\t\t\t\t\twindow.addEventListener('touchstart', eventBuffer, options);\n\t\t\t\t\t\t\twindow.addEventListener('touchend', setInput);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// mouse wheel\n\t\t\t\t\twindow.addEventListener(detectWheel(), setIntent, options);\n\n\t\t\t\t\t// keyboard events\n\t\t\t\t\twindow.addEventListener('keydown', eventBuffer);\n\t\t\t\t\twindow.addEventListener('keyup', eventBuffer);\n\n\t\t\t\t\t// focus events\n\t\t\t\t\twindow.addEventListener('focusin', setElement);\n\t\t\t\t\twindow.addEventListener('focusout', clearElement);\n\t\t\t\t};\n\n\t\t\t\t// checks conditions before updating new input\n\t\t\t\tvar setInput = function setInput(event) {\n\t\t\t\t\t// only execute if the event buffer timer isn't running\n\t\t\t\t\tif (!isBuffering) {\n\t\t\t\t\t\tvar eventKey = event.which;\n\t\t\t\t\t\tvar value = inputMap[event.type];\n\n\t\t\t\t\t\tif (value === 'pointer') {\n\t\t\t\t\t\t\tvalue = pointerType(event);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar ignoreMatch = !specificMap.length && ignoreMap.indexOf(eventKey) === -1;\n\n\t\t\t\t\t\tvar specificMatch = specificMap.length && specificMap.indexOf(eventKey) !== -1;\n\n\t\t\t\t\t\tvar shouldUpdate = value === 'keyboard' && eventKey && (ignoreMatch || specificMatch) || value === 'mouse' || value === 'touch';\n\n\t\t\t\t\t\tif (currentInput !== value && shouldUpdate) {\n\t\t\t\t\t\t\tcurrentInput = value;\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\twindow.sessionStorage.setItem('what-input', currentInput);\n\t\t\t\t\t\t\t} catch (e) {}\n\n\t\t\t\t\t\t\tdoUpdate('input');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (currentIntent !== value && shouldUpdate) {\n\t\t\t\t\t\t\t// preserve intent for keyboard typing in form fields\n\t\t\t\t\t\t\tvar activeElem = document.activeElement;\n\t\t\t\t\t\t\tvar notFormInput = activeElem && activeElem.nodeName && formInputs.indexOf(activeElem.nodeName.toLowerCase()) === -1;\n\n\t\t\t\t\t\t\tif (notFormInput) {\n\t\t\t\t\t\t\t\tcurrentIntent = value;\n\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\twindow.sessionStorage.setItem('what-intent', currentIntent);\n\t\t\t\t\t\t\t\t} catch (e) {}\n\n\t\t\t\t\t\t\t\tdoUpdate('intent');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// updates the doc and `inputTypes` array with new input\n\t\t\t\tvar doUpdate = function doUpdate(which) {\n\t\t\t\t\tdocElem.setAttribute('data-what' + which, which === 'input' ? currentInput : currentIntent);\n\n\t\t\t\t\tfireFunctions(which);\n\t\t\t\t};\n\n\t\t\t\t// updates input intent for `mousemove` and `pointermove`\n\t\t\t\tvar setIntent = function setIntent(event) {\n\t\t\t\t\t// test to see if `mousemove` happened relative to the screen to detect scrolling versus mousemove\n\t\t\t\t\tdetectScrolling(event);\n\n\t\t\t\t\t// only execute if the event buffer timer isn't running\n\t\t\t\t\t// or scrolling isn't happening\n\t\t\t\t\tif (!isBuffering && !isScrolling) {\n\t\t\t\t\t\tvar value = inputMap[event.type];\n\t\t\t\t\t\tif (value === 'pointer') {\n\t\t\t\t\t\t\tvalue = pointerType(event);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (currentIntent !== value) {\n\t\t\t\t\t\t\tcurrentIntent = value;\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\twindow.sessionStorage.setItem('what-intent', currentIntent);\n\t\t\t\t\t\t\t} catch (e) {}\n\n\t\t\t\t\t\t\tdoUpdate('intent');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tvar setElement = function setElement(event) {\n\t\t\t\t\tif (!event.target.nodeName) {\n\t\t\t\t\t\t// If nodeName is undefined, clear the element\n\t\t\t\t\t\t// This can happen if click inside an <svg> element.\n\t\t\t\t\t\tclearElement();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentElement = event.target.nodeName.toLowerCase();\n\t\t\t\t\tdocElem.setAttribute('data-whatelement', currentElement);\n\n\t\t\t\t\tif (event.target.classList && event.target.classList.length) {\n\t\t\t\t\t\tdocElem.setAttribute('data-whatclasses', event.target.classList.toString().replace(' ', ','));\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tvar clearElement = function clearElement() {\n\t\t\t\t\tcurrentElement = null;\n\n\t\t\t\t\tdocElem.removeAttribute('data-whatelement');\n\t\t\t\t\tdocElem.removeAttribute('data-whatclasses');\n\t\t\t\t};\n\n\t\t\t\t// buffers events that frequently also fire mouse events\n\t\t\t\tvar eventBuffer = function eventBuffer(event) {\n\t\t\t\t\t// set the current input\n\t\t\t\t\tsetInput(event);\n\n\t\t\t\t\t// clear the timer if it happens to be running\n\t\t\t\t\twindow.clearTimeout(eventTimer);\n\n\t\t\t\t\t// set the isBuffering to `true`\n\t\t\t\t\tisBuffering = true;\n\n\t\t\t\t\t// run the timer\n\t\t\t\t\teventTimer = window.setTimeout(function () {\n\t\t\t\t\t\t// if the timer runs out, set isBuffering back to `false`\n\t\t\t\t\t\tisBuffering = false;\n\t\t\t\t\t}, 100);\n\t\t\t\t};\n\n\t\t\t\t/*\n     * utilities\n     */\n\n\t\t\t\tvar pointerType = function pointerType(event) {\n\t\t\t\t\tif (typeof event.pointerType === 'number') {\n\t\t\t\t\t\treturn pointerMap[event.pointerType];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// treat pen like touch\n\t\t\t\t\t\treturn event.pointerType === 'pen' ? 'touch' : event.pointerType;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// detect version of mouse wheel event to use\n\t\t\t\t// via https://developer.mozilla.org/en-US/docs/Web/Events/wheel\n\t\t\t\tvar detectWheel = function detectWheel() {\n\t\t\t\t\tvar wheelType = void 0;\n\n\t\t\t\t\t// Modern browsers support \"wheel\"\n\t\t\t\t\tif ('onwheel' in document.createElement('div')) {\n\t\t\t\t\t\twheelType = 'wheel';\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Webkit and IE support at least \"mousewheel\"\n\t\t\t\t\t\t// or assume that remaining browsers are older Firefox\n\t\t\t\t\t\twheelType = document.onmousewheel !== undefined ? 'mousewheel' : 'DOMMouseScroll';\n\t\t\t\t\t}\n\n\t\t\t\t\treturn wheelType;\n\t\t\t\t};\n\n\t\t\t\t// runs callback functions\n\t\t\t\tvar fireFunctions = function fireFunctions(type) {\n\t\t\t\t\tfor (var i = 0, len = functionList.length; i < len; i++) {\n\t\t\t\t\t\tif (functionList[i].type === type) {\n\t\t\t\t\t\t\tfunctionList[i].fn.call(undefined, type === 'input' ? currentInput : currentIntent);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// finds matching element in an object\n\t\t\t\tvar objPos = function objPos(match) {\n\t\t\t\t\tfor (var i = 0, len = functionList.length; i < len; i++) {\n\t\t\t\t\t\tif (functionList[i].fn === match) {\n\t\t\t\t\t\t\treturn i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tvar detectScrolling = function detectScrolling(event) {\n\t\t\t\t\tif (mousePos['x'] !== event.screenX || mousePos['y'] !== event.screenY) {\n\t\t\t\t\t\tisScrolling = false;\n\n\t\t\t\t\t\tmousePos['x'] = event.screenX;\n\t\t\t\t\t\tmousePos['y'] = event.screenY;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tisScrolling = true;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t/*\n     * init\n     */\n\n\t\t\t\t// don't start script unless browser cuts the mustard\n\t\t\t\t// (also passes if polyfills are used)\n\t\t\t\tif ('addEventListener' in window && Array.prototype.indexOf) {\n\t\t\t\t\tsetUp();\n\t\t\t\t}\n\n\t\t\t\t/*\n     * api\n     */\n\n\t\t\t\treturn {\n\t\t\t\t\t// returns string: the current input type\n\t\t\t\t\t// opt: 'intent'|'input'\n\t\t\t\t\t// 'input' (default): returns the same value as the `data-whatinput` attribute\n\t\t\t\t\t// 'intent': includes `data-whatintent` value if it's different than `data-whatinput`\n\t\t\t\t\task: function ask(opt) {\n\t\t\t\t\t\treturn opt === 'intent' ? currentIntent : currentInput;\n\t\t\t\t\t},\n\n\t\t\t\t\t// returns string: the currently focused element or null\n\t\t\t\t\telement: function element() {\n\t\t\t\t\t\treturn currentElement;\n\t\t\t\t\t},\n\n\t\t\t\t\t// overwrites ignored keys with provided array\n\t\t\t\t\tignoreKeys: function ignoreKeys(arr) {\n\t\t\t\t\t\tignoreMap = arr;\n\t\t\t\t\t},\n\n\t\t\t\t\t// overwrites specific char keys to update on\n\t\t\t\t\tspecificKeys: function specificKeys(arr) {\n\t\t\t\t\t\tspecificMap = arr;\n\t\t\t\t\t},\n\n\t\t\t\t\t// attach functions to input and intent \"events\"\n\t\t\t\t\t// funct: function to fire on change\n\t\t\t\t\t// eventType: 'input'|'intent'\n\t\t\t\t\tregisterOnChange: function registerOnChange(fn, eventType) {\n\t\t\t\t\t\tfunctionList.push({\n\t\t\t\t\t\t\tfn: fn,\n\t\t\t\t\t\t\ttype: eventType || 'input'\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\n\t\t\t\t\tunRegisterOnChange: function unRegisterOnChange(fn) {\n\t\t\t\t\t\tvar position = objPos(fn);\n\n\t\t\t\t\t\tif (position || position === 0) {\n\t\t\t\t\t\t\tfunctionList.splice(position, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}();\n\n\t\t\t/***/\n\t\t}]\n\t\t/******/)\n\t);\n});\n;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(1)(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvdmVuZG9yL3doYXQtaW5wdXQuanM/NGM4MSJdLCJuYW1lcyI6WyJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiaWQiLCJsb2FkZWQiLCJjYWxsIiwibSIsImMiLCJwIiwiZG9jdW1lbnQiLCJ3aW5kb3ciLCJhc2siLCJlbGVtZW50IiwiaWdub3JlS2V5cyIsInNwZWNpZmljS2V5cyIsInJlZ2lzdGVyT25DaGFuZ2UiLCJ1blJlZ2lzdGVyT25DaGFuZ2UiLCJkb2NFbGVtIiwiZG9jdW1lbnRFbGVtZW50IiwiY3VycmVudEVsZW1lbnQiLCJjdXJyZW50SW5wdXQiLCJjdXJyZW50SW50ZW50Iiwic2Vzc2lvblN0b3JhZ2UiLCJnZXRJdGVtIiwiZSIsImV2ZW50VGltZXIiLCJmb3JtSW5wdXRzIiwiZnVuY3Rpb25MaXN0IiwiaWdub3JlTWFwIiwic3BlY2lmaWNNYXAiLCJpbnB1dE1hcCIsImtleWRvd24iLCJrZXl1cCIsIm1vdXNlZG93biIsIm1vdXNlbW92ZSIsIk1TUG9pbnRlckRvd24iLCJNU1BvaW50ZXJNb3ZlIiwicG9pbnRlcmRvd24iLCJwb2ludGVybW92ZSIsInRvdWNoc3RhcnQiLCJpc0J1ZmZlcmluZyIsImlzU2Nyb2xsaW5nIiwibW91c2VQb3MiLCJ4IiwieSIsInBvaW50ZXJNYXAiLCJzdXBwb3J0c1Bhc3NpdmUiLCJvcHRzIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJhZGRFdmVudExpc3RlbmVyIiwic2V0VXAiLCJkZXRlY3RXaGVlbCIsImFkZExpc3RlbmVycyIsImRvVXBkYXRlIiwib3B0aW9ucyIsInBhc3NpdmUiLCJQb2ludGVyRXZlbnQiLCJzZXRJbnB1dCIsInNldEludGVudCIsIk1TUG9pbnRlckV2ZW50IiwiZXZlbnRCdWZmZXIiLCJzZXRFbGVtZW50IiwiY2xlYXJFbGVtZW50IiwiZXZlbnQiLCJldmVudEtleSIsIndoaWNoIiwidmFsdWUiLCJ0eXBlIiwicG9pbnRlclR5cGUiLCJpZ25vcmVNYXRjaCIsImxlbmd0aCIsImluZGV4T2YiLCJzcGVjaWZpY01hdGNoIiwic2hvdWxkVXBkYXRlIiwic2V0SXRlbSIsImFjdGl2ZUVsZW0iLCJhY3RpdmVFbGVtZW50Iiwibm90Rm9ybUlucHV0Iiwibm9kZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsInNldEF0dHJpYnV0ZSIsImZpcmVGdW5jdGlvbnMiLCJkZXRlY3RTY3JvbGxpbmciLCJ0YXJnZXQiLCJjbGFzc0xpc3QiLCJ0b1N0cmluZyIsInJlcGxhY2UiLCJyZW1vdmVBdHRyaWJ1dGUiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0Iiwid2hlZWxUeXBlIiwiY3JlYXRlRWxlbWVudCIsIm9ubW91c2V3aGVlbCIsInVuZGVmaW5lZCIsImkiLCJsZW4iLCJmbiIsIm9ialBvcyIsIm1hdGNoIiwic2NyZWVuWCIsInNjcmVlblkiLCJBcnJheSIsInByb3RvdHlwZSIsIm9wdCIsImFyciIsImV2ZW50VHlwZSIsInB1c2giLCJwb3NpdGlvbiIsInNwbGljZSJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Ozs7QUFNQSxDQUFDLFNBQVNBLGdDQUFULENBQTBDQyxJQUExQyxFQUFnREMsT0FBaEQsRUFBeUQ7QUFDekQsS0FBRyw4QkFBT0MsT0FBUCxPQUFtQixRQUFuQixJQUErQiw4QkFBT0MsTUFBUCxPQUFrQixRQUFwRCxFQUNDQSxPQUFPRCxPQUFQLEdBQWlCRCxTQUFqQixDQURELEtBRUssSUFBRyxJQUFILEVBQ0pHLGlDQUFvQixFQUFwQixvQ0FBd0JILE9BQXhCO0FBQUE7QUFBQTtBQUFBLHFHQURJLEtBRUEsRUFHSjtBQUNELENBVEQsYUFTUyxZQUFXO0FBQ3BCLFFBQU8sU0FBVSxVQUFTSSxPQUFULEVBQWtCO0FBQUU7QUFDckMsV0FEbUMsQ0FDekI7QUFDVixXQUFVLElBQUlDLG1CQUFtQixFQUF2Qjs7QUFFVixXQUptQyxDQUl6QjtBQUNWLFdBQVUsU0FBU0MsbUJBQVQsQ0FBNkJDLFFBQTdCLEVBQXVDOztBQUVqRCxZQUZpRCxDQUV0QztBQUNYLFlBQVcsSUFBR0YsaUJBQWlCRSxRQUFqQixDQUFIO0FBQ1gsYUFBWSxPQUFPRixpQkFBaUJFLFFBQWpCLEVBQTJCTixPQUFsQzs7QUFFWixZQU5pRCxDQU10QztBQUNYLFlBQVcsSUFBSUMsU0FBU0csaUJBQWlCRSxRQUFqQixJQUE2QjtBQUNyRCxhQUFZTixTQUFTLEVBRGdDO0FBRXJELGFBQVlPLElBQUlELFFBRnFDO0FBR3JELGFBQVlFLFFBQVE7QUFDcEIsYUFKcUQsRUFBMUM7O0FBTVgsWUFiaUQsQ0FhdEM7QUFDWCxZQUFXTCxRQUFRRyxRQUFSLEVBQWtCRyxJQUFsQixDQUF1QlIsT0FBT0QsT0FBOUIsRUFBdUNDLE1BQXZDLEVBQStDQSxPQUFPRCxPQUF0RCxFQUErREssbUJBQS9EOztBQUVYLFlBaEJpRCxDQWdCdEM7QUFDWCxZQUFXSixPQUFPTyxNQUFQLEdBQWdCLElBQWhCOztBQUVYLFlBbkJpRCxDQW1CdEM7QUFDWCxZQUFXLE9BQU9QLE9BQU9ELE9BQWQ7QUFDWDtBQUFXOztBQUdYLFdBN0JtQyxDQTZCekI7QUFDVixXQUFVSyxvQkFBb0JLLENBQXBCLEdBQXdCUCxPQUF4Qjs7QUFFVixXQWhDbUMsQ0FnQ3pCO0FBQ1YsV0FBVUUsb0JBQW9CTSxDQUFwQixHQUF3QlAsZ0JBQXhCOztBQUVWLFdBbkNtQyxDQW1DekI7QUFDVixXQUFVQyxvQkFBb0JPLENBQXBCLEdBQXdCLEVBQXhCOztBQUVWLFdBdENtQyxDQXNDekI7QUFDVixXQUFVLE9BQU9QLG9CQUFvQixDQUFwQixDQUFQO0FBQ1Y7QUFBVSxHQXhDTTtBQXlDaEI7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxPQUFPLFVBQVNKLE1BQVQsRUFBaUJELE9BQWpCLEVBQTBCOztBQUVoQzs7QUFFQUMsVUFBT0QsT0FBUCxHQUFpQixZQUFZO0FBQzNCOzs7Ozs7QUFNQSxRQUFJLE9BQU9hLFFBQVAsS0FBb0IsV0FBcEIsSUFBbUMsT0FBT0MsTUFBUCxLQUFrQixXQUF6RCxFQUFzRTtBQUNwRSxZQUFPO0FBQ0w7QUFDQUMsV0FBSyxTQUFTQSxHQUFULEdBQWU7QUFDbEIsY0FBTyxTQUFQO0FBQ0QsT0FKSTs7QUFNTDtBQUNBQyxlQUFTLFNBQVNBLE9BQVQsR0FBbUI7QUFDMUIsY0FBTyxJQUFQO0FBQ0QsT0FUSTs7QUFXTDtBQUNBQyxrQkFBWSxTQUFTQSxVQUFULEdBQXNCLENBQUUsQ0FaL0I7O0FBY0w7QUFDQUMsb0JBQWMsU0FBU0EsWUFBVCxHQUF3QixDQUFFLENBZm5DOztBQWlCTDtBQUNBQyx3QkFBa0IsU0FBU0EsZ0JBQVQsR0FBNEIsQ0FBRSxDQWxCM0M7O0FBb0JMO0FBQ0FDLDBCQUFvQixTQUFTQSxrQkFBVCxHQUE4QixDQUFFO0FBckIvQyxNQUFQO0FBdUJEOztBQUVEOzs7O0FBSUE7QUFDQSxRQUFJQyxVQUFVUixTQUFTUyxlQUF2Qjs7QUFFQTtBQUNBLFFBQUlDLGlCQUFpQixJQUFyQjs7QUFFQTtBQUNBLFFBQUlDLGVBQWUsU0FBbkI7O0FBRUE7QUFDQSxRQUFJQyxnQkFBZ0JELFlBQXBCOztBQUVBO0FBQ0E7QUFDQSxRQUFJO0FBQ0YsU0FBSVYsT0FBT1ksY0FBUCxDQUFzQkMsT0FBdEIsQ0FBOEIsWUFBOUIsQ0FBSixFQUFpRDtBQUMvQ0gscUJBQWVWLE9BQU9ZLGNBQVAsQ0FBc0JDLE9BQXRCLENBQThCLFlBQTlCLENBQWY7QUFDRDs7QUFFRCxTQUFJYixPQUFPWSxjQUFQLENBQXNCQyxPQUF0QixDQUE4QixhQUE5QixDQUFKLEVBQWtEO0FBQ2hERixzQkFBZ0JYLE9BQU9ZLGNBQVAsQ0FBc0JDLE9BQXRCLENBQThCLGFBQTlCLENBQWhCO0FBQ0Q7QUFDRixLQVJELENBUUUsT0FBT0MsQ0FBUCxFQUFVLENBQUU7O0FBRWQ7QUFDQSxRQUFJQyxhQUFhLElBQWpCOztBQUVBO0FBQ0EsUUFBSUMsYUFBYSxDQUFDLE9BQUQsRUFBVSxRQUFWLEVBQW9CLFVBQXBCLENBQWpCOztBQUVBO0FBQ0EsUUFBSUMsZUFBZSxFQUFuQjs7QUFFQTtBQUNBO0FBQ0EsUUFBSUMsWUFBWSxDQUFDLEVBQUQsRUFBSztBQUNyQixNQURnQixFQUNaO0FBQ0osTUFGZ0IsRUFFWjtBQUNKLE1BSGdCLEVBR1o7QUFDSixNQUpnQixDQUliO0FBSmEsS0FBaEI7O0FBT0EsUUFBSUMsY0FBYyxFQUFsQjs7QUFFQTtBQUNBLFFBQUlDLFdBQVc7QUFDYkMsY0FBUyxVQURJO0FBRWJDLFlBQU8sVUFGTTtBQUdiQyxnQkFBVyxPQUhFO0FBSWJDLGdCQUFXLE9BSkU7QUFLYkMsb0JBQWUsU0FMRjtBQU1iQyxvQkFBZSxTQU5GO0FBT2JDLGtCQUFhLFNBUEE7QUFRYkMsa0JBQWEsU0FSQTtBQVNiQyxpQkFBWTs7QUFFWjtBQVhhLEtBQWYsQ0FZRSxJQUFJQyxjQUFjLEtBQWxCOztBQUVGO0FBQ0EsUUFBSUMsY0FBYyxLQUFsQjs7QUFFQTtBQUNBLFFBQUlDLFdBQVc7QUFDYkMsUUFBRyxJQURVO0FBRWJDLFFBQUc7O0FBRUg7QUFKYSxLQUFmLENBS0UsSUFBSUMsYUFBYTtBQUNqQixRQUFHLE9BRGM7QUFFakIsUUFBRyxPQUZjLEVBRUw7QUFDWixRQUFHOztBQUVIO0FBTGlCLEtBQWpCLENBTUEsSUFBSUMsa0JBQWtCLEtBQXRCOztBQUVGLFFBQUk7QUFDRixTQUFJQyxPQUFPQyxPQUFPQyxjQUFQLENBQXNCLEVBQXRCLEVBQTBCLFNBQTFCLEVBQXFDO0FBQzlDQyxXQUFLLFNBQVNBLEdBQVQsR0FBZTtBQUNsQkoseUJBQWtCLElBQWxCO0FBQ0Q7QUFINkMsTUFBckMsQ0FBWDs7QUFNQXBDLFlBQU95QyxnQkFBUCxDQUF3QixNQUF4QixFQUFnQyxJQUFoQyxFQUFzQ0osSUFBdEM7QUFDRCxLQVJELENBUUUsT0FBT3ZCLENBQVAsRUFBVSxDQUFFOztBQUVkOzs7O0FBSUEsUUFBSTRCLFFBQVEsU0FBU0EsS0FBVCxHQUFpQjtBQUMzQjtBQUNBdEIsY0FBU3VCLGFBQVQsSUFBMEIsT0FBMUI7O0FBRUFDO0FBQ0FDLGNBQVMsT0FBVDtBQUNBQSxjQUFTLFFBQVQ7QUFDRCxLQVBEOztBQVNBOzs7O0FBSUEsUUFBSUQsZUFBZSxTQUFTQSxZQUFULEdBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFNBQUlFLFVBQVVWLGtCQUFrQixFQUFFVyxTQUFTLElBQVgsRUFBbEIsR0FBc0MsS0FBcEQ7O0FBRUE7QUFDQSxTQUFJL0MsT0FBT2dELFlBQVgsRUFBeUI7QUFDdkJoRCxhQUFPeUMsZ0JBQVAsQ0FBd0IsYUFBeEIsRUFBdUNRLFFBQXZDO0FBQ0FqRCxhQUFPeUMsZ0JBQVAsQ0FBd0IsYUFBeEIsRUFBdUNTLFNBQXZDO0FBQ0QsTUFIRCxNQUdPLElBQUlsRCxPQUFPbUQsY0FBWCxFQUEyQjtBQUNoQ25ELGFBQU95QyxnQkFBUCxDQUF3QixlQUF4QixFQUF5Q1EsUUFBekM7QUFDQWpELGFBQU95QyxnQkFBUCxDQUF3QixlQUF4QixFQUF5Q1MsU0FBekM7QUFDRCxNQUhNLE1BR0E7QUFDTDtBQUNBbEQsYUFBT3lDLGdCQUFQLENBQXdCLFdBQXhCLEVBQXFDUSxRQUFyQztBQUNBakQsYUFBT3lDLGdCQUFQLENBQXdCLFdBQXhCLEVBQXFDUyxTQUFyQzs7QUFFQTtBQUNBLFVBQUksa0JBQWtCbEQsTUFBdEIsRUFBOEI7QUFDNUJBLGNBQU95QyxnQkFBUCxDQUF3QixZQUF4QixFQUFzQ1csV0FBdEMsRUFBbUROLE9BQW5EO0FBQ0E5QyxjQUFPeUMsZ0JBQVAsQ0FBd0IsVUFBeEIsRUFBb0NRLFFBQXBDO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBakQsWUFBT3lDLGdCQUFQLENBQXdCRSxhQUF4QixFQUF1Q08sU0FBdkMsRUFBa0RKLE9BQWxEOztBQUVBO0FBQ0E5QyxZQUFPeUMsZ0JBQVAsQ0FBd0IsU0FBeEIsRUFBbUNXLFdBQW5DO0FBQ0FwRCxZQUFPeUMsZ0JBQVAsQ0FBd0IsT0FBeEIsRUFBaUNXLFdBQWpDOztBQUVBO0FBQ0FwRCxZQUFPeUMsZ0JBQVAsQ0FBd0IsU0FBeEIsRUFBbUNZLFVBQW5DO0FBQ0FyRCxZQUFPeUMsZ0JBQVAsQ0FBd0IsVUFBeEIsRUFBb0NhLFlBQXBDO0FBQ0QsS0FuQ0Q7O0FBcUNBO0FBQ0EsUUFBSUwsV0FBVyxTQUFTQSxRQUFULENBQWtCTSxLQUFsQixFQUF5QjtBQUN0QztBQUNBLFNBQUksQ0FBQ3pCLFdBQUwsRUFBa0I7QUFDaEIsVUFBSTBCLFdBQVdELE1BQU1FLEtBQXJCO0FBQ0EsVUFBSUMsUUFBUXRDLFNBQVNtQyxNQUFNSSxJQUFmLENBQVo7O0FBRUEsVUFBSUQsVUFBVSxTQUFkLEVBQXlCO0FBQ3ZCQSxlQUFRRSxZQUFZTCxLQUFaLENBQVI7QUFDRDs7QUFFRCxVQUFJTSxjQUFjLENBQUMxQyxZQUFZMkMsTUFBYixJQUF1QjVDLFVBQVU2QyxPQUFWLENBQWtCUCxRQUFsQixNQUFnQyxDQUFDLENBQTFFOztBQUVBLFVBQUlRLGdCQUFnQjdDLFlBQVkyQyxNQUFaLElBQXNCM0MsWUFBWTRDLE9BQVosQ0FBb0JQLFFBQXBCLE1BQWtDLENBQUMsQ0FBN0U7O0FBRUEsVUFBSVMsZUFBZVAsVUFBVSxVQUFWLElBQXdCRixRQUF4QixLQUFxQ0ssZUFBZUcsYUFBcEQsS0FBc0VOLFVBQVUsT0FBaEYsSUFBMkZBLFVBQVUsT0FBeEg7O0FBRUEsVUFBSWhELGlCQUFpQmdELEtBQWpCLElBQTBCTyxZQUE5QixFQUE0QztBQUMxQ3ZELHNCQUFlZ0QsS0FBZjs7QUFFQSxXQUFJO0FBQ0YxRCxlQUFPWSxjQUFQLENBQXNCc0QsT0FBdEIsQ0FBOEIsWUFBOUIsRUFBNEN4RCxZQUE1QztBQUNELFFBRkQsQ0FFRSxPQUFPSSxDQUFQLEVBQVUsQ0FBRTs7QUFFZCtCLGdCQUFTLE9BQVQ7QUFDRDs7QUFFRCxVQUFJbEMsa0JBQWtCK0MsS0FBbEIsSUFBMkJPLFlBQS9CLEVBQTZDO0FBQzNDO0FBQ0EsV0FBSUUsYUFBYXBFLFNBQVNxRSxhQUExQjtBQUNBLFdBQUlDLGVBQWVGLGNBQWNBLFdBQVdHLFFBQXpCLElBQXFDdEQsV0FBVytDLE9BQVgsQ0FBbUJJLFdBQVdHLFFBQVgsQ0FBb0JDLFdBQXBCLEVBQW5CLE1BQTBELENBQUMsQ0FBbkg7O0FBRUEsV0FBSUYsWUFBSixFQUFrQjtBQUNoQjFELHdCQUFnQitDLEtBQWhCOztBQUVBLFlBQUk7QUFDRjFELGdCQUFPWSxjQUFQLENBQXNCc0QsT0FBdEIsQ0FBOEIsYUFBOUIsRUFBNkN2RCxhQUE3QztBQUNELFNBRkQsQ0FFRSxPQUFPRyxDQUFQLEVBQVUsQ0FBRTs7QUFFZCtCLGlCQUFTLFFBQVQ7QUFDRDtBQUNGO0FBQ0Y7QUFDRixLQTFDRDs7QUE0Q0E7QUFDQSxRQUFJQSxXQUFXLFNBQVNBLFFBQVQsQ0FBa0JZLEtBQWxCLEVBQXlCO0FBQ3RDbEQsYUFBUWlFLFlBQVIsQ0FBcUIsY0FBY2YsS0FBbkMsRUFBMENBLFVBQVUsT0FBVixHQUFvQi9DLFlBQXBCLEdBQW1DQyxhQUE3RTs7QUFFQThELG1CQUFjaEIsS0FBZDtBQUNELEtBSkQ7O0FBTUE7QUFDQSxRQUFJUCxZQUFZLFNBQVNBLFNBQVQsQ0FBbUJLLEtBQW5CLEVBQTBCO0FBQ3hDO0FBQ0FtQixxQkFBZ0JuQixLQUFoQjs7QUFFQTtBQUNBO0FBQ0EsU0FBSSxDQUFDekIsV0FBRCxJQUFnQixDQUFDQyxXQUFyQixFQUFrQztBQUNoQyxVQUFJMkIsUUFBUXRDLFNBQVNtQyxNQUFNSSxJQUFmLENBQVo7QUFDQSxVQUFJRCxVQUFVLFNBQWQsRUFBeUI7QUFDdkJBLGVBQVFFLFlBQVlMLEtBQVosQ0FBUjtBQUNEOztBQUVELFVBQUk1QyxrQkFBa0IrQyxLQUF0QixFQUE2QjtBQUMzQi9DLHVCQUFnQitDLEtBQWhCOztBQUVBLFdBQUk7QUFDRjFELGVBQU9ZLGNBQVAsQ0FBc0JzRCxPQUF0QixDQUE4QixhQUE5QixFQUE2Q3ZELGFBQTdDO0FBQ0QsUUFGRCxDQUVFLE9BQU9HLENBQVAsRUFBVSxDQUFFOztBQUVkK0IsZ0JBQVMsUUFBVDtBQUNEO0FBQ0Y7QUFDRixLQXRCRDs7QUF3QkEsUUFBSVEsYUFBYSxTQUFTQSxVQUFULENBQW9CRSxLQUFwQixFQUEyQjtBQUMxQyxTQUFJLENBQUNBLE1BQU1vQixNQUFOLENBQWFMLFFBQWxCLEVBQTRCO0FBQzFCO0FBQ0E7QUFDQWhCO0FBQ0E7QUFDRDs7QUFFRDdDLHNCQUFpQjhDLE1BQU1vQixNQUFOLENBQWFMLFFBQWIsQ0FBc0JDLFdBQXRCLEVBQWpCO0FBQ0FoRSxhQUFRaUUsWUFBUixDQUFxQixrQkFBckIsRUFBeUMvRCxjQUF6Qzs7QUFFQSxTQUFJOEMsTUFBTW9CLE1BQU4sQ0FBYUMsU0FBYixJQUEwQnJCLE1BQU1vQixNQUFOLENBQWFDLFNBQWIsQ0FBdUJkLE1BQXJELEVBQTZEO0FBQzNEdkQsY0FBUWlFLFlBQVIsQ0FBcUIsa0JBQXJCLEVBQXlDakIsTUFBTW9CLE1BQU4sQ0FBYUMsU0FBYixDQUF1QkMsUUFBdkIsR0FBa0NDLE9BQWxDLENBQTBDLEdBQTFDLEVBQStDLEdBQS9DLENBQXpDO0FBQ0Q7QUFDRixLQWREOztBQWdCQSxRQUFJeEIsZUFBZSxTQUFTQSxZQUFULEdBQXdCO0FBQ3pDN0Msc0JBQWlCLElBQWpCOztBQUVBRixhQUFRd0UsZUFBUixDQUF3QixrQkFBeEI7QUFDQXhFLGFBQVF3RSxlQUFSLENBQXdCLGtCQUF4QjtBQUNELEtBTEQ7O0FBT0E7QUFDQSxRQUFJM0IsY0FBYyxTQUFTQSxXQUFULENBQXFCRyxLQUFyQixFQUE0QjtBQUM1QztBQUNBTixjQUFTTSxLQUFUOztBQUVBO0FBQ0F2RCxZQUFPZ0YsWUFBUCxDQUFvQmpFLFVBQXBCOztBQUVBO0FBQ0FlLG1CQUFjLElBQWQ7O0FBRUE7QUFDQWYsa0JBQWFmLE9BQU9pRixVQUFQLENBQWtCLFlBQVk7QUFDekM7QUFDQW5ELG9CQUFjLEtBQWQ7QUFDRCxNQUhZLEVBR1YsR0FIVSxDQUFiO0FBSUQsS0FmRDs7QUFpQkE7Ozs7QUFJQSxRQUFJOEIsY0FBYyxTQUFTQSxXQUFULENBQXFCTCxLQUFyQixFQUE0QjtBQUM1QyxTQUFJLE9BQU9BLE1BQU1LLFdBQWIsS0FBNkIsUUFBakMsRUFBMkM7QUFDekMsYUFBT3pCLFdBQVdvQixNQUFNSyxXQUFqQixDQUFQO0FBQ0QsTUFGRCxNQUVPO0FBQ0w7QUFDQSxhQUFPTCxNQUFNSyxXQUFOLEtBQXNCLEtBQXRCLEdBQThCLE9BQTlCLEdBQXdDTCxNQUFNSyxXQUFyRDtBQUNEO0FBQ0YsS0FQRDs7QUFTQTtBQUNBO0FBQ0EsUUFBSWpCLGNBQWMsU0FBU0EsV0FBVCxHQUF1QjtBQUN2QyxTQUFJdUMsWUFBWSxLQUFLLENBQXJCOztBQUVBO0FBQ0EsU0FBSSxhQUFhbkYsU0FBU29GLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBakIsRUFBZ0Q7QUFDOUNELGtCQUFZLE9BQVo7QUFDRCxNQUZELE1BRU87QUFDTDtBQUNBO0FBQ0FBLGtCQUFZbkYsU0FBU3FGLFlBQVQsS0FBMEJDLFNBQTFCLEdBQXNDLFlBQXRDLEdBQXFELGdCQUFqRTtBQUNEOztBQUVELFlBQU9ILFNBQVA7QUFDRCxLQWJEOztBQWVBO0FBQ0EsUUFBSVQsZ0JBQWdCLFNBQVNBLGFBQVQsQ0FBdUJkLElBQXZCLEVBQTZCO0FBQy9DLFVBQUssSUFBSTJCLElBQUksQ0FBUixFQUFXQyxNQUFNdEUsYUFBYTZDLE1BQW5DLEVBQTJDd0IsSUFBSUMsR0FBL0MsRUFBb0RELEdBQXBELEVBQXlEO0FBQ3ZELFVBQUlyRSxhQUFhcUUsQ0FBYixFQUFnQjNCLElBQWhCLEtBQXlCQSxJQUE3QixFQUFtQztBQUNqQzFDLG9CQUFhcUUsQ0FBYixFQUFnQkUsRUFBaEIsQ0FBbUI3RixJQUFuQixDQUF3QjBGLFNBQXhCLEVBQW1DMUIsU0FBUyxPQUFULEdBQW1CakQsWUFBbkIsR0FBa0NDLGFBQXJFO0FBQ0Q7QUFDRjtBQUNGLEtBTkQ7O0FBUUE7QUFDQSxRQUFJOEUsU0FBUyxTQUFTQSxNQUFULENBQWdCQyxLQUFoQixFQUF1QjtBQUNsQyxVQUFLLElBQUlKLElBQUksQ0FBUixFQUFXQyxNQUFNdEUsYUFBYTZDLE1BQW5DLEVBQTJDd0IsSUFBSUMsR0FBL0MsRUFBb0RELEdBQXBELEVBQXlEO0FBQ3ZELFVBQUlyRSxhQUFhcUUsQ0FBYixFQUFnQkUsRUFBaEIsS0FBdUJFLEtBQTNCLEVBQWtDO0FBQ2hDLGNBQU9KLENBQVA7QUFDRDtBQUNGO0FBQ0YsS0FORDs7QUFRQSxRQUFJWixrQkFBa0IsU0FBU0EsZUFBVCxDQUF5Qm5CLEtBQXpCLEVBQWdDO0FBQ3BELFNBQUl2QixTQUFTLEdBQVQsTUFBa0J1QixNQUFNb0MsT0FBeEIsSUFBbUMzRCxTQUFTLEdBQVQsTUFBa0J1QixNQUFNcUMsT0FBL0QsRUFBd0U7QUFDdEU3RCxvQkFBYyxLQUFkOztBQUVBQyxlQUFTLEdBQVQsSUFBZ0J1QixNQUFNb0MsT0FBdEI7QUFDQTNELGVBQVMsR0FBVCxJQUFnQnVCLE1BQU1xQyxPQUF0QjtBQUNELE1BTEQsTUFLTztBQUNMN0Qsb0JBQWMsSUFBZDtBQUNEO0FBQ0YsS0FURDs7QUFXQTs7OztBQUlBO0FBQ0E7QUFDQSxRQUFJLHNCQUFzQi9CLE1BQXRCLElBQWdDNkYsTUFBTUMsU0FBTixDQUFnQi9CLE9BQXBELEVBQTZEO0FBQzNEckI7QUFDRDs7QUFFRDs7OztBQUlBLFdBQU87QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBekMsVUFBSyxTQUFTQSxHQUFULENBQWE4RixHQUFiLEVBQWtCO0FBQ3JCLGFBQU9BLFFBQVEsUUFBUixHQUFtQnBGLGFBQW5CLEdBQW1DRCxZQUExQztBQUNELE1BUEk7O0FBU0w7QUFDQVIsY0FBUyxTQUFTQSxPQUFULEdBQW1CO0FBQzFCLGFBQU9PLGNBQVA7QUFDRCxNQVpJOztBQWNMO0FBQ0FOLGlCQUFZLFNBQVNBLFVBQVQsQ0FBb0I2RixHQUFwQixFQUF5QjtBQUNuQzlFLGtCQUFZOEUsR0FBWjtBQUNELE1BakJJOztBQW1CTDtBQUNBNUYsbUJBQWMsU0FBU0EsWUFBVCxDQUFzQjRGLEdBQXRCLEVBQTJCO0FBQ3ZDN0Usb0JBQWM2RSxHQUFkO0FBQ0QsTUF0Qkk7O0FBd0JMO0FBQ0E7QUFDQTtBQUNBM0YsdUJBQWtCLFNBQVNBLGdCQUFULENBQTBCbUYsRUFBMUIsRUFBOEJTLFNBQTlCLEVBQXlDO0FBQ3pEaEYsbUJBQWFpRixJQUFiLENBQWtCO0FBQ2hCVixXQUFJQSxFQURZO0FBRWhCN0IsYUFBTXNDLGFBQWE7QUFGSCxPQUFsQjtBQUlELE1BaENJOztBQWtDTDNGLHlCQUFvQixTQUFTQSxrQkFBVCxDQUE0QmtGLEVBQTVCLEVBQWdDO0FBQ2xELFVBQUlXLFdBQVdWLE9BQU9ELEVBQVAsQ0FBZjs7QUFFQSxVQUFJVyxZQUFZQSxhQUFhLENBQTdCLEVBQWdDO0FBQzlCbEYsb0JBQWFtRixNQUFiLENBQW9CRCxRQUFwQixFQUE4QixDQUE5QjtBQUNEO0FBQ0Y7QUF4Q0ksS0FBUDtBQTBDRCxJQTFaZ0IsRUFBakI7O0FBNFpEO0FBQU8sR0FsYUc7QUFtYVYsVUE3Y2dCO0FBQWhCO0FBOGNDLENBeGREO0FBeWRBLEMiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogd2hhdC1pbnB1dCAtIEEgZ2xvYmFsIHV0aWxpdHkgZm9yIHRyYWNraW5nIHRoZSBjdXJyZW50IGlucHV0IG1ldGhvZCAobW91c2UsIGtleWJvYXJkIG9yIHRvdWNoKS5cbiAqIEB2ZXJzaW9uIHY1LjEuM1xuICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3RlbjFzZXZlbi93aGF0LWlucHV0XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJ3aGF0SW5wdXRcIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wid2hhdElucHV0XCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIndoYXRJbnB1dFwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG5cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG5cblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHQgIC8qXG5cdCAgICogYmFpbCBvdXQgaWYgdGhlcmUgaXMgbm8gZG9jdW1lbnQgb3Igd2luZG93XG5cdCAgICogKGkuZS4gaW4gYSBub2RlL25vbi1ET00gZW52aXJvbm1lbnQpXG5cdCAgICpcblx0ICAgKiBSZXR1cm4gYSBzdHViYmVkIEFQSSBpbnN0ZWFkXG5cdCAgICovXG5cdCAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIC8vIGFsd2F5cyByZXR1cm4gXCJpbml0aWFsXCIgYmVjYXVzZSBubyBpbnRlcmFjdGlvbiB3aWxsIGV2ZXIgYmUgZGV0ZWN0ZWRcblx0ICAgICAgYXNrOiBmdW5jdGlvbiBhc2soKSB7XG5cdCAgICAgICAgcmV0dXJuICdpbml0aWFsJztcblx0ICAgICAgfSxcblxuXHQgICAgICAvLyBhbHdheXMgcmV0dXJuIG51bGxcblx0ICAgICAgZWxlbWVudDogZnVuY3Rpb24gZWxlbWVudCgpIHtcblx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgfSxcblxuXHQgICAgICAvLyBuby1vcFxuXHQgICAgICBpZ25vcmVLZXlzOiBmdW5jdGlvbiBpZ25vcmVLZXlzKCkge30sXG5cblx0ICAgICAgLy8gbm8tb3Bcblx0ICAgICAgc3BlY2lmaWNLZXlzOiBmdW5jdGlvbiBzcGVjaWZpY0tleXMoKSB7fSxcblxuXHQgICAgICAvLyBuby1vcFxuXHQgICAgICByZWdpc3Rlck9uQ2hhbmdlOiBmdW5jdGlvbiByZWdpc3Rlck9uQ2hhbmdlKCkge30sXG5cblx0ICAgICAgLy8gbm8tb3Bcblx0ICAgICAgdW5SZWdpc3Rlck9uQ2hhbmdlOiBmdW5jdGlvbiB1blJlZ2lzdGVyT25DaGFuZ2UoKSB7fVxuXHQgICAgfTtcblx0ICB9XG5cblx0ICAvKlxuXHQgICAqIHZhcmlhYmxlc1xuXHQgICAqL1xuXG5cdCAgLy8gY2FjaGUgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XG5cdCAgdmFyIGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblx0ICAvLyBjdXJyZW50bHkgZm9jdXNlZCBkb20gZWxlbWVudFxuXHQgIHZhciBjdXJyZW50RWxlbWVudCA9IG51bGw7XG5cblx0ICAvLyBsYXN0IHVzZWQgaW5wdXQgdHlwZVxuXHQgIHZhciBjdXJyZW50SW5wdXQgPSAnaW5pdGlhbCc7XG5cblx0ICAvLyBsYXN0IHVzZWQgaW5wdXQgaW50ZW50XG5cdCAgdmFyIGN1cnJlbnRJbnRlbnQgPSBjdXJyZW50SW5wdXQ7XG5cblx0ICAvLyBjaGVjayBmb3Igc2Vzc2lvblN0b3JhZ2Ugc3VwcG9ydFxuXHQgIC8vIHRoZW4gY2hlY2sgZm9yIHNlc3Npb24gdmFyaWFibGVzIGFuZCB1c2UgaWYgYXZhaWxhYmxlXG5cdCAgdHJ5IHtcblx0ICAgIGlmICh3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnd2hhdC1pbnB1dCcpKSB7XG5cdCAgICAgIGN1cnJlbnRJbnB1dCA9IHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCd3aGF0LWlucHV0Jyk7XG5cdCAgICB9XG5cblx0ICAgIGlmICh3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnd2hhdC1pbnRlbnQnKSkge1xuXHQgICAgICBjdXJyZW50SW50ZW50ID0gd2luZG93LnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ3doYXQtaW50ZW50Jyk7XG5cdCAgICB9XG5cdCAgfSBjYXRjaCAoZSkge31cblxuXHQgIC8vIGV2ZW50IGJ1ZmZlciB0aW1lclxuXHQgIHZhciBldmVudFRpbWVyID0gbnVsbDtcblxuXHQgIC8vIGZvcm0gaW5wdXQgdHlwZXNcblx0ICB2YXIgZm9ybUlucHV0cyA9IFsnaW5wdXQnLCAnc2VsZWN0JywgJ3RleHRhcmVhJ107XG5cblx0ICAvLyBlbXB0eSBhcnJheSBmb3IgaG9sZGluZyBjYWxsYmFjayBmdW5jdGlvbnNcblx0ICB2YXIgZnVuY3Rpb25MaXN0ID0gW107XG5cblx0ICAvLyBsaXN0IG9mIG1vZGlmaWVyIGtleXMgY29tbW9ubHkgdXNlZCB3aXRoIHRoZSBtb3VzZSBhbmRcblx0ICAvLyBjYW4gYmUgc2FmZWx5IGlnbm9yZWQgdG8gcHJldmVudCBmYWxzZSBrZXlib2FyZCBkZXRlY3Rpb25cblx0ICB2YXIgaWdub3JlTWFwID0gWzE2LCAvLyBzaGlmdFxuXHQgIDE3LCAvLyBjb250cm9sXG5cdCAgMTgsIC8vIGFsdFxuXHQgIDkxLCAvLyBXaW5kb3dzIGtleSAvIGxlZnQgQXBwbGUgY21kXG5cdCAgOTMgLy8gV2luZG93cyBtZW51IC8gcmlnaHQgQXBwbGUgY21kXG5cdCAgXTtcblxuXHQgIHZhciBzcGVjaWZpY01hcCA9IFtdO1xuXG5cdCAgLy8gbWFwcGluZyBvZiBldmVudHMgdG8gaW5wdXQgdHlwZXNcblx0ICB2YXIgaW5wdXRNYXAgPSB7XG5cdCAgICBrZXlkb3duOiAna2V5Ym9hcmQnLFxuXHQgICAga2V5dXA6ICdrZXlib2FyZCcsXG5cdCAgICBtb3VzZWRvd246ICdtb3VzZScsXG5cdCAgICBtb3VzZW1vdmU6ICdtb3VzZScsXG5cdCAgICBNU1BvaW50ZXJEb3duOiAncG9pbnRlcicsXG5cdCAgICBNU1BvaW50ZXJNb3ZlOiAncG9pbnRlcicsXG5cdCAgICBwb2ludGVyZG93bjogJ3BvaW50ZXInLFxuXHQgICAgcG9pbnRlcm1vdmU6ICdwb2ludGVyJyxcblx0ICAgIHRvdWNoc3RhcnQ6ICd0b3VjaCdcblxuXHQgICAgLy8gYm9vbGVhbjogdHJ1ZSBpZiB0b3VjaCBidWZmZXIgaXMgYWN0aXZlXG5cdCAgfTt2YXIgaXNCdWZmZXJpbmcgPSBmYWxzZTtcblxuXHQgIC8vIGJvb2xlYW46IHRydWUgaWYgdGhlIHBhZ2UgaXMgYmVpbmcgc2Nyb2xsZWRcblx0ICB2YXIgaXNTY3JvbGxpbmcgPSBmYWxzZTtcblxuXHQgIC8vIHN0b3JlIGN1cnJlbnQgbW91c2UgcG9zaXRpb25cblx0ICB2YXIgbW91c2VQb3MgPSB7XG5cdCAgICB4OiBudWxsLFxuXHQgICAgeTogbnVsbFxuXG5cdCAgICAvLyBtYXAgb2YgSUUgMTAgcG9pbnRlciBldmVudHNcblx0ICB9O3ZhciBwb2ludGVyTWFwID0ge1xuXHQgICAgMjogJ3RvdWNoJyxcblx0ICAgIDM6ICd0b3VjaCcsIC8vIHRyZWF0IHBlbiBsaWtlIHRvdWNoXG5cdCAgICA0OiAnbW91c2UnXG5cblx0ICAgIC8vIGNoZWNrIHN1cHBvcnQgZm9yIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzXG5cdCAgfTt2YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5cblx0ICB0cnkge1xuXHQgICAgdmFyIG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuXHQgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRzKTtcblx0ICB9IGNhdGNoIChlKSB7fVxuXG5cdCAgLypcblx0ICAgKiBzZXQgdXBcblx0ICAgKi9cblxuXHQgIHZhciBzZXRVcCA9IGZ1bmN0aW9uIHNldFVwKCkge1xuXHQgICAgLy8gYWRkIGNvcnJlY3QgbW91c2Ugd2hlZWwgZXZlbnQgbWFwcGluZyB0byBgaW5wdXRNYXBgXG5cdCAgICBpbnB1dE1hcFtkZXRlY3RXaGVlbCgpXSA9ICdtb3VzZSc7XG5cblx0ICAgIGFkZExpc3RlbmVycygpO1xuXHQgICAgZG9VcGRhdGUoJ2lucHV0Jyk7XG5cdCAgICBkb1VwZGF0ZSgnaW50ZW50Jyk7XG5cdCAgfTtcblxuXHQgIC8qXG5cdCAgICogZXZlbnRzXG5cdCAgICovXG5cblx0ICB2YXIgYWRkTGlzdGVuZXJzID0gZnVuY3Rpb24gYWRkTGlzdGVuZXJzKCkge1xuXHQgICAgLy8gYHBvaW50ZXJtb3ZlYCwgYE1TUG9pbnRlck1vdmVgLCBgbW91c2Vtb3ZlYCBhbmQgbW91c2Ugd2hlZWwgZXZlbnQgYmluZGluZ1xuXHQgICAgLy8gY2FuIG9ubHkgZGVtb25zdHJhdGUgcG90ZW50aWFsLCBidXQgbm90IGFjdHVhbCwgaW50ZXJhY3Rpb25cblx0ICAgIC8vIGFuZCBhcmUgdHJlYXRlZCBzZXBhcmF0ZWx5XG5cdCAgICB2YXIgb3B0aW9ucyA9IHN1cHBvcnRzUGFzc2l2ZSA/IHsgcGFzc2l2ZTogdHJ1ZSB9IDogZmFsc2U7XG5cblx0ICAgIC8vIHBvaW50ZXIgZXZlbnRzIChtb3VzZSwgcGVuLCB0b3VjaClcblx0ICAgIGlmICh3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG5cdCAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHNldElucHV0KTtcblx0ICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgc2V0SW50ZW50KTtcblx0ICAgIH0gZWxzZSBpZiAod2luZG93Lk1TUG9pbnRlckV2ZW50KSB7XG5cdCAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdNU1BvaW50ZXJEb3duJywgc2V0SW5wdXQpO1xuXHQgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignTVNQb2ludGVyTW92ZScsIHNldEludGVudCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyBtb3VzZSBldmVudHNcblx0ICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHNldElucHV0KTtcblx0ICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHNldEludGVudCk7XG5cblx0ICAgICAgLy8gdG91Y2ggZXZlbnRzXG5cdCAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHtcblx0ICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGV2ZW50QnVmZmVyLCBvcHRpb25zKTtcblx0ICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBzZXRJbnB1dCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgLy8gbW91c2Ugd2hlZWxcblx0ICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGRldGVjdFdoZWVsKCksIHNldEludGVudCwgb3B0aW9ucyk7XG5cblx0ICAgIC8vIGtleWJvYXJkIGV2ZW50c1xuXHQgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBldmVudEJ1ZmZlcik7XG5cdCAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBldmVudEJ1ZmZlcik7XG5cblx0ICAgIC8vIGZvY3VzIGV2ZW50c1xuXHQgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBzZXRFbGVtZW50KTtcblx0ICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIGNsZWFyRWxlbWVudCk7XG5cdCAgfTtcblxuXHQgIC8vIGNoZWNrcyBjb25kaXRpb25zIGJlZm9yZSB1cGRhdGluZyBuZXcgaW5wdXRcblx0ICB2YXIgc2V0SW5wdXQgPSBmdW5jdGlvbiBzZXRJbnB1dChldmVudCkge1xuXHQgICAgLy8gb25seSBleGVjdXRlIGlmIHRoZSBldmVudCBidWZmZXIgdGltZXIgaXNuJ3QgcnVubmluZ1xuXHQgICAgaWYgKCFpc0J1ZmZlcmluZykge1xuXHQgICAgICB2YXIgZXZlbnRLZXkgPSBldmVudC53aGljaDtcblx0ICAgICAgdmFyIHZhbHVlID0gaW5wdXRNYXBbZXZlbnQudHlwZV07XG5cblx0ICAgICAgaWYgKHZhbHVlID09PSAncG9pbnRlcicpIHtcblx0ICAgICAgICB2YWx1ZSA9IHBvaW50ZXJUeXBlKGV2ZW50KTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBpZ25vcmVNYXRjaCA9ICFzcGVjaWZpY01hcC5sZW5ndGggJiYgaWdub3JlTWFwLmluZGV4T2YoZXZlbnRLZXkpID09PSAtMTtcblxuXHQgICAgICB2YXIgc3BlY2lmaWNNYXRjaCA9IHNwZWNpZmljTWFwLmxlbmd0aCAmJiBzcGVjaWZpY01hcC5pbmRleE9mKGV2ZW50S2V5KSAhPT0gLTE7XG5cblx0ICAgICAgdmFyIHNob3VsZFVwZGF0ZSA9IHZhbHVlID09PSAna2V5Ym9hcmQnICYmIGV2ZW50S2V5ICYmIChpZ25vcmVNYXRjaCB8fCBzcGVjaWZpY01hdGNoKSB8fCB2YWx1ZSA9PT0gJ21vdXNlJyB8fCB2YWx1ZSA9PT0gJ3RvdWNoJztcblxuXHQgICAgICBpZiAoY3VycmVudElucHV0ICE9PSB2YWx1ZSAmJiBzaG91bGRVcGRhdGUpIHtcblx0ICAgICAgICBjdXJyZW50SW5wdXQgPSB2YWx1ZTtcblxuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnd2hhdC1pbnB1dCcsIGN1cnJlbnRJbnB1dCk7XG5cdCAgICAgICAgfSBjYXRjaCAoZSkge31cblxuXHQgICAgICAgIGRvVXBkYXRlKCdpbnB1dCcpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGN1cnJlbnRJbnRlbnQgIT09IHZhbHVlICYmIHNob3VsZFVwZGF0ZSkge1xuXHQgICAgICAgIC8vIHByZXNlcnZlIGludGVudCBmb3Iga2V5Ym9hcmQgdHlwaW5nIGluIGZvcm0gZmllbGRzXG5cdCAgICAgICAgdmFyIGFjdGl2ZUVsZW0gPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHQgICAgICAgIHZhciBub3RGb3JtSW5wdXQgPSBhY3RpdmVFbGVtICYmIGFjdGl2ZUVsZW0ubm9kZU5hbWUgJiYgZm9ybUlucHV0cy5pbmRleE9mKGFjdGl2ZUVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkgPT09IC0xO1xuXG5cdCAgICAgICAgaWYgKG5vdEZvcm1JbnB1dCkge1xuXHQgICAgICAgICAgY3VycmVudEludGVudCA9IHZhbHVlO1xuXG5cdCAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnd2hhdC1pbnRlbnQnLCBjdXJyZW50SW50ZW50KTtcblx0ICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cblx0ICAgICAgICAgIGRvVXBkYXRlKCdpbnRlbnQnKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgLy8gdXBkYXRlcyB0aGUgZG9jIGFuZCBgaW5wdXRUeXBlc2AgYXJyYXkgd2l0aCBuZXcgaW5wdXRcblx0ICB2YXIgZG9VcGRhdGUgPSBmdW5jdGlvbiBkb1VwZGF0ZSh3aGljaCkge1xuXHQgICAgZG9jRWxlbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtd2hhdCcgKyB3aGljaCwgd2hpY2ggPT09ICdpbnB1dCcgPyBjdXJyZW50SW5wdXQgOiBjdXJyZW50SW50ZW50KTtcblxuXHQgICAgZmlyZUZ1bmN0aW9ucyh3aGljaCk7XG5cdCAgfTtcblxuXHQgIC8vIHVwZGF0ZXMgaW5wdXQgaW50ZW50IGZvciBgbW91c2Vtb3ZlYCBhbmQgYHBvaW50ZXJtb3ZlYFxuXHQgIHZhciBzZXRJbnRlbnQgPSBmdW5jdGlvbiBzZXRJbnRlbnQoZXZlbnQpIHtcblx0ICAgIC8vIHRlc3QgdG8gc2VlIGlmIGBtb3VzZW1vdmVgIGhhcHBlbmVkIHJlbGF0aXZlIHRvIHRoZSBzY3JlZW4gdG8gZGV0ZWN0IHNjcm9sbGluZyB2ZXJzdXMgbW91c2Vtb3ZlXG5cdCAgICBkZXRlY3RTY3JvbGxpbmcoZXZlbnQpO1xuXG5cdCAgICAvLyBvbmx5IGV4ZWN1dGUgaWYgdGhlIGV2ZW50IGJ1ZmZlciB0aW1lciBpc24ndCBydW5uaW5nXG5cdCAgICAvLyBvciBzY3JvbGxpbmcgaXNuJ3QgaGFwcGVuaW5nXG5cdCAgICBpZiAoIWlzQnVmZmVyaW5nICYmICFpc1Njcm9sbGluZykge1xuXHQgICAgICB2YXIgdmFsdWUgPSBpbnB1dE1hcFtldmVudC50eXBlXTtcblx0ICAgICAgaWYgKHZhbHVlID09PSAncG9pbnRlcicpIHtcblx0ICAgICAgICB2YWx1ZSA9IHBvaW50ZXJUeXBlKGV2ZW50KTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChjdXJyZW50SW50ZW50ICE9PSB2YWx1ZSkge1xuXHQgICAgICAgIGN1cnJlbnRJbnRlbnQgPSB2YWx1ZTtcblxuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnd2hhdC1pbnRlbnQnLCBjdXJyZW50SW50ZW50KTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7fVxuXG5cdCAgICAgICAgZG9VcGRhdGUoJ2ludGVudCcpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHZhciBzZXRFbGVtZW50ID0gZnVuY3Rpb24gc2V0RWxlbWVudChldmVudCkge1xuXHQgICAgaWYgKCFldmVudC50YXJnZXQubm9kZU5hbWUpIHtcblx0ICAgICAgLy8gSWYgbm9kZU5hbWUgaXMgdW5kZWZpbmVkLCBjbGVhciB0aGUgZWxlbWVudFxuXHQgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgY2xpY2sgaW5zaWRlIGFuIDxzdmc+IGVsZW1lbnQuXG5cdCAgICAgIGNsZWFyRWxlbWVudCgpO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIGN1cnJlbnRFbGVtZW50ID0gZXZlbnQudGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdCAgICBkb2NFbGVtLnNldEF0dHJpYnV0ZSgnZGF0YS13aGF0ZWxlbWVudCcsIGN1cnJlbnRFbGVtZW50KTtcblxuXHQgICAgaWYgKGV2ZW50LnRhcmdldC5jbGFzc0xpc3QgJiYgZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5sZW5ndGgpIHtcblx0ICAgICAgZG9jRWxlbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtd2hhdGNsYXNzZXMnLCBldmVudC50YXJnZXQuY2xhc3NMaXN0LnRvU3RyaW5nKCkucmVwbGFjZSgnICcsICcsJykpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICB2YXIgY2xlYXJFbGVtZW50ID0gZnVuY3Rpb24gY2xlYXJFbGVtZW50KCkge1xuXHQgICAgY3VycmVudEVsZW1lbnQgPSBudWxsO1xuXG5cdCAgICBkb2NFbGVtLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS13aGF0ZWxlbWVudCcpO1xuXHQgICAgZG9jRWxlbS5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtd2hhdGNsYXNzZXMnKTtcblx0ICB9O1xuXG5cdCAgLy8gYnVmZmVycyBldmVudHMgdGhhdCBmcmVxdWVudGx5IGFsc28gZmlyZSBtb3VzZSBldmVudHNcblx0ICB2YXIgZXZlbnRCdWZmZXIgPSBmdW5jdGlvbiBldmVudEJ1ZmZlcihldmVudCkge1xuXHQgICAgLy8gc2V0IHRoZSBjdXJyZW50IGlucHV0XG5cdCAgICBzZXRJbnB1dChldmVudCk7XG5cblx0ICAgIC8vIGNsZWFyIHRoZSB0aW1lciBpZiBpdCBoYXBwZW5zIHRvIGJlIHJ1bm5pbmdcblx0ICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoZXZlbnRUaW1lcik7XG5cblx0ICAgIC8vIHNldCB0aGUgaXNCdWZmZXJpbmcgdG8gYHRydWVgXG5cdCAgICBpc0J1ZmZlcmluZyA9IHRydWU7XG5cblx0ICAgIC8vIHJ1biB0aGUgdGltZXJcblx0ICAgIGV2ZW50VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIC8vIGlmIHRoZSB0aW1lciBydW5zIG91dCwgc2V0IGlzQnVmZmVyaW5nIGJhY2sgdG8gYGZhbHNlYFxuXHQgICAgICBpc0J1ZmZlcmluZyA9IGZhbHNlO1xuXHQgICAgfSwgMTAwKTtcblx0ICB9O1xuXG5cdCAgLypcblx0ICAgKiB1dGlsaXRpZXNcblx0ICAgKi9cblxuXHQgIHZhciBwb2ludGVyVHlwZSA9IGZ1bmN0aW9uIHBvaW50ZXJUeXBlKGV2ZW50KSB7XG5cdCAgICBpZiAodHlwZW9mIGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbnVtYmVyJykge1xuXHQgICAgICByZXR1cm4gcG9pbnRlck1hcFtldmVudC5wb2ludGVyVHlwZV07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyB0cmVhdCBwZW4gbGlrZSB0b3VjaFxuXHQgICAgICByZXR1cm4gZXZlbnQucG9pbnRlclR5cGUgPT09ICdwZW4nID8gJ3RvdWNoJyA6IGV2ZW50LnBvaW50ZXJUeXBlO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICAvLyBkZXRlY3QgdmVyc2lvbiBvZiBtb3VzZSB3aGVlbCBldmVudCB0byB1c2Vcblx0ICAvLyB2aWEgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzL3doZWVsXG5cdCAgdmFyIGRldGVjdFdoZWVsID0gZnVuY3Rpb24gZGV0ZWN0V2hlZWwoKSB7XG5cdCAgICB2YXIgd2hlZWxUeXBlID0gdm9pZCAwO1xuXG5cdCAgICAvLyBNb2Rlcm4gYnJvd3NlcnMgc3VwcG9ydCBcIndoZWVsXCJcblx0ICAgIGlmICgnb253aGVlbCcgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpIHtcblx0ICAgICAgd2hlZWxUeXBlID0gJ3doZWVsJztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIFdlYmtpdCBhbmQgSUUgc3VwcG9ydCBhdCBsZWFzdCBcIm1vdXNld2hlZWxcIlxuXHQgICAgICAvLyBvciBhc3N1bWUgdGhhdCByZW1haW5pbmcgYnJvd3NlcnMgYXJlIG9sZGVyIEZpcmVmb3hcblx0ICAgICAgd2hlZWxUeXBlID0gZG9jdW1lbnQub25tb3VzZXdoZWVsICE9PSB1bmRlZmluZWQgPyAnbW91c2V3aGVlbCcgOiAnRE9NTW91c2VTY3JvbGwnO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gd2hlZWxUeXBlO1xuXHQgIH07XG5cblx0ICAvLyBydW5zIGNhbGxiYWNrIGZ1bmN0aW9uc1xuXHQgIHZhciBmaXJlRnVuY3Rpb25zID0gZnVuY3Rpb24gZmlyZUZ1bmN0aW9ucyh0eXBlKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZnVuY3Rpb25MaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIGlmIChmdW5jdGlvbkxpc3RbaV0udHlwZSA9PT0gdHlwZSkge1xuXHQgICAgICAgIGZ1bmN0aW9uTGlzdFtpXS5mbi5jYWxsKHVuZGVmaW5lZCwgdHlwZSA9PT0gJ2lucHV0JyA/IGN1cnJlbnRJbnB1dCA6IGN1cnJlbnRJbnRlbnQpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIC8vIGZpbmRzIG1hdGNoaW5nIGVsZW1lbnQgaW4gYW4gb2JqZWN0XG5cdCAgdmFyIG9ialBvcyA9IGZ1bmN0aW9uIG9ialBvcyhtYXRjaCkge1xuXHQgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZ1bmN0aW9uTGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICBpZiAoZnVuY3Rpb25MaXN0W2ldLmZuID09PSBtYXRjaCkge1xuXHQgICAgICAgIHJldHVybiBpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHZhciBkZXRlY3RTY3JvbGxpbmcgPSBmdW5jdGlvbiBkZXRlY3RTY3JvbGxpbmcoZXZlbnQpIHtcblx0ICAgIGlmIChtb3VzZVBvc1sneCddICE9PSBldmVudC5zY3JlZW5YIHx8IG1vdXNlUG9zWyd5J10gIT09IGV2ZW50LnNjcmVlblkpIHtcblx0ICAgICAgaXNTY3JvbGxpbmcgPSBmYWxzZTtcblxuXHQgICAgICBtb3VzZVBvc1sneCddID0gZXZlbnQuc2NyZWVuWDtcblx0ICAgICAgbW91c2VQb3NbJ3knXSA9IGV2ZW50LnNjcmVlblk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpc1Njcm9sbGluZyA9IHRydWU7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIC8qXG5cdCAgICogaW5pdFxuXHQgICAqL1xuXG5cdCAgLy8gZG9uJ3Qgc3RhcnQgc2NyaXB0IHVubGVzcyBicm93c2VyIGN1dHMgdGhlIG11c3RhcmRcblx0ICAvLyAoYWxzbyBwYXNzZXMgaWYgcG9seWZpbGxzIGFyZSB1c2VkKVxuXHQgIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gd2luZG93ICYmIEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG5cdCAgICBzZXRVcCgpO1xuXHQgIH1cblxuXHQgIC8qXG5cdCAgICogYXBpXG5cdCAgICovXG5cblx0ICByZXR1cm4ge1xuXHQgICAgLy8gcmV0dXJucyBzdHJpbmc6IHRoZSBjdXJyZW50IGlucHV0IHR5cGVcblx0ICAgIC8vIG9wdDogJ2ludGVudCd8J2lucHV0J1xuXHQgICAgLy8gJ2lucHV0JyAoZGVmYXVsdCk6IHJldHVybnMgdGhlIHNhbWUgdmFsdWUgYXMgdGhlIGBkYXRhLXdoYXRpbnB1dGAgYXR0cmlidXRlXG5cdCAgICAvLyAnaW50ZW50JzogaW5jbHVkZXMgYGRhdGEtd2hhdGludGVudGAgdmFsdWUgaWYgaXQncyBkaWZmZXJlbnQgdGhhbiBgZGF0YS13aGF0aW5wdXRgXG5cdCAgICBhc2s6IGZ1bmN0aW9uIGFzayhvcHQpIHtcblx0ICAgICAgcmV0dXJuIG9wdCA9PT0gJ2ludGVudCcgPyBjdXJyZW50SW50ZW50IDogY3VycmVudElucHV0O1xuXHQgICAgfSxcblxuXHQgICAgLy8gcmV0dXJucyBzdHJpbmc6IHRoZSBjdXJyZW50bHkgZm9jdXNlZCBlbGVtZW50IG9yIG51bGxcblx0ICAgIGVsZW1lbnQ6IGZ1bmN0aW9uIGVsZW1lbnQoKSB7XG5cdCAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcblx0ICAgIH0sXG5cblx0ICAgIC8vIG92ZXJ3cml0ZXMgaWdub3JlZCBrZXlzIHdpdGggcHJvdmlkZWQgYXJyYXlcblx0ICAgIGlnbm9yZUtleXM6IGZ1bmN0aW9uIGlnbm9yZUtleXMoYXJyKSB7XG5cdCAgICAgIGlnbm9yZU1hcCA9IGFycjtcblx0ICAgIH0sXG5cblx0ICAgIC8vIG92ZXJ3cml0ZXMgc3BlY2lmaWMgY2hhciBrZXlzIHRvIHVwZGF0ZSBvblxuXHQgICAgc3BlY2lmaWNLZXlzOiBmdW5jdGlvbiBzcGVjaWZpY0tleXMoYXJyKSB7XG5cdCAgICAgIHNwZWNpZmljTWFwID0gYXJyO1xuXHQgICAgfSxcblxuXHQgICAgLy8gYXR0YWNoIGZ1bmN0aW9ucyB0byBpbnB1dCBhbmQgaW50ZW50IFwiZXZlbnRzXCJcblx0ICAgIC8vIGZ1bmN0OiBmdW5jdGlvbiB0byBmaXJlIG9uIGNoYW5nZVxuXHQgICAgLy8gZXZlbnRUeXBlOiAnaW5wdXQnfCdpbnRlbnQnXG5cdCAgICByZWdpc3Rlck9uQ2hhbmdlOiBmdW5jdGlvbiByZWdpc3Rlck9uQ2hhbmdlKGZuLCBldmVudFR5cGUpIHtcblx0ICAgICAgZnVuY3Rpb25MaXN0LnB1c2goe1xuXHQgICAgICAgIGZuOiBmbixcblx0ICAgICAgICB0eXBlOiBldmVudFR5cGUgfHwgJ2lucHV0J1xuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cblx0ICAgIHVuUmVnaXN0ZXJPbkNoYW5nZTogZnVuY3Rpb24gdW5SZWdpc3Rlck9uQ2hhbmdlKGZuKSB7XG5cdCAgICAgIHZhciBwb3NpdGlvbiA9IG9ialBvcyhmbik7XG5cblx0ICAgICAgaWYgKHBvc2l0aW9uIHx8IHBvc2l0aW9uID09PSAwKSB7XG5cdCAgICAgICAgZnVuY3Rpb25MaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHR9KCk7XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKVxufSk7XG47Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n!function (n, e) {\n  if (\"object\" == ( false ? undefined : _typeof(exports)) && \"object\" == ( false ? undefined : _typeof(module))) module.exports = e(__webpack_require__(0));else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (e),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else { var o, t; }\n}(window, function (__WEBPACK_EXTERNAL_MODULE_jquery__) {\n  return function (t) {\n    var o = {};function i(n) {\n      if (o[n]) return o[n].exports;var e = o[n] = { i: n, l: !1, exports: {} };return t[n].call(e.exports, e, e.exports, i), e.l = !0, e.exports;\n    }return i.m = t, i.c = o, i.d = function (n, e, t) {\n      i.o(n, e) || Object.defineProperty(n, e, { enumerable: !0, get: t });\n    }, i.r = function (n) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(n, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(n, \"__esModule\", { value: !0 });\n    }, i.t = function (e, n) {\n      if (1 & n && (e = i(e)), 8 & n) return e;if (4 & n && \"object\" == (typeof e === \"undefined\" ? \"undefined\" : _typeof(e)) && e && e.__esModule) return e;var t = Object.create(null);if (i.r(t), Object.defineProperty(t, \"default\", { enumerable: !0, value: e }), 2 & n && \"string\" != typeof e) for (var o in e) {\n        i.d(t, o, function (n) {\n          return e[n];\n        }.bind(null, o));\n      }return t;\n    }, i.n = function (n) {\n      var e = n && n.__esModule ? function () {\n        return n.default;\n      } : function () {\n        return n;\n      };return i.d(e, \"a\", e), e;\n    }, i.o = function (n, e) {\n      return Object.prototype.hasOwnProperty.call(n, e);\n    }, i.p = \"\", i(i.s = \"../../../../../../tmp/tmp.6.5.1.51374274eded0810baae275f488b770a/js/vendor/foundation.js\");\n  }({ \"../../../../../../tmp/tmp.6.5.1.51374274eded0810baae275f488b770a/js/vendor/foundation.js\": function tmpTmp65151374274eded0810baae275f488b770aJsVendorFoundationJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./js/foundation.core */ \"./js/foundation.core.js\");\\n/* harmony import */ var _home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./js/foundation.util.mediaQuery */ \"./js/foundation.util.mediaQuery.js\");\\n/* harmony import */ var _home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_util_triggers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./js/foundation.util.triggers */ \"./js/foundation.util.triggers.js\");\\n/* harmony import */ var _home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_slider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./js/foundation.slider */ \"./js/foundation.slider.js\");\\n/* harmony import */ var _home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_drilldown__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./js/foundation.drilldown */ \"./js/foundation.drilldown.js\");\\n/* harmony import */ var _home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_accordionMenu__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./js/foundation.accordionMenu */ \"./js/foundation.accordionMenu.js\");\\n/* harmony import */ var _home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_dropdownMenu__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./js/foundation.dropdownMenu */ \"./js/foundation.dropdownMenu.js\");\\n/* harmony import */ var _home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_magellan__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./js/foundation.magellan */ \"./js/foundation.magellan.js\");\\n/* harmony import */ var _home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_responsiveMenu__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./js/foundation.responsiveMenu */ \"./js/foundation.responsiveMenu.js\");\\n/* harmony import */ var _home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_accordion__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./js/foundation.accordion */ \"./js/foundation.accordion.js\");\\n/* harmony import */ var _home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_dropdown__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./js/foundation.dropdown */ \"./js/foundation.dropdown.js\");\\n/* harmony import */ var _home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_offcanvas__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./js/foundation.offcanvas */ \"./js/foundation.offcanvas.js\");\\n/* harmony import */ var _home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_tabs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./js/foundation.tabs */ \"./js/foundation.tabs.js\");\\n/* harmony import */ var _home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_reveal__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./js/foundation.reveal */ \"./js/foundation.reveal.js\");\\n/* harmony import */ var _home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_responsiveAccordionTabs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./js/foundation.responsiveAccordionTabs */ \"./js/foundation.responsiveAccordionTabs.js\");\\n/* harmony import */ var _home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_tooltip__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./js/foundation.tooltip */ \"./js/foundation.tooltip.js\");\\n/* harmony import */ var _home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_orbit__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./js/foundation.orbit */ \"./js/foundation.orbit.js\");\\n/* harmony import */ var _home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_sticky__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./js/foundation.sticky */ \"./js/foundation.sticky.js\");\\n/* harmony import */ var _home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_interchange__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./js/foundation.interchange */ \"./js/foundation.interchange.js\");\\n/* harmony import */ var _home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_responsiveToggle__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./js/foundation.responsiveToggle */ \"./js/foundation.responsiveToggle.js\");\\n/* harmony import */ var _home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_toggler__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./js/foundation.toggler */ \"./js/foundation.toggler.js\");\\n/* harmony import */ var _home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_abide__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./js/foundation.abide */ \"./js/foundation.abide.js\");\\n/* harmony import */ var _home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_equalizer__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./js/foundation.equalizer */ \"./js/foundation.equalizer.js\");\\n/* harmony import */ var _home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_smoothScroll__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./js/foundation.smoothScroll */ \"./js/foundation.smoothScroll.js\");\\n\\n\\n_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].addToJquery(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\\n\\n_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].MediaQuery = _home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_2__[\"MediaQuery\"];\\n\\n_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_util_triggers__WEBPACK_IMPORTED_MODULE_3__[\"Triggers\"].init(jquery__WEBPACK_IMPORTED_MODULE_0___default.a, _home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"]);\\n\\n_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_slider__WEBPACK_IMPORTED_MODULE_4__[\"Slider\"], \\'Slider\\');\\n\\n_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_drilldown__WEBPACK_IMPORTED_MODULE_5__[\"Drilldown\"], \\'Drilldown\\');\\n\\n_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_accordionMenu__WEBPACK_IMPORTED_MODULE_6__[\"AccordionMenu\"], \\'AccordionMenu\\');\\n\\n_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_dropdownMenu__WEBPACK_IMPORTED_MODULE_7__[\"DropdownMenu\"], \\'DropdownMenu\\');\\n\\n_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_magellan__WEBPACK_IMPORTED_MODULE_8__[\"Magellan\"], \\'Magellan\\');\\n\\n_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_responsiveMenu__WEBPACK_IMPORTED_MODULE_9__[\"ResponsiveMenu\"], \\'ResponsiveMenu\\');\\n\\n_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_accordion__WEBPACK_IMPORTED_MODULE_10__[\"Accordion\"], \\'Accordion\\');\\n\\n_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_dropdown__WEBPACK_IMPORTED_MODULE_11__[\"Dropdown\"], \\'Dropdown\\');\\n\\n_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_offcanvas__WEBPACK_IMPORTED_MODULE_12__[\"OffCanvas\"], \\'OffCanvas\\');\\n\\n_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_tabs__WEBPACK_IMPORTED_MODULE_13__[\"Tabs\"], \\'Tabs\\');\\n\\n_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_reveal__WEBPACK_IMPORTED_MODULE_14__[\"Reveal\"], \\'Reveal\\');\\n\\n_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_responsiveAccordionTabs__WEBPACK_IMPORTED_MODULE_15__[\"ResponsiveAccordionTabs\"], \\'ResponsiveAccordionTabs\\');\\n\\n_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_tooltip__WEBPACK_IMPORTED_MODULE_16__[\"Tooltip\"], \\'Tooltip\\');\\n\\n_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_orbit__WEBPACK_IMPORTED_MODULE_17__[\"Orbit\"], \\'Orbit\\');\\n\\n_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_sticky__WEBPACK_IMPORTED_MODULE_18__[\"Sticky\"], \\'Sticky\\');\\n\\n_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_interchange__WEBPACK_IMPORTED_MODULE_19__[\"Interchange\"], \\'Interchange\\');\\n\\n_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_responsiveToggle__WEBPACK_IMPORTED_MODULE_20__[\"ResponsiveToggle\"], \\'ResponsiveToggle\\');\\n\\n_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_toggler__WEBPACK_IMPORTED_MODULE_21__[\"Toggler\"], \\'Toggler\\');\\n\\n_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_abide__WEBPACK_IMPORTED_MODULE_22__[\"Abide\"], \\'Abide\\');\\n\\n_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_equalizer__WEBPACK_IMPORTED_MODULE_23__[\"Equalizer\"], \\'Equalizer\\');\\n\\n_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_home_deployer_sites_node_foundation_customizer_node_foundation_customizer_foundation_sites_js_foundation_smoothScroll__WEBPACK_IMPORTED_MODULE_24__[\"SmoothScroll\"], \\'SmoothScroll\\');\\n\\n//# sourceURL=webpack:////tmp/tmp.6.5.1.51374274eded0810baae275f488b770a/js/vendor/foundation.js?');\n    }, \"./js/foundation.abide.js\": function jsFoundationAbideJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Abide\\\", function() { return Abide; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.plugin */ \\\"./js/foundation.core.plugin.js\\\");\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.core.utils */ \\\"./js/foundation.core.utils.js\\\");\\n\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n\\n\\n\\n/**\\n * Abide module.\\n * @module foundation.abide\\n */\\n\\nvar Abide =\\n/*#__PURE__*/\\nfunction (_Plugin) {\\n  _inherits(Abide, _Plugin);\\n\\n  function Abide() {\\n    _classCallCheck(this, Abide);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(Abide).apply(this, arguments));\\n  }\\n\\n  _createClass(Abide, [{\\n    key: \\\"_setup\\\",\\n\\n    /**\\n     * Creates a new instance of Abide.\\n     * @class\\n     * @name Abide\\n     * @fires Abide#init\\n     * @param {Object} element - jQuery object to add the trigger to.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element) {\\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n      this.$element = element;\\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend(true, {}, Abide.defaults, this.$element.data(), options);\\n      this.className = 'Abide'; // ie9 back compat\\n\\n      this._init();\\n    }\\n    /**\\n     * Initializes the Abide plugin and calls functions to get Abide functioning on load.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_init\\\",\\n    value: function _init() {\\n      var _this2 = this;\\n\\n      this.$inputs = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.merge( // Consider as input to validate:\\n      this.$element.find('input').not('[type=submit]'), // * all input fields expect submit\\n      this.$element.find('textarea, select') // * all textareas and select fields\\n      );\\n      var $globalErrors = this.$element.find('[data-abide-error]'); // Add a11y attributes to all fields\\n\\n      if (this.options.a11yAttributes) {\\n        this.$inputs.each(function (i, input) {\\n          return _this2.addA11yAttributes(jquery__WEBPACK_IMPORTED_MODULE_0___default()(input));\\n        });\\n        $globalErrors.each(function (i, error) {\\n          return _this2.addGlobalErrorA11yAttributes(jquery__WEBPACK_IMPORTED_MODULE_0___default()(error));\\n        });\\n      }\\n\\n      this._events();\\n    }\\n    /**\\n     * Initializes events for Abide.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_events\\\",\\n    value: function _events() {\\n      var _this3 = this;\\n\\n      this.$element.off('.abide').on('reset.zf.abide', function () {\\n        _this3.resetForm();\\n      }).on('submit.zf.abide', function () {\\n        return _this3.validateForm();\\n      });\\n\\n      if (this.options.validateOn === 'fieldChange') {\\n        this.$inputs.off('change.zf.abide').on('change.zf.abide', function (e) {\\n          _this3.validateInput(jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target));\\n        });\\n      }\\n\\n      if (this.options.liveValidate) {\\n        this.$inputs.off('input.zf.abide').on('input.zf.abide', function (e) {\\n          _this3.validateInput(jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target));\\n        });\\n      }\\n\\n      if (this.options.validateOnBlur) {\\n        this.$inputs.off('blur.zf.abide').on('blur.zf.abide', function (e) {\\n          _this3.validateInput(jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target));\\n        });\\n      }\\n    }\\n    /**\\n     * Calls necessary functions to update Abide upon DOM change\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_reflow\\\",\\n    value: function _reflow() {\\n      this._init();\\n    }\\n    /**\\n     * Checks whether or not a form element has the required attribute and if it's checked or not\\n     * @param {Object} element - jQuery object to check for required attribute\\n     * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty\\n     */\\n\\n  }, {\\n    key: \\\"requiredCheck\\\",\\n    value: function requiredCheck($el) {\\n      if (!$el.attr('required')) return true;\\n      var isGood = true;\\n\\n      switch ($el[0].type) {\\n        case 'checkbox':\\n          isGood = $el[0].checked;\\n          break;\\n\\n        case 'select':\\n        case 'select-one':\\n        case 'select-multiple':\\n          var opt = $el.find('option:selected');\\n          if (!opt.length || !opt.val()) isGood = false;\\n          break;\\n\\n        default:\\n          if (!$el.val() || !$el.val().length) isGood = false;\\n      }\\n\\n      return isGood;\\n    }\\n    /**\\n     * Get:\\n     * - Based on $el, the first element(s) corresponding to `formErrorSelector` in this order:\\n     *   1. The element's direct sibling('s).\\n     *   2. The element's parent's children.\\n     * - Element(s) with the attribute `[data-form-error-for]` set with the element's id.\\n     *\\n     * This allows for multiple form errors per input, though if none are found, no form errors will be shown.\\n     *\\n     * @param {Object} $el - jQuery object to use as reference to find the form error selector.\\n     * @returns {Object} jQuery object with the selector.\\n     */\\n\\n  }, {\\n    key: \\\"findFormError\\\",\\n    value: function findFormError($el) {\\n      var id = $el[0].id;\\n      var $error = $el.siblings(this.options.formErrorSelector);\\n\\n      if (!$error.length) {\\n        $error = $el.parent().find(this.options.formErrorSelector);\\n      }\\n\\n      if (id) {\\n        $error = $error.add(this.$element.find(\\\"[data-form-error-for=\\\\\\\"\\\".concat(id, \\\"\\\\\\\"]\\\")));\\n      }\\n\\n      return $error;\\n    }\\n    /**\\n     * Get the first element in this order:\\n     * 2. The <label> with the attribute `[for=\\\"someInputId\\\"]`\\n     * 3. The `.closest()` <label>\\n     *\\n     * @param {Object} $el - jQuery object to check for required attribute\\n     * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty\\n     */\\n\\n  }, {\\n    key: \\\"findLabel\\\",\\n    value: function findLabel($el) {\\n      var id = $el[0].id;\\n      var $label = this.$element.find(\\\"label[for=\\\\\\\"\\\".concat(id, \\\"\\\\\\\"]\\\"));\\n\\n      if (!$label.length) {\\n        return $el.closest('label');\\n      }\\n\\n      return $label;\\n    }\\n    /**\\n     * Get the set of labels associated with a set of radio els in this order\\n     * 2. The <label> with the attribute `[for=\\\"someInputId\\\"]`\\n     * 3. The `.closest()` <label>\\n     *\\n     * @param {Object} $el - jQuery object to check for required attribute\\n     * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty\\n     */\\n\\n  }, {\\n    key: \\\"findRadioLabels\\\",\\n    value: function findRadioLabels($els) {\\n      var _this4 = this;\\n\\n      var labels = $els.map(function (i, el) {\\n        var id = el.id;\\n\\n        var $label = _this4.$element.find(\\\"label[for=\\\\\\\"\\\".concat(id, \\\"\\\\\\\"]\\\"));\\n\\n        if (!$label.length) {\\n          $label = jquery__WEBPACK_IMPORTED_MODULE_0___default()(el).closest('label');\\n        }\\n\\n        return $label[0];\\n      });\\n      return jquery__WEBPACK_IMPORTED_MODULE_0___default()(labels);\\n    }\\n    /**\\n     * Adds the CSS error class as specified by the Abide settings to the label, input, and the form\\n     * @param {Object} $el - jQuery object to add the class to\\n     */\\n\\n  }, {\\n    key: \\\"addErrorClasses\\\",\\n    value: function addErrorClasses($el) {\\n      var $label = this.findLabel($el);\\n      var $formError = this.findFormError($el);\\n\\n      if ($label.length) {\\n        $label.addClass(this.options.labelErrorClass);\\n      }\\n\\n      if ($formError.length) {\\n        $formError.addClass(this.options.formErrorClass);\\n      }\\n\\n      $el.addClass(this.options.inputErrorClass).attr({\\n        'data-invalid': '',\\n        'aria-invalid': true\\n      });\\n    }\\n    /**\\n     * Adds [for] and [role=alert] attributes to all form error targetting $el,\\n     * and [aria-describedby] attribute to $el toward the first form error.\\n     * @param {Object} $el - jQuery object\\n     */\\n\\n  }, {\\n    key: \\\"addA11yAttributes\\\",\\n    value: function addA11yAttributes($el) {\\n      var $errors = this.findFormError($el);\\n      var $labels = $errors.filter('label');\\n      var $error = $errors.first();\\n      if (!$errors.length) return; // Set [aria-describedby] on the input toward the first form error if it is not set\\n\\n      if (typeof $el.attr('aria-describedby') === 'undefined') {\\n        // Get the first error ID or create one\\n        var errorId = $error.attr('id');\\n\\n        if (typeof errorId === 'undefined') {\\n          errorId = Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\\\"GetYoDigits\\\"])(6, 'abide-error');\\n          $error.attr('id', errorId);\\n        }\\n\\n        ;\\n        $el.attr('aria-describedby', errorId);\\n      }\\n\\n      if ($labels.filter('[for]').length < $labels.length) {\\n        // Get the input ID or create one\\n        var elemId = $el.attr('id');\\n\\n        if (typeof elemId === 'undefined') {\\n          elemId = Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\\\"GetYoDigits\\\"])(6, 'abide-input');\\n          $el.attr('id', elemId);\\n        }\\n\\n        ; // For each label targeting $el, set [for] if it is not set.\\n\\n        $labels.each(function (i, label) {\\n          var $label = jquery__WEBPACK_IMPORTED_MODULE_0___default()(label);\\n          if (typeof $label.attr('for') === 'undefined') $label.attr('for', elemId);\\n        });\\n      } // For each error targeting $el, set [role=alert] if it is not set.\\n\\n\\n      $errors.each(function (i, label) {\\n        var $label = jquery__WEBPACK_IMPORTED_MODULE_0___default()(label);\\n        if (typeof $label.attr('role') === 'undefined') $label.attr('role', 'alert');\\n      }).end();\\n    }\\n    /**\\n     * Adds [aria-live] attribute to the given global form error $el.\\n     * @param {Object} $el - jQuery object to add the attribute to\\n     */\\n\\n  }, {\\n    key: \\\"addGlobalErrorA11yAttributes\\\",\\n    value: function addGlobalErrorA11yAttributes($el) {\\n      if (typeof $el.attr('aria-live') === 'undefined') $el.attr('aria-live', this.options.a11yErrorLevel);\\n    }\\n    /**\\n     * Remove CSS error classes etc from an entire radio button group\\n     * @param {String} groupName - A string that specifies the name of a radio button group\\n     *\\n     */\\n\\n  }, {\\n    key: \\\"removeRadioErrorClasses\\\",\\n    value: function removeRadioErrorClasses(groupName) {\\n      var $els = this.$element.find(\\\":radio[name=\\\\\\\"\\\".concat(groupName, \\\"\\\\\\\"]\\\"));\\n      var $labels = this.findRadioLabels($els);\\n      var $formErrors = this.findFormError($els);\\n\\n      if ($labels.length) {\\n        $labels.removeClass(this.options.labelErrorClass);\\n      }\\n\\n      if ($formErrors.length) {\\n        $formErrors.removeClass(this.options.formErrorClass);\\n      }\\n\\n      $els.removeClass(this.options.inputErrorClass).attr({\\n        'data-invalid': null,\\n        'aria-invalid': null\\n      });\\n    }\\n    /**\\n     * Removes CSS error class as specified by the Abide settings from the label, input, and the form\\n     * @param {Object} $el - jQuery object to remove the class from\\n     */\\n\\n  }, {\\n    key: \\\"removeErrorClasses\\\",\\n    value: function removeErrorClasses($el) {\\n      // radios need to clear all of the els\\n      if ($el[0].type == 'radio') {\\n        return this.removeRadioErrorClasses($el.attr('name'));\\n      }\\n\\n      var $label = this.findLabel($el);\\n      var $formError = this.findFormError($el);\\n\\n      if ($label.length) {\\n        $label.removeClass(this.options.labelErrorClass);\\n      }\\n\\n      if ($formError.length) {\\n        $formError.removeClass(this.options.formErrorClass);\\n      }\\n\\n      $el.removeClass(this.options.inputErrorClass).attr({\\n        'data-invalid': null,\\n        'aria-invalid': null\\n      });\\n    }\\n    /**\\n     * Goes through a form to find inputs and proceeds to validate them in ways specific to their type.\\n     * Ignores inputs with data-abide-ignore, type=\\\"hidden\\\" or disabled attributes set\\n     * @fires Abide#invalid\\n     * @fires Abide#valid\\n     * @param {Object} element - jQuery object to validate, should be an HTML input\\n     * @returns {Boolean} goodToGo - If the input is valid or not.\\n     */\\n\\n  }, {\\n    key: \\\"validateInput\\\",\\n    value: function validateInput($el) {\\n      var clearRequire = this.requiredCheck($el),\\n          validated = false,\\n          customValidator = true,\\n          validator = $el.attr('data-validator'),\\n          equalTo = true; // don't validate ignored inputs or hidden inputs or disabled inputs\\n\\n      if ($el.is('[data-abide-ignore]') || $el.is('[type=\\\"hidden\\\"]') || $el.is('[disabled]')) {\\n        return true;\\n      }\\n\\n      switch ($el[0].type) {\\n        case 'radio':\\n          validated = this.validateRadio($el.attr('name'));\\n          break;\\n\\n        case 'checkbox':\\n          validated = clearRequire;\\n          break;\\n\\n        case 'select':\\n        case 'select-one':\\n        case 'select-multiple':\\n          validated = clearRequire;\\n          break;\\n\\n        default:\\n          validated = this.validateText($el);\\n      }\\n\\n      if (validator) {\\n        customValidator = this.matchValidation($el, validator, $el.attr('required'));\\n      }\\n\\n      if ($el.attr('data-equalto')) {\\n        equalTo = this.options.validators.equalTo($el);\\n      }\\n\\n      var goodToGo = [clearRequire, validated, customValidator, equalTo].indexOf(false) === -1;\\n      var message = (goodToGo ? 'valid' : 'invalid') + '.zf.abide';\\n\\n      if (goodToGo) {\\n        // Re-validate inputs that depend on this one with equalto\\n        var dependentElements = this.$element.find(\\\"[data-equalto=\\\\\\\"\\\".concat($el.attr('id'), \\\"\\\\\\\"]\\\"));\\n\\n        if (dependentElements.length) {\\n          var _this = this;\\n\\n          dependentElements.each(function () {\\n            if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).val()) {\\n              _this.validateInput(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this));\\n            }\\n          });\\n        }\\n      }\\n\\n      this[goodToGo ? 'removeErrorClasses' : 'addErrorClasses']($el);\\n      /**\\n       * Fires when the input is done checking for validation. Event trigger is either `valid.zf.abide` or `invalid.zf.abide`\\n       * Trigger includes the DOM element of the input.\\n       * @event Abide#valid\\n       * @event Abide#invalid\\n       */\\n\\n      $el.trigger(message, [$el]);\\n      return goodToGo;\\n    }\\n    /**\\n     * Goes through a form and if there are any invalid inputs, it will display the form error element\\n     * @returns {Boolean} noError - true if no errors were detected...\\n     * @fires Abide#formvalid\\n     * @fires Abide#forminvalid\\n     */\\n\\n  }, {\\n    key: \\\"validateForm\\\",\\n    value: function validateForm() {\\n      var _this5 = this;\\n\\n      var acc = [];\\n\\n      var _this = this;\\n\\n      this.$inputs.each(function () {\\n        acc.push(_this.validateInput(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this)));\\n      });\\n      var noError = acc.indexOf(false) === -1;\\n      this.$element.find('[data-abide-error]').each(function (i, elem) {\\n        var $elem = jquery__WEBPACK_IMPORTED_MODULE_0___default()(elem); // Ensure a11y attributes are set\\n\\n        if (_this5.options.a11yAttributes) _this5.addGlobalErrorA11yAttributes($elem); // Show or hide the error\\n\\n        $elem.css('display', noError ? 'none' : 'block');\\n      });\\n      /**\\n       * Fires when the form is finished validating. Event trigger is either `formvalid.zf.abide` or `forminvalid.zf.abide`.\\n       * Trigger includes the element of the form.\\n       * @event Abide#formvalid\\n       * @event Abide#forminvalid\\n       */\\n\\n      this.$element.trigger((noError ? 'formvalid' : 'forminvalid') + '.zf.abide', [this.$element]);\\n      return noError;\\n    }\\n    /**\\n     * Determines whether or a not a text input is valid based on the pattern specified in the attribute. If no matching pattern is found, returns true.\\n     * @param {Object} $el - jQuery object to validate, should be a text input HTML element\\n     * @param {String} pattern - string value of one of the RegEx patterns in Abide.options.patterns\\n     * @returns {Boolean} Boolean value depends on whether or not the input value matches the pattern specified\\n     */\\n\\n  }, {\\n    key: \\\"validateText\\\",\\n    value: function validateText($el, pattern) {\\n      // A pattern can be passed to this function, or it will be infered from the input's \\\"pattern\\\" attribute, or it's \\\"type\\\" attribute\\n      pattern = pattern || $el.attr('pattern') || $el.attr('type');\\n      var inputText = $el.val();\\n      var valid = false;\\n\\n      if (inputText.length) {\\n        // If the pattern attribute on the element is in Abide's list of patterns, then test that regexp\\n        if (this.options.patterns.hasOwnProperty(pattern)) {\\n          valid = this.options.patterns[pattern].test(inputText);\\n        } // If the pattern name isn't also the type attribute of the field, then test it as a regexp\\n        else if (pattern !== $el.attr('type')) {\\n            valid = new RegExp(pattern).test(inputText);\\n          } else {\\n            valid = true;\\n          }\\n      } // An empty field is valid if it's not required\\n      else if (!$el.prop('required')) {\\n          valid = true;\\n        }\\n\\n      return valid;\\n    }\\n    /**\\n     * Determines whether or a not a radio input is valid based on whether or not it is required and selected. Although the function targets a single `<input>`, it validates by checking the `required` and `checked` properties of all radio buttons in its group.\\n     * @param {String} groupName - A string that specifies the name of a radio button group\\n     * @returns {Boolean} Boolean value depends on whether or not at least one radio input has been selected (if it's required)\\n     */\\n\\n  }, {\\n    key: \\\"validateRadio\\\",\\n    value: function validateRadio(groupName) {\\n      // If at least one radio in the group has the `required` attribute, the group is considered required\\n      // Per W3C spec, all radio buttons in a group should have `required`, but we're being nice\\n      var $group = this.$element.find(\\\":radio[name=\\\\\\\"\\\".concat(groupName, \\\"\\\\\\\"]\\\"));\\n      var valid = false,\\n          required = false; // For the group to be required, at least one radio needs to be required\\n\\n      $group.each(function (i, e) {\\n        if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(e).attr('required')) {\\n          required = true;\\n        }\\n      });\\n      if (!required) valid = true;\\n\\n      if (!valid) {\\n        // For the group to be valid, at least one radio needs to be checked\\n        $group.each(function (i, e) {\\n          if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(e).prop('checked')) {\\n            valid = true;\\n          }\\n        });\\n      }\\n\\n      ;\\n      return valid;\\n    }\\n    /**\\n     * Determines if a selected input passes a custom validation function. Multiple validations can be used, if passed to the element with `data-validator=\\\"foo bar baz\\\"` in a space separated listed.\\n     * @param {Object} $el - jQuery input element.\\n     * @param {String} validators - a string of function names matching functions in the Abide.options.validators object.\\n     * @param {Boolean} required - self explanatory?\\n     * @returns {Boolean} - true if validations passed.\\n     */\\n\\n  }, {\\n    key: \\\"matchValidation\\\",\\n    value: function matchValidation($el, validators, required) {\\n      var _this6 = this;\\n\\n      required = required ? true : false;\\n      var clear = validators.split(' ').map(function (v) {\\n        return _this6.options.validators[v]($el, required, $el.parent());\\n      });\\n      return clear.indexOf(false) === -1;\\n    }\\n    /**\\n     * Resets form inputs and styles\\n     * @fires Abide#formreset\\n     */\\n\\n  }, {\\n    key: \\\"resetForm\\\",\\n    value: function resetForm() {\\n      var $form = this.$element,\\n          opts = this.options;\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(\\\".\\\".concat(opts.labelErrorClass), $form).not('small').removeClass(opts.labelErrorClass);\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(\\\".\\\".concat(opts.inputErrorClass), $form).not('small').removeClass(opts.inputErrorClass);\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(\\\"\\\".concat(opts.formErrorSelector, \\\".\\\").concat(opts.formErrorClass)).removeClass(opts.formErrorClass);\\n      $form.find('[data-abide-error]').css('display', 'none');\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(':input', $form).not(':button, :submit, :reset, :hidden, :radio, :checkbox, [data-abide-ignore]').val('').attr({\\n        'data-invalid': null,\\n        'aria-invalid': null\\n      });\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(':input:radio', $form).not('[data-abide-ignore]').prop('checked', false).attr({\\n        'data-invalid': null,\\n        'aria-invalid': null\\n      });\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(':input:checkbox', $form).not('[data-abide-ignore]').prop('checked', false).attr({\\n        'data-invalid': null,\\n        'aria-invalid': null\\n      });\\n      /**\\n       * Fires when the form has been reset.\\n       * @event Abide#formreset\\n       */\\n\\n      $form.trigger('formreset.zf.abide', [$form]);\\n    }\\n    /**\\n     * Destroys an instance of Abide.\\n     * Removes error styles and classes from elements, without resetting their values.\\n     */\\n\\n  }, {\\n    key: \\\"_destroy\\\",\\n    value: function _destroy() {\\n      var _this = this;\\n\\n      this.$element.off('.abide').find('[data-abide-error]').css('display', 'none');\\n      this.$inputs.off('.abide').each(function () {\\n        _this.removeErrorClasses(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this));\\n      });\\n    }\\n  }]);\\n\\n  return Abide;\\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_1__[\\\"Plugin\\\"]);\\n/**\\n * Default settings for plugin\\n */\\n\\n\\nAbide.defaults = {\\n  /**\\n   * The default event to validate inputs. Checkboxes and radios validate immediately.\\n   * Remove or change this value for manual validation.\\n   * @option\\n   * @type {?string}\\n   * @default 'fieldChange'\\n   */\\n  validateOn: 'fieldChange',\\n\\n  /**\\n   * Class to be applied to input labels on failed validation.\\n   * @option\\n   * @type {string}\\n   * @default 'is-invalid-label'\\n   */\\n  labelErrorClass: 'is-invalid-label',\\n\\n  /**\\n   * Class to be applied to inputs on failed validation.\\n   * @option\\n   * @type {string}\\n   * @default 'is-invalid-input'\\n   */\\n  inputErrorClass: 'is-invalid-input',\\n\\n  /**\\n   * Class selector to use to target Form Errors for show/hide.\\n   * @option\\n   * @type {string}\\n   * @default '.form-error'\\n   */\\n  formErrorSelector: '.form-error',\\n\\n  /**\\n   * Class added to Form Errors on failed validation.\\n   * @option\\n   * @type {string}\\n   * @default 'is-visible'\\n   */\\n  formErrorClass: 'is-visible',\\n\\n  /**\\n   * If true, automatically insert when possible:\\n   * - `[aria-describedby]` on fields\\n   * - `[role=alert]` on form errors and `[for]` on form error labels\\n   * - `[aria-live]` on global errors `[data-abide-error]` (see option `a11yErrorLevel`).\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  a11yAttributes: true,\\n\\n  /**\\n   * [aria-live] attribute value to be applied on global errors `[data-abide-error]`.\\n   * Options are: 'assertive', 'polite' and 'off'/null\\n   * @option\\n   * @see https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions\\n   * @type {string}\\n   * @default 'assertive'\\n   */\\n  a11yErrorLevel: 'assertive',\\n\\n  /**\\n   * Set to true to validate text inputs on any value change.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  liveValidate: false,\\n\\n  /**\\n   * Set to true to validate inputs on blur.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  validateOnBlur: false,\\n  patterns: {\\n    alpha: /^[a-zA-Z]+$/,\\n    alpha_numeric: /^[a-zA-Z0-9]+$/,\\n    integer: /^[-+]?\\\\d+$/,\\n    number: /^[-+]?\\\\d*(?:[\\\\.\\\\,]\\\\d+)?$/,\\n    // amex, visa, diners\\n    card: /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(?:222[1-9]|2[3-6][0-9]{2}|27[0-1][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\\\d{3})\\\\d{11})$/,\\n    cvv: /^([0-9]){3,4}$/,\\n    // http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#valid-e-mail-address\\n    email: /^[a-zA-Z0-9.!#$%&'*+\\\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/,\\n    // From CommonRegexJS (@talyssonoc)\\n    // https://github.com/talyssonoc/CommonRegexJS/blob/e2901b9f57222bc14069dc8f0598d5f412555411/lib/commonregex.js#L76\\n    // For more restrictive URL Regexs, see https://mathiasbynens.be/demo/url-regex.\\n    url: /^((?:(https?|ftps?|file|ssh|sftp):\\\\/\\\\/|www\\\\d{0,3}[.]|[a-z0-9.\\\\-]+[.][a-z]{2,4}\\\\/)(?:[^\\\\s()<>]+|\\\\((?:[^\\\\s()<>]+|(?:\\\\([^\\\\s()<>]+\\\\)))*\\\\))+(?:\\\\((?:[^\\\\s()<>]+|(?:\\\\([^\\\\s()<>]+\\\\)))*\\\\)|[^\\\\s`!()\\\\[\\\\]{};:\\\\'\\\".,<>?\\\\xab\\\\xbb\\\\u201c\\\\u201d\\\\u2018\\\\u2019]))$/,\\n    // abc.de\\n    domain: /^([a-zA-Z0-9]([a-zA-Z0-9\\\\-]{0,61}[a-zA-Z0-9])?\\\\.)+[a-zA-Z]{2,8}$/,\\n    datetime: /^([0-2][0-9]{3})\\\\-([0-1][0-9])\\\\-([0-3][0-9])T([0-5][0-9])\\\\:([0-5][0-9])\\\\:([0-5][0-9])(Z|([\\\\-\\\\+]([0-1][0-9])\\\\:00))$/,\\n    // YYYY-MM-DD\\n    date: /(?:19|20)[0-9]{2}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-9])|(?:(?!02)(?:0[1-9]|1[0-2])-(?:30))|(?:(?:0[13578]|1[02])-31))$/,\\n    // HH:MM:SS\\n    time: /^(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$/,\\n    dateISO: /^\\\\d{4}[\\\\/\\\\-]\\\\d{1,2}[\\\\/\\\\-]\\\\d{1,2}$/,\\n    // MM/DD/YYYY\\n    month_day_year: /^(0[1-9]|1[012])[- \\\\/.](0[1-9]|[12][0-9]|3[01])[- \\\\/.]\\\\d{4}$/,\\n    // DD/MM/YYYY\\n    day_month_year: /^(0[1-9]|[12][0-9]|3[01])[- \\\\/.](0[1-9]|1[012])[- \\\\/.]\\\\d{4}$/,\\n    // #FFF or #FFFFFF\\n    color: /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/,\\n    // Domain || URL\\n    website: {\\n      test: function test(text) {\\n        return Abide.defaults.patterns['domain'].test(text) || Abide.defaults.patterns['url'].test(text);\\n      }\\n    }\\n  },\\n\\n  /**\\n   * Optional validation functions to be used. `equalTo` being the only default included function.\\n   * Functions should return only a boolean if the input is valid or not. Functions are given the following arguments:\\n   * el : The jQuery element to validate.\\n   * required : Boolean value of the required attribute be present or not.\\n   * parent : The direct parent of the input.\\n   * @option\\n   */\\n  validators: {\\n    equalTo: function equalTo(el, required, parent) {\\n      return jquery__WEBPACK_IMPORTED_MODULE_0___default()(\\\"#\\\".concat(el.attr('data-equalto'))).val() === el.val();\\n    }\\n  }\\n};\\n\\n\\n//# sourceURL=webpack:///./js/foundation.abide.js?\");\n    }, \"./js/foundation.accordion.js\": function jsFoundationAccordionJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Accordion\\\", function() { return Accordion; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.utils */ \\\"./js/foundation.core.utils.js\\\");\\n/* harmony import */ var _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.util.keyboard */ \\\"./js/foundation.util.keyboard.js\\\");\\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.core.plugin */ \\\"./js/foundation.core.plugin.js\\\");\\n\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n\\n\\n\\n\\n/**\\n * Accordion module.\\n * @module foundation.accordion\\n * @requires foundation.util.keyboard\\n */\\n\\nvar Accordion =\\n/*#__PURE__*/\\nfunction (_Plugin) {\\n  _inherits(Accordion, _Plugin);\\n\\n  function Accordion() {\\n    _classCallCheck(this, Accordion);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(Accordion).apply(this, arguments));\\n  }\\n\\n  _createClass(Accordion, [{\\n    key: \\\"_setup\\\",\\n\\n    /**\\n     * Creates a new instance of an accordion.\\n     * @class\\n     * @name Accordion\\n     * @fires Accordion#init\\n     * @param {jQuery} element - jQuery object to make into an accordion.\\n     * @param {Object} options - a plain object with settings to override the default options.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, Accordion.defaults, this.$element.data(), options);\\n      this.className = 'Accordion'; // ie9 back compat\\n\\n      this._init();\\n\\n      _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_2__[\\\"Keyboard\\\"].register('Accordion', {\\n        'ENTER': 'toggle',\\n        'SPACE': 'toggle',\\n        'ARROW_DOWN': 'next',\\n        'ARROW_UP': 'previous'\\n      });\\n    }\\n    /**\\n     * Initializes the accordion by animating the preset active pane(s).\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_init\\\",\\n    value: function _init() {\\n      var _this2 = this;\\n\\n      this._isInitializing = true;\\n      this.$element.attr('role', 'tablist');\\n      this.$tabs = this.$element.children('[data-accordion-item]');\\n      this.$tabs.each(function (idx, el) {\\n        var $el = jquery__WEBPACK_IMPORTED_MODULE_0___default()(el),\\n            $content = $el.children('[data-tab-content]'),\\n            id = $content[0].id || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\\\"GetYoDigits\\\"])(6, 'accordion'),\\n            linkId = el.id ? \\\"\\\".concat(el.id, \\\"-label\\\") : \\\"\\\".concat(id, \\\"-label\\\");\\n        $el.find('a:first').attr({\\n          'aria-controls': id,\\n          'role': 'tab',\\n          'id': linkId,\\n          'aria-expanded': false,\\n          'aria-selected': false\\n        });\\n        $content.attr({\\n          'role': 'tabpanel',\\n          'aria-labelledby': linkId,\\n          'aria-hidden': true,\\n          'id': id\\n        });\\n      });\\n      var $initActive = this.$element.find('.is-active').children('[data-tab-content]');\\n\\n      if ($initActive.length) {\\n        // Save up the initial hash to return to it later when going back in history\\n        this._initialAnchor = $initActive.prev('a').attr('href');\\n\\n        this._openSingleTab($initActive);\\n      }\\n\\n      this._checkDeepLink = function () {\\n        var anchor = window.location.hash;\\n\\n        if (!anchor.length) {\\n          // If we are still initializing and there is no anchor, then there is nothing to do\\n          if (_this2._isInitializing) return; // Otherwise, move to the initial anchor\\n\\n          if (_this2._initialAnchor) anchor = _this2._initialAnchor;\\n        }\\n\\n        var $anchor = anchor && jquery__WEBPACK_IMPORTED_MODULE_0___default()(anchor);\\n\\n        var $link = anchor && _this2.$element.find(\\\"[href$=\\\\\\\"\\\".concat(anchor, \\\"\\\\\\\"]\\\")); // Whether the anchor element that has been found is part of this element\\n\\n\\n        var isOwnAnchor = !!($anchor.length && $link.length); // If there is an anchor for the hash, open it (if not already active)\\n\\n        if ($anchor && $link && $link.length) {\\n          if (!$link.parent('[data-accordion-item]').hasClass('is-active')) {\\n            _this2._openSingleTab($anchor);\\n          }\\n\\n          ;\\n        } // Otherwise, close everything\\n        else {\\n            _this2._closeAllTabs();\\n          }\\n\\n        if (isOwnAnchor) {\\n          // Roll up a little to show the titles\\n          if (_this2.options.deepLinkSmudge) {\\n            Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\\\"onLoad\\\"])(jquery__WEBPACK_IMPORTED_MODULE_0___default()(window), function () {\\n              var offset = _this2.$element.offset();\\n\\n              jquery__WEBPACK_IMPORTED_MODULE_0___default()('html, body').animate({\\n                scrollTop: offset.top\\n              }, _this2.options.deepLinkSmudgeDelay);\\n            });\\n          }\\n          /**\\n           * Fires when the plugin has deeplinked at pageload\\n           * @event Accordion#deeplink\\n           */\\n\\n\\n          _this2.$element.trigger('deeplink.zf.accordion', [$link, $anchor]);\\n        }\\n      }; //use browser to open a tab, if it exists in this tabset\\n\\n\\n      if (this.options.deepLink) {\\n        this._checkDeepLink();\\n      }\\n\\n      this._events();\\n\\n      this._isInitializing = false;\\n    }\\n    /**\\n     * Adds event handlers for items within the accordion.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_events\\\",\\n    value: function _events() {\\n      var _this = this;\\n\\n      this.$tabs.each(function () {\\n        var $elem = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);\\n        var $tabContent = $elem.children('[data-tab-content]');\\n\\n        if ($tabContent.length) {\\n          $elem.children('a').off('click.zf.accordion keydown.zf.accordion').on('click.zf.accordion', function (e) {\\n            e.preventDefault();\\n\\n            _this.toggle($tabContent);\\n          }).on('keydown.zf.accordion', function (e) {\\n            _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_2__[\\\"Keyboard\\\"].handleKey(e, 'Accordion', {\\n              toggle: function toggle() {\\n                _this.toggle($tabContent);\\n              },\\n              next: function next() {\\n                var $a = $elem.next().find('a').focus();\\n\\n                if (!_this.options.multiExpand) {\\n                  $a.trigger('click.zf.accordion');\\n                }\\n              },\\n              previous: function previous() {\\n                var $a = $elem.prev().find('a').focus();\\n\\n                if (!_this.options.multiExpand) {\\n                  $a.trigger('click.zf.accordion');\\n                }\\n              },\\n              handled: function handled() {\\n                e.preventDefault();\\n                e.stopPropagation();\\n              }\\n            });\\n          });\\n        }\\n      });\\n\\n      if (this.options.deepLink) {\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on('hashchange', this._checkDeepLink);\\n      }\\n    }\\n    /**\\n     * Toggles the selected content pane's open/close state.\\n     * @param {jQuery} $target - jQuery object of the pane to toggle (`.accordion-content`).\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"toggle\\\",\\n    value: function toggle($target) {\\n      if ($target.closest('[data-accordion]').is('[disabled]')) {\\n        console.info('Cannot toggle an accordion that is disabled.');\\n        return;\\n      }\\n\\n      if ($target.parent().hasClass('is-active')) {\\n        this.up($target);\\n      } else {\\n        this.down($target);\\n      } //either replace or update browser history\\n\\n\\n      if (this.options.deepLink) {\\n        var anchor = $target.prev('a').attr('href');\\n\\n        if (this.options.updateHistory) {\\n          history.pushState({}, '', anchor);\\n        } else {\\n          history.replaceState({}, '', anchor);\\n        }\\n      }\\n    }\\n    /**\\n     * Opens the accordion tab defined by `$target`.\\n     * @param {jQuery} $target - Accordion pane to open (`.accordion-content`).\\n     * @fires Accordion#down\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"down\\\",\\n    value: function down($target) {\\n      if ($target.closest('[data-accordion]').is('[disabled]')) {\\n        console.info('Cannot call down on an accordion that is disabled.');\\n        return;\\n      }\\n\\n      if (this.options.multiExpand) this._openTab($target);else this._openSingleTab($target);\\n    }\\n    /**\\n     * Closes the tab defined by `$target`.\\n     * It may be ignored if the Accordion options don't allow it.\\n     *\\n     * @param {jQuery} $target - Accordion tab to close (`.accordion-content`).\\n     * @fires Accordion#up\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"up\\\",\\n    value: function up($target) {\\n      if (this.$element.is('[disabled]')) {\\n        console.info('Cannot call up on an accordion that is disabled.');\\n        return;\\n      } // Don't close the item if it is already closed\\n\\n\\n      var $targetItem = $target.parent();\\n      if (!$targetItem.hasClass('is-active')) return; // Don't close the item if there is no other active item (unless with `allowAllClosed`)\\n\\n      var $othersItems = $targetItem.siblings();\\n      if (!this.options.allowAllClosed && !$othersItems.hasClass('is-active')) return;\\n\\n      this._closeTab($target);\\n    }\\n    /**\\n     * Make the tab defined by `$target` the only opened tab, closing all others tabs.\\n     * @param {jQuery} $target - Accordion tab to open (`.accordion-content`).\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_openSingleTab\\\",\\n    value: function _openSingleTab($target) {\\n      // Close all the others active tabs.\\n      var $activeContents = this.$element.children('.is-active').children('[data-tab-content]');\\n\\n      if ($activeContents.length) {\\n        this._closeTab($activeContents.not($target));\\n      } // Then open the target.\\n\\n\\n      this._openTab($target);\\n    }\\n    /**\\n     * Opens the tab defined by `$target`.\\n     * @param {jQuery} $target - Accordion tab to open (`.accordion-content`).\\n     * @fires Accordion#down\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_openTab\\\",\\n    value: function _openTab($target) {\\n      var _this3 = this;\\n\\n      var $targetItem = $target.parent();\\n      var targetContentId = $target.attr('aria-labelledby');\\n      $target.attr('aria-hidden', false);\\n      $targetItem.addClass('is-active');\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(\\\"#\\\".concat(targetContentId)).attr({\\n        'aria-expanded': true,\\n        'aria-selected': true\\n      });\\n      $target.slideDown(this.options.slideSpeed, function () {\\n        /**\\n         * Fires when the tab is done opening.\\n         * @event Accordion#down\\n         */\\n        _this3.$element.trigger('down.zf.accordion', [$target]);\\n      });\\n    }\\n    /**\\n     * Closes the tab defined by `$target`.\\n     * @param {jQuery} $target - Accordion tab to close (`.accordion-content`).\\n     * @fires Accordion#up\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_closeTab\\\",\\n    value: function _closeTab($target) {\\n      var _this4 = this;\\n\\n      var $targetItem = $target.parent();\\n      var targetContentId = $target.attr('aria-labelledby');\\n      $target.attr('aria-hidden', true);\\n      $targetItem.removeClass('is-active');\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(\\\"#\\\".concat(targetContentId)).attr({\\n        'aria-expanded': false,\\n        'aria-selected': false\\n      });\\n      $target.slideUp(this.options.slideSpeed, function () {\\n        /**\\n         * Fires when the tab is done collapsing up.\\n         * @event Accordion#up\\n         */\\n        _this4.$element.trigger('up.zf.accordion', [$target]);\\n      });\\n    }\\n    /**\\n     * Closes all active tabs\\n     * @fires Accordion#up\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_closeAllTabs\\\",\\n    value: function _closeAllTabs() {\\n      var $activeTabs = this.$element.children('.is-active').children('[data-tab-content]');\\n\\n      if ($activeTabs.length) {\\n        this._closeTab($activeTabs);\\n      }\\n    }\\n    /**\\n     * Destroys an instance of an accordion.\\n     * @fires Accordion#destroyed\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"_destroy\\\",\\n    value: function _destroy() {\\n      this.$element.find('[data-tab-content]').stop(true).slideUp(0).css('display', '');\\n      this.$element.find('a').off('.zf.accordion');\\n\\n      if (this.options.deepLink) {\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off('hashchange', this._checkDeepLink);\\n      }\\n    }\\n  }]);\\n\\n  return Accordion;\\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_3__[\\\"Plugin\\\"]);\\n\\nAccordion.defaults = {\\n  /**\\n   * Amount of time to animate the opening of an accordion pane.\\n   * @option\\n   * @type {number}\\n   * @default 250\\n   */\\n  slideSpeed: 250,\\n\\n  /**\\n   * Allow the accordion to have multiple open panes.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  multiExpand: false,\\n\\n  /**\\n   * Allow the accordion to close all panes.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  allowAllClosed: false,\\n\\n  /**\\n   * Link the location hash to the open pane.\\n   * Set the location hash when the opened pane changes, and open and scroll to the corresponding pane when the location changes.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  deepLink: false,\\n\\n  /**\\n   * If `deepLink` is enabled, adjust the deep link scroll to make sure the top of the accordion panel is visible\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  deepLinkSmudge: false,\\n\\n  /**\\n   * If `deepLinkSmudge` is enabled, animation time (ms) for the deep link adjustment\\n   * @option\\n   * @type {number}\\n   * @default 300\\n   */\\n  deepLinkSmudgeDelay: 300,\\n\\n  /**\\n   * If `deepLink` is enabled, update the browser history with the open accordion\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  updateHistory: false\\n};\\n\\n\\n//# sourceURL=webpack:///./js/foundation.accordion.js?\");\n    }, \"./js/foundation.accordionMenu.js\": function jsFoundationAccordionMenuJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"AccordionMenu\\\", function() { return AccordionMenu; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.util.keyboard */ \\\"./js/foundation.util.keyboard.js\\\");\\n/* harmony import */ var _foundation_util_nest__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.util.nest */ \\\"./js/foundation.util.nest.js\\\");\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.core.utils */ \\\"./js/foundation.core.utils.js\\\");\\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.core.plugin */ \\\"./js/foundation.core.plugin.js\\\");\\n\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n\\n\\n\\n\\n\\n/**\\n * AccordionMenu module.\\n * @module foundation.accordionMenu\\n * @requires foundation.util.keyboard\\n * @requires foundation.util.nest\\n */\\n\\nvar AccordionMenu =\\n/*#__PURE__*/\\nfunction (_Plugin) {\\n  _inherits(AccordionMenu, _Plugin);\\n\\n  function AccordionMenu() {\\n    _classCallCheck(this, AccordionMenu);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(AccordionMenu).apply(this, arguments));\\n  }\\n\\n  _createClass(AccordionMenu, [{\\n    key: \\\"_setup\\\",\\n\\n    /**\\n     * Creates a new instance of an accordion menu.\\n     * @class\\n     * @name AccordionMenu\\n     * @fires AccordionMenu#init\\n     * @param {jQuery} element - jQuery object to make into an accordion menu.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, AccordionMenu.defaults, this.$element.data(), options);\\n      this.className = 'AccordionMenu'; // ie9 back compat\\n\\n      this._init();\\n\\n      _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\\\"Keyboard\\\"].register('AccordionMenu', {\\n        'ENTER': 'toggle',\\n        'SPACE': 'toggle',\\n        'ARROW_RIGHT': 'open',\\n        'ARROW_UP': 'up',\\n        'ARROW_DOWN': 'down',\\n        'ARROW_LEFT': 'close',\\n        'ESCAPE': 'closeAll'\\n      });\\n    }\\n    /**\\n     * Initializes the accordion menu by hiding all nested menus.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_init\\\",\\n    value: function _init() {\\n      _foundation_util_nest__WEBPACK_IMPORTED_MODULE_2__[\\\"Nest\\\"].Feather(this.$element, 'accordion');\\n\\n      var _this = this;\\n\\n      this.$element.find('[data-submenu]').not('.is-active').slideUp(0); //.find('a').css('padding-left', '1rem');\\n\\n      this.$element.attr({\\n        'role': 'tree',\\n        'aria-multiselectable': this.options.multiOpen\\n      });\\n      this.$menuLinks = this.$element.find('.is-accordion-submenu-parent');\\n      this.$menuLinks.each(function () {\\n        var linkId = this.id || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\\\"GetYoDigits\\\"])(6, 'acc-menu-link'),\\n            $elem = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\\n            $sub = $elem.children('[data-submenu]'),\\n            subId = $sub[0].id || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\\\"GetYoDigits\\\"])(6, 'acc-menu'),\\n            isActive = $sub.hasClass('is-active');\\n\\n        if (_this.options.parentLink) {\\n          var $anchor = $elem.children('a');\\n          $anchor.clone().prependTo($sub).wrap('<li data-is-parent-link class=\\\"is-submenu-parent-item is-submenu-item is-accordion-submenu-item\\\"></li>');\\n        }\\n\\n        if (_this.options.submenuToggle) {\\n          $elem.addClass('has-submenu-toggle');\\n          $elem.children('a').after('<button id=\\\"' + linkId + '\\\" class=\\\"submenu-toggle\\\" aria-controls=\\\"' + subId + '\\\" aria-expanded=\\\"' + isActive + '\\\" title=\\\"' + _this.options.submenuToggleText + '\\\"><span class=\\\"submenu-toggle-text\\\">' + _this.options.submenuToggleText + '</span></button>');\\n        } else {\\n          $elem.attr({\\n            'aria-controls': subId,\\n            'aria-expanded': isActive,\\n            'id': linkId\\n          });\\n        }\\n\\n        $sub.attr({\\n          'aria-labelledby': linkId,\\n          'aria-hidden': !isActive,\\n          'role': 'group',\\n          'id': subId\\n        });\\n      });\\n      this.$element.find('li').attr({\\n        'role': 'treeitem'\\n      });\\n      var initPanes = this.$element.find('.is-active');\\n\\n      if (initPanes.length) {\\n        var _this = this;\\n\\n        initPanes.each(function () {\\n          _this.down(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this));\\n        });\\n      }\\n\\n      this._events();\\n    }\\n    /**\\n     * Adds event handlers for items within the menu.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_events\\\",\\n    value: function _events() {\\n      var _this = this;\\n\\n      this.$element.find('li').each(function () {\\n        var $submenu = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).children('[data-submenu]');\\n\\n        if ($submenu.length) {\\n          if (_this.options.submenuToggle) {\\n            jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).children('.submenu-toggle').off('click.zf.accordionMenu').on('click.zf.accordionMenu', function (e) {\\n              _this.toggle($submenu);\\n            });\\n          } else {\\n            jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).children('a').off('click.zf.accordionMenu').on('click.zf.accordionMenu', function (e) {\\n              e.preventDefault();\\n\\n              _this.toggle($submenu);\\n            });\\n          }\\n        }\\n      }).on('keydown.zf.accordionmenu', function (e) {\\n        var $element = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\\n            $elements = $element.parent('ul').children('li'),\\n            $prevElement,\\n            $nextElement,\\n            $target = $element.children('[data-submenu]');\\n        $elements.each(function (i) {\\n          if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).is($element)) {\\n            $prevElement = $elements.eq(Math.max(0, i - 1)).find('a').first();\\n            $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1)).find('a').first();\\n\\n            if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).children('[data-submenu]:visible').length) {\\n              // has open sub menu\\n              $nextElement = $element.find('li:first-child').find('a').first();\\n            }\\n\\n            if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).is(':first-child')) {\\n              // is first element of sub menu\\n              $prevElement = $element.parents('li').first().find('a').first();\\n            } else if ($prevElement.parents('li').first().children('[data-submenu]:visible').length) {\\n              // if previous element has open sub menu\\n              $prevElement = $prevElement.parents('li').find('li:last-child').find('a').first();\\n            }\\n\\n            if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).is(':last-child')) {\\n              // is last element of sub menu\\n              $nextElement = $element.parents('li').first().next('li').find('a').first();\\n            }\\n\\n            return;\\n          }\\n        });\\n        _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\\\"Keyboard\\\"].handleKey(e, 'AccordionMenu', {\\n          open: function open() {\\n            if ($target.is(':hidden')) {\\n              _this.down($target);\\n\\n              $target.find('li').first().find('a').first().focus();\\n            }\\n          },\\n          close: function close() {\\n            if ($target.length && !$target.is(':hidden')) {\\n              // close active sub of this item\\n              _this.up($target);\\n            } else if ($element.parent('[data-submenu]').length) {\\n              // close currently open sub\\n              _this.up($element.parent('[data-submenu]'));\\n\\n              $element.parents('li').first().find('a').first().focus();\\n            }\\n          },\\n          up: function up() {\\n            $prevElement.focus();\\n            return true;\\n          },\\n          down: function down() {\\n            $nextElement.focus();\\n            return true;\\n          },\\n          toggle: function toggle() {\\n            if (_this.options.submenuToggle) {\\n              return false;\\n            }\\n\\n            if ($element.children('[data-submenu]').length) {\\n              _this.toggle($element.children('[data-submenu]'));\\n\\n              return true;\\n            }\\n          },\\n          closeAll: function closeAll() {\\n            _this.hideAll();\\n          },\\n          handled: function handled(preventDefault) {\\n            if (preventDefault) {\\n              e.preventDefault();\\n            }\\n\\n            e.stopImmediatePropagation();\\n          }\\n        });\\n      }); //.attr('tabindex', 0);\\n    }\\n    /**\\n     * Closes all panes of the menu.\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"hideAll\\\",\\n    value: function hideAll() {\\n      this.up(this.$element.find('[data-submenu]'));\\n    }\\n    /**\\n     * Opens all panes of the menu.\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"showAll\\\",\\n    value: function showAll() {\\n      this.down(this.$element.find('[data-submenu]'));\\n    }\\n    /**\\n     * Toggles the open/close state of a submenu.\\n     * @function\\n     * @param {jQuery} $target - the submenu to toggle\\n     */\\n\\n  }, {\\n    key: \\\"toggle\\\",\\n    value: function toggle($target) {\\n      if (!$target.is(':animated')) {\\n        if (!$target.is(':hidden')) {\\n          this.up($target);\\n        } else {\\n          this.down($target);\\n        }\\n      }\\n    }\\n    /**\\n     * Opens the sub-menu defined by `$target`.\\n     * @param {jQuery} $target - Sub-menu to open.\\n     * @fires AccordionMenu#down\\n     */\\n\\n  }, {\\n    key: \\\"down\\\",\\n    value: function down($target) {\\n      var _this2 = this;\\n\\n      if (!this.options.multiOpen) {\\n        this.up(this.$element.find('.is-active').not($target.parentsUntil(this.$element).add($target)));\\n      }\\n\\n      $target.addClass('is-active').attr({\\n        'aria-hidden': false\\n      });\\n\\n      if (this.options.submenuToggle) {\\n        $target.prev('.submenu-toggle').attr({\\n          'aria-expanded': true\\n        });\\n      } else {\\n        $target.parent('.is-accordion-submenu-parent').attr({\\n          'aria-expanded': true\\n        });\\n      }\\n\\n      $target.slideDown(this.options.slideSpeed, function () {\\n        /**\\n         * Fires when the menu is done opening.\\n         * @event AccordionMenu#down\\n         */\\n        _this2.$element.trigger('down.zf.accordionMenu', [$target]);\\n      });\\n    }\\n    /**\\n     * Closes the sub-menu defined by `$target`. All sub-menus inside the target will be closed as well.\\n     * @param {jQuery} $target - Sub-menu to close.\\n     * @fires AccordionMenu#up\\n     */\\n\\n  }, {\\n    key: \\\"up\\\",\\n    value: function up($target) {\\n      var _this3 = this;\\n\\n      var $submenus = $target.find('[data-submenu]');\\n      var $allmenus = $target.add($submenus);\\n      $submenus.slideUp(0);\\n      $allmenus.removeClass('is-active').attr('aria-hidden', true);\\n\\n      if (this.options.submenuToggle) {\\n        $allmenus.prev('.submenu-toggle').attr('aria-expanded', false);\\n      } else {\\n        $allmenus.parent('.is-accordion-submenu-parent').attr('aria-expanded', false);\\n      }\\n\\n      $target.slideUp(this.options.slideSpeed, function () {\\n        /**\\n         * Fires when the menu is done collapsing up.\\n         * @event AccordionMenu#up\\n         */\\n        _this3.$element.trigger('up.zf.accordionMenu', [$target]);\\n      });\\n    }\\n    /**\\n     * Destroys an instance of accordion menu.\\n     * @fires AccordionMenu#destroyed\\n     */\\n\\n  }, {\\n    key: \\\"_destroy\\\",\\n    value: function _destroy() {\\n      this.$element.find('[data-submenu]').slideDown(0).css('display', '');\\n      this.$element.find('a').off('click.zf.accordionMenu');\\n      this.$element.find('[data-is-parent-link]').detach();\\n\\n      if (this.options.submenuToggle) {\\n        this.$element.find('.has-submenu-toggle').removeClass('has-submenu-toggle');\\n        this.$element.find('.submenu-toggle').remove();\\n      }\\n\\n      _foundation_util_nest__WEBPACK_IMPORTED_MODULE_2__[\\\"Nest\\\"].Burn(this.$element, 'accordion');\\n    }\\n  }]);\\n\\n  return AccordionMenu;\\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_4__[\\\"Plugin\\\"]);\\n\\nAccordionMenu.defaults = {\\n  /**\\n   * Adds the parent link to the submenu.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  parentLink: false,\\n\\n  /**\\n   * Amount of time to animate the opening of a submenu in ms.\\n   * @option\\n   * @type {number}\\n   * @default 250\\n   */\\n  slideSpeed: 250,\\n\\n  /**\\n   * Adds a separate submenu toggle button. This allows the parent item to have a link.\\n   * @option\\n   * @example true\\n   */\\n  submenuToggle: false,\\n\\n  /**\\n   * The text used for the submenu toggle if enabled. This is used for screen readers only.\\n   * @option\\n   * @example true\\n   */\\n  submenuToggleText: 'Toggle menu',\\n\\n  /**\\n   * Allow the menu to have multiple open panes.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  multiOpen: true\\n};\\n\\n\\n//# sourceURL=webpack:///./js/foundation.accordionMenu.js?\");\n    }, \"./js/foundation.core.js\": function jsFoundationCoreJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Foundation\\\", function() { return Foundation; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.utils */ \\\"./js/foundation.core.utils.js\\\");\\n/* harmony import */ var _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.util.mediaQuery */ \\\"./js/foundation.util.mediaQuery.js\\\");\\n\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\n\\n\\n\\nvar FOUNDATION_VERSION = '6.5.1'; // Global Foundation object\\n// This is attached to the window, or used as a module for AMD/Browserify\\n\\nvar Foundation = {\\n  version: FOUNDATION_VERSION,\\n\\n  /**\\n   * Stores initialized plugins.\\n   */\\n  _plugins: {},\\n\\n  /**\\n   * Stores generated unique ids for plugin instances\\n   */\\n  _uuids: [],\\n\\n  /**\\n   * Defines a Foundation plugin, adding it to the `Foundation` namespace and the list of plugins to initialize when reflowing.\\n   * @param {Object} plugin - The constructor of the plugin.\\n   */\\n  plugin: function plugin(_plugin, name) {\\n    // Object key to use when adding to global Foundation object\\n    // Examples: Foundation.Reveal, Foundation.OffCanvas\\n    var className = name || functionName(_plugin); // Object key to use when storing the plugin, also used to create the identifying data attribute for the plugin\\n    // Examples: data-reveal, data-off-canvas\\n\\n    var attrName = hyphenate(className); // Add to the Foundation object and the plugins list (for reflowing)\\n\\n    this._plugins[attrName] = this[className] = _plugin;\\n  },\\n\\n  /**\\n   * @function\\n   * Populates the _uuids array with pointers to each individual plugin instance.\\n   * Adds the `zfPlugin` data-attribute to programmatically created plugins to allow use of $(selector).foundation(method) calls.\\n   * Also fires the initialization event for each plugin, consolidating repetitive code.\\n   * @param {Object} plugin - an instance of a plugin, usually `this` in context.\\n   * @param {String} name - the name of the plugin, passed as a camelCased string.\\n   * @fires Plugin#init\\n   */\\n  registerPlugin: function registerPlugin(plugin, name) {\\n    var pluginName = name ? hyphenate(name) : functionName(plugin.constructor).toLowerCase();\\n    plugin.uuid = Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\\\"GetYoDigits\\\"])(6, pluginName);\\n\\n    if (!plugin.$element.attr(\\\"data-\\\".concat(pluginName))) {\\n      plugin.$element.attr(\\\"data-\\\".concat(pluginName), plugin.uuid);\\n    }\\n\\n    if (!plugin.$element.data('zfPlugin')) {\\n      plugin.$element.data('zfPlugin', plugin);\\n    }\\n    /**\\n     * Fires when the plugin has initialized.\\n     * @event Plugin#init\\n     */\\n\\n\\n    plugin.$element.trigger(\\\"init.zf.\\\".concat(pluginName));\\n\\n    this._uuids.push(plugin.uuid);\\n\\n    return;\\n  },\\n\\n  /**\\n   * @function\\n   * Removes the plugins uuid from the _uuids array.\\n   * Removes the zfPlugin data attribute, as well as the data-plugin-name attribute.\\n   * Also fires the destroyed event for the plugin, consolidating repetitive code.\\n   * @param {Object} plugin - an instance of a plugin, usually `this` in context.\\n   * @fires Plugin#destroyed\\n   */\\n  unregisterPlugin: function unregisterPlugin(plugin) {\\n    var pluginName = hyphenate(functionName(plugin.$element.data('zfPlugin').constructor));\\n\\n    this._uuids.splice(this._uuids.indexOf(plugin.uuid), 1);\\n\\n    plugin.$element.removeAttr(\\\"data-\\\".concat(pluginName)).removeData('zfPlugin')\\n    /**\\n     * Fires when the plugin has been destroyed.\\n     * @event Plugin#destroyed\\n     */\\n    .trigger(\\\"destroyed.zf.\\\".concat(pluginName));\\n\\n    for (var prop in plugin) {\\n      plugin[prop] = null; //clean up script to prep for garbage collection.\\n    }\\n\\n    return;\\n  },\\n\\n  /**\\n   * @function\\n   * Causes one or more active plugins to re-initialize, resetting event listeners, recalculating positions, etc.\\n   * @param {String} plugins - optional string of an individual plugin key, attained by calling `$(element).data('pluginName')`, or string of a plugin class i.e. `'dropdown'`\\n   * @default If no argument is passed, reflow all currently active plugins.\\n   */\\n  reInit: function reInit(plugins) {\\n    var isJQ = plugins instanceof jquery__WEBPACK_IMPORTED_MODULE_0___default.a;\\n\\n    try {\\n      if (isJQ) {\\n        plugins.each(function () {\\n          jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data('zfPlugin')._init();\\n        });\\n      } else {\\n        var type = _typeof(plugins),\\n            _this = this,\\n            fns = {\\n          'object': function object(plgs) {\\n            plgs.forEach(function (p) {\\n              p = hyphenate(p);\\n              jquery__WEBPACK_IMPORTED_MODULE_0___default()('[data-' + p + ']').foundation('_init');\\n            });\\n          },\\n          'string': function string() {\\n            plugins = hyphenate(plugins);\\n            jquery__WEBPACK_IMPORTED_MODULE_0___default()('[data-' + plugins + ']').foundation('_init');\\n          },\\n          'undefined': function undefined() {\\n            this['object'](Object.keys(_this._plugins));\\n          }\\n        };\\n\\n        fns[type](plugins);\\n      }\\n    } catch (err) {\\n      console.error(err);\\n    } finally {\\n      return plugins;\\n    }\\n  },\\n\\n  /**\\n   * Initialize plugins on any elements within `elem` (and `elem` itself) that aren't already initialized.\\n   * @param {Object} elem - jQuery object containing the element to check inside. Also checks the element itself, unless it's the `document` object.\\n   * @param {String|Array} plugins - A list of plugins to initialize. Leave this out to initialize everything.\\n   */\\n  reflow: function reflow(elem, plugins) {\\n    // If plugins is undefined, just grab everything\\n    if (typeof plugins === 'undefined') {\\n      plugins = Object.keys(this._plugins);\\n    } // If plugins is a string, convert it to an array with one item\\n    else if (typeof plugins === 'string') {\\n        plugins = [plugins];\\n      }\\n\\n    var _this = this; // Iterate through each plugin\\n\\n\\n    jquery__WEBPACK_IMPORTED_MODULE_0___default.a.each(plugins, function (i, name) {\\n      // Get the current plugin\\n      var plugin = _this._plugins[name]; // Localize the search to all elements inside elem, as well as elem itself, unless elem === document\\n\\n      var $elem = jquery__WEBPACK_IMPORTED_MODULE_0___default()(elem).find('[data-' + name + ']').addBack('[data-' + name + ']'); // For each plugin found, initialize it\\n\\n      $elem.each(function () {\\n        var $el = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\\n            opts = {}; // Don't double-dip on plugins\\n\\n        if ($el.data('zfPlugin')) {\\n          console.warn(\\\"Tried to initialize \\\" + name + \\\" on an element that already has a Foundation plugin.\\\");\\n          return;\\n        }\\n\\n        if ($el.attr('data-options')) {\\n          var thing = $el.attr('data-options').split(';').forEach(function (e, i) {\\n            var opt = e.split(':').map(function (el) {\\n              return el.trim();\\n            });\\n            if (opt[0]) opts[opt[0]] = parseValue(opt[1]);\\n          });\\n        }\\n\\n        try {\\n          $el.data('zfPlugin', new plugin(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this), opts));\\n        } catch (er) {\\n          console.error(er);\\n        } finally {\\n          return;\\n        }\\n      });\\n    });\\n  },\\n  getFnName: functionName,\\n  addToJquery: function addToJquery($) {\\n    // TODO: consider not making this a jQuery function\\n    // TODO: need way to reflow vs. re-initialize\\n\\n    /**\\n     * The Foundation jQuery method.\\n     * @param {String|Array} method - An action to perform on the current jQuery object.\\n     */\\n    var foundation = function foundation(method) {\\n      var type = _typeof(method),\\n          $noJS = $('.no-js');\\n\\n      if ($noJS.length) {\\n        $noJS.removeClass('no-js');\\n      }\\n\\n      if (type === 'undefined') {\\n        //needs to initialize the Foundation object, or an individual plugin.\\n        _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_2__[\\\"MediaQuery\\\"]._init();\\n\\n        Foundation.reflow(this);\\n      } else if (type === 'string') {\\n        //an individual method to invoke on a plugin or group of plugins\\n        var args = Array.prototype.slice.call(arguments, 1); //collect all the arguments, if necessary\\n\\n        var plugClass = this.data('zfPlugin'); //determine the class of plugin\\n\\n        if (typeof plugClass !== 'undefined' && typeof plugClass[method] !== 'undefined') {\\n          //make sure both the class and method exist\\n          if (this.length === 1) {\\n            //if there's only one, call it directly.\\n            plugClass[method].apply(plugClass, args);\\n          } else {\\n            this.each(function (i, el) {\\n              //otherwise loop through the jQuery collection and invoke the method on each\\n              plugClass[method].apply($(el).data('zfPlugin'), args);\\n            });\\n          }\\n        } else {\\n          //error for no class or no method\\n          throw new ReferenceError(\\\"We're sorry, '\\\" + method + \\\"' is not an available method for \\\" + (plugClass ? functionName(plugClass) : 'this element') + '.');\\n        }\\n      } else {\\n        //error for invalid argument type\\n        throw new TypeError(\\\"We're sorry, \\\".concat(type, \\\" is not a valid parameter. You must use a string representing the method you wish to invoke.\\\"));\\n      }\\n\\n      return this;\\n    };\\n\\n    $.fn.foundation = foundation;\\n    return $;\\n  }\\n};\\nFoundation.util = {\\n  /**\\n   * Function for applying a debounce effect to a function call.\\n   * @function\\n   * @param {Function} func - Function to be called at end of timeout.\\n   * @param {Number} delay - Time in ms to delay the call of `func`.\\n   * @returns function\\n   */\\n  throttle: function throttle(func, delay) {\\n    var timer = null;\\n    return function () {\\n      var context = this,\\n          args = arguments;\\n\\n      if (timer === null) {\\n        timer = setTimeout(function () {\\n          func.apply(context, args);\\n          timer = null;\\n        }, delay);\\n      }\\n    };\\n  }\\n};\\nwindow.Foundation = Foundation; // Polyfill for requestAnimationFrame\\n\\n(function () {\\n  if (!Date.now || !window.Date.now) window.Date.now = Date.now = function () {\\n    return new Date().getTime();\\n  };\\n  var vendors = ['webkit', 'moz'];\\n\\n  for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {\\n    var vp = vendors[i];\\n    window.requestAnimationFrame = window[vp + 'RequestAnimationFrame'];\\n    window.cancelAnimationFrame = window[vp + 'CancelAnimationFrame'] || window[vp + 'CancelRequestAnimationFrame'];\\n  }\\n\\n  if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) || !window.requestAnimationFrame || !window.cancelAnimationFrame) {\\n    var lastTime = 0;\\n\\n    window.requestAnimationFrame = function (callback) {\\n      var now = Date.now();\\n      var nextTime = Math.max(lastTime + 16, now);\\n      return setTimeout(function () {\\n        callback(lastTime = nextTime);\\n      }, nextTime - now);\\n    };\\n\\n    window.cancelAnimationFrame = clearTimeout;\\n  }\\n  /**\\n   * Polyfill for performance.now, required by rAF\\n   */\\n\\n\\n  if (!window.performance || !window.performance.now) {\\n    window.performance = {\\n      start: Date.now(),\\n      now: function now() {\\n        return Date.now() - this.start;\\n      }\\n    };\\n  }\\n})();\\n\\nif (!Function.prototype.bind) {\\n  Function.prototype.bind = function (oThis) {\\n    if (typeof this !== 'function') {\\n      // closest thing possible to the ECMAScript 5\\n      // internal IsCallable function\\n      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\\n    }\\n\\n    var aArgs = Array.prototype.slice.call(arguments, 1),\\n        fToBind = this,\\n        fNOP = function fNOP() {},\\n        fBound = function fBound() {\\n      return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));\\n    };\\n\\n    if (this.prototype) {\\n      // native functions don't have a prototype\\n      fNOP.prototype = this.prototype;\\n    }\\n\\n    fBound.prototype = new fNOP();\\n    return fBound;\\n  };\\n} // Polyfill to get the name of a function in IE9\\n\\n\\nfunction functionName(fn) {\\n  if (typeof Function.prototype.name === 'undefined') {\\n    var funcNameRegex = /function\\\\s([^(]{1,})\\\\(/;\\n    var results = funcNameRegex.exec(fn.toString());\\n    return results && results.length > 1 ? results[1].trim() : \\\"\\\";\\n  } else if (typeof fn.prototype === 'undefined') {\\n    return fn.constructor.name;\\n  } else {\\n    return fn.prototype.constructor.name;\\n  }\\n}\\n\\nfunction parseValue(str) {\\n  if ('true' === str) return true;else if ('false' === str) return false;else if (!isNaN(str * 1)) return parseFloat(str);\\n  return str;\\n} // Convert PascalCase to kebab-case\\n// Thank you: http://stackoverflow.com/a/8955580\\n\\n\\nfunction hyphenate(str) {\\n  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\\n}\\n\\n\\n\\n//# sourceURL=webpack:///./js/foundation.core.js?\");\n    }, \"./js/foundation.core.plugin.js\": function jsFoundationCorePluginJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Plugin\", function() { return Plugin; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\\n\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\n\\n // Abstract class for providing lifecycle hooks. Expect plugins to define AT LEAST\\n// {function} _setup (replaces previous constructor),\\n// {function} _destroy (replaces previous destroy)\\n\\nvar Plugin =\\n/*#__PURE__*/\\nfunction () {\\n  function Plugin(element, options) {\\n    _classCallCheck(this, Plugin);\\n\\n    this._setup(element, options);\\n\\n    var pluginName = getPluginName(this);\\n    this.uuid = Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"GetYoDigits\"])(6, pluginName);\\n\\n    if (!this.$element.attr(\"data-\".concat(pluginName))) {\\n      this.$element.attr(\"data-\".concat(pluginName), this.uuid);\\n    }\\n\\n    if (!this.$element.data(\\'zfPlugin\\')) {\\n      this.$element.data(\\'zfPlugin\\', this);\\n    }\\n    /**\\n     * Fires when the plugin has initialized.\\n     * @event Plugin#init\\n     */\\n\\n\\n    this.$element.trigger(\"init.zf.\".concat(pluginName));\\n  }\\n\\n  _createClass(Plugin, [{\\n    key: \"destroy\",\\n    value: function destroy() {\\n      this._destroy();\\n\\n      var pluginName = getPluginName(this);\\n      this.$element.removeAttr(\"data-\".concat(pluginName)).removeData(\\'zfPlugin\\')\\n      /**\\n       * Fires when the plugin has been destroyed.\\n       * @event Plugin#destroyed\\n       */\\n      .trigger(\"destroyed.zf.\".concat(pluginName));\\n\\n      for (var prop in this) {\\n        this[prop] = null; //clean up script to prep for garbage collection.\\n      }\\n    }\\n  }]);\\n\\n  return Plugin;\\n}(); // Convert PascalCase to kebab-case\\n// Thank you: http://stackoverflow.com/a/8955580\\n\\n\\nfunction hyphenate(str) {\\n  return str.replace(/([a-z])([A-Z])/g, \\'$1-$2\\').toLowerCase();\\n}\\n\\nfunction getPluginName(obj) {\\n  if (typeof obj.constructor.name !== \\'undefined\\') {\\n    return hyphenate(obj.constructor.name);\\n  } else {\\n    return hyphenate(obj.className);\\n  }\\n}\\n\\n\\n\\n//# sourceURL=webpack:///./js/foundation.core.plugin.js?');\n    }, \"./js/foundation.core.utils.js\": function jsFoundationCoreUtilsJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"rtl\\\", function() { return rtl; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"GetYoDigits\\\", function() { return GetYoDigits; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RegExpEscape\\\", function() { return RegExpEscape; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"transitionend\\\", function() { return transitionend; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"onLoad\\\", function() { return onLoad; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ignoreMousedisappear\\\", function() { return ignoreMousedisappear; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n\\n\\n // Core Foundation Utilities, utilized in a number of places.\\n\\n/**\\n * Returns a boolean for RTL support\\n */\\n\\nfunction rtl() {\\n  return jquery__WEBPACK_IMPORTED_MODULE_0___default()('html').attr('dir') === 'rtl';\\n}\\n/**\\n * returns a random base-36 uid with namespacing\\n * @function\\n * @param {Number} length - number of random base-36 digits desired. Increase for more random strings.\\n * @param {String} namespace - name of plugin to be incorporated in uid, optional.\\n * @default {String} '' - if no plugin name is provided, nothing is appended to the uid.\\n * @returns {String} - unique id\\n */\\n\\n\\nfunction GetYoDigits(length, namespace) {\\n  length = length || 6;\\n  return Math.round(Math.pow(36, length + 1) - Math.random() * Math.pow(36, length)).toString(36).slice(1) + (namespace ? \\\"-\\\".concat(namespace) : '');\\n}\\n/**\\n * Escape a string so it can be used as a regexp pattern\\n * @function\\n * @see https://stackoverflow.com/a/9310752/4317384\\n *\\n * @param {String} str - string to escape.\\n * @returns {String} - escaped string\\n */\\n\\n\\nfunction RegExpEscape(str) {\\n  return str.replace(/[-[\\\\]{}()*+?.,\\\\\\\\^$|#\\\\s]/g, '\\\\\\\\$&');\\n}\\n\\nfunction transitionend($elem) {\\n  var transitions = {\\n    'transition': 'transitionend',\\n    'WebkitTransition': 'webkitTransitionEnd',\\n    'MozTransition': 'transitionend',\\n    'OTransition': 'otransitionend'\\n  };\\n  var elem = document.createElement('div'),\\n      end;\\n\\n  for (var t in transitions) {\\n    if (typeof elem.style[t] !== 'undefined') {\\n      end = transitions[t];\\n    }\\n  }\\n\\n  if (end) {\\n    return end;\\n  } else {\\n    end = setTimeout(function () {\\n      $elem.triggerHandler('transitionend', [$elem]);\\n    }, 1);\\n    return 'transitionend';\\n  }\\n}\\n/**\\n * Return an event type to listen for window load.\\n *\\n * If `$elem` is passed, an event will be triggered on `$elem`. If window is already loaded, the event will still be triggered.\\n * If `handler` is passed, attach it to the event on `$elem`.\\n * Calling `onLoad` without handler allows you to get the event type that will be triggered before attaching the handler by yourself.\\n * @function\\n *\\n * @param {Object} [] $elem - jQuery element on which the event will be triggered if passed.\\n * @param {Function} [] handler - function to attach to the event.\\n * @returns {String} - event type that should or will be triggered.\\n */\\n\\n\\nfunction onLoad($elem, handler) {\\n  var didLoad = document.readyState === 'complete';\\n  var eventType = (didLoad ? '_didLoad' : 'load') + '.zf.util.onLoad';\\n\\n  var cb = function cb() {\\n    return $elem.triggerHandler(eventType);\\n  };\\n\\n  if ($elem) {\\n    if (handler) $elem.one(eventType, handler);\\n    if (didLoad) setTimeout(cb);else jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).one('load', cb);\\n  }\\n\\n  return eventType;\\n}\\n/**\\n * Retuns an handler for the `mouseleave` that ignore disappeared mouses.\\n *\\n * If the mouse \\\"disappeared\\\" from the document (like when going on a browser UI element, See https://git.io/zf-11410),\\n * the event is ignored.\\n * - If the `ignoreLeaveWindow` is `true`, the event is ignored when the user actually left the window\\n *   (like by switching to an other window with [Alt]+[Tab]).\\n * - If the `ignoreReappear` is `true`, the event will be ignored when the mouse will reappear later on the document\\n *   outside of the element it left.\\n *\\n * @function\\n *\\n * @param {Function} [] handler - handler for the filtered `mouseleave` event to watch.\\n * @param {Object} [] options - object of options:\\n * - {Boolean} [false] ignoreLeaveWindow - also ignore when the user switched windows.\\n * - {Boolean} [false] ignoreReappear - also ignore when the mouse reappeared outside of the element it left.\\n * @returns {Function} - filtered handler to use to listen on the `mouseleave` event.\\n */\\n\\n\\nfunction ignoreMousedisappear(handler) {\\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\\n      _ref$ignoreLeaveWindo = _ref.ignoreLeaveWindow,\\n      ignoreLeaveWindow = _ref$ignoreLeaveWindo === void 0 ? false : _ref$ignoreLeaveWindo,\\n      _ref$ignoreReappear = _ref.ignoreReappear,\\n      ignoreReappear = _ref$ignoreReappear === void 0 ? false : _ref$ignoreReappear;\\n\\n  return function leaveEventHandler(eLeave) {\\n    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n      rest[_key - 1] = arguments[_key];\\n    }\\n\\n    var callback = handler.bind.apply(handler, [this, eLeave].concat(rest)); // The mouse left: call the given callback if the mouse entered elsewhere\\n\\n    if (eLeave.relatedTarget !== null) {\\n      return callback();\\n    } // Otherwise, check if the mouse actually left the window.\\n    // In firefox if the user switched between windows, the window sill have the focus by the time\\n    // the event is triggered. We have to debounce the event to test this case.\\n\\n\\n    setTimeout(function leaveEventDebouncer() {\\n      if (!ignoreLeaveWindow && document.hasFocus && !document.hasFocus()) {\\n        return callback();\\n      } // Otherwise, wait for the mouse to reeapear outside of the element,\\n\\n\\n      if (!ignoreReappear) {\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).one('mouseenter', function reenterEventHandler(eReenter) {\\n          if (!jquery__WEBPACK_IMPORTED_MODULE_0___default()(eLeave.currentTarget).has(eReenter.target).length) {\\n            // Fill where the mouse finally entered.\\n            eLeave.relatedTarget = eReenter.target;\\n            callback();\\n          }\\n        });\\n      }\\n    }, 0);\\n  };\\n}\\n\\n\\n\\n//# sourceURL=webpack:///./js/foundation.core.utils.js?\");\n    }, \"./js/foundation.drilldown.js\": function jsFoundationDrilldownJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Drilldown\\\", function() { return Drilldown; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.util.keyboard */ \\\"./js/foundation.util.keyboard.js\\\");\\n/* harmony import */ var _foundation_util_nest__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.util.nest */ \\\"./js/foundation.util.nest.js\\\");\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.core.utils */ \\\"./js/foundation.core.utils.js\\\");\\n/* harmony import */ var _foundation_util_box__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.util.box */ \\\"./js/foundation.util.box.js\\\");\\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./foundation.core.plugin */ \\\"./js/foundation.core.plugin.js\\\");\\n\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * Drilldown module.\\n * @module foundation.drilldown\\n * @requires foundation.util.keyboard\\n * @requires foundation.util.nest\\n * @requires foundation.util.box\\n */\\n\\nvar Drilldown =\\n/*#__PURE__*/\\nfunction (_Plugin) {\\n  _inherits(Drilldown, _Plugin);\\n\\n  function Drilldown() {\\n    _classCallCheck(this, Drilldown);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(Drilldown).apply(this, arguments));\\n  }\\n\\n  _createClass(Drilldown, [{\\n    key: \\\"_setup\\\",\\n\\n    /**\\n     * Creates a new instance of a drilldown menu.\\n     * @class\\n     * @name Drilldown\\n     * @param {jQuery} element - jQuery object to make into an accordion menu.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, Drilldown.defaults, this.$element.data(), options);\\n      this.className = 'Drilldown'; // ie9 back compat\\n\\n      this._init();\\n\\n      _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\\\"Keyboard\\\"].register('Drilldown', {\\n        'ENTER': 'open',\\n        'SPACE': 'open',\\n        'ARROW_RIGHT': 'next',\\n        'ARROW_UP': 'up',\\n        'ARROW_DOWN': 'down',\\n        'ARROW_LEFT': 'previous',\\n        'ESCAPE': 'close',\\n        'TAB': 'down',\\n        'SHIFT_TAB': 'up'\\n      });\\n    }\\n    /**\\n     * Initializes the drilldown by creating jQuery collections of elements\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_init\\\",\\n    value: function _init() {\\n      _foundation_util_nest__WEBPACK_IMPORTED_MODULE_2__[\\\"Nest\\\"].Feather(this.$element, 'drilldown');\\n\\n      if (this.options.autoApplyClass) {\\n        this.$element.addClass('drilldown');\\n      }\\n\\n      this.$element.attr({\\n        'role': 'tree',\\n        'aria-multiselectable': false\\n      });\\n      this.$submenuAnchors = this.$element.find('li.is-drilldown-submenu-parent').children('a');\\n      this.$submenus = this.$submenuAnchors.parent('li').children('[data-submenu]').attr('role', 'group');\\n      this.$menuItems = this.$element.find('li').not('.js-drilldown-back').attr('role', 'treeitem').find('a'); // Set the main menu as current by default (unless a submenu is selected)\\n      // Used to set the wrapper height when the drilldown is closed/reopened from any (sub)menu\\n\\n      this.$currentMenu = this.$element;\\n      this.$element.attr('data-mutate', this.$element.attr('data-drilldown') || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\\\"GetYoDigits\\\"])(6, 'drilldown'));\\n\\n      this._prepareMenu();\\n\\n      this._registerEvents();\\n\\n      this._keyboardEvents();\\n    }\\n    /**\\n     * prepares drilldown menu by setting attributes to links and elements\\n     * sets a min height to prevent content jumping\\n     * wraps the element if not already wrapped\\n     * @private\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"_prepareMenu\\\",\\n    value: function _prepareMenu() {\\n      var _this = this; // if(!this.options.holdOpen){\\n      //   this._menuLinkEvents();\\n      // }\\n\\n\\n      this.$submenuAnchors.each(function () {\\n        var $link = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);\\n        var $sub = $link.parent();\\n\\n        if (_this.options.parentLink) {\\n          $link.clone().prependTo($sub.children('[data-submenu]')).wrap('<li data-is-parent-link class=\\\"is-submenu-parent-item is-submenu-item is-drilldown-submenu-item\\\" role=\\\"menuitem\\\"></li>');\\n        }\\n\\n        $link.data('savedHref', $link.attr('href')).removeAttr('href').attr('tabindex', 0);\\n        $link.children('[data-submenu]').attr({\\n          'aria-hidden': true,\\n          'tabindex': 0,\\n          'role': 'group'\\n        });\\n\\n        _this._events($link);\\n      });\\n      this.$submenus.each(function () {\\n        var $menu = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\\n            $back = $menu.find('.js-drilldown-back');\\n\\n        if (!$back.length) {\\n          switch (_this.options.backButtonPosition) {\\n            case \\\"bottom\\\":\\n              $menu.append(_this.options.backButton);\\n              break;\\n\\n            case \\\"top\\\":\\n              $menu.prepend(_this.options.backButton);\\n              break;\\n\\n            default:\\n              console.error(\\\"Unsupported backButtonPosition value '\\\" + _this.options.backButtonPosition + \\\"'\\\");\\n          }\\n        }\\n\\n        _this._back($menu);\\n      });\\n      this.$submenus.addClass('invisible');\\n\\n      if (!this.options.autoHeight) {\\n        this.$submenus.addClass('drilldown-submenu-cover-previous');\\n      } // create a wrapper on element if it doesn't exist.\\n\\n\\n      if (!this.$element.parent().hasClass('is-drilldown')) {\\n        this.$wrapper = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this.options.wrapper).addClass('is-drilldown');\\n        if (this.options.animateHeight) this.$wrapper.addClass('animate-height');\\n        this.$element.wrap(this.$wrapper);\\n      } // set wrapper\\n\\n\\n      this.$wrapper = this.$element.parent();\\n      this.$wrapper.css(this._getMaxDims());\\n    }\\n  }, {\\n    key: \\\"_resize\\\",\\n    value: function _resize() {\\n      this.$wrapper.css({\\n        'max-width': 'none',\\n        'min-height': 'none'\\n      }); // _getMaxDims has side effects (boo) but calling it should update all other necessary heights & widths\\n\\n      this.$wrapper.css(this._getMaxDims());\\n    }\\n    /**\\n     * Adds event handlers to elements in the menu.\\n     * @function\\n     * @private\\n     * @param {jQuery} $elem - the current menu item to add handlers to.\\n     */\\n\\n  }, {\\n    key: \\\"_events\\\",\\n    value: function _events($elem) {\\n      var _this = this;\\n\\n      $elem.off('click.zf.drilldown').on('click.zf.drilldown', function (e) {\\n        if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).parentsUntil('ul', 'li').hasClass('is-drilldown-submenu-parent')) {\\n          e.stopImmediatePropagation();\\n          e.preventDefault();\\n        } // if(e.target !== e.currentTarget.firstElementChild){\\n        //   return false;\\n        // }\\n\\n\\n        _this._show($elem.parent('li'));\\n\\n        if (_this.options.closeOnClick) {\\n          var $body = jquery__WEBPACK_IMPORTED_MODULE_0___default()('body');\\n          $body.off('.zf.drilldown').on('click.zf.drilldown', function (e) {\\n            if (e.target === _this.$element[0] || jquery__WEBPACK_IMPORTED_MODULE_0___default.a.contains(_this.$element[0], e.target)) {\\n              return;\\n            }\\n\\n            e.preventDefault();\\n\\n            _this._hideAll();\\n\\n            $body.off('.zf.drilldown');\\n          });\\n        }\\n      });\\n    }\\n    /**\\n     * Adds event handlers to the menu element.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_registerEvents\\\",\\n    value: function _registerEvents() {\\n      if (this.options.scrollTop) {\\n        this._bindHandler = this._scrollTop.bind(this);\\n        this.$element.on('open.zf.drilldown hide.zf.drilldown closed.zf.drilldown', this._bindHandler);\\n      }\\n\\n      this.$element.on('mutateme.zf.trigger', this._resize.bind(this));\\n    }\\n    /**\\n     * Scroll to Top of Element or data-scroll-top-element\\n     * @function\\n     * @fires Drilldown#scrollme\\n     */\\n\\n  }, {\\n    key: \\\"_scrollTop\\\",\\n    value: function _scrollTop() {\\n      var _this = this;\\n\\n      var $scrollTopElement = _this.options.scrollTopElement != '' ? jquery__WEBPACK_IMPORTED_MODULE_0___default()(_this.options.scrollTopElement) : _this.$element,\\n          scrollPos = parseInt($scrollTopElement.offset().top + _this.options.scrollTopOffset, 10);\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()('html, body').stop(true).animate({\\n        scrollTop: scrollPos\\n      }, _this.options.animationDuration, _this.options.animationEasing, function () {\\n        /**\\n          * Fires after the menu has scrolled\\n          * @event Drilldown#scrollme\\n          */\\n        if (this === jquery__WEBPACK_IMPORTED_MODULE_0___default()('html')[0]) _this.$element.trigger('scrollme.zf.drilldown');\\n      });\\n    }\\n    /**\\n     * Adds keydown event listener to `li`'s in the menu.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_keyboardEvents\\\",\\n    value: function _keyboardEvents() {\\n      var _this = this;\\n\\n      this.$menuItems.add(this.$element.find('.js-drilldown-back > a, .is-submenu-parent-item > a')).on('keydown.zf.drilldown', function (e) {\\n        var $element = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\\n            $elements = $element.parent('li').parent('ul').children('li').children('a'),\\n            $prevElement,\\n            $nextElement;\\n        $elements.each(function (i) {\\n          if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).is($element)) {\\n            $prevElement = $elements.eq(Math.max(0, i - 1));\\n            $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1));\\n            return;\\n          }\\n        });\\n        _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\\\"Keyboard\\\"].handleKey(e, 'Drilldown', {\\n          next: function next() {\\n            if ($element.is(_this.$submenuAnchors)) {\\n              _this._show($element.parent('li'));\\n\\n              $element.parent('li').one(Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\\\"transitionend\\\"])($element), function () {\\n                $element.parent('li').find('ul li a').not('.js-drilldown-back a').first().focus();\\n              });\\n              return true;\\n            }\\n          },\\n          previous: function previous() {\\n            _this._hide($element.parent('li').parent('ul'));\\n\\n            $element.parent('li').parent('ul').one(Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\\\"transitionend\\\"])($element), function () {\\n              setTimeout(function () {\\n                $element.parent('li').parent('ul').parent('li').children('a').first().focus();\\n              }, 1);\\n            });\\n            return true;\\n          },\\n          up: function up() {\\n            $prevElement.focus(); // Don't tap focus on first element in root ul\\n\\n            return !$element.is(_this.$element.find('> li:first-child > a'));\\n          },\\n          down: function down() {\\n            $nextElement.focus(); // Don't tap focus on last element in root ul\\n\\n            return !$element.is(_this.$element.find('> li:last-child > a'));\\n          },\\n          close: function close() {\\n            // Don't close on element in root ul\\n            if (!$element.is(_this.$element.find('> li > a'))) {\\n              _this._hide($element.parent().parent());\\n\\n              $element.parent().parent().siblings('a').focus();\\n            }\\n          },\\n          open: function open() {\\n            if (_this.options.parentLink && $element.attr('href')) {\\n              // Link with href\\n              return false;\\n            } else if (!$element.is(_this.$menuItems)) {\\n              // not menu item means back button\\n              _this._hide($element.parent('li').parent('ul'));\\n\\n              $element.parent('li').parent('ul').one(Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\\\"transitionend\\\"])($element), function () {\\n                setTimeout(function () {\\n                  $element.parent('li').parent('ul').parent('li').children('a').first().focus();\\n                }, 1);\\n              });\\n              return true;\\n            } else if ($element.is(_this.$submenuAnchors)) {\\n              // Sub menu item\\n              _this._show($element.parent('li'));\\n\\n              $element.parent('li').one(Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\\\"transitionend\\\"])($element), function () {\\n                $element.parent('li').find('ul li a').not('.js-drilldown-back a').first().focus();\\n              });\\n              return true;\\n            }\\n          },\\n          handled: function handled(preventDefault) {\\n            if (preventDefault) {\\n              e.preventDefault();\\n            }\\n\\n            e.stopImmediatePropagation();\\n          }\\n        });\\n      }); // end keyboardAccess\\n    }\\n    /**\\n     * Closes all open elements, and returns to root menu.\\n     * @function\\n     * @fires Drilldown#closed\\n     */\\n\\n  }, {\\n    key: \\\"_hideAll\\\",\\n    value: function _hideAll() {\\n      var $elem = this.$element.find('.is-drilldown-submenu.is-active').addClass('is-closing');\\n      if (this.options.autoHeight) this.$wrapper.css({\\n        height: $elem.parent().closest('ul').data('calcHeight')\\n      });\\n      $elem.one(Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\\\"transitionend\\\"])($elem), function (e) {\\n        $elem.removeClass('is-active is-closing');\\n      });\\n      /**\\n       * Fires when the menu is fully closed.\\n       * @event Drilldown#closed\\n       */\\n\\n      this.$element.trigger('closed.zf.drilldown');\\n    }\\n    /**\\n     * Adds event listener for each `back` button, and closes open menus.\\n     * @function\\n     * @fires Drilldown#back\\n     * @param {jQuery} $elem - the current sub-menu to add `back` event.\\n     */\\n\\n  }, {\\n    key: \\\"_back\\\",\\n    value: function _back($elem) {\\n      var _this = this;\\n\\n      $elem.off('click.zf.drilldown');\\n      $elem.children('.js-drilldown-back').on('click.zf.drilldown', function (e) {\\n        e.stopImmediatePropagation(); // console.log('mouseup on back');\\n\\n        _this._hide($elem); // If there is a parent submenu, call show\\n\\n\\n        var parentSubMenu = $elem.parent('li').parent('ul').parent('li');\\n\\n        if (parentSubMenu.length) {\\n          _this._show(parentSubMenu);\\n        }\\n      });\\n    }\\n    /**\\n     * Adds event listener to menu items w/o submenus to close open menus on click.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_menuLinkEvents\\\",\\n    value: function _menuLinkEvents() {\\n      var _this = this;\\n\\n      this.$menuItems.not('.is-drilldown-submenu-parent').off('click.zf.drilldown').on('click.zf.drilldown', function (e) {\\n        // e.stopImmediatePropagation();\\n        setTimeout(function () {\\n          _this._hideAll();\\n        }, 0);\\n      });\\n    }\\n    /**\\n     * Sets the CSS classes for submenu to show it.\\n     * @function\\n     * @private\\n     * @param {jQuery} $elem - the target submenu (`ul` tag)\\n     * @param {boolean} trigger - trigger drilldown event\\n     */\\n\\n  }, {\\n    key: \\\"_setShowSubMenuClasses\\\",\\n    value: function _setShowSubMenuClasses($elem, trigger) {\\n      $elem.addClass('is-active').removeClass('invisible').attr('aria-hidden', false);\\n      $elem.parent('li').attr('aria-expanded', true);\\n\\n      if (trigger === true) {\\n        this.$element.trigger('open.zf.drilldown', [$elem]);\\n      }\\n    }\\n    /**\\n     * Sets the CSS classes for submenu to hide it.\\n     * @function\\n     * @private\\n     * @param {jQuery} $elem - the target submenu (`ul` tag)\\n     * @param {boolean} trigger - trigger drilldown event\\n     */\\n\\n  }, {\\n    key: \\\"_setHideSubMenuClasses\\\",\\n    value: function _setHideSubMenuClasses($elem, trigger) {\\n      $elem.removeClass('is-active').addClass('invisible').attr('aria-hidden', true);\\n      $elem.parent('li').attr('aria-expanded', false);\\n\\n      if (trigger === true) {\\n        $elem.trigger('hide.zf.drilldown', [$elem]);\\n      }\\n    }\\n    /**\\n     * Opens a specific drilldown (sub)menu no matter which (sub)menu in it is currently visible.\\n     * Compared to _show() this lets you jump into any submenu without clicking through every submenu on the way to it.\\n     * @function\\n     * @fires Drilldown#open\\n     * @param {jQuery} $elem - the target (sub)menu (`ul` tag)\\n     * @param {boolean} autoFocus - if true the first link in the target (sub)menu gets auto focused\\n     */\\n\\n  }, {\\n    key: \\\"_showMenu\\\",\\n    value: function _showMenu($elem, autoFocus) {\\n      var _this = this; // Reset drilldown\\n\\n\\n      var $expandedSubmenus = this.$element.find('li[aria-expanded=\\\"true\\\"] > ul[data-submenu]');\\n      $expandedSubmenus.each(function (index) {\\n        _this._setHideSubMenuClasses(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this));\\n      }); // Save the menu as the currently displayed one.\\n\\n      this.$currentMenu = $elem; // If target menu is root, focus first link & exit\\n\\n      if ($elem.is('[data-drilldown]')) {\\n        if (autoFocus === true) $elem.find('li[role=\\\"treeitem\\\"] > a').first().focus();\\n        if (this.options.autoHeight) this.$wrapper.css('height', $elem.data('calcHeight'));\\n        return;\\n      } // Find all submenus on way to root incl. the element itself\\n\\n\\n      var $submenus = $elem.children().first().parentsUntil('[data-drilldown]', '[data-submenu]'); // Open target menu and all submenus on its way to root\\n\\n      $submenus.each(function (index) {\\n        // Update height of first child (target menu) if autoHeight option true\\n        if (index === 0 && _this.options.autoHeight) {\\n          _this.$wrapper.css('height', jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data('calcHeight'));\\n        }\\n\\n        var isLastChild = index == $submenus.length - 1; // Add transitionsend listener to last child (root due to reverse order) to open target menu's first link\\n        // Last child makes sure the event gets always triggered even if going through several menus\\n\\n        if (isLastChild === true) {\\n          jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).one(Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\\\"transitionend\\\"])(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this)), function () {\\n            if (autoFocus === true) {\\n              $elem.find('li[role=\\\"treeitem\\\"] > a').first().focus();\\n            }\\n          });\\n        }\\n\\n        _this._setShowSubMenuClasses(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this), isLastChild);\\n      });\\n    }\\n    /**\\n     * Opens a submenu.\\n     * @function\\n     * @fires Drilldown#open\\n     * @param {jQuery} $elem - the current element with a submenu to open, i.e. the `li` tag.\\n     */\\n\\n  }, {\\n    key: \\\"_show\\\",\\n    value: function _show($elem) {\\n      var $submenu = $elem.children('[data-submenu]');\\n      $elem.attr('aria-expanded', true);\\n      this.$currentMenu = $submenu;\\n      $submenu.addClass('is-active').removeClass('invisible').attr('aria-hidden', false);\\n\\n      if (this.options.autoHeight) {\\n        this.$wrapper.css({\\n          height: $submenu.data('calcHeight')\\n        });\\n      }\\n      /**\\n       * Fires when the submenu has opened.\\n       * @event Drilldown#open\\n       */\\n\\n\\n      this.$element.trigger('open.zf.drilldown', [$elem]);\\n    }\\n    /**\\n     * Hides a submenu\\n     * @function\\n     * @fires Drilldown#hide\\n     * @param {jQuery} $elem - the current sub-menu to hide, i.e. the `ul` tag.\\n     */\\n\\n  }, {\\n    key: \\\"_hide\\\",\\n    value: function _hide($elem) {\\n      if (this.options.autoHeight) this.$wrapper.css({\\n        height: $elem.parent().closest('ul').data('calcHeight')\\n      });\\n\\n      var _this = this;\\n\\n      $elem.parent('li').attr('aria-expanded', false);\\n      $elem.attr('aria-hidden', true);\\n      $elem.addClass('is-closing').one(Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\\\"transitionend\\\"])($elem), function () {\\n        $elem.removeClass('is-active is-closing');\\n        $elem.blur().addClass('invisible');\\n      });\\n      /**\\n       * Fires when the submenu has closed.\\n       * @event Drilldown#hide\\n       */\\n\\n      $elem.trigger('hide.zf.drilldown', [$elem]);\\n    }\\n    /**\\n     * Iterates through the nested menus to calculate the min-height, and max-width for the menu.\\n     * Prevents content jumping.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_getMaxDims\\\",\\n    value: function _getMaxDims() {\\n      var maxHeight = 0,\\n          result = {},\\n          _this = this; // Recalculate menu heights and total max height\\n\\n\\n      this.$submenus.add(this.$element).each(function () {\\n        var numOfElems = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).children('li').length;\\n        var height = _foundation_util_box__WEBPACK_IMPORTED_MODULE_4__[\\\"Box\\\"].GetDimensions(this).height;\\n        maxHeight = height > maxHeight ? height : maxHeight;\\n\\n        if (_this.options.autoHeight) {\\n          jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data('calcHeight', height);\\n        }\\n      });\\n      if (this.options.autoHeight) result['height'] = this.$currentMenu.data('calcHeight');else result['min-height'] = \\\"\\\".concat(maxHeight, \\\"px\\\");\\n      result['max-width'] = \\\"\\\".concat(this.$element[0].getBoundingClientRect().width, \\\"px\\\");\\n      return result;\\n    }\\n    /**\\n     * Destroys the Drilldown Menu\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"_destroy\\\",\\n    value: function _destroy() {\\n      if (this.options.scrollTop) this.$element.off('.zf.drilldown', this._bindHandler);\\n\\n      this._hideAll();\\n\\n      this.$element.off('mutateme.zf.trigger');\\n      _foundation_util_nest__WEBPACK_IMPORTED_MODULE_2__[\\\"Nest\\\"].Burn(this.$element, 'drilldown');\\n      this.$element.unwrap().find('.js-drilldown-back, .is-submenu-parent-item').remove().end().find('.is-active, .is-closing, .is-drilldown-submenu').removeClass('is-active is-closing is-drilldown-submenu').end().find('[data-submenu]').removeAttr('aria-hidden tabindex role');\\n      this.$submenuAnchors.each(function () {\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).off('.zf.drilldown');\\n      });\\n      this.$element.find('[data-is-parent-link]').detach();\\n      this.$submenus.removeClass('drilldown-submenu-cover-previous invisible');\\n      this.$element.find('a').each(function () {\\n        var $link = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);\\n        $link.removeAttr('tabindex');\\n\\n        if ($link.data('savedHref')) {\\n          $link.attr('href', $link.data('savedHref')).removeData('savedHref');\\n        } else {\\n          return;\\n        }\\n      });\\n    }\\n  }]);\\n\\n  return Drilldown;\\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_5__[\\\"Plugin\\\"]);\\n\\nDrilldown.defaults = {\\n  /**\\n   * Drilldowns depend on styles in order to function properly; in the default build of Foundation these are\\n   * on the `drilldown` class. This option auto-applies this class to the drilldown upon initialization.\\n   * @option\\n   * @type {boolian}\\n   * @default true\\n   */\\n  autoApplyClass: true,\\n\\n  /**\\n   * Markup used for JS generated back button. Prepended  or appended (see backButtonPosition) to submenu lists and deleted on `destroy` method, 'js-drilldown-back' class required. Remove the backslash (`\\\\`) if copy and pasting.\\n   * @option\\n   * @type {string}\\n   * @default '<li class=\\\"js-drilldown-back\\\"><a tabindex=\\\"0\\\">Back</a></li>'\\n   */\\n  backButton: '<li class=\\\"js-drilldown-back\\\"><a tabindex=\\\"0\\\">Back</a></li>',\\n\\n  /**\\n   * Position the back button either at the top or bottom of drilldown submenus. Can be `'left'` or `'bottom'`.\\n   * @option\\n   * @type {string}\\n   * @default top\\n   */\\n  backButtonPosition: 'top',\\n\\n  /**\\n   * Markup used to wrap drilldown menu. Use a class name for independent styling; the JS applied class: `is-drilldown` is required. Remove the backslash (`\\\\`) if copy and pasting.\\n   * @option\\n   * @type {string}\\n   * @default '<div></div>'\\n   */\\n  wrapper: '<div></div>',\\n\\n  /**\\n   * Adds the parent link to the submenu.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  parentLink: false,\\n\\n  /**\\n   * Allow the menu to return to root list on body click.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  closeOnClick: false,\\n\\n  /**\\n   * Allow the menu to auto adjust height.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  autoHeight: false,\\n\\n  /**\\n   * Animate the auto adjust height.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  animateHeight: false,\\n\\n  /**\\n   * Scroll to the top of the menu after opening a submenu or navigating back using the menu back button\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  scrollTop: false,\\n\\n  /**\\n   * String jquery selector (for example 'body') of element to take offset().top from, if empty string the drilldown menu offset().top is taken\\n   * @option\\n   * @type {string}\\n   * @default ''\\n   */\\n  scrollTopElement: '',\\n\\n  /**\\n   * ScrollTop offset\\n   * @option\\n   * @type {number}\\n   * @default 0\\n   */\\n  scrollTopOffset: 0,\\n\\n  /**\\n   * Scroll animation duration\\n   * @option\\n   * @type {number}\\n   * @default 500\\n   */\\n  animationDuration: 500,\\n\\n  /**\\n   * Scroll animation easing. Can be `'swing'` or `'linear'`.\\n   * @option\\n   * @type {string}\\n   * @see {@link https://api.jquery.com/animate|JQuery animate}\\n   * @default 'swing'\\n   */\\n  animationEasing: 'swing' // holdOpen: false\\n\\n};\\n\\n\\n//# sourceURL=webpack:///./js/foundation.drilldown.js?\");\n    }, \"./js/foundation.dropdown.js\": function jsFoundationDropdownJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Dropdown\\\", function() { return Dropdown; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.util.keyboard */ \\\"./js/foundation.util.keyboard.js\\\");\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.core.utils */ \\\"./js/foundation.core.utils.js\\\");\\n/* harmony import */ var _foundation_positionable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.positionable */ \\\"./js/foundation.positionable.js\\\");\\n/* harmony import */ var _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.util.triggers */ \\\"./js/foundation.util.triggers.js\\\");\\n\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _get(target, property, receiver) { if (typeof Reflect !== \\\"undefined\\\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\\n\\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n\\n\\n\\n\\n\\n/**\\n * Dropdown module.\\n * @module foundation.dropdown\\n * @requires foundation.util.keyboard\\n * @requires foundation.util.box\\n * @requires foundation.util.triggers\\n */\\n\\nvar Dropdown =\\n/*#__PURE__*/\\nfunction (_Positionable) {\\n  _inherits(Dropdown, _Positionable);\\n\\n  function Dropdown() {\\n    _classCallCheck(this, Dropdown);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(Dropdown).apply(this, arguments));\\n  }\\n\\n  _createClass(Dropdown, [{\\n    key: \\\"_setup\\\",\\n\\n    /**\\n     * Creates a new instance of a dropdown.\\n     * @class\\n     * @name Dropdown\\n     * @param {jQuery} element - jQuery object to make into a dropdown.\\n     *        Object should be of the dropdown panel, rather than its anchor.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, Dropdown.defaults, this.$element.data(), options);\\n      this.className = 'Dropdown'; // ie9 back compat\\n      // Triggers init is idempotent, just need to make sure it is initialized\\n\\n      _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_4__[\\\"Triggers\\\"].init(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\\n\\n      this._init();\\n\\n      _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\\\"Keyboard\\\"].register('Dropdown', {\\n        'ENTER': 'toggle',\\n        'SPACE': 'toggle',\\n        'ESCAPE': 'close'\\n      });\\n    }\\n    /**\\n     * Initializes the plugin by setting/checking options and attributes, adding helper variables, and saving the anchor.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_init\\\",\\n    value: function _init() {\\n      var $id = this.$element.attr('id');\\n      this.$anchors = jquery__WEBPACK_IMPORTED_MODULE_0___default()(\\\"[data-toggle=\\\\\\\"\\\".concat($id, \\\"\\\\\\\"]\\\")).length ? jquery__WEBPACK_IMPORTED_MODULE_0___default()(\\\"[data-toggle=\\\\\\\"\\\".concat($id, \\\"\\\\\\\"]\\\")) : jquery__WEBPACK_IMPORTED_MODULE_0___default()(\\\"[data-open=\\\\\\\"\\\".concat($id, \\\"\\\\\\\"]\\\"));\\n      this.$anchors.attr({\\n        'aria-controls': $id,\\n        'data-is-focus': false,\\n        'data-yeti-box': $id,\\n        'aria-haspopup': true,\\n        'aria-expanded': false\\n      });\\n\\n      this._setCurrentAnchor(this.$anchors.first());\\n\\n      if (this.options.parentClass) {\\n        this.$parent = this.$element.parents('.' + this.options.parentClass);\\n      } else {\\n        this.$parent = null;\\n      } // Set [aria-labelledby] on the Dropdown if it is not set\\n\\n\\n      if (typeof this.$element.attr('aria-labelledby') === 'undefined') {\\n        // Get the anchor ID or create one\\n        if (typeof this.$currentAnchor.attr('id') === 'undefined') {\\n          this.$currentAnchor.attr('id', Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\\\"GetYoDigits\\\"])(6, 'dd-anchor'));\\n        }\\n\\n        ;\\n        this.$element.attr('aria-labelledby', this.$currentAnchor.attr('id'));\\n      }\\n\\n      this.$element.attr({\\n        'aria-hidden': 'true',\\n        'data-yeti-box': $id,\\n        'data-resize': $id\\n      });\\n\\n      _get(_getPrototypeOf(Dropdown.prototype), \\\"_init\\\", this).call(this);\\n\\n      this._events();\\n    }\\n  }, {\\n    key: \\\"_getDefaultPosition\\\",\\n    value: function _getDefaultPosition() {\\n      // handle legacy classnames\\n      var position = this.$element[0].className.match(/(top|left|right|bottom)/g);\\n\\n      if (position) {\\n        return position[0];\\n      } else {\\n        return 'bottom';\\n      }\\n    }\\n  }, {\\n    key: \\\"_getDefaultAlignment\\\",\\n    value: function _getDefaultAlignment() {\\n      // handle legacy float approach\\n      var horizontalPosition = /float-(\\\\S+)/.exec(this.$currentAnchor.attr('class'));\\n\\n      if (horizontalPosition) {\\n        return horizontalPosition[1];\\n      }\\n\\n      return _get(_getPrototypeOf(Dropdown.prototype), \\\"_getDefaultAlignment\\\", this).call(this);\\n    }\\n    /**\\n     * Sets the position and orientation of the dropdown pane, checks for collisions if allow-overlap is not true.\\n     * Recursively calls itself if a collision is detected, with a new position class.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_setPosition\\\",\\n    value: function _setPosition() {\\n      this.$element.removeClass(\\\"has-position-\\\".concat(this.position, \\\" has-alignment-\\\").concat(this.alignment));\\n\\n      _get(_getPrototypeOf(Dropdown.prototype), \\\"_setPosition\\\", this).call(this, this.$currentAnchor, this.$element, this.$parent);\\n\\n      this.$element.addClass(\\\"has-position-\\\".concat(this.position, \\\" has-alignment-\\\").concat(this.alignment));\\n    }\\n    /**\\n     * Make it a current anchor.\\n     * Current anchor as the reference for the position of Dropdown panes.\\n     * @param {HTML} el - DOM element of the anchor.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_setCurrentAnchor\\\",\\n    value: function _setCurrentAnchor(el) {\\n      this.$currentAnchor = jquery__WEBPACK_IMPORTED_MODULE_0___default()(el);\\n    }\\n    /**\\n     * Adds event listeners to the element utilizing the triggers utility library.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_events\\\",\\n    value: function _events() {\\n      var _this = this;\\n\\n      this.$element.on({\\n        'open.zf.trigger': this.open.bind(this),\\n        'close.zf.trigger': this.close.bind(this),\\n        'toggle.zf.trigger': this.toggle.bind(this),\\n        'resizeme.zf.trigger': this._setPosition.bind(this)\\n      });\\n      this.$anchors.off('click.zf.trigger').on('click.zf.trigger', function () {\\n        _this._setCurrentAnchor(this);\\n      });\\n\\n      if (this.options.hover) {\\n        this.$anchors.off('mouseenter.zf.dropdown mouseleave.zf.dropdown').on('mouseenter.zf.dropdown', function () {\\n          _this._setCurrentAnchor(this);\\n\\n          var bodyData = jquery__WEBPACK_IMPORTED_MODULE_0___default()('body').data();\\n\\n          if (typeof bodyData.whatinput === 'undefined' || bodyData.whatinput === 'mouse') {\\n            clearTimeout(_this.timeout);\\n            _this.timeout = setTimeout(function () {\\n              _this.open();\\n\\n              _this.$anchors.data('hover', true);\\n            }, _this.options.hoverDelay);\\n          }\\n        }).on('mouseleave.zf.dropdown', Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\\\"ignoreMousedisappear\\\"])(function () {\\n          clearTimeout(_this.timeout);\\n          _this.timeout = setTimeout(function () {\\n            _this.close();\\n\\n            _this.$anchors.data('hover', false);\\n          }, _this.options.hoverDelay);\\n        }));\\n\\n        if (this.options.hoverPane) {\\n          this.$element.off('mouseenter.zf.dropdown mouseleave.zf.dropdown').on('mouseenter.zf.dropdown', function () {\\n            clearTimeout(_this.timeout);\\n          }).on('mouseleave.zf.dropdown', Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\\\"ignoreMousedisappear\\\"])(function () {\\n            clearTimeout(_this.timeout);\\n            _this.timeout = setTimeout(function () {\\n              _this.close();\\n\\n              _this.$anchors.data('hover', false);\\n            }, _this.options.hoverDelay);\\n          }));\\n        }\\n      }\\n\\n      this.$anchors.add(this.$element).on('keydown.zf.dropdown', function (e) {\\n        var $target = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\\n            visibleFocusableElements = _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\\\"Keyboard\\\"].findFocusable(_this.$element);\\n        _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\\\"Keyboard\\\"].handleKey(e, 'Dropdown', {\\n          open: function open() {\\n            if ($target.is(_this.$anchors) && !$target.is('input, textarea')) {\\n              _this.open();\\n\\n              _this.$element.attr('tabindex', -1).focus();\\n\\n              e.preventDefault();\\n            }\\n          },\\n          close: function close() {\\n            _this.close();\\n\\n            _this.$anchors.focus();\\n          }\\n        });\\n      });\\n    }\\n    /**\\n     * Adds an event handler to the body to close any dropdowns on a click.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_addBodyHandler\\\",\\n    value: function _addBodyHandler() {\\n      var $body = jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body).not(this.$element),\\n          _this = this;\\n\\n      $body.off('click.zf.dropdown').on('click.zf.dropdown', function (e) {\\n        if (_this.$anchors.is(e.target) || _this.$anchors.find(e.target).length) {\\n          return;\\n        }\\n\\n        if (_this.$element.is(e.target) || _this.$element.find(e.target).length) {\\n          return;\\n        }\\n\\n        _this.close();\\n\\n        $body.off('click.zf.dropdown');\\n      });\\n    }\\n    /**\\n     * Opens the dropdown pane, and fires a bubbling event to close other dropdowns.\\n     * @function\\n     * @fires Dropdown#closeme\\n     * @fires Dropdown#show\\n     */\\n\\n  }, {\\n    key: \\\"open\\\",\\n    value: function open() {\\n      // var _this = this;\\n\\n      /**\\n       * Fires to close other open dropdowns, typically when dropdown is opening\\n       * @event Dropdown#closeme\\n       */\\n      this.$element.trigger('closeme.zf.dropdown', this.$element.attr('id'));\\n      this.$anchors.addClass('hover').attr({\\n        'aria-expanded': true\\n      }); // this.$element/*.show()*/;\\n\\n      this.$element.addClass('is-opening');\\n\\n      this._setPosition();\\n\\n      this.$element.removeClass('is-opening').addClass('is-open').attr({\\n        'aria-hidden': false\\n      });\\n\\n      if (this.options.autoFocus) {\\n        var $focusable = _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\\\"Keyboard\\\"].findFocusable(this.$element);\\n\\n        if ($focusable.length) {\\n          $focusable.eq(0).focus();\\n        }\\n      }\\n\\n      if (this.options.closeOnClick) {\\n        this._addBodyHandler();\\n      }\\n\\n      if (this.options.trapFocus) {\\n        _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\\\"Keyboard\\\"].trapFocus(this.$element);\\n      }\\n      /**\\n       * Fires once the dropdown is visible.\\n       * @event Dropdown#show\\n       */\\n\\n\\n      this.$element.trigger('show.zf.dropdown', [this.$element]);\\n    }\\n    /**\\n     * Closes the open dropdown pane.\\n     * @function\\n     * @fires Dropdown#hide\\n     */\\n\\n  }, {\\n    key: \\\"close\\\",\\n    value: function close() {\\n      if (!this.$element.hasClass('is-open')) {\\n        return false;\\n      }\\n\\n      this.$element.removeClass('is-open').attr({\\n        'aria-hidden': true\\n      });\\n      this.$anchors.removeClass('hover').attr('aria-expanded', false);\\n      /**\\n       * Fires once the dropdown is no longer visible.\\n       * @event Dropdown#hide\\n       */\\n\\n      this.$element.trigger('hide.zf.dropdown', [this.$element]);\\n\\n      if (this.options.trapFocus) {\\n        _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\\\"Keyboard\\\"].releaseFocus(this.$element);\\n      }\\n    }\\n    /**\\n     * Toggles the dropdown pane's visibility.\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"toggle\\\",\\n    value: function toggle() {\\n      if (this.$element.hasClass('is-open')) {\\n        if (this.$anchors.data('hover')) return;\\n        this.close();\\n      } else {\\n        this.open();\\n      }\\n    }\\n    /**\\n     * Destroys the dropdown.\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"_destroy\\\",\\n    value: function _destroy() {\\n      this.$element.off('.zf.trigger').hide();\\n      this.$anchors.off('.zf.dropdown');\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body).off('click.zf.dropdown');\\n    }\\n  }]);\\n\\n  return Dropdown;\\n}(_foundation_positionable__WEBPACK_IMPORTED_MODULE_3__[\\\"Positionable\\\"]);\\n\\nDropdown.defaults = {\\n  /**\\n   * Class that designates bounding container of Dropdown (default: window)\\n   * @option\\n   * @type {?string}\\n   * @default null\\n   */\\n  parentClass: null,\\n\\n  /**\\n   * Amount of time to delay opening a submenu on hover event.\\n   * @option\\n   * @type {number}\\n   * @default 250\\n   */\\n  hoverDelay: 250,\\n\\n  /**\\n   * Allow submenus to open on hover events\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  hover: false,\\n\\n  /**\\n   * Don't close dropdown when hovering over dropdown pane\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  hoverPane: false,\\n\\n  /**\\n   * Number of pixels between the dropdown pane and the triggering element on open.\\n   * @option\\n   * @type {number}\\n   * @default 0\\n   */\\n  vOffset: 0,\\n\\n  /**\\n   * Number of pixels between the dropdown pane and the triggering element on open.\\n   * @option\\n   * @type {number}\\n   * @default 0\\n   */\\n  hOffset: 0,\\n\\n  /**\\n   * Position of dropdown. Can be left, right, bottom, top, or auto.\\n   * @option\\n   * @type {string}\\n   * @default 'auto'\\n   */\\n  position: 'auto',\\n\\n  /**\\n   * Alignment of dropdown relative to anchor. Can be left, right, bottom, top, center, or auto.\\n   * @option\\n   * @type {string}\\n   * @default 'auto'\\n   */\\n  alignment: 'auto',\\n\\n  /**\\n   * Allow overlap of container/window. If false, dropdown will first try to position as defined by data-position and data-alignment, but reposition if it would cause an overflow.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  allowOverlap: false,\\n\\n  /**\\n   * Allow overlap of only the bottom of the container. This is the most common\\n   * behavior for dropdowns, allowing the dropdown to extend the bottom of the\\n   * screen but not otherwise influence or break out of the container.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  allowBottomOverlap: true,\\n\\n  /**\\n   * Allow the plugin to trap focus to the dropdown pane if opened with keyboard commands.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  trapFocus: false,\\n\\n  /**\\n   * Allow the plugin to set focus to the first focusable element within the pane, regardless of method of opening.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  autoFocus: false,\\n\\n  /**\\n   * Allows a click on the body to close the dropdown.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  closeOnClick: false\\n};\\n\\n\\n//# sourceURL=webpack:///./js/foundation.dropdown.js?\");\n    }, \"./js/foundation.dropdownMenu.js\": function jsFoundationDropdownMenuJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DropdownMenu\\\", function() { return DropdownMenu; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.plugin */ \\\"./js/foundation.core.plugin.js\\\");\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.core.utils */ \\\"./js/foundation.core.utils.js\\\");\\n/* harmony import */ var _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.util.keyboard */ \\\"./js/foundation.util.keyboard.js\\\");\\n/* harmony import */ var _foundation_util_nest__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.util.nest */ \\\"./js/foundation.util.nest.js\\\");\\n/* harmony import */ var _foundation_util_box__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./foundation.util.box */ \\\"./js/foundation.util.box.js\\\");\\n\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * DropdownMenu module.\\n * @module foundation.dropdown-menu\\n * @requires foundation.util.keyboard\\n * @requires foundation.util.box\\n * @requires foundation.util.nest\\n */\\n\\nvar DropdownMenu =\\n/*#__PURE__*/\\nfunction (_Plugin) {\\n  _inherits(DropdownMenu, _Plugin);\\n\\n  function DropdownMenu() {\\n    _classCallCheck(this, DropdownMenu);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(DropdownMenu).apply(this, arguments));\\n  }\\n\\n  _createClass(DropdownMenu, [{\\n    key: \\\"_setup\\\",\\n\\n    /**\\n     * Creates a new instance of DropdownMenu.\\n     * @class\\n     * @name DropdownMenu\\n     * @fires DropdownMenu#init\\n     * @param {jQuery} element - jQuery object to make into a dropdown menu.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, DropdownMenu.defaults, this.$element.data(), options);\\n      this.className = 'DropdownMenu'; // ie9 back compat\\n\\n      this._init();\\n\\n      _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_3__[\\\"Keyboard\\\"].register('DropdownMenu', {\\n        'ENTER': 'open',\\n        'SPACE': 'open',\\n        'ARROW_RIGHT': 'next',\\n        'ARROW_UP': 'up',\\n        'ARROW_DOWN': 'down',\\n        'ARROW_LEFT': 'previous',\\n        'ESCAPE': 'close'\\n      });\\n    }\\n    /**\\n     * Initializes the plugin, and calls _prepareMenu\\n     * @private\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"_init\\\",\\n    value: function _init() {\\n      _foundation_util_nest__WEBPACK_IMPORTED_MODULE_4__[\\\"Nest\\\"].Feather(this.$element, 'dropdown');\\n      var subs = this.$element.find('li.is-dropdown-submenu-parent');\\n      this.$element.children('.is-dropdown-submenu-parent').children('.is-dropdown-submenu').addClass('first-sub');\\n      this.$menuItems = this.$element.find('[role=\\\"menuitem\\\"]');\\n      this.$tabs = this.$element.children('[role=\\\"menuitem\\\"]');\\n      this.$tabs.find('ul.is-dropdown-submenu').addClass(this.options.verticalClass);\\n\\n      if (this.options.alignment === 'auto') {\\n        if (this.$element.hasClass(this.options.rightClass) || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\\\"rtl\\\"])() || this.$element.parents('.top-bar-right').is('*')) {\\n          this.options.alignment = 'right';\\n          subs.addClass('opens-left');\\n        } else {\\n          this.options.alignment = 'left';\\n          subs.addClass('opens-right');\\n        }\\n      } else {\\n        if (this.options.alignment === 'right') {\\n          subs.addClass('opens-left');\\n        } else {\\n          subs.addClass('opens-right');\\n        }\\n      }\\n\\n      this.changed = false;\\n\\n      this._events();\\n    }\\n  }, {\\n    key: \\\"_isVertical\\\",\\n    value: function _isVertical() {\\n      return this.$tabs.css('display') === 'block' || this.$element.css('flex-direction') === 'column';\\n    }\\n  }, {\\n    key: \\\"_isRtl\\\",\\n    value: function _isRtl() {\\n      return this.$element.hasClass('align-right') || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\\\"rtl\\\"])() && !this.$element.hasClass('align-left');\\n    }\\n    /**\\n     * Adds event listeners to elements within the menu\\n     * @private\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"_events\\\",\\n    value: function _events() {\\n      var _this = this,\\n          hasTouch = 'ontouchstart' in window || typeof window.ontouchstart !== 'undefined',\\n          parClass = 'is-dropdown-submenu-parent'; // used for onClick and in the keyboard handlers\\n\\n\\n      var handleClickFn = function handleClickFn(e) {\\n        var $elem = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).parentsUntil('ul', \\\".\\\".concat(parClass)),\\n            hasSub = $elem.hasClass(parClass),\\n            hasClicked = $elem.attr('data-is-click') === 'true',\\n            $sub = $elem.children('.is-dropdown-submenu');\\n\\n        if (hasSub) {\\n          if (hasClicked) {\\n            if (!_this.options.closeOnClick || !_this.options.clickOpen && !hasTouch || _this.options.forceFollow && hasTouch) {\\n              return;\\n            } else {\\n              e.stopImmediatePropagation();\\n              e.preventDefault();\\n\\n              _this._hide($elem);\\n            }\\n          } else {\\n            e.preventDefault();\\n            e.stopImmediatePropagation();\\n\\n            _this._show($sub);\\n\\n            $elem.add($elem.parentsUntil(_this.$element, \\\".\\\".concat(parClass))).attr('data-is-click', true);\\n          }\\n        }\\n      };\\n\\n      if (this.options.clickOpen || hasTouch) {\\n        this.$menuItems.on('click.zf.dropdownmenu touchstart.zf.dropdownmenu', handleClickFn);\\n      } // Handle Leaf element Clicks\\n\\n\\n      if (_this.options.closeOnClickInside) {\\n        this.$menuItems.on('click.zf.dropdownmenu', function (e) {\\n          var $elem = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\\n              hasSub = $elem.hasClass(parClass);\\n\\n          if (!hasSub) {\\n            _this._hide();\\n          }\\n        });\\n      }\\n\\n      if (!this.options.disableHover) {\\n        this.$menuItems.on('mouseenter.zf.dropdownmenu', function (e) {\\n          var $elem = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\\n              hasSub = $elem.hasClass(parClass);\\n\\n          if (hasSub) {\\n            clearTimeout($elem.data('_delay'));\\n            $elem.data('_delay', setTimeout(function () {\\n              _this._show($elem.children('.is-dropdown-submenu'));\\n            }, _this.options.hoverDelay));\\n          }\\n        }).on('mouseleave.zf.dropdownMenu', Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\\\"ignoreMousedisappear\\\"])(function (e) {\\n          var $elem = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\\n              hasSub = $elem.hasClass(parClass);\\n\\n          if (hasSub && _this.options.autoclose) {\\n            if ($elem.attr('data-is-click') === 'true' && _this.options.clickOpen) {\\n              return false;\\n            }\\n\\n            clearTimeout($elem.data('_delay'));\\n            $elem.data('_delay', setTimeout(function () {\\n              _this._hide($elem);\\n            }, _this.options.closingTime));\\n          }\\n        }));\\n      }\\n\\n      this.$menuItems.on('keydown.zf.dropdownmenu', function (e) {\\n        var $element = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).parentsUntil('ul', '[role=\\\"menuitem\\\"]'),\\n            isTab = _this.$tabs.index($element) > -1,\\n            $elements = isTab ? _this.$tabs : $element.siblings('li').add($element),\\n            $prevElement,\\n            $nextElement;\\n        $elements.each(function (i) {\\n          if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).is($element)) {\\n            $prevElement = $elements.eq(i - 1);\\n            $nextElement = $elements.eq(i + 1);\\n            return;\\n          }\\n        });\\n\\n        var nextSibling = function nextSibling() {\\n          $nextElement.children('a:first').focus();\\n          e.preventDefault();\\n        },\\n            prevSibling = function prevSibling() {\\n          $prevElement.children('a:first').focus();\\n          e.preventDefault();\\n        },\\n            openSub = function openSub() {\\n          var $sub = $element.children('ul.is-dropdown-submenu');\\n\\n          if ($sub.length) {\\n            _this._show($sub);\\n\\n            $element.find('li > a:first').focus();\\n            e.preventDefault();\\n          } else {\\n            return;\\n          }\\n        },\\n            closeSub = function closeSub() {\\n          //if ($element.is(':first-child')) {\\n          var close = $element.parent('ul').parent('li');\\n          close.children('a:first').focus();\\n\\n          _this._hide(close);\\n\\n          e.preventDefault(); //}\\n        };\\n\\n        var functions = {\\n          open: openSub,\\n          close: function close() {\\n            _this._hide(_this.$element);\\n\\n            _this.$menuItems.eq(0).children('a').focus(); // focus to first element\\n\\n\\n            e.preventDefault();\\n          },\\n          handled: function handled() {\\n            e.stopImmediatePropagation();\\n          }\\n        };\\n\\n        if (isTab) {\\n          if (_this._isVertical()) {\\n            // vertical menu\\n            if (_this._isRtl()) {\\n              // right aligned\\n              jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend(functions, {\\n                down: nextSibling,\\n                up: prevSibling,\\n                next: closeSub,\\n                previous: openSub\\n              });\\n            } else {\\n              // left aligned\\n              jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend(functions, {\\n                down: nextSibling,\\n                up: prevSibling,\\n                next: openSub,\\n                previous: closeSub\\n              });\\n            }\\n          } else {\\n            // horizontal menu\\n            if (_this._isRtl()) {\\n              // right aligned\\n              jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend(functions, {\\n                next: prevSibling,\\n                previous: nextSibling,\\n                down: openSub,\\n                up: closeSub\\n              });\\n            } else {\\n              // left aligned\\n              jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend(functions, {\\n                next: nextSibling,\\n                previous: prevSibling,\\n                down: openSub,\\n                up: closeSub\\n              });\\n            }\\n          }\\n        } else {\\n          // not tabs -> one sub\\n          if (_this._isRtl()) {\\n            // right aligned\\n            jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend(functions, {\\n              next: closeSub,\\n              previous: openSub,\\n              down: nextSibling,\\n              up: prevSibling\\n            });\\n          } else {\\n            // left aligned\\n            jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend(functions, {\\n              next: openSub,\\n              previous: closeSub,\\n              down: nextSibling,\\n              up: prevSibling\\n            });\\n          }\\n        }\\n\\n        _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_3__[\\\"Keyboard\\\"].handleKey(e, 'DropdownMenu', functions);\\n      });\\n    }\\n    /**\\n     * Adds an event handler to the body to close any dropdowns on a click.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_addBodyHandler\\\",\\n    value: function _addBodyHandler() {\\n      var $body = jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body),\\n          _this = this;\\n\\n      $body.off('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu').on('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu', function (e) {\\n        var $link = _this.$element.find(e.target);\\n\\n        if ($link.length) {\\n          return;\\n        }\\n\\n        _this._hide();\\n\\n        $body.off('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu');\\n      });\\n    }\\n    /**\\n     * Opens a dropdown pane, and checks for collisions first.\\n     * @param {jQuery} $sub - ul element that is a submenu to show\\n     * @function\\n     * @private\\n     * @fires Dropdownmenu#show\\n     */\\n\\n  }, {\\n    key: \\\"_show\\\",\\n    value: function _show($sub) {\\n      var idx = this.$tabs.index(this.$tabs.filter(function (i, el) {\\n        return jquery__WEBPACK_IMPORTED_MODULE_0___default()(el).find($sub).length > 0;\\n      }));\\n      var $sibs = $sub.parent('li.is-dropdown-submenu-parent').siblings('li.is-dropdown-submenu-parent');\\n\\n      this._hide($sibs, idx);\\n\\n      $sub.css('visibility', 'hidden').addClass('js-dropdown-active').parent('li.is-dropdown-submenu-parent').addClass('is-active');\\n      var clear = _foundation_util_box__WEBPACK_IMPORTED_MODULE_5__[\\\"Box\\\"].ImNotTouchingYou($sub, null, true);\\n\\n      if (!clear) {\\n        var oldClass = this.options.alignment === 'left' ? '-right' : '-left',\\n            $parentLi = $sub.parent('.is-dropdown-submenu-parent');\\n        $parentLi.removeClass(\\\"opens\\\".concat(oldClass)).addClass(\\\"opens-\\\".concat(this.options.alignment));\\n        clear = _foundation_util_box__WEBPACK_IMPORTED_MODULE_5__[\\\"Box\\\"].ImNotTouchingYou($sub, null, true);\\n\\n        if (!clear) {\\n          $parentLi.removeClass(\\\"opens-\\\".concat(this.options.alignment)).addClass('opens-inner');\\n        }\\n\\n        this.changed = true;\\n      }\\n\\n      $sub.css('visibility', '');\\n\\n      if (this.options.closeOnClick) {\\n        this._addBodyHandler();\\n      }\\n      /**\\n       * Fires when the new dropdown pane is visible.\\n       * @event Dropdownmenu#show\\n       */\\n\\n\\n      this.$element.trigger('show.zf.dropdownmenu', [$sub]);\\n    }\\n    /**\\n     * Hides a single, currently open dropdown pane, if passed a parameter, otherwise, hides everything.\\n     * @function\\n     * @param {jQuery} $elem - element with a submenu to hide\\n     * @param {Number} idx - index of the $tabs collection to hide\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_hide\\\",\\n    value: function _hide($elem, idx) {\\n      var $toClose;\\n\\n      if ($elem && $elem.length) {\\n        $toClose = $elem;\\n      } else if (typeof idx !== 'undefined') {\\n        $toClose = this.$tabs.not(function (i, el) {\\n          return i === idx;\\n        });\\n      } else {\\n        $toClose = this.$element;\\n      }\\n\\n      var somethingToClose = $toClose.hasClass('is-active') || $toClose.find('.is-active').length > 0;\\n\\n      if (somethingToClose) {\\n        $toClose.find('li.is-active').add($toClose).attr({\\n          'data-is-click': false\\n        }).removeClass('is-active');\\n        $toClose.find('ul.js-dropdown-active').removeClass('js-dropdown-active');\\n\\n        if (this.changed || $toClose.find('opens-inner').length) {\\n          var oldClass = this.options.alignment === 'left' ? 'right' : 'left';\\n          $toClose.find('li.is-dropdown-submenu-parent').add($toClose).removeClass(\\\"opens-inner opens-\\\".concat(this.options.alignment)).addClass(\\\"opens-\\\".concat(oldClass));\\n          this.changed = false;\\n        }\\n        /**\\n         * Fires when the open menus are closed.\\n         * @event Dropdownmenu#hide\\n         */\\n\\n\\n        this.$element.trigger('hide.zf.dropdownmenu', [$toClose]);\\n      }\\n    }\\n    /**\\n     * Destroys the plugin.\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"_destroy\\\",\\n    value: function _destroy() {\\n      this.$menuItems.off('.zf.dropdownmenu').removeAttr('data-is-click').removeClass('is-right-arrow is-left-arrow is-down-arrow opens-right opens-left opens-inner');\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body).off('.zf.dropdownmenu');\\n      _foundation_util_nest__WEBPACK_IMPORTED_MODULE_4__[\\\"Nest\\\"].Burn(this.$element, 'dropdown');\\n    }\\n  }]);\\n\\n  return DropdownMenu;\\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_1__[\\\"Plugin\\\"]);\\n/**\\n * Default settings for plugin\\n */\\n\\n\\nDropdownMenu.defaults = {\\n  /**\\n   * Disallows hover events from opening submenus\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  disableHover: false,\\n\\n  /**\\n   * Allow a submenu to automatically close on a mouseleave event, if not clicked open.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  autoclose: true,\\n\\n  /**\\n   * Amount of time to delay opening a submenu on hover event.\\n   * @option\\n   * @type {number}\\n   * @default 50\\n   */\\n  hoverDelay: 50,\\n\\n  /**\\n   * Allow a submenu to open/remain open on parent click event. Allows cursor to move away from menu.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  clickOpen: false,\\n\\n  /**\\n   * Amount of time to delay closing a submenu on a mouseleave event.\\n   * @option\\n   * @type {number}\\n   * @default 500\\n   */\\n  closingTime: 500,\\n\\n  /**\\n   * Position of the menu relative to what direction the submenus should open. Handled by JS. Can be `'auto'`, `'left'` or `'right'`.\\n   * @option\\n   * @type {string}\\n   * @default 'auto'\\n   */\\n  alignment: 'auto',\\n\\n  /**\\n   * Allow clicks on the body to close any open submenus.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  closeOnClick: true,\\n\\n  /**\\n   * Allow clicks on leaf anchor links to close any open submenus.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  closeOnClickInside: true,\\n\\n  /**\\n   * Class applied to vertical oriented menus, Foundation default is `vertical`. Update this if using your own class.\\n   * @option\\n   * @type {string}\\n   * @default 'vertical'\\n   */\\n  verticalClass: 'vertical',\\n\\n  /**\\n   * Class applied to right-side oriented menus, Foundation default is `align-right`. Update this if using your own class.\\n   * @option\\n   * @type {string}\\n   * @default 'align-right'\\n   */\\n  rightClass: 'align-right',\\n\\n  /**\\n   * Boolean to force overide the clicking of links to perform default action, on second touch event for mobile.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  forceFollow: true\\n};\\n\\n\\n//# sourceURL=webpack:///./js/foundation.dropdownMenu.js?\");\n    }, \"./js/foundation.equalizer.js\": function jsFoundationEqualizerJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Equalizer\\\", function() { return Equalizer; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.util.mediaQuery */ \\\"./js/foundation.util.mediaQuery.js\\\");\\n/* harmony import */ var _foundation_util_imageLoader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.util.imageLoader */ \\\"./js/foundation.util.imageLoader.js\\\");\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.core.utils */ \\\"./js/foundation.core.utils.js\\\");\\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.core.plugin */ \\\"./js/foundation.core.plugin.js\\\");\\n\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n\\n\\n\\n\\n\\n/**\\n * Equalizer module.\\n * @module foundation.equalizer\\n * @requires foundation.util.mediaQuery\\n * @requires foundation.util.imageLoader if equalizer contains images\\n */\\n\\nvar Equalizer =\\n/*#__PURE__*/\\nfunction (_Plugin) {\\n  _inherits(Equalizer, _Plugin);\\n\\n  function Equalizer() {\\n    _classCallCheck(this, Equalizer);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(Equalizer).apply(this, arguments));\\n  }\\n\\n  _createClass(Equalizer, [{\\n    key: \\\"_setup\\\",\\n\\n    /**\\n     * Creates a new instance of Equalizer.\\n     * @class\\n     * @name Equalizer\\n     * @fires Equalizer#init\\n     * @param {Object} element - jQuery object to add the trigger to.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, Equalizer.defaults, this.$element.data(), options);\\n      this.className = 'Equalizer'; // ie9 back compat\\n\\n      this._init();\\n    }\\n    /**\\n     * Initializes the Equalizer plugin and calls functions to get equalizer functioning on load.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_init\\\",\\n    value: function _init() {\\n      var eqId = this.$element.attr('data-equalizer') || '';\\n      var $watched = this.$element.find(\\\"[data-equalizer-watch=\\\\\\\"\\\".concat(eqId, \\\"\\\\\\\"]\\\"));\\n\\n      _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__[\\\"MediaQuery\\\"]._init();\\n\\n      this.$watched = $watched.length ? $watched : this.$element.find('[data-equalizer-watch]');\\n      this.$element.attr('data-resize', eqId || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\\\"GetYoDigits\\\"])(6, 'eq'));\\n      this.$element.attr('data-mutate', eqId || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\\\"GetYoDigits\\\"])(6, 'eq'));\\n      this.hasNested = this.$element.find('[data-equalizer]').length > 0;\\n      this.isNested = this.$element.parentsUntil(document.body, '[data-equalizer]').length > 0;\\n      this.isOn = false;\\n      this._bindHandler = {\\n        onResizeMeBound: this._onResizeMe.bind(this),\\n        onPostEqualizedBound: this._onPostEqualized.bind(this)\\n      };\\n      var imgs = this.$element.find('img');\\n      var tooSmall;\\n\\n      if (this.options.equalizeOn) {\\n        tooSmall = this._checkMQ();\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on('changed.zf.mediaquery', this._checkMQ.bind(this));\\n      } else {\\n        this._events();\\n      }\\n\\n      if (typeof tooSmall !== 'undefined' && tooSmall === false || typeof tooSmall === 'undefined') {\\n        if (imgs.length) {\\n          Object(_foundation_util_imageLoader__WEBPACK_IMPORTED_MODULE_2__[\\\"onImagesLoaded\\\"])(imgs, this._reflow.bind(this));\\n        } else {\\n          this._reflow();\\n        }\\n      }\\n    }\\n    /**\\n     * Removes event listeners if the breakpoint is too small.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_pauseEvents\\\",\\n    value: function _pauseEvents() {\\n      this.isOn = false;\\n      this.$element.off({\\n        '.zf.equalizer': this._bindHandler.onPostEqualizedBound,\\n        'resizeme.zf.trigger': this._bindHandler.onResizeMeBound,\\n        'mutateme.zf.trigger': this._bindHandler.onResizeMeBound\\n      });\\n    }\\n    /**\\n     * function to handle $elements resizeme.zf.trigger, with bound this on _bindHandler.onResizeMeBound\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_onResizeMe\\\",\\n    value: function _onResizeMe(e) {\\n      this._reflow();\\n    }\\n    /**\\n     * function to handle $elements postequalized.zf.equalizer, with bound this on _bindHandler.onPostEqualizedBound\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_onPostEqualized\\\",\\n    value: function _onPostEqualized(e) {\\n      if (e.target !== this.$element[0]) {\\n        this._reflow();\\n      }\\n    }\\n    /**\\n     * Initializes events for Equalizer.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_events\\\",\\n    value: function _events() {\\n      var _this = this;\\n\\n      this._pauseEvents();\\n\\n      if (this.hasNested) {\\n        this.$element.on('postequalized.zf.equalizer', this._bindHandler.onPostEqualizedBound);\\n      } else {\\n        this.$element.on('resizeme.zf.trigger', this._bindHandler.onResizeMeBound);\\n        this.$element.on('mutateme.zf.trigger', this._bindHandler.onResizeMeBound);\\n      }\\n\\n      this.isOn = true;\\n    }\\n    /**\\n     * Checks the current breakpoint to the minimum required size.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_checkMQ\\\",\\n    value: function _checkMQ() {\\n      var tooSmall = !_foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__[\\\"MediaQuery\\\"].is(this.options.equalizeOn);\\n\\n      if (tooSmall) {\\n        if (this.isOn) {\\n          this._pauseEvents();\\n\\n          this.$watched.css('height', 'auto');\\n        }\\n      } else {\\n        if (!this.isOn) {\\n          this._events();\\n        }\\n      }\\n\\n      return tooSmall;\\n    }\\n    /**\\n     * A noop version for the plugin\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_killswitch\\\",\\n    value: function _killswitch() {\\n      return;\\n    }\\n    /**\\n     * Calls necessary functions to update Equalizer upon DOM change\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_reflow\\\",\\n    value: function _reflow() {\\n      if (!this.options.equalizeOnStack) {\\n        if (this._isStacked()) {\\n          this.$watched.css('height', 'auto');\\n          return false;\\n        }\\n      }\\n\\n      if (this.options.equalizeByRow) {\\n        this.getHeightsByRow(this.applyHeightByRow.bind(this));\\n      } else {\\n        this.getHeights(this.applyHeight.bind(this));\\n      }\\n    }\\n    /**\\n     * Manually determines if the first 2 elements are *NOT* stacked.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_isStacked\\\",\\n    value: function _isStacked() {\\n      if (!this.$watched[0] || !this.$watched[1]) {\\n        return true;\\n      }\\n\\n      return this.$watched[0].getBoundingClientRect().top !== this.$watched[1].getBoundingClientRect().top;\\n    }\\n    /**\\n     * Finds the outer heights of children contained within an Equalizer parent and returns them in an array\\n     * @param {Function} cb - A non-optional callback to return the heights array to.\\n     * @returns {Array} heights - An array of heights of children within Equalizer container\\n     */\\n\\n  }, {\\n    key: \\\"getHeights\\\",\\n    value: function getHeights(cb) {\\n      var heights = [];\\n\\n      for (var i = 0, len = this.$watched.length; i < len; i++) {\\n        this.$watched[i].style.height = 'auto';\\n        heights.push(this.$watched[i].offsetHeight);\\n      }\\n\\n      cb(heights);\\n    }\\n    /**\\n     * Finds the outer heights of children contained within an Equalizer parent and returns them in an array\\n     * @param {Function} cb - A non-optional callback to return the heights array to.\\n     * @returns {Array} groups - An array of heights of children within Equalizer container grouped by row with element,height and max as last child\\n     */\\n\\n  }, {\\n    key: \\\"getHeightsByRow\\\",\\n    value: function getHeightsByRow(cb) {\\n      var lastElTopOffset = this.$watched.length ? this.$watched.first().offset().top : 0,\\n          groups = [],\\n          group = 0; //group by Row\\n\\n      groups[group] = [];\\n\\n      for (var i = 0, len = this.$watched.length; i < len; i++) {\\n        this.$watched[i].style.height = 'auto'; //maybe could use this.$watched[i].offsetTop\\n\\n        var elOffsetTop = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this.$watched[i]).offset().top;\\n\\n        if (elOffsetTop != lastElTopOffset) {\\n          group++;\\n          groups[group] = [];\\n          lastElTopOffset = elOffsetTop;\\n        }\\n\\n        groups[group].push([this.$watched[i], this.$watched[i].offsetHeight]);\\n      }\\n\\n      for (var j = 0, ln = groups.length; j < ln; j++) {\\n        var heights = jquery__WEBPACK_IMPORTED_MODULE_0___default()(groups[j]).map(function () {\\n          return this[1];\\n        }).get();\\n        var max = Math.max.apply(null, heights);\\n        groups[j].push(max);\\n      }\\n\\n      cb(groups);\\n    }\\n    /**\\n     * Changes the CSS height property of each child in an Equalizer parent to match the tallest\\n     * @param {array} heights - An array of heights of children within Equalizer container\\n     * @fires Equalizer#preequalized\\n     * @fires Equalizer#postequalized\\n     */\\n\\n  }, {\\n    key: \\\"applyHeight\\\",\\n    value: function applyHeight(heights) {\\n      var max = Math.max.apply(null, heights);\\n      /**\\n       * Fires before the heights are applied\\n       * @event Equalizer#preequalized\\n       */\\n\\n      this.$element.trigger('preequalized.zf.equalizer');\\n      this.$watched.css('height', max);\\n      /**\\n       * Fires when the heights have been applied\\n       * @event Equalizer#postequalized\\n       */\\n\\n      this.$element.trigger('postequalized.zf.equalizer');\\n    }\\n    /**\\n     * Changes the CSS height property of each child in an Equalizer parent to match the tallest by row\\n     * @param {array} groups - An array of heights of children within Equalizer container grouped by row with element,height and max as last child\\n     * @fires Equalizer#preequalized\\n     * @fires Equalizer#preequalizedrow\\n     * @fires Equalizer#postequalizedrow\\n     * @fires Equalizer#postequalized\\n     */\\n\\n  }, {\\n    key: \\\"applyHeightByRow\\\",\\n    value: function applyHeightByRow(groups) {\\n      /**\\n       * Fires before the heights are applied\\n       */\\n      this.$element.trigger('preequalized.zf.equalizer');\\n\\n      for (var i = 0, len = groups.length; i < len; i++) {\\n        var groupsILength = groups[i].length,\\n            max = groups[i][groupsILength - 1];\\n\\n        if (groupsILength <= 2) {\\n          jquery__WEBPACK_IMPORTED_MODULE_0___default()(groups[i][0][0]).css({\\n            'height': 'auto'\\n          });\\n          continue;\\n        }\\n        /**\\n          * Fires before the heights per row are applied\\n          * @event Equalizer#preequalizedrow\\n          */\\n\\n\\n        this.$element.trigger('preequalizedrow.zf.equalizer');\\n\\n        for (var j = 0, lenJ = groupsILength - 1; j < lenJ; j++) {\\n          jquery__WEBPACK_IMPORTED_MODULE_0___default()(groups[i][j][0]).css({\\n            'height': max\\n          });\\n        }\\n        /**\\n          * Fires when the heights per row have been applied\\n          * @event Equalizer#postequalizedrow\\n          */\\n\\n\\n        this.$element.trigger('postequalizedrow.zf.equalizer');\\n      }\\n      /**\\n       * Fires when the heights have been applied\\n       */\\n\\n\\n      this.$element.trigger('postequalized.zf.equalizer');\\n    }\\n    /**\\n     * Destroys an instance of Equalizer.\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"_destroy\\\",\\n    value: function _destroy() {\\n      this._pauseEvents();\\n\\n      this.$watched.css('height', 'auto');\\n    }\\n  }]);\\n\\n  return Equalizer;\\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_4__[\\\"Plugin\\\"]);\\n/**\\n * Default settings for plugin\\n */\\n\\n\\nEqualizer.defaults = {\\n  /**\\n   * Enable height equalization when stacked on smaller screens.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  equalizeOnStack: false,\\n\\n  /**\\n   * Enable height equalization row by row.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  equalizeByRow: false,\\n\\n  /**\\n   * String representing the minimum breakpoint size the plugin should equalize heights on.\\n   * @option\\n   * @type {string}\\n   * @default ''\\n   */\\n  equalizeOn: ''\\n};\\n\\n\\n//# sourceURL=webpack:///./js/foundation.equalizer.js?\");\n    }, \"./js/foundation.interchange.js\": function jsFoundationInterchangeJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Interchange\\\", function() { return Interchange; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.util.mediaQuery */ \\\"./js/foundation.util.mediaQuery.js\\\");\\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.core.plugin */ \\\"./js/foundation.core.plugin.js\\\");\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.core.utils */ \\\"./js/foundation.core.utils.js\\\");\\n\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n\\n\\n\\n\\n/**\\n * Interchange module.\\n * @module foundation.interchange\\n * @requires foundation.util.mediaQuery\\n */\\n\\nvar Interchange =\\n/*#__PURE__*/\\nfunction (_Plugin) {\\n  _inherits(Interchange, _Plugin);\\n\\n  function Interchange() {\\n    _classCallCheck(this, Interchange);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(Interchange).apply(this, arguments));\\n  }\\n\\n  _createClass(Interchange, [{\\n    key: \\\"_setup\\\",\\n\\n    /**\\n     * Creates a new instance of Interchange.\\n     * @class\\n     * @name Interchange\\n     * @fires Interchange#init\\n     * @param {Object} element - jQuery object to add the trigger to.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, Interchange.defaults, options);\\n      this.rules = [];\\n      this.currentPath = '';\\n      this.className = 'Interchange'; // ie9 back compat\\n\\n      this._init();\\n\\n      this._events();\\n    }\\n    /**\\n     * Initializes the Interchange plugin and calls functions to get interchange functioning on load.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_init\\\",\\n    value: function _init() {\\n      _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__[\\\"MediaQuery\\\"]._init();\\n\\n      var id = this.$element[0].id || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\\\"GetYoDigits\\\"])(6, 'interchange');\\n      this.$element.attr({\\n        'data-resize': id,\\n        'id': id\\n      });\\n\\n      this._addBreakpoints();\\n\\n      this._generateRules();\\n\\n      this._reflow();\\n    }\\n    /**\\n     * Initializes events for Interchange.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_events\\\",\\n    value: function _events() {\\n      var _this2 = this;\\n\\n      this.$element.off('resizeme.zf.trigger').on('resizeme.zf.trigger', function () {\\n        return _this2._reflow();\\n      });\\n    }\\n    /**\\n     * Calls necessary functions to update Interchange upon DOM change\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_reflow\\\",\\n    value: function _reflow() {\\n      var match; // Iterate through each rule, but only save the last match\\n\\n      for (var i in this.rules) {\\n        if (this.rules.hasOwnProperty(i)) {\\n          var rule = this.rules[i];\\n\\n          if (window.matchMedia(rule.query).matches) {\\n            match = rule;\\n          }\\n        }\\n      }\\n\\n      if (match) {\\n        this.replace(match.path);\\n      }\\n    }\\n    /**\\n     * Gets the Foundation breakpoints and adds them to the Interchange.SPECIAL_QUERIES object.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_addBreakpoints\\\",\\n    value: function _addBreakpoints() {\\n      for (var i in _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__[\\\"MediaQuery\\\"].queries) {\\n        if (_foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__[\\\"MediaQuery\\\"].queries.hasOwnProperty(i)) {\\n          var query = _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__[\\\"MediaQuery\\\"].queries[i];\\n          Interchange.SPECIAL_QUERIES[query.name] = query.value;\\n        }\\n      }\\n    }\\n    /**\\n     * Checks the Interchange element for the provided media query + content pairings\\n     * @function\\n     * @private\\n     * @param {Object} element - jQuery object that is an Interchange instance\\n     * @returns {Array} scenarios - Array of objects that have 'mq' and 'path' keys with corresponding keys\\n     */\\n\\n  }, {\\n    key: \\\"_generateRules\\\",\\n    value: function _generateRules(element) {\\n      var rulesList = [];\\n      var rules;\\n\\n      if (this.options.rules) {\\n        rules = this.options.rules;\\n      } else {\\n        rules = this.$element.data('interchange');\\n      }\\n\\n      rules = typeof rules === 'string' ? rules.match(/\\\\[.*?, .*?\\\\]/g) : rules;\\n\\n      for (var i in rules) {\\n        if (rules.hasOwnProperty(i)) {\\n          var rule = rules[i].slice(1, -1).split(', ');\\n          var path = rule.slice(0, -1).join('');\\n          var query = rule[rule.length - 1];\\n\\n          if (Interchange.SPECIAL_QUERIES[query]) {\\n            query = Interchange.SPECIAL_QUERIES[query];\\n          }\\n\\n          rulesList.push({\\n            path: path,\\n            query: query\\n          });\\n        }\\n      }\\n\\n      this.rules = rulesList;\\n    }\\n    /**\\n     * Update the `src` property of an image, or change the HTML of a container, to the specified path.\\n     * @function\\n     * @param {String} path - Path to the image or HTML partial.\\n     * @fires Interchange#replaced\\n     */\\n\\n  }, {\\n    key: \\\"replace\\\",\\n    value: function replace(path) {\\n      if (this.currentPath === path) return;\\n\\n      var _this = this,\\n          trigger = 'replaced.zf.interchange'; // Replacing images\\n\\n\\n      if (this.$element[0].nodeName === 'IMG') {\\n        this.$element.attr('src', path).on('load', function () {\\n          _this.currentPath = path;\\n        }).trigger(trigger);\\n      } // Replacing background images\\n      else if (path.match(/\\\\.(gif|jpg|jpeg|png|svg|tiff)([?#].*)?/i)) {\\n          path = path.replace(/\\\\(/g, '%28').replace(/\\\\)/g, '%29');\\n          this.$element.css({\\n            'background-image': 'url(' + path + ')'\\n          }).trigger(trigger);\\n        } // Replacing HTML\\n        else {\\n            jquery__WEBPACK_IMPORTED_MODULE_0___default.a.get(path, function (response) {\\n              _this.$element.html(response).trigger(trigger);\\n\\n              jquery__WEBPACK_IMPORTED_MODULE_0___default()(response).foundation();\\n              _this.currentPath = path;\\n            });\\n          }\\n      /**\\n       * Fires when content in an Interchange element is done being loaded.\\n       * @event Interchange#replaced\\n       */\\n      // this.$element.trigger('replaced.zf.interchange');\\n\\n    }\\n    /**\\n     * Destroys an instance of interchange.\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"_destroy\\\",\\n    value: function _destroy() {\\n      this.$element.off('resizeme.zf.trigger');\\n    }\\n  }]);\\n\\n  return Interchange;\\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_2__[\\\"Plugin\\\"]);\\n/**\\n * Default settings for plugin\\n */\\n\\n\\nInterchange.defaults = {\\n  /**\\n   * Rules to be applied to Interchange elements. Set with the `data-interchange` array notation.\\n   * @option\\n   * @type {?array}\\n   * @default null\\n   */\\n  rules: null\\n};\\nInterchange.SPECIAL_QUERIES = {\\n  'landscape': 'screen and (orientation: landscape)',\\n  'portrait': 'screen and (orientation: portrait)',\\n  'retina': 'only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (-o-min-device-pixel-ratio: 2/1), only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi), only screen and (min-resolution: 2dppx)'\\n};\\n\\n\\n//# sourceURL=webpack:///./js/foundation.interchange.js?\");\n    }, \"./js/foundation.magellan.js\": function jsFoundationMagellanJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Magellan\\\", function() { return Magellan; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.utils */ \\\"./js/foundation.core.utils.js\\\");\\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.core.plugin */ \\\"./js/foundation.core.plugin.js\\\");\\n/* harmony import */ var _foundation_smoothScroll__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.smoothScroll */ \\\"./js/foundation.smoothScroll.js\\\");\\n\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n\\n\\n\\n\\n/**\\n * Magellan module.\\n * @module foundation.magellan\\n * @requires foundation.smoothScroll\\n */\\n\\nvar Magellan =\\n/*#__PURE__*/\\nfunction (_Plugin) {\\n  _inherits(Magellan, _Plugin);\\n\\n  function Magellan() {\\n    _classCallCheck(this, Magellan);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(Magellan).apply(this, arguments));\\n  }\\n\\n  _createClass(Magellan, [{\\n    key: \\\"_setup\\\",\\n\\n    /**\\n     * Creates a new instance of Magellan.\\n     * @class\\n     * @name Magellan\\n     * @fires Magellan#init\\n     * @param {Object} element - jQuery object to add the trigger to.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, Magellan.defaults, this.$element.data(), options);\\n      this.className = 'Magellan'; // ie9 back compat\\n\\n      this._init();\\n\\n      this.calcPoints();\\n    }\\n    /**\\n     * Initializes the Magellan plugin and calls functions to get equalizer functioning on load.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_init\\\",\\n    value: function _init() {\\n      var id = this.$element[0].id || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\\\"GetYoDigits\\\"])(6, 'magellan');\\n\\n      var _this = this;\\n\\n      this.$targets = jquery__WEBPACK_IMPORTED_MODULE_0___default()('[data-magellan-target]');\\n      this.$links = this.$element.find('a');\\n      this.$element.attr({\\n        'data-resize': id,\\n        'data-scroll': id,\\n        'id': id\\n      });\\n      this.$active = jquery__WEBPACK_IMPORTED_MODULE_0___default()();\\n      this.scrollPos = parseInt(window.pageYOffset, 10);\\n\\n      this._events();\\n    }\\n    /**\\n     * Calculates an array of pixel values that are the demarcation lines between locations on the page.\\n     * Can be invoked if new elements are added or the size of a location changes.\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"calcPoints\\\",\\n    value: function calcPoints() {\\n      var _this = this,\\n          body = document.body,\\n          html = document.documentElement;\\n\\n      this.points = [];\\n      this.winHeight = Math.round(Math.max(window.innerHeight, html.clientHeight));\\n      this.docHeight = Math.round(Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight));\\n      this.$targets.each(function () {\\n        var $tar = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\\n            pt = Math.round($tar.offset().top - _this.options.threshold);\\n        $tar.targetPoint = pt;\\n\\n        _this.points.push(pt);\\n      });\\n    }\\n    /**\\n     * Initializes events for Magellan.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_events\\\",\\n    value: function _events() {\\n      var _this = this,\\n          $body = jquery__WEBPACK_IMPORTED_MODULE_0___default()('html, body'),\\n          opts = {\\n        duration: _this.options.animationDuration,\\n        easing: _this.options.animationEasing\\n      };\\n\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).one('load', function () {\\n        if (_this.options.deepLinking) {\\n          if (location.hash) {\\n            _this.scrollToLoc(location.hash);\\n          }\\n        }\\n\\n        _this.calcPoints();\\n\\n        _this._updateActive();\\n      });\\n      _this.onLoadListener = Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\\\"onLoad\\\"])(jquery__WEBPACK_IMPORTED_MODULE_0___default()(window), function () {\\n        _this.$element.on({\\n          'resizeme.zf.trigger': _this.reflow.bind(_this),\\n          'scrollme.zf.trigger': _this._updateActive.bind(_this)\\n        }).on('click.zf.magellan', 'a[href^=\\\"#\\\"]', function (e) {\\n          e.preventDefault();\\n          var arrival = this.getAttribute('href');\\n\\n          _this.scrollToLoc(arrival);\\n        });\\n      });\\n\\n      this._deepLinkScroll = function (e) {\\n        if (_this.options.deepLinking) {\\n          _this.scrollToLoc(window.location.hash);\\n        }\\n      };\\n\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on('hashchange', this._deepLinkScroll);\\n    }\\n    /**\\n     * Function to scroll to a given location on the page.\\n     * @param {String} loc - a properly formatted jQuery id selector. Example: '#foo'\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"scrollToLoc\\\",\\n    value: function scrollToLoc(loc) {\\n      this._inTransition = true;\\n\\n      var _this = this;\\n\\n      var options = {\\n        animationEasing: this.options.animationEasing,\\n        animationDuration: this.options.animationDuration,\\n        threshold: this.options.threshold,\\n        offset: this.options.offset\\n      };\\n      _foundation_smoothScroll__WEBPACK_IMPORTED_MODULE_3__[\\\"SmoothScroll\\\"].scrollToLoc(loc, options, function () {\\n        _this._inTransition = false;\\n      });\\n    }\\n    /**\\n     * Calls necessary functions to update Magellan upon DOM change\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"reflow\\\",\\n    value: function reflow() {\\n      this.calcPoints();\\n\\n      this._updateActive();\\n    }\\n    /**\\n     * Updates the visibility of an active location link, and updates the url hash for the page, if deepLinking enabled.\\n     * @private\\n     * @function\\n     * @fires Magellan#update\\n     */\\n\\n  }, {\\n    key: \\\"_updateActive\\\",\\n    value: function _updateActive()\\n    /*evt, elem, scrollPos*/\\n    {\\n      var _this2 = this;\\n\\n      if (this._inTransition) return;\\n      var newScrollPos = parseInt(window.pageYOffset, 10);\\n      var isScrollingUp = this.scrollPos > newScrollPos;\\n      this.scrollPos = newScrollPos;\\n      var activeIdx; // Before the first point: no link\\n\\n      if (newScrollPos < this.points[0]) {}\\n      /* do nothing */\\n      // At the bottom of the page: last link\\n      else if (newScrollPos + this.winHeight === this.docHeight) {\\n          activeIdx = this.points.length - 1;\\n        } // Otherwhise, use the last visible link\\n        else {\\n            var visibleLinks = this.points.filter(function (p, i) {\\n              return p - _this2.options.offset - (isScrollingUp ? _this2.options.threshold : 0) <= newScrollPos;\\n            });\\n            activeIdx = visibleLinks.length ? visibleLinks.length - 1 : 0;\\n          } // Get the new active link\\n\\n\\n      var $oldActive = this.$active;\\n      var activeHash = '';\\n\\n      if (typeof activeIdx !== 'undefined') {\\n        this.$active = this.$links.filter('[href=\\\"#' + this.$targets.eq(activeIdx).data('magellan-target') + '\\\"]');\\n        if (this.$active.length) activeHash = this.$active[0].getAttribute('href');\\n      } else {\\n        this.$active = jquery__WEBPACK_IMPORTED_MODULE_0___default()();\\n      }\\n\\n      var isNewActive = !(!this.$active.length && !$oldActive.length) && !this.$active.is($oldActive);\\n      var isNewHash = activeHash !== window.location.hash; // Update the active link element\\n\\n      if (isNewActive) {\\n        $oldActive.removeClass(this.options.activeClass);\\n        this.$active.addClass(this.options.activeClass);\\n      } // Update the hash (it may have changed with the same active link)\\n\\n\\n      if (this.options.deepLinking && isNewHash) {\\n        if (window.history.pushState) {\\n          // Set or remove the hash (see: https://stackoverflow.com/a/5298684/4317384\\n          var url = activeHash ? activeHash : window.location.pathname + window.location.search;\\n          window.history.pushState(null, null, url);\\n        } else {\\n          window.location.hash = activeHash;\\n        }\\n      }\\n\\n      if (isNewActive) {\\n        /**\\n         * Fires when magellan is finished updating to the new active element.\\n         * @event Magellan#update\\n         */\\n        this.$element.trigger('update.zf.magellan', [this.$active]);\\n      }\\n    }\\n    /**\\n     * Destroys an instance of Magellan and resets the url of the window.\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"_destroy\\\",\\n    value: function _destroy() {\\n      this.$element.off('.zf.trigger .zf.magellan').find(\\\".\\\".concat(this.options.activeClass)).removeClass(this.options.activeClass);\\n\\n      if (this.options.deepLinking) {\\n        var hash = this.$active[0].getAttribute('href');\\n        window.location.hash.replace(hash, '');\\n      }\\n\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off('hashchange', this._deepLinkScroll);\\n      if (this.onLoadListener) jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off(this.onLoadListener);\\n    }\\n  }]);\\n\\n  return Magellan;\\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_2__[\\\"Plugin\\\"]);\\n/**\\n * Default settings for plugin\\n */\\n\\n\\nMagellan.defaults = {\\n  /**\\n   * Amount of time, in ms, the animated scrolling should take between locations.\\n   * @option\\n   * @type {number}\\n   * @default 500\\n   */\\n  animationDuration: 500,\\n\\n  /**\\n   * Animation style to use when scrolling between locations. Can be `'swing'` or `'linear'`.\\n   * @option\\n   * @type {string}\\n   * @default 'linear'\\n   * @see {@link https://api.jquery.com/animate|Jquery animate}\\n   */\\n  animationEasing: 'linear',\\n\\n  /**\\n   * Number of pixels to use as a marker for location changes.\\n   * @option\\n   * @type {number}\\n   * @default 50\\n   */\\n  threshold: 50,\\n\\n  /**\\n   * Class applied to the active locations link on the magellan container.\\n   * @option\\n   * @type {string}\\n   * @default 'is-active'\\n   */\\n  activeClass: 'is-active',\\n\\n  /**\\n   * Allows the script to manipulate the url of the current page, and if supported, alter the history.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  deepLinking: false,\\n\\n  /**\\n   * Number of pixels to offset the scroll of the page on item click if using a sticky nav bar.\\n   * @option\\n   * @type {number}\\n   * @default 0\\n   */\\n  offset: 0\\n};\\n\\n\\n//# sourceURL=webpack:///./js/foundation.magellan.js?\");\n    }, \"./js/foundation.offcanvas.js\": function jsFoundationOffcanvasJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"OffCanvas\\\", function() { return OffCanvas; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.utils */ \\\"./js/foundation.core.utils.js\\\");\\n/* harmony import */ var _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.util.keyboard */ \\\"./js/foundation.util.keyboard.js\\\");\\n/* harmony import */ var _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.util.mediaQuery */ \\\"./js/foundation.util.mediaQuery.js\\\");\\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.core.plugin */ \\\"./js/foundation.core.plugin.js\\\");\\n/* harmony import */ var _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./foundation.util.triggers */ \\\"./js/foundation.util.triggers.js\\\");\\n\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * OffCanvas module.\\n * @module foundation.offcanvas\\n * @requires foundation.util.keyboard\\n * @requires foundation.util.mediaQuery\\n * @requires foundation.util.triggers\\n */\\n\\nvar OffCanvas =\\n/*#__PURE__*/\\nfunction (_Plugin) {\\n  _inherits(OffCanvas, _Plugin);\\n\\n  function OffCanvas() {\\n    _classCallCheck(this, OffCanvas);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(OffCanvas).apply(this, arguments));\\n  }\\n\\n  _createClass(OffCanvas, [{\\n    key: \\\"_setup\\\",\\n\\n    /**\\n     * Creates a new instance of an off-canvas wrapper.\\n     * @class\\n     * @name OffCanvas\\n     * @fires OffCanvas#init\\n     * @param {Object} element - jQuery object to initialize.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      var _this2 = this;\\n\\n      this.className = 'OffCanvas'; // ie9 back compat\\n\\n      this.$element = element;\\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, OffCanvas.defaults, this.$element.data(), options);\\n      this.contentClasses = {\\n        base: [],\\n        reveal: []\\n      };\\n      this.$lastTrigger = jquery__WEBPACK_IMPORTED_MODULE_0___default()();\\n      this.$triggers = jquery__WEBPACK_IMPORTED_MODULE_0___default()();\\n      this.position = 'left';\\n      this.$content = jquery__WEBPACK_IMPORTED_MODULE_0___default()();\\n      this.nested = !!this.options.nested; // Defines the CSS transition/position classes of the off-canvas content container.\\n\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(['push', 'overlap']).each(function (index, val) {\\n        _this2.contentClasses.base.push('has-transition-' + val);\\n      });\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(['left', 'right', 'top', 'bottom']).each(function (index, val) {\\n        _this2.contentClasses.base.push('has-position-' + val);\\n\\n        _this2.contentClasses.reveal.push('has-reveal-' + val);\\n      }); // Triggers init is idempotent, just need to make sure it is initialized\\n\\n      _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_5__[\\\"Triggers\\\"].init(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\\n\\n      _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_3__[\\\"MediaQuery\\\"]._init();\\n\\n      this._init();\\n\\n      this._events();\\n\\n      _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_2__[\\\"Keyboard\\\"].register('OffCanvas', {\\n        'ESCAPE': 'close'\\n      });\\n    }\\n    /**\\n     * Initializes the off-canvas wrapper by adding the exit overlay (if needed).\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_init\\\",\\n    value: function _init() {\\n      var id = this.$element.attr('id');\\n      this.$element.attr('aria-hidden', 'true'); // Find off-canvas content, either by ID (if specified), by siblings or by closest selector (fallback)\\n\\n      if (this.options.contentId) {\\n        this.$content = jquery__WEBPACK_IMPORTED_MODULE_0___default()('#' + this.options.contentId);\\n      } else if (this.$element.siblings('[data-off-canvas-content]').length) {\\n        this.$content = this.$element.siblings('[data-off-canvas-content]').first();\\n      } else {\\n        this.$content = this.$element.closest('[data-off-canvas-content]').first();\\n      }\\n\\n      if (!this.options.contentId) {\\n        // Assume that the off-canvas element is nested if it isn't a sibling of the content\\n        this.nested = this.$element.siblings('[data-off-canvas-content]').length === 0;\\n      } else if (this.options.contentId && this.options.nested === null) {\\n        // Warning if using content ID without setting the nested option\\n        // Once the element is nested it is required to work properly in this case\\n        console.warn('Remember to use the nested option if using the content ID option!');\\n      }\\n\\n      if (this.nested === true) {\\n        // Force transition overlap if nested\\n        this.options.transition = 'overlap'; // Remove appropriate classes if already assigned in markup\\n\\n        this.$element.removeClass('is-transition-push');\\n      }\\n\\n      this.$element.addClass(\\\"is-transition-\\\".concat(this.options.transition, \\\" is-closed\\\")); // Find triggers that affect this element and add aria-expanded to them\\n\\n      this.$triggers = jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).find('[data-open=\\\"' + id + '\\\"], [data-close=\\\"' + id + '\\\"], [data-toggle=\\\"' + id + '\\\"]').attr('aria-expanded', 'false').attr('aria-controls', id); // Get position by checking for related CSS class\\n\\n      this.position = this.$element.is('.position-left, .position-top, .position-right, .position-bottom') ? this.$element.attr('class').match(/position\\\\-(left|top|right|bottom)/)[1] : this.position; // Add an overlay over the content if necessary\\n\\n      if (this.options.contentOverlay === true) {\\n        var overlay = document.createElement('div');\\n        var overlayPosition = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this.$element).css(\\\"position\\\") === 'fixed' ? 'is-overlay-fixed' : 'is-overlay-absolute';\\n        overlay.setAttribute('class', 'js-off-canvas-overlay ' + overlayPosition);\\n        this.$overlay = jquery__WEBPACK_IMPORTED_MODULE_0___default()(overlay);\\n\\n        if (overlayPosition === 'is-overlay-fixed') {\\n          jquery__WEBPACK_IMPORTED_MODULE_0___default()(this.$overlay).insertAfter(this.$element);\\n        } else {\\n          this.$content.append(this.$overlay);\\n        }\\n      } // Get the revealOn option from the class.\\n\\n\\n      var revealOnRegExp = new RegExp(Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\\\"RegExpEscape\\\"])(this.options.revealClass) + '([^\\\\\\\\s]+)', 'g');\\n      var revealOnClass = revealOnRegExp.exec(this.$element[0].className);\\n\\n      if (revealOnClass) {\\n        this.options.isRevealed = true;\\n        this.options.revealOn = this.options.revealOn || revealOnClass[1];\\n      } // Ensure the `reveal-on-*` class is set.\\n\\n\\n      if (this.options.isRevealed === true && this.options.revealOn) {\\n        this.$element.first().addClass(\\\"\\\".concat(this.options.revealClass).concat(this.options.revealOn));\\n\\n        this._setMQChecker();\\n      }\\n\\n      if (this.options.transitionTime) {\\n        this.$element.css('transition-duration', this.options.transitionTime);\\n      } // Initally remove all transition/position CSS classes from off-canvas content container.\\n\\n\\n      this._removeContentClasses();\\n    }\\n    /**\\n     * Adds event handlers to the off-canvas wrapper and the exit overlay.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_events\\\",\\n    value: function _events() {\\n      this.$element.off('.zf.trigger .zf.offcanvas').on({\\n        'open.zf.trigger': this.open.bind(this),\\n        'close.zf.trigger': this.close.bind(this),\\n        'toggle.zf.trigger': this.toggle.bind(this),\\n        'keydown.zf.offcanvas': this._handleKeyboard.bind(this)\\n      });\\n\\n      if (this.options.closeOnClick === true) {\\n        var $target = this.options.contentOverlay ? this.$overlay : this.$content;\\n        $target.on({\\n          'click.zf.offcanvas': this.close.bind(this)\\n        });\\n      }\\n    }\\n    /**\\n     * Applies event listener for elements that will reveal at certain breakpoints.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_setMQChecker\\\",\\n    value: function _setMQChecker() {\\n      var _this = this;\\n\\n      this.onLoadListener = Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\\\"onLoad\\\"])(jquery__WEBPACK_IMPORTED_MODULE_0___default()(window), function () {\\n        if (_foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_3__[\\\"MediaQuery\\\"].atLeast(_this.options.revealOn)) {\\n          _this.reveal(true);\\n        }\\n      });\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on('changed.zf.mediaquery', function () {\\n        if (_foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_3__[\\\"MediaQuery\\\"].atLeast(_this.options.revealOn)) {\\n          _this.reveal(true);\\n        } else {\\n          _this.reveal(false);\\n        }\\n      });\\n    }\\n    /**\\n     * Removes the CSS transition/position classes of the off-canvas content container.\\n     * Removing the classes is important when another off-canvas gets opened that uses the same content container.\\n     * @param {Boolean} hasReveal - true if related off-canvas element is revealed.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_removeContentClasses\\\",\\n    value: function _removeContentClasses(hasReveal) {\\n      if (typeof hasReveal !== 'boolean') {\\n        this.$content.removeClass(this.contentClasses.base.join(' '));\\n      } else if (hasReveal === false) {\\n        this.$content.removeClass(\\\"has-reveal-\\\".concat(this.position));\\n      }\\n    }\\n    /**\\n     * Adds the CSS transition/position classes of the off-canvas content container, based on the opening off-canvas element.\\n     * Beforehand any transition/position class gets removed.\\n     * @param {Boolean} hasReveal - true if related off-canvas element is revealed.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_addContentClasses\\\",\\n    value: function _addContentClasses(hasReveal) {\\n      this._removeContentClasses(hasReveal);\\n\\n      if (typeof hasReveal !== 'boolean') {\\n        this.$content.addClass(\\\"has-transition-\\\".concat(this.options.transition, \\\" has-position-\\\").concat(this.position));\\n      } else if (hasReveal === true) {\\n        this.$content.addClass(\\\"has-reveal-\\\".concat(this.position));\\n      }\\n    }\\n    /**\\n     * Handles the revealing/hiding the off-canvas at breakpoints, not the same as open.\\n     * @param {Boolean} isRevealed - true if element should be revealed.\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"reveal\\\",\\n    value: function reveal(isRevealed) {\\n      if (isRevealed) {\\n        this.close();\\n        this.isRevealed = true;\\n        this.$element.attr('aria-hidden', 'false');\\n        this.$element.off('open.zf.trigger toggle.zf.trigger');\\n        this.$element.removeClass('is-closed');\\n      } else {\\n        this.isRevealed = false;\\n        this.$element.attr('aria-hidden', 'true');\\n        this.$element.off('open.zf.trigger toggle.zf.trigger').on({\\n          'open.zf.trigger': this.open.bind(this),\\n          'toggle.zf.trigger': this.toggle.bind(this)\\n        });\\n        this.$element.addClass('is-closed');\\n      }\\n\\n      this._addContentClasses(isRevealed);\\n    }\\n    /**\\n     * Stops scrolling of the body when offcanvas is open on mobile Safari and other troublesome browsers.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_stopScrolling\\\",\\n    value: function _stopScrolling(event) {\\n      return false;\\n    } // Taken and adapted from http://stackoverflow.com/questions/16889447/prevent-full-page-scrolling-ios\\n    // Only really works for y, not sure how to extend to x or if we need to.\\n\\n  }, {\\n    key: \\\"_recordScrollable\\\",\\n    value: function _recordScrollable(event) {\\n      var elem = this; // called from event handler context with this as elem\\n      // If the element is scrollable (content overflows), then...\\n\\n      if (elem.scrollHeight !== elem.clientHeight) {\\n        // If we're at the top, scroll down one pixel to allow scrolling up\\n        if (elem.scrollTop === 0) {\\n          elem.scrollTop = 1;\\n        } // If we're at the bottom, scroll up one pixel to allow scrolling down\\n\\n\\n        if (elem.scrollTop === elem.scrollHeight - elem.clientHeight) {\\n          elem.scrollTop = elem.scrollHeight - elem.clientHeight - 1;\\n        }\\n      }\\n\\n      elem.allowUp = elem.scrollTop > 0;\\n      elem.allowDown = elem.scrollTop < elem.scrollHeight - elem.clientHeight;\\n      elem.lastY = event.originalEvent.pageY;\\n    }\\n  }, {\\n    key: \\\"_stopScrollPropagation\\\",\\n    value: function _stopScrollPropagation(event) {\\n      var elem = this; // called from event handler context with this as elem\\n\\n      var up = event.pageY < elem.lastY;\\n      var down = !up;\\n      elem.lastY = event.pageY;\\n\\n      if (up && elem.allowUp || down && elem.allowDown) {\\n        event.stopPropagation();\\n      } else {\\n        event.preventDefault();\\n      }\\n    }\\n    /**\\n     * Opens the off-canvas menu.\\n     * @function\\n     * @param {Object} event - Event object passed from listener.\\n     * @param {jQuery} trigger - element that triggered the off-canvas to open.\\n     * @fires Offcanvas#opened\\n     * @todo also trigger 'open' event?\\n     */\\n\\n  }, {\\n    key: \\\"open\\\",\\n    value: function open(event, trigger) {\\n      if (this.$element.hasClass('is-open') || this.isRevealed) {\\n        return;\\n      }\\n\\n      var _this = this;\\n\\n      if (trigger) {\\n        this.$lastTrigger = trigger;\\n      }\\n\\n      if (this.options.forceTo === 'top') {\\n        window.scrollTo(0, 0);\\n      } else if (this.options.forceTo === 'bottom') {\\n        window.scrollTo(0, document.body.scrollHeight);\\n      }\\n\\n      if (this.options.transitionTime && this.options.transition !== 'overlap') {\\n        this.$element.siblings('[data-off-canvas-content]').css('transition-duration', this.options.transitionTime);\\n      } else {\\n        this.$element.siblings('[data-off-canvas-content]').css('transition-duration', '');\\n      }\\n\\n      this.$element.addClass('is-open').removeClass('is-closed');\\n      this.$triggers.attr('aria-expanded', 'true');\\n      this.$element.attr('aria-hidden', 'false');\\n      this.$content.addClass('is-open-' + this.position); // If `contentScroll` is set to false, add class and disable scrolling on touch devices.\\n\\n      if (this.options.contentScroll === false) {\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()('body').addClass('is-off-canvas-open').on('touchmove', this._stopScrolling);\\n        this.$element.on('touchstart', this._recordScrollable);\\n        this.$element.on('touchmove', this._stopScrollPropagation);\\n      }\\n\\n      if (this.options.contentOverlay === true) {\\n        this.$overlay.addClass('is-visible');\\n      }\\n\\n      if (this.options.closeOnClick === true && this.options.contentOverlay === true) {\\n        this.$overlay.addClass('is-closable');\\n      }\\n\\n      if (this.options.autoFocus === true) {\\n        this.$element.one(Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\\\"transitionend\\\"])(this.$element), function () {\\n          if (!_this.$element.hasClass('is-open')) {\\n            return; // exit if prematurely closed\\n          }\\n\\n          var canvasFocus = _this.$element.find('[data-autofocus]');\\n\\n          if (canvasFocus.length) {\\n            canvasFocus.eq(0).focus();\\n          } else {\\n            _this.$element.find('a, button').eq(0).focus();\\n          }\\n        });\\n      }\\n\\n      if (this.options.trapFocus === true) {\\n        this.$content.attr('tabindex', '-1');\\n        _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_2__[\\\"Keyboard\\\"].trapFocus(this.$element);\\n      }\\n\\n      this._addContentClasses();\\n      /**\\n       * Fires when the off-canvas menu opens.\\n       * @event Offcanvas#opened\\n       */\\n\\n\\n      this.$element.trigger('opened.zf.offcanvas');\\n    }\\n    /**\\n     * Closes the off-canvas menu.\\n     * @function\\n     * @param {Function} cb - optional cb to fire after closure.\\n     * @fires Offcanvas#closed\\n     */\\n\\n  }, {\\n    key: \\\"close\\\",\\n    value: function close(cb) {\\n      if (!this.$element.hasClass('is-open') || this.isRevealed) {\\n        return;\\n      }\\n\\n      var _this = this;\\n\\n      this.$element.removeClass('is-open');\\n      this.$element.attr('aria-hidden', 'true')\\n      /**\\n       * Fires when the off-canvas menu opens.\\n       * @event Offcanvas#closed\\n       */\\n      .trigger('closed.zf.offcanvas');\\n      this.$content.removeClass('is-open-left is-open-top is-open-right is-open-bottom'); // If `contentScroll` is set to false, remove class and re-enable scrolling on touch devices.\\n\\n      if (this.options.contentScroll === false) {\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()('body').removeClass('is-off-canvas-open').off('touchmove', this._stopScrolling);\\n        this.$element.off('touchstart', this._recordScrollable);\\n        this.$element.off('touchmove', this._stopScrollPropagation);\\n      }\\n\\n      if (this.options.contentOverlay === true) {\\n        this.$overlay.removeClass('is-visible');\\n      }\\n\\n      if (this.options.closeOnClick === true && this.options.contentOverlay === true) {\\n        this.$overlay.removeClass('is-closable');\\n      }\\n\\n      this.$triggers.attr('aria-expanded', 'false');\\n\\n      if (this.options.trapFocus === true) {\\n        this.$content.removeAttr('tabindex');\\n        _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_2__[\\\"Keyboard\\\"].releaseFocus(this.$element);\\n      } // Listen to transitionEnd and add class when done.\\n\\n\\n      this.$element.one(Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\\\"transitionend\\\"])(this.$element), function (e) {\\n        _this.$element.addClass('is-closed');\\n\\n        _this._removeContentClasses();\\n      });\\n    }\\n    /**\\n     * Toggles the off-canvas menu open or closed.\\n     * @function\\n     * @param {Object} event - Event object passed from listener.\\n     * @param {jQuery} trigger - element that triggered the off-canvas to open.\\n     */\\n\\n  }, {\\n    key: \\\"toggle\\\",\\n    value: function toggle(event, trigger) {\\n      if (this.$element.hasClass('is-open')) {\\n        this.close(event, trigger);\\n      } else {\\n        this.open(event, trigger);\\n      }\\n    }\\n    /**\\n     * Handles keyboard input when detected. When the escape key is pressed, the off-canvas menu closes, and focus is restored to the element that opened the menu.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_handleKeyboard\\\",\\n    value: function _handleKeyboard(e) {\\n      var _this3 = this;\\n\\n      _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_2__[\\\"Keyboard\\\"].handleKey(e, 'OffCanvas', {\\n        close: function close() {\\n          _this3.close();\\n\\n          _this3.$lastTrigger.focus();\\n\\n          return true;\\n        },\\n        handled: function handled() {\\n          e.stopPropagation();\\n          e.preventDefault();\\n        }\\n      });\\n    }\\n    /**\\n     * Destroys the offcanvas plugin.\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"_destroy\\\",\\n    value: function _destroy() {\\n      this.close();\\n      this.$element.off('.zf.trigger .zf.offcanvas');\\n      this.$overlay.off('.zf.offcanvas');\\n      if (this.onLoadListener) jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off(this.onLoadListener);\\n    }\\n  }]);\\n\\n  return OffCanvas;\\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_4__[\\\"Plugin\\\"]);\\n\\nOffCanvas.defaults = {\\n  /**\\n   * Allow the user to click outside of the menu to close it.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  closeOnClick: true,\\n\\n  /**\\n   * Adds an overlay on top of `[data-off-canvas-content]`.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  contentOverlay: true,\\n\\n  /**\\n   * Target an off-canvas content container by ID that may be placed anywhere. If null the closest content container will be taken.\\n   * @option\\n   * @type {?string}\\n   * @default null\\n   */\\n  contentId: null,\\n\\n  /**\\n   * Define the off-canvas element is nested in an off-canvas content. This is required when using the contentId option for a nested element.\\n   * @option\\n   * @type {boolean}\\n   * @default null\\n   */\\n  nested: null,\\n\\n  /**\\n   * Enable/disable scrolling of the main content when an off canvas panel is open.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  contentScroll: true,\\n\\n  /**\\n   * Amount of time in ms the open and close transition requires. If none selected, pulls from body style.\\n   * @option\\n   * @type {number}\\n   * @default null\\n   */\\n  transitionTime: null,\\n\\n  /**\\n   * Type of transition for the offcanvas menu. Options are 'push', 'detached' or 'slide'.\\n   * @option\\n   * @type {string}\\n   * @default push\\n   */\\n  transition: 'push',\\n\\n  /**\\n   * Force the page to scroll to top or bottom on open.\\n   * @option\\n   * @type {?string}\\n   * @default null\\n   */\\n  forceTo: null,\\n\\n  /**\\n   * Allow the offcanvas to remain open for certain breakpoints.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  isRevealed: false,\\n\\n  /**\\n   * Breakpoint at which to reveal. JS will use a RegExp to target standard classes, if changing classnames, pass your class with the `revealClass` option.\\n   * @option\\n   * @type {?string}\\n   * @default null\\n   */\\n  revealOn: null,\\n\\n  /**\\n   * Force focus to the offcanvas on open. If true, will focus the opening trigger on close.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  autoFocus: true,\\n\\n  /**\\n   * Class used to force an offcanvas to remain open. Foundation defaults for this are `reveal-for-large` & `reveal-for-medium`.\\n   * @option\\n   * @type {string}\\n   * @default reveal-for-\\n   * @todo improve the regex testing for this.\\n   */\\n  revealClass: 'reveal-for-',\\n\\n  /**\\n   * Triggers optional focus trapping when opening an offcanvas. Sets tabindex of [data-off-canvas-content] to -1 for accessibility purposes.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  trapFocus: false\\n};\\n\\n\\n//# sourceURL=webpack:///./js/foundation.offcanvas.js?\");\n    }, \"./js/foundation.orbit.js\": function jsFoundationOrbitJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Orbit\\\", function() { return Orbit; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.util.keyboard */ \\\"./js/foundation.util.keyboard.js\\\");\\n/* harmony import */ var _foundation_util_motion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.util.motion */ \\\"./js/foundation.util.motion.js\\\");\\n/* harmony import */ var _foundation_util_timer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.util.timer */ \\\"./js/foundation.util.timer.js\\\");\\n/* harmony import */ var _foundation_util_imageLoader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.util.imageLoader */ \\\"./js/foundation.util.imageLoader.js\\\");\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./foundation.core.utils */ \\\"./js/foundation.core.utils.js\\\");\\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./foundation.core.plugin */ \\\"./js/foundation.core.plugin.js\\\");\\n/* harmony import */ var _foundation_util_touch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./foundation.util.touch */ \\\"./js/foundation.util.touch.js\\\");\\n\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * Orbit module.\\n * @module foundation.orbit\\n * @requires foundation.util.keyboard\\n * @requires foundation.util.motion\\n * @requires foundation.util.timer\\n * @requires foundation.util.imageLoader\\n * @requires foundation.util.touch\\n */\\n\\nvar Orbit =\\n/*#__PURE__*/\\nfunction (_Plugin) {\\n  _inherits(Orbit, _Plugin);\\n\\n  function Orbit() {\\n    _classCallCheck(this, Orbit);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(Orbit).apply(this, arguments));\\n  }\\n\\n  _createClass(Orbit, [{\\n    key: \\\"_setup\\\",\\n\\n    /**\\n    * Creates a new instance of an orbit carousel.\\n    * @class\\n    * @name Orbit\\n    * @param {jQuery} element - jQuery object to make into an Orbit Carousel.\\n    * @param {Object} options - Overrides to the default plugin settings.\\n    */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, Orbit.defaults, this.$element.data(), options);\\n      this.className = 'Orbit'; // ie9 back compat\\n\\n      _foundation_util_touch__WEBPACK_IMPORTED_MODULE_7__[\\\"Touch\\\"].init(jquery__WEBPACK_IMPORTED_MODULE_0___default.a); // Touch init is idempotent, we just need to make sure it's initialied.\\n\\n      this._init();\\n\\n      _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\\\"Keyboard\\\"].register('Orbit', {\\n        'ltr': {\\n          'ARROW_RIGHT': 'next',\\n          'ARROW_LEFT': 'previous'\\n        },\\n        'rtl': {\\n          'ARROW_LEFT': 'next',\\n          'ARROW_RIGHT': 'previous'\\n        }\\n      });\\n    }\\n    /**\\n    * Initializes the plugin by creating jQuery collections, setting attributes, and starting the animation.\\n    * @function\\n    * @private\\n    */\\n\\n  }, {\\n    key: \\\"_init\\\",\\n    value: function _init() {\\n      // @TODO: consider discussion on PR #9278 about DOM pollution by changeSlide\\n      this._reset();\\n\\n      this.$wrapper = this.$element.find(\\\".\\\".concat(this.options.containerClass));\\n      this.$slides = this.$element.find(\\\".\\\".concat(this.options.slideClass));\\n      var $images = this.$element.find('img'),\\n          initActive = this.$slides.filter('.is-active'),\\n          id = this.$element[0].id || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_5__[\\\"GetYoDigits\\\"])(6, 'orbit');\\n      this.$element.attr({\\n        'data-resize': id,\\n        'id': id\\n      });\\n\\n      if (!initActive.length) {\\n        this.$slides.eq(0).addClass('is-active');\\n      }\\n\\n      if (!this.options.useMUI) {\\n        this.$slides.addClass('no-motionui');\\n      }\\n\\n      if ($images.length) {\\n        Object(_foundation_util_imageLoader__WEBPACK_IMPORTED_MODULE_4__[\\\"onImagesLoaded\\\"])($images, this._prepareForOrbit.bind(this));\\n      } else {\\n        this._prepareForOrbit(); //hehe\\n\\n      }\\n\\n      if (this.options.bullets) {\\n        this._loadBullets();\\n      }\\n\\n      this._events();\\n\\n      if (this.options.autoPlay && this.$slides.length > 1) {\\n        this.geoSync();\\n      }\\n\\n      if (this.options.accessible) {\\n        // allow wrapper to be focusable to enable arrow navigation\\n        this.$wrapper.attr('tabindex', 0);\\n      }\\n    }\\n    /**\\n    * Creates a jQuery collection of bullets, if they are being used.\\n    * @function\\n    * @private\\n    */\\n\\n  }, {\\n    key: \\\"_loadBullets\\\",\\n    value: function _loadBullets() {\\n      this.$bullets = this.$element.find(\\\".\\\".concat(this.options.boxOfBullets)).find('button');\\n    }\\n    /**\\n    * Sets a `timer` object on the orbit, and starts the counter for the next slide.\\n    * @function\\n    */\\n\\n  }, {\\n    key: \\\"geoSync\\\",\\n    value: function geoSync() {\\n      var _this = this;\\n\\n      this.timer = new _foundation_util_timer__WEBPACK_IMPORTED_MODULE_3__[\\\"Timer\\\"](this.$element, {\\n        duration: this.options.timerDelay,\\n        infinite: false\\n      }, function () {\\n        _this.changeSlide(true);\\n      });\\n      this.timer.start();\\n    }\\n    /**\\n    * Sets wrapper and slide heights for the orbit.\\n    * @function\\n    * @private\\n    */\\n\\n  }, {\\n    key: \\\"_prepareForOrbit\\\",\\n    value: function _prepareForOrbit() {\\n      var _this = this;\\n\\n      this._setWrapperHeight();\\n    }\\n    /**\\n    * Calulates the height of each slide in the collection, and uses the tallest one for the wrapper height.\\n    * @function\\n    * @private\\n    * @param {Function} cb - a callback function to fire when complete.\\n    */\\n\\n  }, {\\n    key: \\\"_setWrapperHeight\\\",\\n    value: function _setWrapperHeight(cb) {\\n      //rewrite this to `for` loop\\n      var max = 0,\\n          temp,\\n          counter = 0,\\n          _this = this;\\n\\n      this.$slides.each(function () {\\n        temp = this.getBoundingClientRect().height;\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).attr('data-slide', counter); // hide all slides but the active one\\n\\n        if (!/mui/g.test(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this)[0].className) && _this.$slides.filter('.is-active')[0] !== _this.$slides.eq(counter)[0]) {\\n          jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).css({\\n            'display': 'none'\\n          });\\n        }\\n\\n        max = temp > max ? temp : max;\\n        counter++;\\n      });\\n\\n      if (counter === this.$slides.length) {\\n        this.$wrapper.css({\\n          'height': max\\n        }); //only change the wrapper height property once.\\n\\n        if (cb) {\\n          cb(max);\\n        } //fire callback with max height dimension.\\n\\n      }\\n    }\\n    /**\\n    * Sets the max-height of each slide.\\n    * @function\\n    * @private\\n    */\\n\\n  }, {\\n    key: \\\"_setSlideHeight\\\",\\n    value: function _setSlideHeight(height) {\\n      this.$slides.each(function () {\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).css('max-height', height);\\n      });\\n    }\\n    /**\\n    * Adds event listeners to basically everything within the element.\\n    * @function\\n    * @private\\n    */\\n\\n  }, {\\n    key: \\\"_events\\\",\\n    value: function _events() {\\n      var _this = this; //***************************************\\n      //**Now using custom event - thanks to:**\\n      //**      Yohai Ararat of Toronto      **\\n      //***************************************\\n      //\\n\\n\\n      this.$element.off('.resizeme.zf.trigger').on({\\n        'resizeme.zf.trigger': this._prepareForOrbit.bind(this)\\n      });\\n\\n      if (this.$slides.length > 1) {\\n        if (this.options.swipe) {\\n          this.$slides.off('swipeleft.zf.orbit swiperight.zf.orbit').on('swipeleft.zf.orbit', function (e) {\\n            e.preventDefault();\\n\\n            _this.changeSlide(true);\\n          }).on('swiperight.zf.orbit', function (e) {\\n            e.preventDefault();\\n\\n            _this.changeSlide(false);\\n          });\\n        } //***************************************\\n\\n\\n        if (this.options.autoPlay) {\\n          this.$slides.on('click.zf.orbit', function () {\\n            _this.$element.data('clickedOn', _this.$element.data('clickedOn') ? false : true);\\n\\n            _this.timer[_this.$element.data('clickedOn') ? 'pause' : 'start']();\\n          });\\n\\n          if (this.options.pauseOnHover) {\\n            this.$element.on('mouseenter.zf.orbit', function () {\\n              _this.timer.pause();\\n            }).on('mouseleave.zf.orbit', function () {\\n              if (!_this.$element.data('clickedOn')) {\\n                _this.timer.start();\\n              }\\n            });\\n          }\\n        }\\n\\n        if (this.options.navButtons) {\\n          var $controls = this.$element.find(\\\".\\\".concat(this.options.nextClass, \\\", .\\\").concat(this.options.prevClass));\\n          $controls.attr('tabindex', 0) //also need to handle enter/return and spacebar key presses\\n          .on('click.zf.orbit touchend.zf.orbit', function (e) {\\n            e.preventDefault();\\n\\n            _this.changeSlide(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).hasClass(_this.options.nextClass));\\n          });\\n        }\\n\\n        if (this.options.bullets) {\\n          this.$bullets.on('click.zf.orbit touchend.zf.orbit', function () {\\n            if (/is-active/g.test(this.className)) {\\n              return false;\\n            } //if this is active, kick out of function.\\n\\n\\n            var idx = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data('slide'),\\n                ltr = idx > _this.$slides.filter('.is-active').data('slide'),\\n                $slide = _this.$slides.eq(idx);\\n\\n            _this.changeSlide(ltr, $slide, idx);\\n          });\\n        }\\n\\n        if (this.options.accessible) {\\n          this.$wrapper.add(this.$bullets).on('keydown.zf.orbit', function (e) {\\n            // handle keyboard event with keyboard util\\n            _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\\\"Keyboard\\\"].handleKey(e, 'Orbit', {\\n              next: function next() {\\n                _this.changeSlide(true);\\n              },\\n              previous: function previous() {\\n                _this.changeSlide(false);\\n              },\\n              handled: function handled() {\\n                // if bullet is focused, make sure focus moves\\n                if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).is(_this.$bullets)) {\\n                  _this.$bullets.filter('.is-active').focus();\\n                }\\n              }\\n            });\\n          });\\n        }\\n      }\\n    }\\n    /**\\n     * Resets Orbit so it can be reinitialized\\n     */\\n\\n  }, {\\n    key: \\\"_reset\\\",\\n    value: function _reset() {\\n      // Don't do anything if there are no slides (first run)\\n      if (typeof this.$slides == 'undefined') {\\n        return;\\n      }\\n\\n      if (this.$slides.length > 1) {\\n        // Remove old events\\n        this.$element.off('.zf.orbit').find('*').off('.zf.orbit'); // Restart timer if autoPlay is enabled\\n\\n        if (this.options.autoPlay) {\\n          this.timer.restart();\\n        } // Reset all sliddes\\n\\n\\n        this.$slides.each(function (el) {\\n          jquery__WEBPACK_IMPORTED_MODULE_0___default()(el).removeClass('is-active is-active is-in').removeAttr('aria-live').hide();\\n        }); // Show the first slide\\n\\n        this.$slides.first().addClass('is-active').show(); // Triggers when the slide has finished animating\\n\\n        this.$element.trigger('slidechange.zf.orbit', [this.$slides.first()]); // Select first bullet if bullets are present\\n\\n        if (this.options.bullets) {\\n          this._updateBullets(0);\\n        }\\n      }\\n    }\\n    /**\\n    * Changes the current slide to a new one.\\n    * @function\\n    * @param {Boolean} isLTR - if true the slide moves from right to left, if false the slide moves from left to right.\\n    * @param {jQuery} chosenSlide - the jQuery element of the slide to show next, if one is selected.\\n    * @param {Number} idx - the index of the new slide in its collection, if one chosen.\\n    * @fires Orbit#slidechange\\n    */\\n\\n  }, {\\n    key: \\\"changeSlide\\\",\\n    value: function changeSlide(isLTR, chosenSlide, idx) {\\n      if (!this.$slides) {\\n        return;\\n      } // Don't freak out if we're in the middle of cleanup\\n\\n\\n      var $curSlide = this.$slides.filter('.is-active').eq(0);\\n\\n      if (/mui/g.test($curSlide[0].className)) {\\n        return false;\\n      } //if the slide is currently animating, kick out of the function\\n\\n\\n      var $firstSlide = this.$slides.first(),\\n          $lastSlide = this.$slides.last(),\\n          dirIn = isLTR ? 'Right' : 'Left',\\n          dirOut = isLTR ? 'Left' : 'Right',\\n          _this = this,\\n          $newSlide;\\n\\n      if (!chosenSlide) {\\n        //most of the time, this will be auto played or clicked from the navButtons.\\n        $newSlide = isLTR ? //if wrapping enabled, check to see if there is a `next` or `prev` sibling, if not, select the first or last slide to fill in. if wrapping not enabled, attempt to select `next` or `prev`, if there's nothing there, the function will kick out on next step. CRAZY NESTED TERNARIES!!!!!\\n        this.options.infiniteWrap ? $curSlide.next(\\\".\\\".concat(this.options.slideClass)).length ? $curSlide.next(\\\".\\\".concat(this.options.slideClass)) : $firstSlide : $curSlide.next(\\\".\\\".concat(this.options.slideClass)) : //pick next slide if moving left to right\\n        this.options.infiniteWrap ? $curSlide.prev(\\\".\\\".concat(this.options.slideClass)).length ? $curSlide.prev(\\\".\\\".concat(this.options.slideClass)) : $lastSlide : $curSlide.prev(\\\".\\\".concat(this.options.slideClass)); //pick prev slide if moving right to left\\n      } else {\\n        $newSlide = chosenSlide;\\n      }\\n\\n      if ($newSlide.length) {\\n        /**\\n        * Triggers before the next slide starts animating in and only if a next slide has been found.\\n        * @event Orbit#beforeslidechange\\n        */\\n        this.$element.trigger('beforeslidechange.zf.orbit', [$curSlide, $newSlide]);\\n\\n        if (this.options.bullets) {\\n          idx = idx || this.$slides.index($newSlide); //grab index to update bullets\\n\\n          this._updateBullets(idx);\\n        }\\n\\n        if (this.options.useMUI && !this.$element.is(':hidden')) {\\n          _foundation_util_motion__WEBPACK_IMPORTED_MODULE_2__[\\\"Motion\\\"].animateIn($newSlide.addClass('is-active'), this.options[\\\"animInFrom\\\".concat(dirIn)], function () {\\n            $newSlide.css({\\n              'display': 'block'\\n            }).attr('aria-live', 'polite');\\n          });\\n          _foundation_util_motion__WEBPACK_IMPORTED_MODULE_2__[\\\"Motion\\\"].animateOut($curSlide.removeClass('is-active'), this.options[\\\"animOutTo\\\".concat(dirOut)], function () {\\n            $curSlide.removeAttr('aria-live');\\n\\n            if (_this.options.autoPlay && !_this.timer.isPaused) {\\n              _this.timer.restart();\\n            } //do stuff?\\n\\n          });\\n        } else {\\n          $curSlide.removeClass('is-active is-in').removeAttr('aria-live').hide();\\n          $newSlide.addClass('is-active is-in').attr('aria-live', 'polite').show();\\n\\n          if (this.options.autoPlay && !this.timer.isPaused) {\\n            this.timer.restart();\\n          }\\n        }\\n        /**\\n        * Triggers when the slide has finished animating in.\\n        * @event Orbit#slidechange\\n        */\\n\\n\\n        this.$element.trigger('slidechange.zf.orbit', [$newSlide]);\\n      }\\n    }\\n    /**\\n    * Updates the active state of the bullets, if displayed.\\n    * @function\\n    * @private\\n    * @param {Number} idx - the index of the current slide.\\n    */\\n\\n  }, {\\n    key: \\\"_updateBullets\\\",\\n    value: function _updateBullets(idx) {\\n      var $oldBullet = this.$element.find(\\\".\\\".concat(this.options.boxOfBullets)).find('.is-active').removeClass('is-active').blur(),\\n          span = $oldBullet.find('span:last').detach(),\\n          $newBullet = this.$bullets.eq(idx).addClass('is-active').append(span);\\n    }\\n    /**\\n    * Destroys the carousel and hides the element.\\n    * @function\\n    */\\n\\n  }, {\\n    key: \\\"_destroy\\\",\\n    value: function _destroy() {\\n      this.$element.off('.zf.orbit').find('*').off('.zf.orbit').end().hide();\\n    }\\n  }]);\\n\\n  return Orbit;\\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_6__[\\\"Plugin\\\"]);\\n\\nOrbit.defaults = {\\n  /**\\n  * Tells the JS to look for and loadBullets.\\n  * @option\\n   * @type {boolean}\\n  * @default true\\n  */\\n  bullets: true,\\n\\n  /**\\n  * Tells the JS to apply event listeners to nav buttons\\n  * @option\\n   * @type {boolean}\\n  * @default true\\n  */\\n  navButtons: true,\\n\\n  /**\\n  * motion-ui animation class to apply\\n  * @option\\n   * @type {string}\\n  * @default 'slide-in-right'\\n  */\\n  animInFromRight: 'slide-in-right',\\n\\n  /**\\n  * motion-ui animation class to apply\\n  * @option\\n   * @type {string}\\n  * @default 'slide-out-right'\\n  */\\n  animOutToRight: 'slide-out-right',\\n\\n  /**\\n  * motion-ui animation class to apply\\n  * @option\\n   * @type {string}\\n  * @default 'slide-in-left'\\n  *\\n  */\\n  animInFromLeft: 'slide-in-left',\\n\\n  /**\\n  * motion-ui animation class to apply\\n  * @option\\n   * @type {string}\\n  * @default 'slide-out-left'\\n  */\\n  animOutToLeft: 'slide-out-left',\\n\\n  /**\\n  * Allows Orbit to automatically animate on page load.\\n  * @option\\n   * @type {boolean}\\n  * @default true\\n  */\\n  autoPlay: true,\\n\\n  /**\\n  * Amount of time, in ms, between slide transitions\\n  * @option\\n   * @type {number}\\n  * @default 5000\\n  */\\n  timerDelay: 5000,\\n\\n  /**\\n  * Allows Orbit to infinitely loop through the slides\\n  * @option\\n   * @type {boolean}\\n  * @default true\\n  */\\n  infiniteWrap: true,\\n\\n  /**\\n  * Allows the Orbit slides to bind to swipe events for mobile, requires an additional util library\\n  * @option\\n   * @type {boolean}\\n  * @default true\\n  */\\n  swipe: true,\\n\\n  /**\\n  * Allows the timing function to pause animation on hover.\\n  * @option\\n   * @type {boolean}\\n  * @default true\\n  */\\n  pauseOnHover: true,\\n\\n  /**\\n  * Allows Orbit to bind keyboard events to the slider, to animate frames with arrow keys\\n  * @option\\n   * @type {boolean}\\n  * @default true\\n  */\\n  accessible: true,\\n\\n  /**\\n  * Class applied to the container of Orbit\\n  * @option\\n   * @type {string}\\n  * @default 'orbit-container'\\n  */\\n  containerClass: 'orbit-container',\\n\\n  /**\\n  * Class applied to individual slides.\\n  * @option\\n   * @type {string}\\n  * @default 'orbit-slide'\\n  */\\n  slideClass: 'orbit-slide',\\n\\n  /**\\n  * Class applied to the bullet container. You're welcome.\\n  * @option\\n   * @type {string}\\n  * @default 'orbit-bullets'\\n  */\\n  boxOfBullets: 'orbit-bullets',\\n\\n  /**\\n  * Class applied to the `next` navigation button.\\n  * @option\\n   * @type {string}\\n  * @default 'orbit-next'\\n  */\\n  nextClass: 'orbit-next',\\n\\n  /**\\n  * Class applied to the `previous` navigation button.\\n  * @option\\n   * @type {string}\\n  * @default 'orbit-previous'\\n  */\\n  prevClass: 'orbit-previous',\\n\\n  /**\\n  * Boolean to flag the js to use motion ui classes or not. Default to true for backwards compatibility.\\n  * @option\\n   * @type {boolean}\\n  * @default true\\n  */\\n  useMUI: true\\n};\\n\\n\\n//# sourceURL=webpack:///./js/foundation.orbit.js?\");\n    }, \"./js/foundation.positionable.js\": function jsFoundationPositionableJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Positionable\", function() { return Positionable; });\\n/* harmony import */ var _foundation_util_box__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./foundation.util.box */ \"./js/foundation.util.box.js\");\\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.plugin */ \"./js/foundation.core.plugin.js\");\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\\n\\n\\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn\\'t been initialised - super() hasn\\'t been called\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n\\n\\n\\nvar POSITIONS = [\\'left\\', \\'right\\', \\'top\\', \\'bottom\\'];\\nvar VERTICAL_ALIGNMENTS = [\\'top\\', \\'bottom\\', \\'center\\'];\\nvar HORIZONTAL_ALIGNMENTS = [\\'left\\', \\'right\\', \\'center\\'];\\nvar ALIGNMENTS = {\\n  \\'left\\': VERTICAL_ALIGNMENTS,\\n  \\'right\\': VERTICAL_ALIGNMENTS,\\n  \\'top\\': HORIZONTAL_ALIGNMENTS,\\n  \\'bottom\\': HORIZONTAL_ALIGNMENTS\\n};\\n\\nfunction nextItem(item, array) {\\n  var currentIdx = array.indexOf(item);\\n\\n  if (currentIdx === array.length - 1) {\\n    return array[0];\\n  } else {\\n    return array[currentIdx + 1];\\n  }\\n}\\n\\nvar Positionable =\\n/*#__PURE__*/\\nfunction (_Plugin) {\\n  _inherits(Positionable, _Plugin);\\n\\n  function Positionable() {\\n    _classCallCheck(this, Positionable);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(Positionable).apply(this, arguments));\\n  }\\n\\n  _createClass(Positionable, [{\\n    key: \"_init\",\\n\\n    /**\\n     * Abstract class encapsulating the tether-like explicit positioning logic\\n     * including repositioning based on overlap.\\n     * Expects classes to define defaults for vOffset, hOffset, position,\\n     * alignment, allowOverlap, and allowBottomOverlap. They can do this by\\n     * extending the defaults, or (for now recommended due to the way docs are\\n     * generated) by explicitly declaring them.\\n     *\\n     **/\\n    value: function _init() {\\n      this.triedPositions = {};\\n      this.position = this.options.position === \\'auto\\' ? this._getDefaultPosition() : this.options.position;\\n      this.alignment = this.options.alignment === \\'auto\\' ? this._getDefaultAlignment() : this.options.alignment;\\n      this.originalPosition = this.position;\\n      this.originalAlignment = this.alignment;\\n    }\\n  }, {\\n    key: \"_getDefaultPosition\",\\n    value: function _getDefaultPosition() {\\n      return \\'bottom\\';\\n    }\\n  }, {\\n    key: \"_getDefaultAlignment\",\\n    value: function _getDefaultAlignment() {\\n      switch (this.position) {\\n        case \\'bottom\\':\\n        case \\'top\\':\\n          return Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"rtl\"])() ? \\'right\\' : \\'left\\';\\n\\n        case \\'left\\':\\n        case \\'right\\':\\n          return \\'bottom\\';\\n      }\\n    }\\n    /**\\n     * Adjusts the positionable possible positions by iterating through alignments\\n     * and positions.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \"_reposition\",\\n    value: function _reposition() {\\n      if (this._alignmentsExhausted(this.position)) {\\n        this.position = nextItem(this.position, POSITIONS);\\n        this.alignment = ALIGNMENTS[this.position][0];\\n      } else {\\n        this._realign();\\n      }\\n    }\\n    /**\\n     * Adjusts the dropdown pane possible positions by iterating through alignments\\n     * on the current position.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \"_realign\",\\n    value: function _realign() {\\n      this._addTriedPosition(this.position, this.alignment);\\n\\n      this.alignment = nextItem(this.alignment, ALIGNMENTS[this.position]);\\n    }\\n  }, {\\n    key: \"_addTriedPosition\",\\n    value: function _addTriedPosition(position, alignment) {\\n      this.triedPositions[position] = this.triedPositions[position] || [];\\n      this.triedPositions[position].push(alignment);\\n    }\\n  }, {\\n    key: \"_positionsExhausted\",\\n    value: function _positionsExhausted() {\\n      var isExhausted = true;\\n\\n      for (var i = 0; i < POSITIONS.length; i++) {\\n        isExhausted = isExhausted && this._alignmentsExhausted(POSITIONS[i]);\\n      }\\n\\n      return isExhausted;\\n    }\\n  }, {\\n    key: \"_alignmentsExhausted\",\\n    value: function _alignmentsExhausted(position) {\\n      return this.triedPositions[position] && this.triedPositions[position].length == ALIGNMENTS[position].length;\\n    } // When we\\'re trying to center, we don\\'t want to apply offset that\\'s going to\\n    // take us just off center, so wrap around to return 0 for the appropriate\\n    // offset in those alignments.  TODO: Figure out if we want to make this\\n    // configurable behavior... it feels more intuitive, especially for tooltips, but\\n    // it\\'s possible someone might actually want to start from center and then nudge\\n    // slightly off.\\n\\n  }, {\\n    key: \"_getVOffset\",\\n    value: function _getVOffset() {\\n      return this.options.vOffset;\\n    }\\n  }, {\\n    key: \"_getHOffset\",\\n    value: function _getHOffset() {\\n      return this.options.hOffset;\\n    }\\n  }, {\\n    key: \"_setPosition\",\\n    value: function _setPosition($anchor, $element, $parent) {\\n      if ($anchor.attr(\\'aria-expanded\\') === \\'false\\') {\\n        return false;\\n      }\\n\\n      var $eleDims = _foundation_util_box__WEBPACK_IMPORTED_MODULE_0__[\"Box\"].GetDimensions($element),\\n          $anchorDims = _foundation_util_box__WEBPACK_IMPORTED_MODULE_0__[\"Box\"].GetDimensions($anchor);\\n\\n      if (!this.options.allowOverlap) {\\n        // restore original position & alignment before checking overlap\\n        this.position = this.originalPosition;\\n        this.alignment = this.originalAlignment;\\n      }\\n\\n      $element.offset(_foundation_util_box__WEBPACK_IMPORTED_MODULE_0__[\"Box\"].GetExplicitOffsets($element, $anchor, this.position, this.alignment, this._getVOffset(), this._getHOffset()));\\n\\n      if (!this.options.allowOverlap) {\\n        var overlaps = {};\\n        var minOverlap = 100000000; // default coordinates to how we start, in case we can\\'t figure out better\\n\\n        var minCoordinates = {\\n          position: this.position,\\n          alignment: this.alignment\\n        };\\n\\n        while (!this._positionsExhausted()) {\\n          var overlap = _foundation_util_box__WEBPACK_IMPORTED_MODULE_0__[\"Box\"].OverlapArea($element, $parent, false, false, this.options.allowBottomOverlap);\\n\\n          if (overlap === 0) {\\n            return;\\n          }\\n\\n          if (overlap < minOverlap) {\\n            minOverlap = overlap;\\n            minCoordinates = {\\n              position: this.position,\\n              alignment: this.alignment\\n            };\\n          }\\n\\n          this._reposition();\\n\\n          $element.offset(_foundation_util_box__WEBPACK_IMPORTED_MODULE_0__[\"Box\"].GetExplicitOffsets($element, $anchor, this.position, this.alignment, this._getVOffset(), this._getHOffset()));\\n        } // If we get through the entire loop, there was no non-overlapping\\n        // position available. Pick the version with least overlap.\\n\\n\\n        this.position = minCoordinates.position;\\n        this.alignment = minCoordinates.alignment;\\n        $element.offset(_foundation_util_box__WEBPACK_IMPORTED_MODULE_0__[\"Box\"].GetExplicitOffsets($element, $anchor, this.position, this.alignment, this._getVOffset(), this._getHOffset()));\\n      }\\n    }\\n  }]);\\n\\n  return Positionable;\\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_1__[\"Plugin\"]);\\n\\nPositionable.defaults = {\\n  /**\\n   * Position of positionable relative to anchor. Can be left, right, bottom, top, or auto.\\n   * @option\\n   * @type {string}\\n   * @default \\'auto\\'\\n   */\\n  position: \\'auto\\',\\n\\n  /**\\n   * Alignment of positionable relative to anchor. Can be left, right, bottom, top, center, or auto.\\n   * @option\\n   * @type {string}\\n   * @default \\'auto\\'\\n   */\\n  alignment: \\'auto\\',\\n\\n  /**\\n   * Allow overlap of container/window. If false, dropdown positionable first\\n   * try to position as defined by data-position and data-alignment, but\\n   * reposition if it would cause an overflow.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  allowOverlap: false,\\n\\n  /**\\n   * Allow overlap of only the bottom of the container. This is the most common\\n   * behavior for dropdowns, allowing the dropdown to extend the bottom of the\\n   * screen but not otherwise influence or break out of the container.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  allowBottomOverlap: true,\\n\\n  /**\\n   * Number of pixels the positionable should be separated vertically from anchor\\n   * @option\\n   * @type {number}\\n   * @default 0\\n   */\\n  vOffset: 0,\\n\\n  /**\\n   * Number of pixels the positionable should be separated horizontally from anchor\\n   * @option\\n   * @type {number}\\n   * @default 0\\n   */\\n  hOffset: 0\\n};\\n\\n\\n//# sourceURL=webpack:///./js/foundation.positionable.js?');\n    }, \"./js/foundation.responsiveAccordionTabs.js\": function jsFoundationResponsiveAccordionTabsJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ResponsiveAccordionTabs\\\", function() { return ResponsiveAccordionTabs; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.util.mediaQuery */ \\\"./js/foundation.util.mediaQuery.js\\\");\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.core.utils */ \\\"./js/foundation.core.utils.js\\\");\\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.core.plugin */ \\\"./js/foundation.core.plugin.js\\\");\\n/* harmony import */ var _foundation_accordion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.accordion */ \\\"./js/foundation.accordion.js\\\");\\n/* harmony import */ var _foundation_tabs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./foundation.tabs */ \\\"./js/foundation.tabs.js\\\");\\n\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n\\n\\n\\n\\n\\n // The plugin matches the plugin classes with these plugin instances.\\n\\nvar MenuPlugins = {\\n  tabs: {\\n    cssClass: 'tabs',\\n    plugin: _foundation_tabs__WEBPACK_IMPORTED_MODULE_5__[\\\"Tabs\\\"]\\n  },\\n  accordion: {\\n    cssClass: 'accordion',\\n    plugin: _foundation_accordion__WEBPACK_IMPORTED_MODULE_4__[\\\"Accordion\\\"]\\n  }\\n};\\n/**\\n * ResponsiveAccordionTabs module.\\n * @module foundation.responsiveAccordionTabs\\n * @requires foundation.util.motion\\n * @requires foundation.accordion\\n * @requires foundation.tabs\\n */\\n\\nvar ResponsiveAccordionTabs =\\n/*#__PURE__*/\\nfunction (_Plugin) {\\n  _inherits(ResponsiveAccordionTabs, _Plugin);\\n\\n  function ResponsiveAccordionTabs() {\\n    _classCallCheck(this, ResponsiveAccordionTabs);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(ResponsiveAccordionTabs).apply(this, arguments));\\n  }\\n\\n  _createClass(ResponsiveAccordionTabs, [{\\n    key: \\\"_setup\\\",\\n\\n    /**\\n     * Creates a new instance of a responsive accordion tabs.\\n     * @class\\n     * @name ResponsiveAccordionTabs\\n     * @fires ResponsiveAccordionTabs#init\\n     * @param {jQuery} element - jQuery object to make into Responsive Accordion Tabs.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = jquery__WEBPACK_IMPORTED_MODULE_0___default()(element);\\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, this.$element.data(), options);\\n      this.rules = this.$element.data('responsive-accordion-tabs');\\n      this.currentMq = null;\\n      this.currentPlugin = null;\\n      this.className = 'ResponsiveAccordionTabs'; // ie9 back compat\\n\\n      if (!this.$element.attr('id')) {\\n        this.$element.attr('id', Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\\\"GetYoDigits\\\"])(6, 'responsiveaccordiontabs'));\\n      }\\n\\n      ;\\n\\n      this._init();\\n\\n      this._events();\\n    }\\n    /**\\n     * Initializes the Menu by parsing the classes from the 'data-responsive-accordion-tabs' attribute on the element.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_init\\\",\\n    value: function _init() {\\n      _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__[\\\"MediaQuery\\\"]._init(); // The first time an Interchange plugin is initialized, this.rules is converted from a string of \\\"classes\\\" to an object of rules\\n\\n\\n      if (typeof this.rules === 'string') {\\n        var rulesTree = {}; // Parse rules from \\\"classes\\\" pulled from data attribute\\n\\n        var rules = this.rules.split(' '); // Iterate through every rule found\\n\\n        for (var i = 0; i < rules.length; i++) {\\n          var rule = rules[i].split('-');\\n          var ruleSize = rule.length > 1 ? rule[0] : 'small';\\n          var rulePlugin = rule.length > 1 ? rule[1] : rule[0];\\n\\n          if (MenuPlugins[rulePlugin] !== null) {\\n            rulesTree[ruleSize] = MenuPlugins[rulePlugin];\\n          }\\n        }\\n\\n        this.rules = rulesTree;\\n      }\\n\\n      this._getAllOptions();\\n\\n      if (!jquery__WEBPACK_IMPORTED_MODULE_0___default.a.isEmptyObject(this.rules)) {\\n        this._checkMediaQueries();\\n      }\\n    }\\n  }, {\\n    key: \\\"_getAllOptions\\\",\\n    value: function _getAllOptions() {\\n      //get all defaults and options\\n      var _this = this;\\n\\n      _this.allOptions = {};\\n\\n      for (var key in MenuPlugins) {\\n        if (MenuPlugins.hasOwnProperty(key)) {\\n          var obj = MenuPlugins[key];\\n\\n          try {\\n            var dummyPlugin = jquery__WEBPACK_IMPORTED_MODULE_0___default()('<ul></ul>');\\n            var tmpPlugin = new obj.plugin(dummyPlugin, _this.options);\\n\\n            for (var keyKey in tmpPlugin.options) {\\n              if (tmpPlugin.options.hasOwnProperty(keyKey) && keyKey !== 'zfPlugin') {\\n                var objObj = tmpPlugin.options[keyKey];\\n                _this.allOptions[keyKey] = objObj;\\n              }\\n            }\\n\\n            tmpPlugin.destroy();\\n          } catch (e) {}\\n        }\\n      }\\n    }\\n    /**\\n     * Initializes events for the Menu.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_events\\\",\\n    value: function _events() {\\n      this._changedZfMediaQueryHandler = this._checkMediaQueries.bind(this);\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on('changed.zf.mediaquery', this._changedZfMediaQueryHandler);\\n    }\\n    /**\\n     * Checks the current screen width against available media queries. If the media query has changed, and the plugin needed has changed, the plugins will swap out.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_checkMediaQueries\\\",\\n    value: function _checkMediaQueries() {\\n      var matchedMq,\\n          _this = this; // Iterate through each rule and find the last matching rule\\n\\n\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default.a.each(this.rules, function (key) {\\n        if (_foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__[\\\"MediaQuery\\\"].atLeast(key)) {\\n          matchedMq = key;\\n        }\\n      }); // No match? No dice\\n\\n      if (!matchedMq) return; // Plugin already initialized? We good\\n\\n      if (this.currentPlugin instanceof this.rules[matchedMq].plugin) return; // Remove existing plugin-specific CSS classes\\n\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default.a.each(MenuPlugins, function (key, value) {\\n        _this.$element.removeClass(value.cssClass);\\n      }); // Add the CSS class for the new plugin\\n\\n      this.$element.addClass(this.rules[matchedMq].cssClass); // Create an instance of the new plugin\\n\\n      if (this.currentPlugin) {\\n        //don't know why but on nested elements data zfPlugin get's lost\\n        if (!this.currentPlugin.$element.data('zfPlugin') && this.storezfData) this.currentPlugin.$element.data('zfPlugin', this.storezfData);\\n        this.currentPlugin.destroy();\\n      }\\n\\n      this._handleMarkup(this.rules[matchedMq].cssClass);\\n\\n      this.currentPlugin = new this.rules[matchedMq].plugin(this.$element, {});\\n      this.storezfData = this.currentPlugin.$element.data('zfPlugin');\\n    }\\n  }, {\\n    key: \\\"_handleMarkup\\\",\\n    value: function _handleMarkup(toSet) {\\n      var _this = this,\\n          fromString = 'accordion';\\n\\n      var $panels = jquery__WEBPACK_IMPORTED_MODULE_0___default()('[data-tabs-content=' + this.$element.attr('id') + ']');\\n      if ($panels.length) fromString = 'tabs';\\n\\n      if (fromString === toSet) {\\n        return;\\n      }\\n\\n      ;\\n      var tabsTitle = _this.allOptions.linkClass ? _this.allOptions.linkClass : 'tabs-title';\\n      var tabsPanel = _this.allOptions.panelClass ? _this.allOptions.panelClass : 'tabs-panel';\\n      this.$element.removeAttr('role');\\n      var $liHeads = this.$element.children('.' + tabsTitle + ',[data-accordion-item]').removeClass(tabsTitle).removeClass('accordion-item').removeAttr('data-accordion-item');\\n      var $liHeadsA = $liHeads.children('a').removeClass('accordion-title');\\n\\n      if (fromString === 'tabs') {\\n        $panels = $panels.children('.' + tabsPanel).removeClass(tabsPanel).removeAttr('role').removeAttr('aria-hidden').removeAttr('aria-labelledby');\\n        $panels.children('a').removeAttr('role').removeAttr('aria-controls').removeAttr('aria-selected');\\n      } else {\\n        $panels = $liHeads.children('[data-tab-content]').removeClass('accordion-content');\\n      }\\n\\n      ;\\n      $panels.css({\\n        display: '',\\n        visibility: ''\\n      });\\n      $liHeads.css({\\n        display: '',\\n        visibility: ''\\n      });\\n\\n      if (toSet === 'accordion') {\\n        $panels.each(function (key, value) {\\n          jquery__WEBPACK_IMPORTED_MODULE_0___default()(value).appendTo($liHeads.get(key)).addClass('accordion-content').attr('data-tab-content', '').removeClass('is-active').css({\\n            height: ''\\n          });\\n          jquery__WEBPACK_IMPORTED_MODULE_0___default()('[data-tabs-content=' + _this.$element.attr('id') + ']').after('<div id=\\\"tabs-placeholder-' + _this.$element.attr('id') + '\\\"></div>').detach();\\n          $liHeads.addClass('accordion-item').attr('data-accordion-item', '');\\n          $liHeadsA.addClass('accordion-title');\\n        });\\n      } else if (toSet === 'tabs') {\\n        var $tabsContent = jquery__WEBPACK_IMPORTED_MODULE_0___default()('[data-tabs-content=' + _this.$element.attr('id') + ']');\\n        var $placeholder = jquery__WEBPACK_IMPORTED_MODULE_0___default()('#tabs-placeholder-' + _this.$element.attr('id'));\\n\\n        if ($placeholder.length) {\\n          $tabsContent = jquery__WEBPACK_IMPORTED_MODULE_0___default()('<div class=\\\"tabs-content\\\"></div>').insertAfter($placeholder).attr('data-tabs-content', _this.$element.attr('id'));\\n          $placeholder.remove();\\n        } else {\\n          $tabsContent = jquery__WEBPACK_IMPORTED_MODULE_0___default()('<div class=\\\"tabs-content\\\"></div>').insertAfter(_this.$element).attr('data-tabs-content', _this.$element.attr('id'));\\n        }\\n\\n        ;\\n        $panels.each(function (key, value) {\\n          var tempValue = jquery__WEBPACK_IMPORTED_MODULE_0___default()(value).appendTo($tabsContent).addClass(tabsPanel);\\n          var hash = $liHeadsA.get(key).hash.slice(1);\\n          var id = jquery__WEBPACK_IMPORTED_MODULE_0___default()(value).attr('id') || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\\\"GetYoDigits\\\"])(6, 'accordion');\\n\\n          if (hash !== id) {\\n            if (hash !== '') {\\n              jquery__WEBPACK_IMPORTED_MODULE_0___default()(value).attr('id', hash);\\n            } else {\\n              hash = id;\\n              jquery__WEBPACK_IMPORTED_MODULE_0___default()(value).attr('id', hash);\\n              jquery__WEBPACK_IMPORTED_MODULE_0___default()($liHeadsA.get(key)).attr('href', jquery__WEBPACK_IMPORTED_MODULE_0___default()($liHeadsA.get(key)).attr('href').replace('#', '') + '#' + hash);\\n            }\\n\\n            ;\\n          }\\n\\n          ;\\n          var isActive = jquery__WEBPACK_IMPORTED_MODULE_0___default()($liHeads.get(key)).hasClass('is-active');\\n\\n          if (isActive) {\\n            tempValue.addClass('is-active');\\n          }\\n\\n          ;\\n        });\\n        $liHeads.addClass(tabsTitle);\\n      }\\n\\n      ;\\n    }\\n    /**\\n     * Destroys the instance of the current plugin on this element, as well as the window resize handler that switches the plugins out.\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"_destroy\\\",\\n    value: function _destroy() {\\n      if (this.currentPlugin) this.currentPlugin.destroy();\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off('changed.zf.mediaquery', this._changedZfMediaQueryHandler);\\n    }\\n  }]);\\n\\n  return ResponsiveAccordionTabs;\\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_3__[\\\"Plugin\\\"]);\\n\\nResponsiveAccordionTabs.defaults = {};\\n\\n\\n//# sourceURL=webpack:///./js/foundation.responsiveAccordionTabs.js?\");\n    }, \"./js/foundation.responsiveMenu.js\": function jsFoundationResponsiveMenuJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ResponsiveMenu\", function() { return ResponsiveMenu; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.util.mediaQuery */ \"./js/foundation.util.mediaQuery.js\");\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.core.plugin */ \"./js/foundation.core.plugin.js\");\\n/* harmony import */ var _foundation_dropdownMenu__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.dropdownMenu */ \"./js/foundation.dropdownMenu.js\");\\n/* harmony import */ var _foundation_drilldown__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./foundation.drilldown */ \"./js/foundation.drilldown.js\");\\n/* harmony import */ var _foundation_accordionMenu__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./foundation.accordionMenu */ \"./js/foundation.accordionMenu.js\");\\n\\n\\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn\\'t been initialised - super() hasn\\'t been called\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n\\n\\n\\n\\n\\n\\n\\nvar MenuPlugins = {\\n  dropdown: {\\n    cssClass: \\'dropdown\\',\\n    plugin: _foundation_dropdownMenu__WEBPACK_IMPORTED_MODULE_4__[\"DropdownMenu\"]\\n  },\\n  drilldown: {\\n    cssClass: \\'drilldown\\',\\n    plugin: _foundation_drilldown__WEBPACK_IMPORTED_MODULE_5__[\"Drilldown\"]\\n  },\\n  accordion: {\\n    cssClass: \\'accordion-menu\\',\\n    plugin: _foundation_accordionMenu__WEBPACK_IMPORTED_MODULE_6__[\"AccordionMenu\"]\\n  }\\n}; // import \"foundation.util.triggers.js\";\\n\\n/**\\n * ResponsiveMenu module.\\n * @module foundation.responsiveMenu\\n * @requires foundation.util.triggers\\n * @requires foundation.util.mediaQuery\\n */\\n\\nvar ResponsiveMenu =\\n/*#__PURE__*/\\nfunction (_Plugin) {\\n  _inherits(ResponsiveMenu, _Plugin);\\n\\n  function ResponsiveMenu() {\\n    _classCallCheck(this, ResponsiveMenu);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(ResponsiveMenu).apply(this, arguments));\\n  }\\n\\n  _createClass(ResponsiveMenu, [{\\n    key: \"_setup\",\\n\\n    /**\\n     * Creates a new instance of a responsive menu.\\n     * @class\\n     * @name ResponsiveMenu\\n     * @fires ResponsiveMenu#init\\n     * @param {jQuery} element - jQuery object to make into a dropdown menu.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = jquery__WEBPACK_IMPORTED_MODULE_0___default()(element);\\n      this.rules = this.$element.data(\\'responsive-menu\\');\\n      this.currentMq = null;\\n      this.currentPlugin = null;\\n      this.className = \\'ResponsiveMenu\\'; // ie9 back compat\\n\\n      this._init();\\n\\n      this._events();\\n    }\\n    /**\\n     * Initializes the Menu by parsing the classes from the \\'data-ResponsiveMenu\\' attribute on the element.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \"_init\",\\n    value: function _init() {\\n      _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__[\"MediaQuery\"]._init(); // The first time an Interchange plugin is initialized, this.rules is converted from a string of \"classes\" to an object of rules\\n\\n\\n      if (typeof this.rules === \\'string\\') {\\n        var rulesTree = {}; // Parse rules from \"classes\" pulled from data attribute\\n\\n        var rules = this.rules.split(\\' \\'); // Iterate through every rule found\\n\\n        for (var i = 0; i < rules.length; i++) {\\n          var rule = rules[i].split(\\'-\\');\\n          var ruleSize = rule.length > 1 ? rule[0] : \\'small\\';\\n          var rulePlugin = rule.length > 1 ? rule[1] : rule[0];\\n\\n          if (MenuPlugins[rulePlugin] !== null) {\\n            rulesTree[ruleSize] = MenuPlugins[rulePlugin];\\n          }\\n        }\\n\\n        this.rules = rulesTree;\\n      }\\n\\n      if (!jquery__WEBPACK_IMPORTED_MODULE_0___default.a.isEmptyObject(this.rules)) {\\n        this._checkMediaQueries();\\n      } // Add data-mutate since children may need it.\\n\\n\\n      this.$element.attr(\\'data-mutate\\', this.$element.attr(\\'data-mutate\\') || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"GetYoDigits\"])(6, \\'responsive-menu\\'));\\n    }\\n    /**\\n     * Initializes events for the Menu.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \"_events\",\\n    value: function _events() {\\n      var _this = this;\\n\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on(\\'changed.zf.mediaquery\\', function () {\\n        _this._checkMediaQueries();\\n      }); // $(window).on(\\'resize.zf.ResponsiveMenu\\', function() {\\n      //   _this._checkMediaQueries();\\n      // });\\n    }\\n    /**\\n     * Checks the current screen width against available media queries. If the media query has changed, and the plugin needed has changed, the plugins will swap out.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \"_checkMediaQueries\",\\n    value: function _checkMediaQueries() {\\n      var matchedMq,\\n          _this = this; // Iterate through each rule and find the last matching rule\\n\\n\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default.a.each(this.rules, function (key) {\\n        if (_foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__[\"MediaQuery\"].atLeast(key)) {\\n          matchedMq = key;\\n        }\\n      }); // No match? No dice\\n\\n      if (!matchedMq) return; // Plugin already initialized? We good\\n\\n      if (this.currentPlugin instanceof this.rules[matchedMq].plugin) return; // Remove existing plugin-specific CSS classes\\n\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default.a.each(MenuPlugins, function (key, value) {\\n        _this.$element.removeClass(value.cssClass);\\n      }); // Add the CSS class for the new plugin\\n\\n      this.$element.addClass(this.rules[matchedMq].cssClass); // Create an instance of the new plugin\\n\\n      if (this.currentPlugin) this.currentPlugin.destroy();\\n      this.currentPlugin = new this.rules[matchedMq].plugin(this.$element, {});\\n    }\\n    /**\\n     * Destroys the instance of the current plugin on this element, as well as the window resize handler that switches the plugins out.\\n     * @function\\n     */\\n\\n  }, {\\n    key: \"_destroy\",\\n    value: function _destroy() {\\n      this.currentPlugin.destroy();\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off(\\'.zf.ResponsiveMenu\\');\\n    }\\n  }]);\\n\\n  return ResponsiveMenu;\\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_3__[\"Plugin\"]);\\n\\nResponsiveMenu.defaults = {};\\n\\n\\n//# sourceURL=webpack:///./js/foundation.responsiveMenu.js?');\n    }, \"./js/foundation.responsiveToggle.js\": function jsFoundationResponsiveToggleJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ResponsiveToggle\", function() { return ResponsiveToggle; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.util.mediaQuery */ \"./js/foundation.util.mediaQuery.js\");\\n/* harmony import */ var _foundation_util_motion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.util.motion */ \"./js/foundation.util.motion.js\");\\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.core.plugin */ \"./js/foundation.core.plugin.js\");\\n\\n\\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn\\'t been initialised - super() hasn\\'t been called\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n\\n\\n\\n\\n/**\\n * ResponsiveToggle module.\\n * @module foundation.responsiveToggle\\n * @requires foundation.util.mediaQuery\\n * @requires foundation.util.motion\\n */\\n\\nvar ResponsiveToggle =\\n/*#__PURE__*/\\nfunction (_Plugin) {\\n  _inherits(ResponsiveToggle, _Plugin);\\n\\n  function ResponsiveToggle() {\\n    _classCallCheck(this, ResponsiveToggle);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(ResponsiveToggle).apply(this, arguments));\\n  }\\n\\n  _createClass(ResponsiveToggle, [{\\n    key: \"_setup\",\\n\\n    /**\\n     * Creates a new instance of Tab Bar.\\n     * @class\\n     * @name ResponsiveToggle\\n     * @fires ResponsiveToggle#init\\n     * @param {jQuery} element - jQuery object to attach tab bar functionality to.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = jquery__WEBPACK_IMPORTED_MODULE_0___default()(element);\\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, ResponsiveToggle.defaults, this.$element.data(), options);\\n      this.className = \\'ResponsiveToggle\\'; // ie9 back compat\\n\\n      this._init();\\n\\n      this._events();\\n    }\\n    /**\\n     * Initializes the tab bar by finding the target element, toggling element, and running update().\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \"_init\",\\n    value: function _init() {\\n      _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__[\"MediaQuery\"]._init();\\n\\n      var targetID = this.$element.data(\\'responsive-toggle\\');\\n\\n      if (!targetID) {\\n        console.error(\\'Your tab bar needs an ID of a Menu as the value of data-tab-bar.\\');\\n      }\\n\\n      this.$targetMenu = jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"#\".concat(targetID));\\n      this.$toggler = this.$element.find(\\'[data-toggle]\\').filter(function () {\\n        var target = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data(\\'toggle\\');\\n        return target === targetID || target === \"\";\\n      });\\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, this.options, this.$targetMenu.data()); // If they were set, parse the animation classes\\n\\n      if (this.options.animate) {\\n        var input = this.options.animate.split(\\' \\');\\n        this.animationIn = input[0];\\n        this.animationOut = input[1] || null;\\n      }\\n\\n      this._update();\\n    }\\n    /**\\n     * Adds necessary event handlers for the tab bar to work.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \"_events\",\\n    value: function _events() {\\n      var _this = this;\\n\\n      this._updateMqHandler = this._update.bind(this);\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on(\\'changed.zf.mediaquery\\', this._updateMqHandler);\\n      this.$toggler.on(\\'click.zf.responsiveToggle\\', this.toggleMenu.bind(this));\\n    }\\n    /**\\n     * Checks the current media query to determine if the tab bar should be visible or hidden.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \"_update\",\\n    value: function _update() {\\n      // Mobile\\n      if (!_foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__[\"MediaQuery\"].atLeast(this.options.hideFor)) {\\n        this.$element.show();\\n        this.$targetMenu.hide();\\n      } // Desktop\\n      else {\\n          this.$element.hide();\\n          this.$targetMenu.show();\\n        }\\n    }\\n    /**\\n     * Toggles the element attached to the tab bar. The toggle only happens if the screen is small enough to allow it.\\n     * @function\\n     * @fires ResponsiveToggle#toggled\\n     */\\n\\n  }, {\\n    key: \"toggleMenu\",\\n    value: function toggleMenu() {\\n      var _this2 = this;\\n\\n      if (!_foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__[\"MediaQuery\"].atLeast(this.options.hideFor)) {\\n        /**\\n         * Fires when the element attached to the tab bar toggles.\\n         * @event ResponsiveToggle#toggled\\n         */\\n        if (this.options.animate) {\\n          if (this.$targetMenu.is(\\':hidden\\')) {\\n            _foundation_util_motion__WEBPACK_IMPORTED_MODULE_2__[\"Motion\"].animateIn(this.$targetMenu, this.animationIn, function () {\\n              _this2.$element.trigger(\\'toggled.zf.responsiveToggle\\');\\n\\n              _this2.$targetMenu.find(\\'[data-mutate]\\').triggerHandler(\\'mutateme.zf.trigger\\');\\n            });\\n          } else {\\n            _foundation_util_motion__WEBPACK_IMPORTED_MODULE_2__[\"Motion\"].animateOut(this.$targetMenu, this.animationOut, function () {\\n              _this2.$element.trigger(\\'toggled.zf.responsiveToggle\\');\\n            });\\n          }\\n        } else {\\n          this.$targetMenu.toggle(0);\\n          this.$targetMenu.find(\\'[data-mutate]\\').trigger(\\'mutateme.zf.trigger\\');\\n          this.$element.trigger(\\'toggled.zf.responsiveToggle\\');\\n        }\\n      }\\n    }\\n  }, {\\n    key: \"_destroy\",\\n    value: function _destroy() {\\n      this.$element.off(\\'.zf.responsiveToggle\\');\\n      this.$toggler.off(\\'.zf.responsiveToggle\\');\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off(\\'changed.zf.mediaquery\\', this._updateMqHandler);\\n    }\\n  }]);\\n\\n  return ResponsiveToggle;\\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_3__[\"Plugin\"]);\\n\\nResponsiveToggle.defaults = {\\n  /**\\n   * The breakpoint after which the menu is always shown, and the tab bar is hidden.\\n   * @option\\n   * @type {string}\\n   * @default \\'medium\\'\\n   */\\n  hideFor: \\'medium\\',\\n\\n  /**\\n   * To decide if the toggle should be animated or not.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  animate: false\\n};\\n\\n\\n//# sourceURL=webpack:///./js/foundation.responsiveToggle.js?');\n    }, \"./js/foundation.reveal.js\": function jsFoundationRevealJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Reveal\\\", function() { return Reveal; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.utils */ \\\"./js/foundation.core.utils.js\\\");\\n/* harmony import */ var _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.util.keyboard */ \\\"./js/foundation.util.keyboard.js\\\");\\n/* harmony import */ var _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.util.mediaQuery */ \\\"./js/foundation.util.mediaQuery.js\\\");\\n/* harmony import */ var _foundation_util_motion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.util.motion */ \\\"./js/foundation.util.motion.js\\\");\\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./foundation.core.plugin */ \\\"./js/foundation.core.plugin.js\\\");\\n/* harmony import */ var _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./foundation.util.triggers */ \\\"./js/foundation.util.triggers.js\\\");\\n\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * Reveal module.\\n * @module foundation.reveal\\n * @requires foundation.util.keyboard\\n * @requires foundation.util.triggers\\n * @requires foundation.util.mediaQuery\\n * @requires foundation.util.motion if using animations\\n */\\n\\nvar Reveal =\\n/*#__PURE__*/\\nfunction (_Plugin) {\\n  _inherits(Reveal, _Plugin);\\n\\n  function Reveal() {\\n    _classCallCheck(this, Reveal);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(Reveal).apply(this, arguments));\\n  }\\n\\n  _createClass(Reveal, [{\\n    key: \\\"_setup\\\",\\n\\n    /**\\n     * Creates a new instance of Reveal.\\n     * @class\\n     * @name Reveal\\n     * @param {jQuery} element - jQuery object to use for the modal.\\n     * @param {Object} options - optional parameters.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, Reveal.defaults, this.$element.data(), options);\\n      this.className = 'Reveal'; // ie9 back compat\\n\\n      this._init(); // Triggers init is idempotent, just need to make sure it is initialized\\n\\n\\n      _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_6__[\\\"Triggers\\\"].init(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\\n      _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_2__[\\\"Keyboard\\\"].register('Reveal', {\\n        'ESCAPE': 'close'\\n      });\\n    }\\n    /**\\n     * Initializes the modal by adding the overlay and close buttons, (if selected).\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_init\\\",\\n    value: function _init() {\\n      var _this2 = this;\\n\\n      _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_3__[\\\"MediaQuery\\\"]._init();\\n\\n      this.id = this.$element.attr('id');\\n      this.isActive = false;\\n      this.cached = {\\n        mq: _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_3__[\\\"MediaQuery\\\"].current\\n      };\\n      this.$anchor = jquery__WEBPACK_IMPORTED_MODULE_0___default()(\\\"[data-open=\\\\\\\"\\\".concat(this.id, \\\"\\\\\\\"]\\\")).length ? jquery__WEBPACK_IMPORTED_MODULE_0___default()(\\\"[data-open=\\\\\\\"\\\".concat(this.id, \\\"\\\\\\\"]\\\")) : jquery__WEBPACK_IMPORTED_MODULE_0___default()(\\\"[data-toggle=\\\\\\\"\\\".concat(this.id, \\\"\\\\\\\"]\\\"));\\n      this.$anchor.attr({\\n        'aria-controls': this.id,\\n        'aria-haspopup': true,\\n        'tabindex': 0\\n      });\\n\\n      if (this.options.fullScreen || this.$element.hasClass('full')) {\\n        this.options.fullScreen = true;\\n        this.options.overlay = false;\\n      }\\n\\n      if (this.options.overlay && !this.$overlay) {\\n        this.$overlay = this._makeOverlay(this.id);\\n      }\\n\\n      this.$element.attr({\\n        'role': 'dialog',\\n        'aria-hidden': true,\\n        'data-yeti-box': this.id,\\n        'data-resize': this.id\\n      });\\n\\n      if (this.$overlay) {\\n        this.$element.detach().appendTo(this.$overlay);\\n      } else {\\n        this.$element.detach().appendTo(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this.options.appendTo));\\n        this.$element.addClass('without-overlay');\\n      }\\n\\n      this._events();\\n\\n      if (this.options.deepLink && window.location.hash === \\\"#\\\".concat(this.id)) {\\n        this.onLoadListener = Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\\\"onLoad\\\"])(jquery__WEBPACK_IMPORTED_MODULE_0___default()(window), function () {\\n          return _this2.open();\\n        });\\n      }\\n    }\\n    /**\\n     * Creates an overlay div to display behind the modal.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_makeOverlay\\\",\\n    value: function _makeOverlay() {\\n      var additionalOverlayClasses = '';\\n\\n      if (this.options.additionalOverlayClasses) {\\n        additionalOverlayClasses = ' ' + this.options.additionalOverlayClasses;\\n      }\\n\\n      return jquery__WEBPACK_IMPORTED_MODULE_0___default()('<div></div>').addClass('reveal-overlay' + additionalOverlayClasses).appendTo(this.options.appendTo);\\n    }\\n    /**\\n     * Updates position of modal\\n     * TODO:  Figure out if we actually need to cache these values or if it doesn't matter\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_updatePosition\\\",\\n    value: function _updatePosition() {\\n      var width = this.$element.outerWidth();\\n      var outerWidth = jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).width();\\n      var height = this.$element.outerHeight();\\n      var outerHeight = jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).height();\\n      var left,\\n          top = null;\\n\\n      if (this.options.hOffset === 'auto') {\\n        left = parseInt((outerWidth - width) / 2, 10);\\n      } else {\\n        left = parseInt(this.options.hOffset, 10);\\n      }\\n\\n      if (this.options.vOffset === 'auto') {\\n        if (height > outerHeight) {\\n          top = parseInt(Math.min(100, outerHeight / 10), 10);\\n        } else {\\n          top = parseInt((outerHeight - height) / 4, 10);\\n        }\\n      } else if (this.options.vOffset !== null) {\\n        top = parseInt(this.options.vOffset, 10);\\n      }\\n\\n      if (top !== null) {\\n        this.$element.css({\\n          top: top + 'px'\\n        });\\n      } // only worry about left if we don't have an overlay or we have a horizontal offset,\\n      // otherwise we're perfectly in the middle\\n\\n\\n      if (!this.$overlay || this.options.hOffset !== 'auto') {\\n        this.$element.css({\\n          left: left + 'px'\\n        });\\n        this.$element.css({\\n          margin: '0px'\\n        });\\n      }\\n    }\\n    /**\\n     * Adds event handlers for the modal.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_events\\\",\\n    value: function _events() {\\n      var _this3 = this;\\n\\n      var _this = this;\\n\\n      this.$element.on({\\n        'open.zf.trigger': this.open.bind(this),\\n        'close.zf.trigger': function closeZfTrigger(event, $element) {\\n          if (event.target === _this.$element[0] || jquery__WEBPACK_IMPORTED_MODULE_0___default()(event.target).parents('[data-closable]')[0] === $element) {\\n            // only close reveal when it's explicitly called\\n            return _this3.close.apply(_this3);\\n          }\\n        },\\n        'toggle.zf.trigger': this.toggle.bind(this),\\n        'resizeme.zf.trigger': function resizemeZfTrigger() {\\n          _this._updatePosition();\\n        }\\n      });\\n\\n      if (this.options.closeOnClick && this.options.overlay) {\\n        this.$overlay.off('.zf.reveal').on('click.zf.reveal', function (e) {\\n          if (e.target === _this.$element[0] || jquery__WEBPACK_IMPORTED_MODULE_0___default.a.contains(_this.$element[0], e.target) || !jquery__WEBPACK_IMPORTED_MODULE_0___default.a.contains(document, e.target)) {\\n            return;\\n          }\\n\\n          _this.close();\\n        });\\n      }\\n\\n      if (this.options.deepLink) {\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on(\\\"hashchange.zf.reveal:\\\".concat(this.id), this._handleState.bind(this));\\n      }\\n    }\\n    /**\\n     * Handles modal methods on back/forward button clicks or any other event that triggers hashchange.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_handleState\\\",\\n    value: function _handleState(e) {\\n      if (window.location.hash === '#' + this.id && !this.isActive) {\\n        this.open();\\n      } else {\\n        this.close();\\n      }\\n    }\\n    /**\\n    * Disables the scroll when Reveal is shown to prevent the background from shifting\\n    * @param {number} scrollTop - Scroll to visually apply, window current scroll by default\\n    */\\n\\n  }, {\\n    key: \\\"_disableScroll\\\",\\n    value: function _disableScroll(scrollTop) {\\n      scrollTop = scrollTop || jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).scrollTop();\\n\\n      if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).height() > jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).height()) {\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(\\\"html\\\").css(\\\"top\\\", -scrollTop);\\n      }\\n    }\\n    /**\\n    * Reenables the scroll when Reveal closes\\n    * @param {number} scrollTop - Scroll to restore, html \\\"top\\\" property by default (as set by `_disableScroll`)\\n    */\\n\\n  }, {\\n    key: \\\"_enableScroll\\\",\\n    value: function _enableScroll(scrollTop) {\\n      scrollTop = scrollTop || parseInt(jquery__WEBPACK_IMPORTED_MODULE_0___default()(\\\"html\\\").css(\\\"top\\\"));\\n\\n      if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).height() > jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).height()) {\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(\\\"html\\\").css(\\\"top\\\", \\\"\\\");\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).scrollTop(-scrollTop);\\n      }\\n    }\\n    /**\\n     * Opens the modal controlled by `this.$anchor`, and closes all others by default.\\n     * @function\\n     * @fires Reveal#closeme\\n     * @fires Reveal#open\\n     */\\n\\n  }, {\\n    key: \\\"open\\\",\\n    value: function open() {\\n      var _this4 = this;\\n\\n      // either update or replace browser history\\n      var hash = \\\"#\\\".concat(this.id);\\n\\n      if (this.options.deepLink && window.location.hash !== hash) {\\n        if (window.history.pushState) {\\n          if (this.options.updateHistory) {\\n            window.history.pushState({}, '', hash);\\n          } else {\\n            window.history.replaceState({}, '', hash);\\n          }\\n        } else {\\n          window.location.hash = hash;\\n        }\\n      } // Remember anchor that opened it to set focus back later, have general anchors as fallback\\n\\n\\n      this.$activeAnchor = jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.activeElement).is(this.$anchor) ? jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.activeElement) : this.$anchor;\\n      this.isActive = true; // Make elements invisible, but remove display: none so we can get size and positioning\\n\\n      this.$element.css({\\n        'visibility': 'hidden'\\n      }).show().scrollTop(0);\\n\\n      if (this.options.overlay) {\\n        this.$overlay.css({\\n          'visibility': 'hidden'\\n        }).show();\\n      }\\n\\n      this._updatePosition();\\n\\n      this.$element.hide().css({\\n        'visibility': ''\\n      });\\n\\n      if (this.$overlay) {\\n        this.$overlay.css({\\n          'visibility': ''\\n        }).hide();\\n\\n        if (this.$element.hasClass('fast')) {\\n          this.$overlay.addClass('fast');\\n        } else if (this.$element.hasClass('slow')) {\\n          this.$overlay.addClass('slow');\\n        }\\n      }\\n\\n      if (!this.options.multipleOpened) {\\n        /**\\n         * Fires immediately before the modal opens.\\n         * Closes any other modals that are currently open\\n         * @event Reveal#closeme\\n         */\\n        this.$element.trigger('closeme.zf.reveal', this.id);\\n      }\\n\\n      this._disableScroll();\\n\\n      var _this = this; // Motion UI method of reveal\\n\\n\\n      if (this.options.animationIn) {\\n        var afterAnimation = function afterAnimation() {\\n          _this.$element.attr({\\n            'aria-hidden': false,\\n            'tabindex': -1\\n          }).focus();\\n\\n          _this._addGlobalClasses();\\n\\n          _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_2__[\\\"Keyboard\\\"].trapFocus(_this.$element);\\n        };\\n\\n        if (this.options.overlay) {\\n          _foundation_util_motion__WEBPACK_IMPORTED_MODULE_4__[\\\"Motion\\\"].animateIn(this.$overlay, 'fade-in');\\n        }\\n\\n        _foundation_util_motion__WEBPACK_IMPORTED_MODULE_4__[\\\"Motion\\\"].animateIn(this.$element, this.options.animationIn, function () {\\n          if (_this4.$element) {\\n            // protect against object having been removed\\n            _this4.focusableElements = _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_2__[\\\"Keyboard\\\"].findFocusable(_this4.$element);\\n            afterAnimation();\\n          }\\n        });\\n      } // jQuery method of reveal\\n      else {\\n          if (this.options.overlay) {\\n            this.$overlay.show(0);\\n          }\\n\\n          this.$element.show(this.options.showDelay);\\n        } // handle accessibility\\n\\n\\n      this.$element.attr({\\n        'aria-hidden': false,\\n        'tabindex': -1\\n      }).focus();\\n      _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_2__[\\\"Keyboard\\\"].trapFocus(this.$element);\\n\\n      this._addGlobalClasses();\\n\\n      this._addGlobalListeners();\\n      /**\\n       * Fires when the modal has successfully opened.\\n       * @event Reveal#open\\n       */\\n\\n\\n      this.$element.trigger('open.zf.reveal');\\n    }\\n    /**\\n     * Adds classes and listeners on document required by open modals.\\n     *\\n     * The following classes are added and updated:\\n     * - `.is-reveal-open` - Prevents the scroll on document\\n     * - `.zf-has-scroll`  - Displays a disabled scrollbar on document if required like if the\\n     *                       scroll was not disabled. This prevent a \\\"shift\\\" of the page content due\\n     *                       the scrollbar disappearing when the modal opens.\\n     *\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_addGlobalClasses\\\",\\n    value: function _addGlobalClasses() {\\n      var updateScrollbarClass = function updateScrollbarClass() {\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()('html').toggleClass('zf-has-scroll', !!(jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).height() > jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).height()));\\n      };\\n\\n      this.$element.on('resizeme.zf.trigger.revealScrollbarListener', function () {\\n        return updateScrollbarClass();\\n      });\\n      updateScrollbarClass();\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()('html').addClass('is-reveal-open');\\n    }\\n    /**\\n     * Removes classes and listeners on document that were required by open modals.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_removeGlobalClasses\\\",\\n    value: function _removeGlobalClasses() {\\n      this.$element.off('resizeme.zf.trigger.revealScrollbarListener');\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()('html').removeClass('is-reveal-open');\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()('html').removeClass('zf-has-scroll');\\n    }\\n    /**\\n     * Adds extra event handlers for the body and window if necessary.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_addGlobalListeners\\\",\\n    value: function _addGlobalListeners() {\\n      var _this = this;\\n\\n      if (!this.$element) {\\n        return;\\n      } // If we're in the middle of cleanup, don't freak out\\n\\n\\n      this.focusableElements = _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_2__[\\\"Keyboard\\\"].findFocusable(this.$element);\\n\\n      if (!this.options.overlay && this.options.closeOnClick && !this.options.fullScreen) {\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()('body').on('click.zf.reveal', function (e) {\\n          if (e.target === _this.$element[0] || jquery__WEBPACK_IMPORTED_MODULE_0___default.a.contains(_this.$element[0], e.target) || !jquery__WEBPACK_IMPORTED_MODULE_0___default.a.contains(document, e.target)) {\\n            return;\\n          }\\n\\n          _this.close();\\n        });\\n      }\\n\\n      if (this.options.closeOnEsc) {\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on('keydown.zf.reveal', function (e) {\\n          _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_2__[\\\"Keyboard\\\"].handleKey(e, 'Reveal', {\\n            close: function close() {\\n              if (_this.options.closeOnEsc) {\\n                _this.close();\\n              }\\n            }\\n          });\\n        });\\n      }\\n    }\\n    /**\\n     * Closes the modal.\\n     * @function\\n     * @fires Reveal#closed\\n     */\\n\\n  }, {\\n    key: \\\"close\\\",\\n    value: function close() {\\n      if (!this.isActive || !this.$element.is(':visible')) {\\n        return false;\\n      }\\n\\n      var _this = this; // Motion UI method of hiding\\n\\n\\n      if (this.options.animationOut) {\\n        if (this.options.overlay) {\\n          _foundation_util_motion__WEBPACK_IMPORTED_MODULE_4__[\\\"Motion\\\"].animateOut(this.$overlay, 'fade-out');\\n        }\\n\\n        _foundation_util_motion__WEBPACK_IMPORTED_MODULE_4__[\\\"Motion\\\"].animateOut(this.$element, this.options.animationOut, finishUp);\\n      } // jQuery method of hiding\\n      else {\\n          this.$element.hide(this.options.hideDelay);\\n\\n          if (this.options.overlay) {\\n            this.$overlay.hide(0, finishUp);\\n          } else {\\n            finishUp();\\n          }\\n        } // Conditionals to remove extra event listeners added on open\\n\\n\\n      if (this.options.closeOnEsc) {\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off('keydown.zf.reveal');\\n      }\\n\\n      if (!this.options.overlay && this.options.closeOnClick) {\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()('body').off('click.zf.reveal');\\n      }\\n\\n      this.$element.off('keydown.zf.reveal');\\n\\n      function finishUp() {\\n        // Get the current top before the modal is closed and restore the scroll after.\\n        // TODO: use component properties instead of HTML properties\\n        // See https://github.com/zurb/foundation-sites/pull/10786\\n        var scrollTop = parseInt(jquery__WEBPACK_IMPORTED_MODULE_0___default()(\\\"html\\\").css(\\\"top\\\"));\\n\\n        if (jquery__WEBPACK_IMPORTED_MODULE_0___default()('.reveal:visible').length === 0) {\\n          _this._removeGlobalClasses(); // also remove .is-reveal-open from the html element when there is no opened reveal\\n\\n        }\\n\\n        _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_2__[\\\"Keyboard\\\"].releaseFocus(_this.$element);\\n\\n        _this.$element.attr('aria-hidden', true);\\n\\n        _this._enableScroll(scrollTop);\\n        /**\\n        * Fires when the modal is done closing.\\n        * @event Reveal#closed\\n        */\\n\\n\\n        _this.$element.trigger('closed.zf.reveal');\\n      }\\n      /**\\n      * Resets the modal content\\n      * This prevents a running video to keep going in the background\\n      */\\n\\n\\n      if (this.options.resetOnClose) {\\n        this.$element.html(this.$element.html());\\n      }\\n\\n      this.isActive = false; // If deepLink and we did not switched to an other modal...\\n\\n      if (_this.options.deepLink && window.location.hash === \\\"#\\\".concat(this.id)) {\\n        // Remove the history hash\\n        if (window.history.replaceState) {\\n          var urlWithoutHash = window.location.pathname + window.location.search;\\n\\n          if (this.options.updateHistory) {\\n            window.history.pushState({}, '', urlWithoutHash); // remove the hash\\n          } else {\\n            window.history.replaceState('', document.title, urlWithoutHash);\\n          }\\n        } else {\\n          window.location.hash = '';\\n        }\\n      }\\n\\n      this.$activeAnchor.focus();\\n    }\\n    /**\\n     * Toggles the open/closed state of a modal.\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"toggle\\\",\\n    value: function toggle() {\\n      if (this.isActive) {\\n        this.close();\\n      } else {\\n        this.open();\\n      }\\n    }\\n  }, {\\n    key: \\\"_destroy\\\",\\n\\n    /**\\n     * Destroys an instance of a modal.\\n     * @function\\n     */\\n    value: function _destroy() {\\n      if (this.options.overlay) {\\n        this.$element.appendTo(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this.options.appendTo)); // move $element outside of $overlay to prevent error unregisterPlugin()\\n\\n        this.$overlay.hide().off().remove();\\n      }\\n\\n      this.$element.hide().off();\\n      this.$anchor.off('.zf');\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off(\\\".zf.reveal:\\\".concat(this.id));\\n      if (this.onLoadListener) jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off(this.onLoadListener);\\n\\n      if (jquery__WEBPACK_IMPORTED_MODULE_0___default()('.reveal:visible').length === 0) {\\n        this._removeGlobalClasses(); // also remove .is-reveal-open from the html element when there is no opened reveal\\n\\n      }\\n    }\\n  }]);\\n\\n  return Reveal;\\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_5__[\\\"Plugin\\\"]);\\n\\nReveal.defaults = {\\n  /**\\n   * Motion-UI class to use for animated elements. If none used, defaults to simple show/hide.\\n   * @option\\n   * @type {string}\\n   * @default ''\\n   */\\n  animationIn: '',\\n\\n  /**\\n   * Motion-UI class to use for animated elements. If none used, defaults to simple show/hide.\\n   * @option\\n   * @type {string}\\n   * @default ''\\n   */\\n  animationOut: '',\\n\\n  /**\\n   * Time, in ms, to delay the opening of a modal after a click if no animation used.\\n   * @option\\n   * @type {number}\\n   * @default 0\\n   */\\n  showDelay: 0,\\n\\n  /**\\n   * Time, in ms, to delay the closing of a modal after a click if no animation used.\\n   * @option\\n   * @type {number}\\n   * @default 0\\n   */\\n  hideDelay: 0,\\n\\n  /**\\n   * Allows a click on the body/overlay to close the modal.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  closeOnClick: true,\\n\\n  /**\\n   * Allows the modal to close if the user presses the `ESCAPE` key.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  closeOnEsc: true,\\n\\n  /**\\n   * If true, allows multiple modals to be displayed at once.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  multipleOpened: false,\\n\\n  /**\\n   * Distance, in pixels, the modal should push down from the top of the screen.\\n   * @option\\n   * @type {number|string}\\n   * @default auto\\n   */\\n  vOffset: 'auto',\\n\\n  /**\\n   * Distance, in pixels, the modal should push in from the side of the screen.\\n   * @option\\n   * @type {number|string}\\n   * @default auto\\n   */\\n  hOffset: 'auto',\\n\\n  /**\\n   * Allows the modal to be fullscreen, completely blocking out the rest of the view. JS checks for this as well.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  fullScreen: false,\\n\\n  /**\\n   * Allows the modal to generate an overlay div, which will cover the view when modal opens.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  overlay: true,\\n\\n  /**\\n   * Allows the modal to remove and reinject markup on close. Should be true if using video elements w/o using provider's api, otherwise, videos will continue to play in the background.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  resetOnClose: false,\\n\\n  /**\\n   * Link the location hash to the modal.\\n   * Set the location hash when the modal is opened/closed, and open/close the modal when the location changes.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  deepLink: false,\\n\\n  /**\\n   * If `deepLink` is enabled, update the browser history with the open modal\\n   * @option\\n   * @default false\\n   */\\n  updateHistory: false,\\n\\n  /**\\n  * Allows the modal to append to custom div.\\n  * @option\\n  * @type {string}\\n  * @default \\\"body\\\"\\n  */\\n  appendTo: \\\"body\\\",\\n\\n  /**\\n   * Allows adding additional class names to the reveal overlay.\\n   * @option\\n   * @type {string}\\n   * @default ''\\n   */\\n  additionalOverlayClasses: ''\\n};\\n\\n\\n//# sourceURL=webpack:///./js/foundation.reveal.js?\");\n    }, \"./js/foundation.slider.js\": function jsFoundationSliderJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Slider\\\", function() { return Slider; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.util.keyboard */ \\\"./js/foundation.util.keyboard.js\\\");\\n/* harmony import */ var _foundation_util_motion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.util.motion */ \\\"./js/foundation.util.motion.js\\\");\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.core.utils */ \\\"./js/foundation.core.utils.js\\\");\\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.core.plugin */ \\\"./js/foundation.core.plugin.js\\\");\\n/* harmony import */ var _foundation_util_touch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./foundation.util.touch */ \\\"./js/foundation.util.touch.js\\\");\\n/* harmony import */ var _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./foundation.util.triggers */ \\\"./js/foundation.util.triggers.js\\\");\\n\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * Slider module.\\n * @module foundation.slider\\n * @requires foundation.util.motion\\n * @requires foundation.util.triggers\\n * @requires foundation.util.keyboard\\n * @requires foundation.util.touch\\n */\\n\\nvar Slider =\\n/*#__PURE__*/\\nfunction (_Plugin) {\\n  _inherits(Slider, _Plugin);\\n\\n  function Slider() {\\n    _classCallCheck(this, Slider);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(Slider).apply(this, arguments));\\n  }\\n\\n  _createClass(Slider, [{\\n    key: \\\"_setup\\\",\\n\\n    /**\\n     * Creates a new instance of a slider control.\\n     * @class\\n     * @name Slider\\n     * @param {jQuery} element - jQuery object to make into a slider control.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, Slider.defaults, this.$element.data(), options);\\n      this.className = 'Slider'; // ie9 back compat\\n      // Touch and Triggers inits are idempotent, we just need to make sure it's initialied.\\n\\n      _foundation_util_touch__WEBPACK_IMPORTED_MODULE_5__[\\\"Touch\\\"].init(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\\n      _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_6__[\\\"Triggers\\\"].init(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\\n\\n      this._init();\\n\\n      _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\\\"Keyboard\\\"].register('Slider', {\\n        'ltr': {\\n          'ARROW_RIGHT': 'increase',\\n          'ARROW_UP': 'increase',\\n          'ARROW_DOWN': 'decrease',\\n          'ARROW_LEFT': 'decrease',\\n          'SHIFT_ARROW_RIGHT': 'increase_fast',\\n          'SHIFT_ARROW_UP': 'increase_fast',\\n          'SHIFT_ARROW_DOWN': 'decrease_fast',\\n          'SHIFT_ARROW_LEFT': 'decrease_fast',\\n          'HOME': 'min',\\n          'END': 'max'\\n        },\\n        'rtl': {\\n          'ARROW_LEFT': 'increase',\\n          'ARROW_RIGHT': 'decrease',\\n          'SHIFT_ARROW_LEFT': 'increase_fast',\\n          'SHIFT_ARROW_RIGHT': 'decrease_fast'\\n        }\\n      });\\n    }\\n    /**\\n     * Initilizes the plugin by reading/setting attributes, creating collections and setting the initial position of the handle(s).\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_init\\\",\\n    value: function _init() {\\n      this.inputs = this.$element.find('input');\\n      this.handles = this.$element.find('[data-slider-handle]');\\n      this.$handle = this.handles.eq(0);\\n      this.$input = this.inputs.length ? this.inputs.eq(0) : jquery__WEBPACK_IMPORTED_MODULE_0___default()(\\\"#\\\".concat(this.$handle.attr('aria-controls')));\\n      this.$fill = this.$element.find('[data-slider-fill]').css(this.options.vertical ? 'height' : 'width', 0);\\n\\n      var isDbl = false,\\n          _this = this;\\n\\n      if (this.options.disabled || this.$element.hasClass(this.options.disabledClass)) {\\n        this.options.disabled = true;\\n        this.$element.addClass(this.options.disabledClass);\\n      }\\n\\n      if (!this.inputs.length) {\\n        this.inputs = jquery__WEBPACK_IMPORTED_MODULE_0___default()().add(this.$input);\\n        this.options.binding = true;\\n      }\\n\\n      this._setInitAttr(0);\\n\\n      if (this.handles[1]) {\\n        this.options.doubleSided = true;\\n        this.$handle2 = this.handles.eq(1);\\n        this.$input2 = this.inputs.length > 1 ? this.inputs.eq(1) : jquery__WEBPACK_IMPORTED_MODULE_0___default()(\\\"#\\\".concat(this.$handle2.attr('aria-controls')));\\n\\n        if (!this.inputs[1]) {\\n          this.inputs = this.inputs.add(this.$input2);\\n        }\\n\\n        isDbl = true; // this.$handle.triggerHandler('click.zf.slider');\\n\\n        this._setInitAttr(1);\\n      } // Set handle positions\\n\\n\\n      this.setHandles();\\n\\n      this._events();\\n    }\\n  }, {\\n    key: \\\"setHandles\\\",\\n    value: function setHandles() {\\n      var _this2 = this;\\n\\n      if (this.handles[1]) {\\n        this._setHandlePos(this.$handle, this.inputs.eq(0).val(), true, function () {\\n          _this2._setHandlePos(_this2.$handle2, _this2.inputs.eq(1).val(), true);\\n        });\\n      } else {\\n        this._setHandlePos(this.$handle, this.inputs.eq(0).val(), true);\\n      }\\n    }\\n  }, {\\n    key: \\\"_reflow\\\",\\n    value: function _reflow() {\\n      this.setHandles();\\n    }\\n    /**\\n    * @function\\n    * @private\\n    * @param {Number} value - floating point (the value) to be transformed using to a relative position on the slider (the inverse of _value)\\n    */\\n\\n  }, {\\n    key: \\\"_pctOfBar\\\",\\n    value: function _pctOfBar(value) {\\n      var pctOfBar = percent(value - this.options.start, this.options.end - this.options.start);\\n\\n      switch (this.options.positionValueFunction) {\\n        case \\\"pow\\\":\\n          pctOfBar = this._logTransform(pctOfBar);\\n          break;\\n\\n        case \\\"log\\\":\\n          pctOfBar = this._powTransform(pctOfBar);\\n          break;\\n      }\\n\\n      return pctOfBar.toFixed(2);\\n    }\\n    /**\\n    * @function\\n    * @private\\n    * @param {Number} pctOfBar - floating point, the relative position of the slider (typically between 0-1) to be transformed to a value\\n    */\\n\\n  }, {\\n    key: \\\"_value\\\",\\n    value: function _value(pctOfBar) {\\n      switch (this.options.positionValueFunction) {\\n        case \\\"pow\\\":\\n          pctOfBar = this._powTransform(pctOfBar);\\n          break;\\n\\n        case \\\"log\\\":\\n          pctOfBar = this._logTransform(pctOfBar);\\n          break;\\n      }\\n\\n      var value = (this.options.end - this.options.start) * pctOfBar + parseFloat(this.options.start);\\n      return value;\\n    }\\n    /**\\n    * @function\\n    * @private\\n    * @param {Number} value - floating point (typically between 0-1) to be transformed using the log function\\n    */\\n\\n  }, {\\n    key: \\\"_logTransform\\\",\\n    value: function _logTransform(value) {\\n      return baseLog(this.options.nonLinearBase, value * (this.options.nonLinearBase - 1) + 1);\\n    }\\n    /**\\n    * @function\\n    * @private\\n    * @param {Number} value - floating point (typically between 0-1) to be transformed using the power function\\n    */\\n\\n  }, {\\n    key: \\\"_powTransform\\\",\\n    value: function _powTransform(value) {\\n      return (Math.pow(this.options.nonLinearBase, value) - 1) / (this.options.nonLinearBase - 1);\\n    }\\n    /**\\n     * Sets the position of the selected handle and fill bar.\\n     * @function\\n     * @private\\n     * @param {jQuery} $hndl - the selected handle to move.\\n     * @param {Number} location - floating point between the start and end values of the slider bar.\\n     * @param {Function} cb - callback function to fire on completion.\\n     * @fires Slider#moved\\n     * @fires Slider#changed\\n     */\\n\\n  }, {\\n    key: \\\"_setHandlePos\\\",\\n    value: function _setHandlePos($hndl, location, noInvert, cb) {\\n      // don't move if the slider has been disabled since its initialization\\n      if (this.$element.hasClass(this.options.disabledClass)) {\\n        return;\\n      } //might need to alter that slightly for bars that will have odd number selections.\\n\\n\\n      location = parseFloat(location); //on input change events, convert string to number...grumble.\\n      // prevent slider from running out of bounds, if value exceeds the limits set through options, override the value to min/max\\n\\n      if (location < this.options.start) {\\n        location = this.options.start;\\n      } else if (location > this.options.end) {\\n        location = this.options.end;\\n      }\\n\\n      var isDbl = this.options.doubleSided; //this is for single-handled vertical sliders, it adjusts the value to account for the slider being \\\"upside-down\\\"\\n      //for click and drag events, it's weird due to the scale(-1, 1) css property\\n\\n      if (this.options.vertical && !noInvert) {\\n        location = this.options.end - location;\\n      }\\n\\n      if (isDbl) {\\n        //this block is to prevent 2 handles from crossing eachother. Could/should be improved.\\n        if (this.handles.index($hndl) === 0) {\\n          var h2Val = parseFloat(this.$handle2.attr('aria-valuenow'));\\n          location = location >= h2Val ? h2Val - this.options.step : location;\\n        } else {\\n          var h1Val = parseFloat(this.$handle.attr('aria-valuenow'));\\n          location = location <= h1Val ? h1Val + this.options.step : location;\\n        }\\n      }\\n\\n      var _this = this,\\n          vert = this.options.vertical,\\n          hOrW = vert ? 'height' : 'width',\\n          lOrT = vert ? 'top' : 'left',\\n          handleDim = $hndl[0].getBoundingClientRect()[hOrW],\\n          elemDim = this.$element[0].getBoundingClientRect()[hOrW],\\n          //percentage of bar min/max value based on click or drag point\\n      pctOfBar = this._pctOfBar(location),\\n          //number of actual pixels to shift the handle, based on the percentage obtained above\\n      pxToMove = (elemDim - handleDim) * pctOfBar,\\n          //percentage of bar to shift the handle\\n      movement = (percent(pxToMove, elemDim) * 100).toFixed(this.options.decimal); //fixing the decimal value for the location number, is passed to other methods as a fixed floating-point value\\n\\n\\n      location = parseFloat(location.toFixed(this.options.decimal)); // declare empty object for css adjustments, only used with 2 handled-sliders\\n\\n      var css = {};\\n\\n      this._setValues($hndl, location); // TODO update to calculate based on values set to respective inputs??\\n\\n\\n      if (isDbl) {\\n        var isLeftHndl = this.handles.index($hndl) === 0,\\n            //empty variable, will be used for min-height/width for fill bar\\n        dim,\\n            //percentage w/h of the handle compared to the slider bar\\n        handlePct = ~~(percent(handleDim, elemDim) * 100); //if left handle, the math is slightly different than if it's the right handle, and the left/top property needs to be changed for the fill bar\\n\\n        if (isLeftHndl) {\\n          //left or top percentage value to apply to the fill bar.\\n          css[lOrT] = \\\"\\\".concat(movement, \\\"%\\\"); //calculate the new min-height/width for the fill bar.\\n\\n          dim = parseFloat(this.$handle2[0].style[lOrT]) - movement + handlePct; //this callback is necessary to prevent errors and allow the proper placement and initialization of a 2-handled slider\\n          //plus, it means we don't care if 'dim' isNaN on init, it won't be in the future.\\n\\n          if (cb && typeof cb === 'function') {\\n            cb();\\n          } //this is only needed for the initialization of 2 handled sliders\\n\\n        } else {\\n          //just caching the value of the left/bottom handle's left/top property\\n          var handlePos = parseFloat(this.$handle[0].style[lOrT]); //calculate the new min-height/width for the fill bar. Use isNaN to prevent false positives for numbers <= 0\\n          //based on the percentage of movement of the handle being manipulated, less the opposing handle's left/top position, plus the percentage w/h of the handle itself\\n\\n          dim = movement - (isNaN(handlePos) ? (this.options.initialStart - this.options.start) / ((this.options.end - this.options.start) / 100) : handlePos) + handlePct;\\n        } // assign the min-height/width to our css object\\n\\n\\n        css[\\\"min-\\\".concat(hOrW)] = \\\"\\\".concat(dim, \\\"%\\\");\\n      }\\n\\n      this.$element.one('finished.zf.animate', function () {\\n        /**\\n         * Fires when the handle is done moving.\\n         * @event Slider#moved\\n         */\\n        _this.$element.trigger('moved.zf.slider', [$hndl]);\\n      }); //because we don't know exactly how the handle will be moved, check the amount of time it should take to move.\\n\\n      var moveTime = this.$element.data('dragging') ? 1000 / 60 : this.options.moveTime;\\n      Object(_foundation_util_motion__WEBPACK_IMPORTED_MODULE_2__[\\\"Move\\\"])(moveTime, $hndl, function () {\\n        // adjusting the left/top property of the handle, based on the percentage calculated above\\n        // if movement isNaN, that is because the slider is hidden and we cannot determine handle width,\\n        // fall back to next best guess.\\n        if (isNaN(movement)) {\\n          $hndl.css(lOrT, \\\"\\\".concat(pctOfBar * 100, \\\"%\\\"));\\n        } else {\\n          $hndl.css(lOrT, \\\"\\\".concat(movement, \\\"%\\\"));\\n        }\\n\\n        if (!_this.options.doubleSided) {\\n          //if single-handled, a simple method to expand the fill bar\\n          _this.$fill.css(hOrW, \\\"\\\".concat(pctOfBar * 100, \\\"%\\\"));\\n        } else {\\n          //otherwise, use the css object we created above\\n          _this.$fill.css(css);\\n        }\\n      });\\n      /**\\n       * Fires when the value has not been change for a given time.\\n       * @event Slider#changed\\n       */\\n\\n      clearTimeout(_this.timeout);\\n      _this.timeout = setTimeout(function () {\\n        _this.$element.trigger('changed.zf.slider', [$hndl]);\\n      }, _this.options.changedDelay);\\n    }\\n    /**\\n     * Sets the initial attribute for the slider element.\\n     * @function\\n     * @private\\n     * @param {Number} idx - index of the current handle/input to use.\\n     */\\n\\n  }, {\\n    key: \\\"_setInitAttr\\\",\\n    value: function _setInitAttr(idx) {\\n      var initVal = idx === 0 ? this.options.initialStart : this.options.initialEnd;\\n      var id = this.inputs.eq(idx).attr('id') || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\\\"GetYoDigits\\\"])(6, 'slider');\\n      this.inputs.eq(idx).attr({\\n        'id': id,\\n        'max': this.options.end,\\n        'min': this.options.start,\\n        'step': this.options.step\\n      });\\n      this.inputs.eq(idx).val(initVal);\\n      this.handles.eq(idx).attr({\\n        'role': 'slider',\\n        'aria-controls': id,\\n        'aria-valuemax': this.options.end,\\n        'aria-valuemin': this.options.start,\\n        'aria-valuenow': initVal,\\n        'aria-orientation': this.options.vertical ? 'vertical' : 'horizontal',\\n        'tabindex': 0\\n      });\\n    }\\n    /**\\n     * Sets the input and `aria-valuenow` values for the slider element.\\n     * @function\\n     * @private\\n     * @param {jQuery} $handle - the currently selected handle.\\n     * @param {Number} val - floating point of the new value.\\n     */\\n\\n  }, {\\n    key: \\\"_setValues\\\",\\n    value: function _setValues($handle, val) {\\n      var idx = this.options.doubleSided ? this.handles.index($handle) : 0;\\n      this.inputs.eq(idx).val(val);\\n      $handle.attr('aria-valuenow', val);\\n    }\\n    /**\\n     * Handles events on the slider element.\\n     * Calculates the new location of the current handle.\\n     * If there are two handles and the bar was clicked, it determines which handle to move.\\n     * @function\\n     * @private\\n     * @param {Object} e - the `event` object passed from the listener.\\n     * @param {jQuery} $handle - the current handle to calculate for, if selected.\\n     * @param {Number} val - floating point number for the new value of the slider.\\n     * TODO clean this up, there's a lot of repeated code between this and the _setHandlePos fn.\\n     */\\n\\n  }, {\\n    key: \\\"_handleEvent\\\",\\n    value: function _handleEvent(e, $handle, val) {\\n      var value, hasVal;\\n\\n      if (!val) {\\n        //click or drag events\\n        e.preventDefault();\\n\\n        var _this = this,\\n            vertical = this.options.vertical,\\n            param = vertical ? 'height' : 'width',\\n            direction = vertical ? 'top' : 'left',\\n            eventOffset = vertical ? e.pageY : e.pageX,\\n            halfOfHandle = this.$handle[0].getBoundingClientRect()[param] / 2,\\n            barDim = this.$element[0].getBoundingClientRect()[param],\\n            windowScroll = vertical ? jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).scrollTop() : jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).scrollLeft();\\n\\n        var elemOffset = this.$element.offset()[direction]; // touch events emulated by the touch util give position relative to screen, add window.scroll to event coordinates...\\n        // best way to guess this is simulated is if clientY == pageY\\n\\n        if (e.clientY === e.pageY) {\\n          eventOffset = eventOffset + windowScroll;\\n        }\\n\\n        var eventFromBar = eventOffset - elemOffset;\\n        var barXY;\\n\\n        if (eventFromBar < 0) {\\n          barXY = 0;\\n        } else if (eventFromBar > barDim) {\\n          barXY = barDim;\\n        } else {\\n          barXY = eventFromBar;\\n        }\\n\\n        var offsetPct = percent(barXY, barDim);\\n        value = this._value(offsetPct); // turn everything around for RTL, yay math!\\n\\n        if (Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\\\"rtl\\\"])() && !this.options.vertical) {\\n          value = this.options.end - value;\\n        }\\n\\n        value = _this._adjustValue(null, value); //boolean flag for the setHandlePos fn, specifically for vertical sliders\\n\\n        hasVal = false;\\n\\n        if (!$handle) {\\n          //figure out which handle it is, pass it to the next function.\\n          var firstHndlPos = absPosition(this.$handle, direction, barXY, param),\\n              secndHndlPos = absPosition(this.$handle2, direction, barXY, param);\\n          $handle = firstHndlPos <= secndHndlPos ? this.$handle : this.$handle2;\\n        }\\n      } else {\\n        //change event on input\\n        value = this._adjustValue(null, val);\\n        hasVal = true;\\n      }\\n\\n      this._setHandlePos($handle, value, hasVal);\\n    }\\n    /**\\n     * Adjustes value for handle in regard to step value. returns adjusted value\\n     * @function\\n     * @private\\n     * @param {jQuery} $handle - the selected handle.\\n     * @param {Number} value - value to adjust. used if $handle is falsy\\n     */\\n\\n  }, {\\n    key: \\\"_adjustValue\\\",\\n    value: function _adjustValue($handle, value) {\\n      var val,\\n          step = this.options.step,\\n          div = parseFloat(step / 2),\\n          left,\\n          prev_val,\\n          next_val;\\n\\n      if (!!$handle) {\\n        val = parseFloat($handle.attr('aria-valuenow'));\\n      } else {\\n        val = value;\\n      }\\n\\n      if (val >= 0) {\\n        left = val % step;\\n      } else {\\n        left = step + val % step;\\n      }\\n\\n      prev_val = val - left;\\n      next_val = prev_val + step;\\n\\n      if (left === 0) {\\n        return val;\\n      }\\n\\n      val = val >= prev_val + div ? next_val : prev_val;\\n      return val;\\n    }\\n    /**\\n     * Adds event listeners to the slider elements.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_events\\\",\\n    value: function _events() {\\n      this._eventsForHandle(this.$handle);\\n\\n      if (this.handles[1]) {\\n        this._eventsForHandle(this.$handle2);\\n      }\\n    }\\n    /**\\n     * Adds event listeners a particular handle\\n     * @function\\n     * @private\\n     * @param {jQuery} $handle - the current handle to apply listeners to.\\n     */\\n\\n  }, {\\n    key: \\\"_eventsForHandle\\\",\\n    value: function _eventsForHandle($handle) {\\n      var _this = this,\\n          curHandle,\\n          timer;\\n\\n      var handleChangeEvent = function handleChangeEvent(e) {\\n        var idx = _this.inputs.index(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this));\\n\\n        _this._handleEvent(e, _this.handles.eq(idx), jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).val());\\n      }; // IE only triggers the change event when the input loses focus which strictly follows the HTML specification\\n      // listen for the enter key and trigger a change\\n      // @see https://html.spec.whatwg.org/multipage/input.html#common-input-element-events\\n\\n\\n      this.inputs.off('keyup.zf.slider').on('keyup.zf.slider', function (e) {\\n        if (e.keyCode == 13) handleChangeEvent.call(this, e);\\n      });\\n      this.inputs.off('change.zf.slider').on('change.zf.slider', handleChangeEvent);\\n\\n      if (this.options.clickSelect) {\\n        this.$element.off('click.zf.slider').on('click.zf.slider', function (e) {\\n          if (_this.$element.data('dragging')) {\\n            return false;\\n          }\\n\\n          if (!jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).is('[data-slider-handle]')) {\\n            if (_this.options.doubleSided) {\\n              _this._handleEvent(e);\\n            } else {\\n              _this._handleEvent(e, _this.$handle);\\n            }\\n          }\\n        });\\n      }\\n\\n      if (this.options.draggable) {\\n        this.handles.addTouch();\\n        var $body = jquery__WEBPACK_IMPORTED_MODULE_0___default()('body');\\n        $handle.off('mousedown.zf.slider').on('mousedown.zf.slider', function (e) {\\n          $handle.addClass('is-dragging');\\n\\n          _this.$fill.addClass('is-dragging'); //\\n\\n\\n          _this.$element.data('dragging', true);\\n\\n          curHandle = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.currentTarget);\\n          $body.on('mousemove.zf.slider', function (e) {\\n            e.preventDefault();\\n\\n            _this._handleEvent(e, curHandle);\\n          }).on('mouseup.zf.slider', function (e) {\\n            _this._handleEvent(e, curHandle);\\n\\n            $handle.removeClass('is-dragging');\\n\\n            _this.$fill.removeClass('is-dragging');\\n\\n            _this.$element.data('dragging', false);\\n\\n            $body.off('mousemove.zf.slider mouseup.zf.slider');\\n          });\\n        }) // prevent events triggered by touch\\n        .on('selectstart.zf.slider touchmove.zf.slider', function (e) {\\n          e.preventDefault();\\n        });\\n      }\\n\\n      $handle.off('keydown.zf.slider').on('keydown.zf.slider', function (e) {\\n        var _$handle = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\\n            idx = _this.options.doubleSided ? _this.handles.index(_$handle) : 0,\\n            oldValue = parseFloat(_this.inputs.eq(idx).val()),\\n            newValue; // handle keyboard event with keyboard util\\n\\n\\n        _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\\\"Keyboard\\\"].handleKey(e, 'Slider', {\\n          decrease: function decrease() {\\n            newValue = oldValue - _this.options.step;\\n          },\\n          increase: function increase() {\\n            newValue = oldValue + _this.options.step;\\n          },\\n          decrease_fast: function decrease_fast() {\\n            newValue = oldValue - _this.options.step * 10;\\n          },\\n          increase_fast: function increase_fast() {\\n            newValue = oldValue + _this.options.step * 10;\\n          },\\n          min: function min() {\\n            newValue = _this.options.start;\\n          },\\n          max: function max() {\\n            newValue = _this.options.end;\\n          },\\n          handled: function handled() {\\n            // only set handle pos when event was handled specially\\n            e.preventDefault();\\n\\n            _this._setHandlePos(_$handle, newValue, true);\\n          }\\n        });\\n        /*if (newValue) { // if pressed key has special function, update value\\n          e.preventDefault();\\n          _this._setHandlePos(_$handle, newValue);\\n        }*/\\n      });\\n    }\\n    /**\\n     * Destroys the slider plugin.\\n     */\\n\\n  }, {\\n    key: \\\"_destroy\\\",\\n    value: function _destroy() {\\n      this.handles.off('.zf.slider');\\n      this.inputs.off('.zf.slider');\\n      this.$element.off('.zf.slider');\\n      clearTimeout(this.timeout);\\n    }\\n  }]);\\n\\n  return Slider;\\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_4__[\\\"Plugin\\\"]);\\n\\nSlider.defaults = {\\n  /**\\n   * Minimum value for the slider scale.\\n   * @option\\n   * @type {number}\\n   * @default 0\\n   */\\n  start: 0,\\n\\n  /**\\n   * Maximum value for the slider scale.\\n   * @option\\n   * @type {number}\\n   * @default 100\\n   */\\n  end: 100,\\n\\n  /**\\n   * Minimum value change per change event.\\n   * @option\\n   * @type {number}\\n   * @default 1\\n   */\\n  step: 1,\\n\\n  /**\\n   * Value at which the handle/input *(left handle/first input)* should be set to on initialization.\\n   * @option\\n   * @type {number}\\n   * @default 0\\n   */\\n  initialStart: 0,\\n\\n  /**\\n   * Value at which the right handle/second input should be set to on initialization.\\n   * @option\\n   * @type {number}\\n   * @default 100\\n   */\\n  initialEnd: 100,\\n\\n  /**\\n   * Allows the input to be located outside the container and visible. Set to by the JS\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  binding: false,\\n\\n  /**\\n   * Allows the user to click/tap on the slider bar to select a value.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  clickSelect: true,\\n\\n  /**\\n   * Set to true and use the `vertical` class to change alignment to vertical.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  vertical: false,\\n\\n  /**\\n   * Allows the user to drag the slider handle(s) to select a value.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  draggable: true,\\n\\n  /**\\n   * Disables the slider and prevents event listeners from being applied. Double checked by JS with `disabledClass`.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  disabled: false,\\n\\n  /**\\n   * Allows the use of two handles. Double checked by the JS. Changes some logic handling.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  doubleSided: false,\\n\\n  /**\\n   * Potential future feature.\\n   */\\n  // steps: 100,\\n\\n  /**\\n   * Number of decimal places the plugin should go to for floating point precision.\\n   * @option\\n   * @type {number}\\n   * @default 2\\n   */\\n  decimal: 2,\\n\\n  /**\\n   * Time delay for dragged elements.\\n   */\\n  // dragDelay: 0,\\n\\n  /**\\n   * Time, in ms, to animate the movement of a slider handle if user clicks/taps on the bar. Needs to be manually set if updating the transition time in the Sass settings.\\n   * @option\\n   * @type {number}\\n   * @default 200\\n   */\\n  moveTime: 200,\\n  //update this if changing the transition time in the sass\\n\\n  /**\\n   * Class applied to disabled sliders.\\n   * @option\\n   * @type {string}\\n   * @default 'disabled'\\n   */\\n  disabledClass: 'disabled',\\n\\n  /**\\n   * Will invert the default layout for a vertical<span data-tooltip title=\\\"who would do this???\\\"> </span>slider.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  invertVertical: false,\\n\\n  /**\\n   * Milliseconds before the `changed.zf-slider` event is triggered after value change.\\n   * @option\\n   * @type {number}\\n   * @default 500\\n   */\\n  changedDelay: 500,\\n\\n  /**\\n  * Basevalue for non-linear sliders\\n  * @option\\n  * @type {number}\\n  * @default 5\\n  */\\n  nonLinearBase: 5,\\n\\n  /**\\n  * Basevalue for non-linear sliders, possible values are: `'linear'`, `'pow'` & `'log'`. Pow and Log use the nonLinearBase setting.\\n  * @option\\n  * @type {string}\\n  * @default 'linear'\\n  */\\n  positionValueFunction: 'linear'\\n};\\n\\nfunction percent(frac, num) {\\n  return frac / num;\\n}\\n\\nfunction absPosition($handle, dir, clickPos, param) {\\n  return Math.abs($handle.position()[dir] + $handle[param]() / 2 - clickPos);\\n}\\n\\nfunction baseLog(base, value) {\\n  return Math.log(value) / Math.log(base);\\n}\\n\\n\\n\\n//# sourceURL=webpack:///./js/foundation.slider.js?\");\n    }, \"./js/foundation.smoothScroll.js\": function jsFoundationSmoothScrollJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SmoothScroll\", function() { return SmoothScroll; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.core.plugin */ \"./js/foundation.core.plugin.js\");\\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn\\'t been initialised - super() hasn\\'t been called\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n\\n\\n\\n/**\\n * SmoothScroll module.\\n * @module foundation.smooth-scroll\\n */\\n\\nvar SmoothScroll =\\n/*#__PURE__*/\\nfunction (_Plugin) {\\n  _inherits(SmoothScroll, _Plugin);\\n\\n  function SmoothScroll() {\\n    _classCallCheck(this, SmoothScroll);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(SmoothScroll).apply(this, arguments));\\n  }\\n\\n  _createClass(SmoothScroll, [{\\n    key: \"_setup\",\\n\\n    /**\\n     * Creates a new instance of SmoothScroll.\\n     * @class\\n     * @name SmoothScroll\\n     * @fires SmoothScroll#init\\n     * @param {Object} element - jQuery object to add the trigger to.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, SmoothScroll.defaults, this.$element.data(), options);\\n      this.className = \\'SmoothScroll\\'; // ie9 back compat\\n\\n      this._init();\\n    }\\n    /**\\n     * Initialize the SmoothScroll plugin\\n     * @private\\n     */\\n\\n  }, {\\n    key: \"_init\",\\n    value: function _init() {\\n      var id = this.$element[0].id || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"GetYoDigits\"])(6, \\'smooth-scroll\\');\\n      this.$element.attr({\\n        id: id\\n      });\\n\\n      this._events();\\n    }\\n    /**\\n     * Initializes events for SmoothScroll.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \"_events\",\\n    value: function _events() {\\n      this.$element.on(\\'click.zf.smoothScroll\\', this._handleLinkClick);\\n      this.$element.on(\\'click.zf.smoothScroll\\', \\'a[href^=\"#\"]\\', this._handleLinkClick);\\n    }\\n    /**\\n     * Handle the given event to smoothly scroll to the anchor pointed by the event target.\\n     * @param {*} e - event\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \"_handleLinkClick\",\\n    value: function _handleLinkClick(e) {\\n      var _this = this;\\n\\n      // Follow the link if it does not point to an anchor.\\n      if (!jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.currentTarget).is(\\'a[href^=\"#\"]\\')) return;\\n      var arrival = e.currentTarget.getAttribute(\\'href\\');\\n      this._inTransition = true;\\n      SmoothScroll.scrollToLoc(arrival, this.options, function () {\\n        _this._inTransition = false;\\n      });\\n      e.preventDefault();\\n    }\\n  }, {\\n    key: \"_destroy\",\\n\\n    /**\\n     * Destroys the SmoothScroll instance.\\n     * @function\\n     */\\n    value: function _destroy() {\\n      this.$element.off(\\'click.zf.smoothScroll\\', this._handleLinkClick);\\n      this.$element.off(\\'click.zf.smoothScroll\\', \\'a[href^=\"#\"]\\', this._handleLinkClick);\\n    }\\n  }], [{\\n    key: \"scrollToLoc\",\\n\\n    /**\\n     * Function to scroll to a given location on the page.\\n     * @param {String} loc - A properly formatted jQuery id selector. Example: \\'#foo\\'\\n     * @param {Object} options - The options to use.\\n     * @param {Function} callback - The callback function.\\n     * @static\\n     * @function\\n     */\\n    value: function scrollToLoc(loc) {\\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SmoothScroll.defaults;\\n      var callback = arguments.length > 2 ? arguments[2] : undefined;\\n      var $loc = jquery__WEBPACK_IMPORTED_MODULE_0___default()(loc); // Do nothing if target does not exist to prevent errors\\n\\n      if (!$loc.length) return false;\\n      var scrollPos = Math.round($loc.offset().top - options.threshold / 2 - options.offset);\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(\\'html, body\\').stop(true).animate({\\n        scrollTop: scrollPos\\n      }, options.animationDuration, options.animationEasing, function () {\\n        if (typeof callback === \\'function\\') {\\n          callback();\\n        }\\n      });\\n    }\\n  }]);\\n\\n  return SmoothScroll;\\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_2__[\"Plugin\"]);\\n/**\\n * Default settings for plugin.\\n */\\n\\n\\nSmoothScroll.defaults = {\\n  /**\\n   * Amount of time, in ms, the animated scrolling should take between locations.\\n   * @option\\n   * @type {number}\\n   * @default 500\\n   */\\n  animationDuration: 500,\\n\\n  /**\\n   * Animation style to use when scrolling between locations. Can be `\\'swing\\'` or `\\'linear\\'`.\\n   * @option\\n   * @type {string}\\n   * @default \\'linear\\'\\n   * @see {@link https://api.jquery.com/animate|Jquery animate}\\n   */\\n  animationEasing: \\'linear\\',\\n\\n  /**\\n   * Number of pixels to use as a marker for location changes.\\n   * @option\\n   * @type {number}\\n   * @default 50\\n   */\\n  threshold: 50,\\n\\n  /**\\n   * Number of pixels to offset the scroll of the page on item click if using a sticky nav bar.\\n   * @option\\n   * @type {number}\\n   * @default 0\\n   */\\n  offset: 0\\n};\\n\\n\\n//# sourceURL=webpack:///./js/foundation.smoothScroll.js?');\n    }, \"./js/foundation.sticky.js\": function jsFoundationStickyJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Sticky\\\", function() { return Sticky; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.utils */ \\\"./js/foundation.core.utils.js\\\");\\n/* harmony import */ var _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.util.mediaQuery */ \\\"./js/foundation.util.mediaQuery.js\\\");\\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.core.plugin */ \\\"./js/foundation.core.plugin.js\\\");\\n/* harmony import */ var _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.util.triggers */ \\\"./js/foundation.util.triggers.js\\\");\\n\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n\\n\\n\\n\\n\\n/**\\n * Sticky module.\\n * @module foundation.sticky\\n * @requires foundation.util.triggers\\n * @requires foundation.util.mediaQuery\\n */\\n\\nvar Sticky =\\n/*#__PURE__*/\\nfunction (_Plugin) {\\n  _inherits(Sticky, _Plugin);\\n\\n  function Sticky() {\\n    _classCallCheck(this, Sticky);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(Sticky).apply(this, arguments));\\n  }\\n\\n  _createClass(Sticky, [{\\n    key: \\\"_setup\\\",\\n\\n    /**\\n     * Creates a new instance of a sticky thing.\\n     * @class\\n     * @name Sticky\\n     * @param {jQuery} element - jQuery object to make sticky.\\n     * @param {Object} options - options object passed when creating the element programmatically.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, Sticky.defaults, this.$element.data(), options);\\n      this.className = 'Sticky'; // ie9 back compat\\n      // Triggers init is idempotent, just need to make sure it is initialized\\n\\n      _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_4__[\\\"Triggers\\\"].init(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\\n\\n      this._init();\\n    }\\n    /**\\n     * Initializes the sticky element by adding classes, getting/setting dimensions, breakpoints and attributes\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_init\\\",\\n    value: function _init() {\\n      _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_2__[\\\"MediaQuery\\\"]._init();\\n\\n      var $parent = this.$element.parent('[data-sticky-container]'),\\n          id = this.$element[0].id || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\\\"GetYoDigits\\\"])(6, 'sticky'),\\n          _this = this;\\n\\n      if ($parent.length) {\\n        this.$container = $parent;\\n      } else {\\n        this.wasWrapped = true;\\n        this.$element.wrap(this.options.container);\\n        this.$container = this.$element.parent();\\n      }\\n\\n      this.$container.addClass(this.options.containerClass);\\n      this.$element.addClass(this.options.stickyClass).attr({\\n        'data-resize': id,\\n        'data-mutate': id\\n      });\\n\\n      if (this.options.anchor !== '') {\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()('#' + _this.options.anchor).attr({\\n          'data-mutate': id\\n        });\\n      }\\n\\n      this.scrollCount = this.options.checkEvery;\\n      this.isStuck = false;\\n      this.onLoadListener = Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\\\"onLoad\\\"])(jquery__WEBPACK_IMPORTED_MODULE_0___default()(window), function () {\\n        //We calculate the container height to have correct values for anchor points offset calculation.\\n        _this.containerHeight = _this.$element.css(\\\"display\\\") == \\\"none\\\" ? 0 : _this.$element[0].getBoundingClientRect().height;\\n\\n        _this.$container.css('height', _this.containerHeight);\\n\\n        _this.elemHeight = _this.containerHeight;\\n\\n        if (_this.options.anchor !== '') {\\n          _this.$anchor = jquery__WEBPACK_IMPORTED_MODULE_0___default()('#' + _this.options.anchor);\\n        } else {\\n          _this._parsePoints();\\n        }\\n\\n        _this._setSizes(function () {\\n          var scroll = window.pageYOffset;\\n\\n          _this._calc(false, scroll); //Unstick the element will ensure that proper classes are set.\\n\\n\\n          if (!_this.isStuck) {\\n            _this._removeSticky(scroll >= _this.topPoint ? false : true);\\n          }\\n        });\\n\\n        _this._events(id.split('-').reverse().join('-'));\\n      });\\n    }\\n    /**\\n     * If using multiple elements as anchors, calculates the top and bottom pixel values the sticky thing should stick and unstick on.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_parsePoints\\\",\\n    value: function _parsePoints() {\\n      var top = this.options.topAnchor == \\\"\\\" ? 1 : this.options.topAnchor,\\n          btm = this.options.btmAnchor == \\\"\\\" ? document.documentElement.scrollHeight : this.options.btmAnchor,\\n          pts = [top, btm],\\n          breaks = {};\\n\\n      for (var i = 0, len = pts.length; i < len && pts[i]; i++) {\\n        var pt;\\n\\n        if (typeof pts[i] === 'number') {\\n          pt = pts[i];\\n        } else {\\n          var place = pts[i].split(':'),\\n              anchor = jquery__WEBPACK_IMPORTED_MODULE_0___default()(\\\"#\\\".concat(place[0]));\\n          pt = anchor.offset().top;\\n\\n          if (place[1] && place[1].toLowerCase() === 'bottom') {\\n            pt += anchor[0].getBoundingClientRect().height;\\n          }\\n        }\\n\\n        breaks[i] = pt;\\n      }\\n\\n      this.points = breaks;\\n      return;\\n    }\\n    /**\\n     * Adds event handlers for the scrolling element.\\n     * @private\\n     * @param {String} id - pseudo-random id for unique scroll event listener.\\n     */\\n\\n  }, {\\n    key: \\\"_events\\\",\\n    value: function _events(id) {\\n      var _this = this,\\n          scrollListener = this.scrollListener = \\\"scroll.zf.\\\".concat(id);\\n\\n      if (this.isOn) {\\n        return;\\n      }\\n\\n      if (this.canStick) {\\n        this.isOn = true;\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off(scrollListener).on(scrollListener, function (e) {\\n          if (_this.scrollCount === 0) {\\n            _this.scrollCount = _this.options.checkEvery;\\n\\n            _this._setSizes(function () {\\n              _this._calc(false, window.pageYOffset);\\n            });\\n          } else {\\n            _this.scrollCount--;\\n\\n            _this._calc(false, window.pageYOffset);\\n          }\\n        });\\n      }\\n\\n      this.$element.off('resizeme.zf.trigger').on('resizeme.zf.trigger', function (e, el) {\\n        _this._eventsHandler(id);\\n      });\\n      this.$element.on('mutateme.zf.trigger', function (e, el) {\\n        _this._eventsHandler(id);\\n      });\\n\\n      if (this.$anchor) {\\n        this.$anchor.on('mutateme.zf.trigger', function (e, el) {\\n          _this._eventsHandler(id);\\n        });\\n      }\\n    }\\n    /**\\n     * Handler for events.\\n     * @private\\n     * @param {String} id - pseudo-random id for unique scroll event listener.\\n     */\\n\\n  }, {\\n    key: \\\"_eventsHandler\\\",\\n    value: function _eventsHandler(id) {\\n      var _this = this,\\n          scrollListener = this.scrollListener = \\\"scroll.zf.\\\".concat(id);\\n\\n      _this._setSizes(function () {\\n        _this._calc(false);\\n\\n        if (_this.canStick) {\\n          if (!_this.isOn) {\\n            _this._events(id);\\n          }\\n        } else if (_this.isOn) {\\n          _this._pauseListeners(scrollListener);\\n        }\\n      });\\n    }\\n    /**\\n     * Removes event handlers for scroll and change events on anchor.\\n     * @fires Sticky#pause\\n     * @param {String} scrollListener - unique, namespaced scroll listener attached to `window`\\n     */\\n\\n  }, {\\n    key: \\\"_pauseListeners\\\",\\n    value: function _pauseListeners(scrollListener) {\\n      this.isOn = false;\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off(scrollListener);\\n      /**\\n       * Fires when the plugin is paused due to resize event shrinking the view.\\n       * @event Sticky#pause\\n       * @private\\n       */\\n\\n      this.$element.trigger('pause.zf.sticky');\\n    }\\n    /**\\n     * Called on every `scroll` event and on `_init`\\n     * fires functions based on booleans and cached values\\n     * @param {Boolean} checkSizes - true if plugin should recalculate sizes and breakpoints.\\n     * @param {Number} scroll - current scroll position passed from scroll event cb function. If not passed, defaults to `window.pageYOffset`.\\n     */\\n\\n  }, {\\n    key: \\\"_calc\\\",\\n    value: function _calc(checkSizes, scroll) {\\n      if (checkSizes) {\\n        this._setSizes();\\n      }\\n\\n      if (!this.canStick) {\\n        if (this.isStuck) {\\n          this._removeSticky(true);\\n        }\\n\\n        return false;\\n      }\\n\\n      if (!scroll) {\\n        scroll = window.pageYOffset;\\n      }\\n\\n      if (scroll >= this.topPoint) {\\n        if (scroll <= this.bottomPoint) {\\n          if (!this.isStuck) {\\n            this._setSticky();\\n          }\\n        } else {\\n          if (this.isStuck) {\\n            this._removeSticky(false);\\n          }\\n        }\\n      } else {\\n        if (this.isStuck) {\\n          this._removeSticky(true);\\n        }\\n      }\\n    }\\n    /**\\n     * Causes the $element to become stuck.\\n     * Adds `position: fixed;`, and helper classes.\\n     * @fires Sticky#stuckto\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_setSticky\\\",\\n    value: function _setSticky() {\\n      var _this = this,\\n          stickTo = this.options.stickTo,\\n          mrgn = stickTo === 'top' ? 'marginTop' : 'marginBottom',\\n          notStuckTo = stickTo === 'top' ? 'bottom' : 'top',\\n          css = {};\\n\\n      css[mrgn] = \\\"\\\".concat(this.options[mrgn], \\\"em\\\");\\n      css[stickTo] = 0;\\n      css[notStuckTo] = 'auto';\\n      this.isStuck = true;\\n      this.$element.removeClass(\\\"is-anchored is-at-\\\".concat(notStuckTo)).addClass(\\\"is-stuck is-at-\\\".concat(stickTo)).css(css)\\n      /**\\n       * Fires when the $element has become `position: fixed;`\\n       * Namespaced to `top` or `bottom`, e.g. `sticky.zf.stuckto:top`\\n       * @event Sticky#stuckto\\n       */\\n      .trigger(\\\"sticky.zf.stuckto:\\\".concat(stickTo));\\n      this.$element.on(\\\"transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd\\\", function () {\\n        _this._setSizes();\\n      });\\n    }\\n    /**\\n     * Causes the $element to become unstuck.\\n     * Removes `position: fixed;`, and helper classes.\\n     * Adds other helper classes.\\n     * @param {Boolean} isTop - tells the function if the $element should anchor to the top or bottom of its $anchor element.\\n     * @fires Sticky#unstuckfrom\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_removeSticky\\\",\\n    value: function _removeSticky(isTop) {\\n      var stickTo = this.options.stickTo,\\n          stickToTop = stickTo === 'top',\\n          css = {},\\n          anchorPt = (this.points ? this.points[1] - this.points[0] : this.anchorHeight) - this.elemHeight,\\n          mrgn = stickToTop ? 'marginTop' : 'marginBottom',\\n          notStuckTo = stickToTop ? 'bottom' : 'top',\\n          topOrBottom = isTop ? 'top' : 'bottom';\\n      css[mrgn] = 0;\\n      css['bottom'] = 'auto';\\n\\n      if (isTop) {\\n        css['top'] = 0;\\n      } else {\\n        css['top'] = anchorPt;\\n      }\\n\\n      this.isStuck = false;\\n      this.$element.removeClass(\\\"is-stuck is-at-\\\".concat(stickTo)).addClass(\\\"is-anchored is-at-\\\".concat(topOrBottom)).css(css)\\n      /**\\n       * Fires when the $element has become anchored.\\n       * Namespaced to `top` or `bottom`, e.g. `sticky.zf.unstuckfrom:bottom`\\n       * @event Sticky#unstuckfrom\\n       */\\n      .trigger(\\\"sticky.zf.unstuckfrom:\\\".concat(topOrBottom));\\n    }\\n    /**\\n     * Sets the $element and $container sizes for plugin.\\n     * Calls `_setBreakPoints`.\\n     * @param {Function} cb - optional callback function to fire on completion of `_setBreakPoints`.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_setSizes\\\",\\n    value: function _setSizes(cb) {\\n      this.canStick = _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_2__[\\\"MediaQuery\\\"].is(this.options.stickyOn);\\n\\n      if (!this.canStick) {\\n        if (cb && typeof cb === 'function') {\\n          cb();\\n        }\\n      }\\n\\n      var _this = this,\\n          newElemWidth = this.$container[0].getBoundingClientRect().width,\\n          comp = window.getComputedStyle(this.$container[0]),\\n          pdngl = parseInt(comp['padding-left'], 10),\\n          pdngr = parseInt(comp['padding-right'], 10);\\n\\n      if (this.$anchor && this.$anchor.length) {\\n        this.anchorHeight = this.$anchor[0].getBoundingClientRect().height;\\n      } else {\\n        this._parsePoints();\\n      }\\n\\n      this.$element.css({\\n        'max-width': \\\"\\\".concat(newElemWidth - pdngl - pdngr, \\\"px\\\")\\n      });\\n      var newContainerHeight = this.$element[0].getBoundingClientRect().height || this.containerHeight;\\n\\n      if (this.$element.css(\\\"display\\\") == \\\"none\\\") {\\n        newContainerHeight = 0;\\n      }\\n\\n      this.containerHeight = newContainerHeight;\\n      this.$container.css({\\n        height: newContainerHeight\\n      });\\n      this.elemHeight = newContainerHeight;\\n\\n      if (!this.isStuck) {\\n        if (this.$element.hasClass('is-at-bottom')) {\\n          var anchorPt = (this.points ? this.points[1] - this.$container.offset().top : this.anchorHeight) - this.elemHeight;\\n          this.$element.css('top', anchorPt);\\n        }\\n      }\\n\\n      this._setBreakPoints(newContainerHeight, function () {\\n        if (cb && typeof cb === 'function') {\\n          cb();\\n        }\\n      });\\n    }\\n    /**\\n     * Sets the upper and lower breakpoints for the element to become sticky/unsticky.\\n     * @param {Number} elemHeight - px value for sticky.$element height, calculated by `_setSizes`.\\n     * @param {Function} cb - optional callback function to be called on completion.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_setBreakPoints\\\",\\n    value: function _setBreakPoints(elemHeight, cb) {\\n      if (!this.canStick) {\\n        if (cb && typeof cb === 'function') {\\n          cb();\\n        } else {\\n          return false;\\n        }\\n      }\\n\\n      var mTop = emCalc(this.options.marginTop),\\n          mBtm = emCalc(this.options.marginBottom),\\n          topPoint = this.points ? this.points[0] : this.$anchor.offset().top,\\n          bottomPoint = this.points ? this.points[1] : topPoint + this.anchorHeight,\\n          // topPoint = this.$anchor.offset().top || this.points[0],\\n      // bottomPoint = topPoint + this.anchorHeight || this.points[1],\\n      winHeight = window.innerHeight;\\n\\n      if (this.options.stickTo === 'top') {\\n        topPoint -= mTop;\\n        bottomPoint -= elemHeight + mTop;\\n      } else if (this.options.stickTo === 'bottom') {\\n        topPoint -= winHeight - (elemHeight + mBtm);\\n        bottomPoint -= winHeight - mBtm;\\n      } else {//this would be the stickTo: both option... tricky\\n      }\\n\\n      this.topPoint = topPoint;\\n      this.bottomPoint = bottomPoint;\\n\\n      if (cb && typeof cb === 'function') {\\n        cb();\\n      }\\n    }\\n    /**\\n     * Destroys the current sticky element.\\n     * Resets the element to the top position first.\\n     * Removes event listeners, JS-added css properties and classes, and unwraps the $element if the JS added the $container.\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"_destroy\\\",\\n    value: function _destroy() {\\n      this._removeSticky(true);\\n\\n      this.$element.removeClass(\\\"\\\".concat(this.options.stickyClass, \\\" is-anchored is-at-top\\\")).css({\\n        height: '',\\n        top: '',\\n        bottom: '',\\n        'max-width': ''\\n      }).off('resizeme.zf.trigger').off('mutateme.zf.trigger');\\n\\n      if (this.$anchor && this.$anchor.length) {\\n        this.$anchor.off('change.zf.sticky');\\n      }\\n\\n      if (this.scrollListener) jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off(this.scrollListener);\\n      if (this.onLoadListener) jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off(this.onLoadListener);\\n\\n      if (this.wasWrapped) {\\n        this.$element.unwrap();\\n      } else {\\n        this.$container.removeClass(this.options.containerClass).css({\\n          height: ''\\n        });\\n      }\\n    }\\n  }]);\\n\\n  return Sticky;\\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_3__[\\\"Plugin\\\"]);\\n\\nSticky.defaults = {\\n  /**\\n   * Customizable container template. Add your own classes for styling and sizing.\\n   * @option\\n   * @type {string}\\n   * @default '&lt;div data-sticky-container&gt;&lt;/div&gt;'\\n   */\\n  container: '<div data-sticky-container></div>',\\n\\n  /**\\n   * Location in the view the element sticks to. Can be `'top'` or `'bottom'`.\\n   * @option\\n   * @type {string}\\n   * @default 'top'\\n   */\\n  stickTo: 'top',\\n\\n  /**\\n   * If anchored to a single element, the id of that element.\\n   * @option\\n   * @type {string}\\n   * @default ''\\n   */\\n  anchor: '',\\n\\n  /**\\n   * If using more than one element as anchor points, the id of the top anchor.\\n   * @option\\n   * @type {string}\\n   * @default ''\\n   */\\n  topAnchor: '',\\n\\n  /**\\n   * If using more than one element as anchor points, the id of the bottom anchor.\\n   * @option\\n   * @type {string}\\n   * @default ''\\n   */\\n  btmAnchor: '',\\n\\n  /**\\n   * Margin, in `em`'s to apply to the top of the element when it becomes sticky.\\n   * @option\\n   * @type {number}\\n   * @default 1\\n   */\\n  marginTop: 1,\\n\\n  /**\\n   * Margin, in `em`'s to apply to the bottom of the element when it becomes sticky.\\n   * @option\\n   * @type {number}\\n   * @default 1\\n   */\\n  marginBottom: 1,\\n\\n  /**\\n   * Breakpoint string that is the minimum screen size an element should become sticky.\\n   * @option\\n   * @type {string}\\n   * @default 'medium'\\n   */\\n  stickyOn: 'medium',\\n\\n  /**\\n   * Class applied to sticky element, and removed on destruction. Foundation defaults to `sticky`.\\n   * @option\\n   * @type {string}\\n   * @default 'sticky'\\n   */\\n  stickyClass: 'sticky',\\n\\n  /**\\n   * Class applied to sticky container. Foundation defaults to `sticky-container`.\\n   * @option\\n   * @type {string}\\n   * @default 'sticky-container'\\n   */\\n  containerClass: 'sticky-container',\\n\\n  /**\\n   * Number of scroll events between the plugin's recalculating sticky points. Setting it to `0` will cause it to recalc every scroll event, setting it to `-1` will prevent recalc on scroll.\\n   * @option\\n   * @type {number}\\n   * @default -1\\n   */\\n  checkEvery: -1\\n};\\n/**\\n * Helper function to calculate em values\\n * @param Number {em} - number of em's to calculate into pixels\\n */\\n\\nfunction emCalc(em) {\\n  return parseInt(window.getComputedStyle(document.body, null).fontSize, 10) * em;\\n}\\n\\n\\n\\n//# sourceURL=webpack:///./js/foundation.sticky.js?\");\n    }, \"./js/foundation.tabs.js\": function jsFoundationTabsJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Tabs\\\", function() { return Tabs; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.utils */ \\\"./js/foundation.core.utils.js\\\");\\n/* harmony import */ var _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.util.keyboard */ \\\"./js/foundation.util.keyboard.js\\\");\\n/* harmony import */ var _foundation_util_imageLoader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.util.imageLoader */ \\\"./js/foundation.util.imageLoader.js\\\");\\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.core.plugin */ \\\"./js/foundation.core.plugin.js\\\");\\n\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n\\n\\n\\n\\n\\n/**\\n * Tabs module.\\n * @module foundation.tabs\\n * @requires foundation.util.keyboard\\n * @requires foundation.util.imageLoader if tabs contain images\\n */\\n\\nvar Tabs =\\n/*#__PURE__*/\\nfunction (_Plugin) {\\n  _inherits(Tabs, _Plugin);\\n\\n  function Tabs() {\\n    _classCallCheck(this, Tabs);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(Tabs).apply(this, arguments));\\n  }\\n\\n  _createClass(Tabs, [{\\n    key: \\\"_setup\\\",\\n\\n    /**\\n     * Creates a new instance of tabs.\\n     * @class\\n     * @name Tabs\\n     * @fires Tabs#init\\n     * @param {jQuery} element - jQuery object to make into tabs.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, Tabs.defaults, this.$element.data(), options);\\n      this.className = 'Tabs'; // ie9 back compat\\n\\n      this._init();\\n\\n      _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_2__[\\\"Keyboard\\\"].register('Tabs', {\\n        'ENTER': 'open',\\n        'SPACE': 'open',\\n        'ARROW_RIGHT': 'next',\\n        'ARROW_UP': 'previous',\\n        'ARROW_DOWN': 'next',\\n        'ARROW_LEFT': 'previous' // 'TAB': 'next',\\n        // 'SHIFT_TAB': 'previous'\\n\\n      });\\n    }\\n    /**\\n     * Initializes the tabs by showing and focusing (if autoFocus=true) the preset active tab.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_init\\\",\\n    value: function _init() {\\n      var _this2 = this;\\n\\n      var _this = this;\\n\\n      this._isInitializing = true;\\n      this.$element.attr({\\n        'role': 'tablist'\\n      });\\n      this.$tabTitles = this.$element.find(\\\".\\\".concat(this.options.linkClass));\\n      this.$tabContent = jquery__WEBPACK_IMPORTED_MODULE_0___default()(\\\"[data-tabs-content=\\\\\\\"\\\".concat(this.$element[0].id, \\\"\\\\\\\"]\\\"));\\n      this.$tabTitles.each(function () {\\n        var $elem = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\\n            $link = $elem.find('a'),\\n            isActive = $elem.hasClass(\\\"\\\".concat(_this.options.linkActiveClass)),\\n            hash = $link.attr('data-tabs-target') || $link[0].hash.slice(1),\\n            linkId = $link[0].id ? $link[0].id : \\\"\\\".concat(hash, \\\"-label\\\"),\\n            $tabContent = jquery__WEBPACK_IMPORTED_MODULE_0___default()(\\\"#\\\".concat(hash));\\n        $elem.attr({\\n          'role': 'presentation'\\n        });\\n        $link.attr({\\n          'role': 'tab',\\n          'aria-controls': hash,\\n          'aria-selected': isActive,\\n          'id': linkId,\\n          'tabindex': isActive ? '0' : '-1'\\n        });\\n        $tabContent.attr({\\n          'role': 'tabpanel',\\n          'aria-labelledby': linkId\\n        }); // Save up the initial hash to return to it later when going back in history\\n\\n        if (isActive) {\\n          _this._initialAnchor = \\\"#\\\".concat(hash);\\n        }\\n\\n        if (!isActive) {\\n          $tabContent.attr('aria-hidden', 'true');\\n        }\\n\\n        if (isActive && _this.options.autoFocus) {\\n          _this.onLoadListener = Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\\\"onLoad\\\"])(jquery__WEBPACK_IMPORTED_MODULE_0___default()(window), function () {\\n            jquery__WEBPACK_IMPORTED_MODULE_0___default()('html, body').animate({\\n              scrollTop: $elem.offset().top\\n            }, _this.options.deepLinkSmudgeDelay, function () {\\n              $link.focus();\\n            });\\n          });\\n        }\\n      });\\n\\n      if (this.options.matchHeight) {\\n        var $images = this.$tabContent.find('img');\\n\\n        if ($images.length) {\\n          Object(_foundation_util_imageLoader__WEBPACK_IMPORTED_MODULE_3__[\\\"onImagesLoaded\\\"])($images, this._setHeight.bind(this));\\n        } else {\\n          this._setHeight();\\n        }\\n      } // Current context-bound function to open tabs on page load or history hashchange\\n\\n\\n      this._checkDeepLink = function () {\\n        var anchor = window.location.hash;\\n\\n        if (!anchor.length) {\\n          // If we are still initializing and there is no anchor, then there is nothing to do\\n          if (_this2._isInitializing) return; // Otherwise, move to the initial anchor\\n\\n          if (_this2._initialAnchor) anchor = _this2._initialAnchor;\\n        }\\n\\n        var $anchor = anchor && jquery__WEBPACK_IMPORTED_MODULE_0___default()(anchor);\\n\\n        var $link = anchor && _this2.$element.find('[href$=\\\"' + anchor + '\\\"]'); // Whether the anchor element that has been found is part of this element\\n\\n\\n        var isOwnAnchor = !!($anchor.length && $link.length); // If there is an anchor for the hash, select it\\n\\n        if ($anchor && $anchor.length && $link && $link.length) {\\n          _this2.selectTab($anchor, true);\\n        } // Otherwise, collapse everything\\n        else {\\n            _this2._collapse();\\n          }\\n\\n        if (isOwnAnchor) {\\n          // Roll up a little to show the titles\\n          if (_this2.options.deepLinkSmudge) {\\n            var offset = _this2.$element.offset();\\n\\n            jquery__WEBPACK_IMPORTED_MODULE_0___default()('html, body').animate({\\n              scrollTop: offset.top\\n            }, _this2.options.deepLinkSmudgeDelay);\\n          }\\n          /**\\n           * Fires when the plugin has deeplinked at pageload\\n           * @event Tabs#deeplink\\n           */\\n\\n\\n          _this2.$element.trigger('deeplink.zf.tabs', [$link, $anchor]);\\n        }\\n      }; //use browser to open a tab, if it exists in this tabset\\n\\n\\n      if (this.options.deepLink) {\\n        this._checkDeepLink();\\n      }\\n\\n      this._events();\\n\\n      this._isInitializing = false;\\n    }\\n    /**\\n     * Adds event handlers for items within the tabs.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_events\\\",\\n    value: function _events() {\\n      this._addKeyHandler();\\n\\n      this._addClickHandler();\\n\\n      this._setHeightMqHandler = null;\\n\\n      if (this.options.matchHeight) {\\n        this._setHeightMqHandler = this._setHeight.bind(this);\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on('changed.zf.mediaquery', this._setHeightMqHandler);\\n      }\\n\\n      if (this.options.deepLink) {\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on('hashchange', this._checkDeepLink);\\n      }\\n    }\\n    /**\\n     * Adds click handlers for items within the tabs.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_addClickHandler\\\",\\n    value: function _addClickHandler() {\\n      var _this = this;\\n\\n      this.$element.off('click.zf.tabs').on('click.zf.tabs', \\\".\\\".concat(this.options.linkClass), function (e) {\\n        e.preventDefault();\\n        e.stopPropagation();\\n\\n        _this._handleTabChange(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this));\\n      });\\n    }\\n    /**\\n     * Adds keyboard event handlers for items within the tabs.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_addKeyHandler\\\",\\n    value: function _addKeyHandler() {\\n      var _this = this;\\n\\n      this.$tabTitles.off('keydown.zf.tabs').on('keydown.zf.tabs', function (e) {\\n        if (e.which === 9) return;\\n        var $element = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\\n            $elements = $element.parent('ul').children('li'),\\n            $prevElement,\\n            $nextElement;\\n        $elements.each(function (i) {\\n          if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).is($element)) {\\n            if (_this.options.wrapOnKeys) {\\n              $prevElement = i === 0 ? $elements.last() : $elements.eq(i - 1);\\n              $nextElement = i === $elements.length - 1 ? $elements.first() : $elements.eq(i + 1);\\n            } else {\\n              $prevElement = $elements.eq(Math.max(0, i - 1));\\n              $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1));\\n            }\\n\\n            return;\\n          }\\n        }); // handle keyboard event with keyboard util\\n\\n        _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_2__[\\\"Keyboard\\\"].handleKey(e, 'Tabs', {\\n          open: function open() {\\n            $element.find('[role=\\\"tab\\\"]').focus();\\n\\n            _this._handleTabChange($element);\\n          },\\n          previous: function previous() {\\n            $prevElement.find('[role=\\\"tab\\\"]').focus();\\n\\n            _this._handleTabChange($prevElement);\\n          },\\n          next: function next() {\\n            $nextElement.find('[role=\\\"tab\\\"]').focus();\\n\\n            _this._handleTabChange($nextElement);\\n          },\\n          handled: function handled() {\\n            e.stopPropagation();\\n            e.preventDefault();\\n          }\\n        });\\n      });\\n    }\\n    /**\\n     * Opens the tab `$targetContent` defined by `$target`. Collapses active tab.\\n     * @param {jQuery} $target - Tab to open.\\n     * @param {boolean} historyHandled - browser has already handled a history update\\n     * @fires Tabs#change\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"_handleTabChange\\\",\\n    value: function _handleTabChange($target, historyHandled) {\\n      // With `activeCollapse`, if the target is the active Tab, collapse it.\\n      if ($target.hasClass(\\\"\\\".concat(this.options.linkActiveClass))) {\\n        if (this.options.activeCollapse) {\\n          this._collapse();\\n        }\\n\\n        return;\\n      }\\n\\n      var $oldTab = this.$element.find(\\\".\\\".concat(this.options.linkClass, \\\".\\\").concat(this.options.linkActiveClass)),\\n          $tabLink = $target.find('[role=\\\"tab\\\"]'),\\n          target = $tabLink.attr('data-tabs-target'),\\n          anchor = target && target.length ? \\\"#\\\".concat(target) : $tabLink[0].hash,\\n          $targetContent = this.$tabContent.find(anchor); //close old tab\\n\\n      this._collapseTab($oldTab); //open new tab\\n\\n\\n      this._openTab($target); //either replace or update browser history\\n\\n\\n      if (this.options.deepLink && !historyHandled) {\\n        if (this.options.updateHistory) {\\n          history.pushState({}, '', anchor);\\n        } else {\\n          history.replaceState({}, '', anchor);\\n        }\\n      }\\n      /**\\n       * Fires when the plugin has successfully changed tabs.\\n       * @event Tabs#change\\n       */\\n\\n\\n      this.$element.trigger('change.zf.tabs', [$target, $targetContent]); //fire to children a mutation event\\n\\n      $targetContent.find(\\\"[data-mutate]\\\").trigger(\\\"mutateme.zf.trigger\\\");\\n    }\\n    /**\\n     * Opens the tab `$targetContent` defined by `$target`.\\n     * @param {jQuery} $target - Tab to open.\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"_openTab\\\",\\n    value: function _openTab($target) {\\n      var $tabLink = $target.find('[role=\\\"tab\\\"]'),\\n          hash = $tabLink.attr('data-tabs-target') || $tabLink[0].hash.slice(1),\\n          $targetContent = this.$tabContent.find(\\\"#\\\".concat(hash));\\n      $target.addClass(\\\"\\\".concat(this.options.linkActiveClass));\\n      $tabLink.attr({\\n        'aria-selected': 'true',\\n        'tabindex': '0'\\n      });\\n      $targetContent.addClass(\\\"\\\".concat(this.options.panelActiveClass)).removeAttr('aria-hidden');\\n    }\\n    /**\\n     * Collapses `$targetContent` defined by `$target`.\\n     * @param {jQuery} $target - Tab to collapse.\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"_collapseTab\\\",\\n    value: function _collapseTab($target) {\\n      var $target_anchor = $target.removeClass(\\\"\\\".concat(this.options.linkActiveClass)).find('[role=\\\"tab\\\"]').attr({\\n        'aria-selected': 'false',\\n        'tabindex': -1\\n      });\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(\\\"#\\\".concat($target_anchor.attr('aria-controls'))).removeClass(\\\"\\\".concat(this.options.panelActiveClass)).attr({\\n        'aria-hidden': 'true'\\n      });\\n    }\\n    /**\\n     * Collapses the active Tab.\\n     * @fires Tabs#collapse\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"_collapse\\\",\\n    value: function _collapse() {\\n      var $activeTab = this.$element.find(\\\".\\\".concat(this.options.linkClass, \\\".\\\").concat(this.options.linkActiveClass));\\n\\n      if ($activeTab.length) {\\n        this._collapseTab($activeTab);\\n        /**\\n        * Fires when the plugin has successfully collapsed tabs.\\n        * @event Tabs#collapse\\n        */\\n\\n\\n        this.$element.trigger('collapse.zf.tabs', [$activeTab]);\\n      }\\n    }\\n    /**\\n     * Public method for selecting a content pane to display.\\n     * @param {jQuery | String} elem - jQuery object or string of the id of the pane to display.\\n     * @param {boolean} historyHandled - browser has already handled a history update\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"selectTab\\\",\\n    value: function selectTab(elem, historyHandled) {\\n      var idStr;\\n\\n      if (_typeof(elem) === 'object') {\\n        idStr = elem[0].id;\\n      } else {\\n        idStr = elem;\\n      }\\n\\n      if (idStr.indexOf('#') < 0) {\\n        idStr = \\\"#\\\".concat(idStr);\\n      }\\n\\n      var $target = this.$tabTitles.has(\\\"[href$=\\\\\\\"\\\".concat(idStr, \\\"\\\\\\\"]\\\"));\\n\\n      this._handleTabChange($target, historyHandled);\\n    }\\n  }, {\\n    key: \\\"_setHeight\\\",\\n\\n    /**\\n     * Sets the height of each panel to the height of the tallest panel.\\n     * If enabled in options, gets called on media query change.\\n     * If loading content via external source, can be called directly or with _reflow.\\n     * If enabled with `data-match-height=\\\"true\\\"`, tabs sets to equal height\\n     * @function\\n     * @private\\n     */\\n    value: function _setHeight() {\\n      var max = 0,\\n          _this = this; // Lock down the `this` value for the root tabs object\\n\\n\\n      this.$tabContent.find(\\\".\\\".concat(this.options.panelClass)).css('height', '').each(function () {\\n        var panel = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\\n            isActive = panel.hasClass(\\\"\\\".concat(_this.options.panelActiveClass)); // get the options from the parent instead of trying to get them from the child\\n\\n        if (!isActive) {\\n          panel.css({\\n            'visibility': 'hidden',\\n            'display': 'block'\\n          });\\n        }\\n\\n        var temp = this.getBoundingClientRect().height;\\n\\n        if (!isActive) {\\n          panel.css({\\n            'visibility': '',\\n            'display': ''\\n          });\\n        }\\n\\n        max = temp > max ? temp : max;\\n      }).css('height', \\\"\\\".concat(max, \\\"px\\\"));\\n    }\\n    /**\\n     * Destroys an instance of tabs.\\n     * @fires Tabs#destroyed\\n     */\\n\\n  }, {\\n    key: \\\"_destroy\\\",\\n    value: function _destroy() {\\n      this.$element.find(\\\".\\\".concat(this.options.linkClass)).off('.zf.tabs').hide().end().find(\\\".\\\".concat(this.options.panelClass)).hide();\\n\\n      if (this.options.matchHeight) {\\n        if (this._setHeightMqHandler != null) {\\n          jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off('changed.zf.mediaquery', this._setHeightMqHandler);\\n        }\\n      }\\n\\n      if (this.options.deepLink) {\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off('hashchange', this._checkDeepLink);\\n      }\\n\\n      if (this.onLoadListener) {\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off(this.onLoadListener);\\n      }\\n    }\\n  }]);\\n\\n  return Tabs;\\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_4__[\\\"Plugin\\\"]);\\n\\nTabs.defaults = {\\n  /**\\n   * Link the location hash to the active pane.\\n   * Set the location hash when the active pane changes, and open the corresponding pane when the location changes.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  deepLink: false,\\n\\n  /**\\n   * If `deepLink` is enabled, adjust the deep link scroll to make sure the top of the tab panel is visible\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  deepLinkSmudge: false,\\n\\n  /**\\n   * If `deepLinkSmudge` is enabled, animation time (ms) for the deep link adjustment\\n   * @option\\n   * @type {number}\\n   * @default 300\\n   */\\n  deepLinkSmudgeDelay: 300,\\n\\n  /**\\n   * If `deepLink` is enabled, update the browser history with the open tab\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  updateHistory: false,\\n\\n  /**\\n   * Allows the window to scroll to content of active pane on load.\\n   * Not recommended if more than one tab panel per page.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  autoFocus: false,\\n\\n  /**\\n   * Allows keyboard input to 'wrap' around the tab links.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  wrapOnKeys: true,\\n\\n  /**\\n   * Allows the tab content panes to match heights if set to true.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  matchHeight: false,\\n\\n  /**\\n   * Allows active tabs to collapse when clicked.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  activeCollapse: false,\\n\\n  /**\\n   * Class applied to `li`'s in tab link list.\\n   * @option\\n   * @type {string}\\n   * @default 'tabs-title'\\n   */\\n  linkClass: 'tabs-title',\\n\\n  /**\\n   * Class applied to the active `li` in tab link list.\\n   * @option\\n   * @type {string}\\n   * @default 'is-active'\\n   */\\n  linkActiveClass: 'is-active',\\n\\n  /**\\n   * Class applied to the content containers.\\n   * @option\\n   * @type {string}\\n   * @default 'tabs-panel'\\n   */\\n  panelClass: 'tabs-panel',\\n\\n  /**\\n   * Class applied to the active content container.\\n   * @option\\n   * @type {string}\\n   * @default 'is-active'\\n   */\\n  panelActiveClass: 'is-active'\\n};\\n\\n\\n//# sourceURL=webpack:///./js/foundation.tabs.js?\");\n    }, \"./js/foundation.toggler.js\": function jsFoundationTogglerJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval('__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Toggler\", function() { return Toggler; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _foundation_util_motion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.util.motion */ \"./js/foundation.util.motion.js\");\\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.core.plugin */ \"./js/foundation.core.plugin.js\");\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\\n/* harmony import */ var _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.util.triggers */ \"./js/foundation.util.triggers.js\");\\n\\n\\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn\\'t been initialised - super() hasn\\'t been called\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n\\n\\n\\n\\n\\n/**\\n * Toggler module.\\n * @module foundation.toggler\\n * @requires foundation.util.motion\\n * @requires foundation.util.triggers\\n */\\n\\nvar Toggler =\\n/*#__PURE__*/\\nfunction (_Plugin) {\\n  _inherits(Toggler, _Plugin);\\n\\n  function Toggler() {\\n    _classCallCheck(this, Toggler);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(Toggler).apply(this, arguments));\\n  }\\n\\n  _createClass(Toggler, [{\\n    key: \"_setup\",\\n\\n    /**\\n     * Creates a new instance of Toggler.\\n     * @class\\n     * @name Toggler\\n     * @fires Toggler#init\\n     * @param {Object} element - jQuery object to add the trigger to.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, Toggler.defaults, element.data(), options);\\n      this.className = \\'\\';\\n      this.className = \\'Toggler\\'; // ie9 back compat\\n      // Triggers init is idempotent, just need to make sure it is initialized\\n\\n      _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_4__[\"Triggers\"].init(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\\n\\n      this._init();\\n\\n      this._events();\\n    }\\n    /**\\n     * Initializes the Toggler plugin by parsing the toggle class from data-toggler, or animation classes from data-animate.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \"_init\",\\n    value: function _init() {\\n      var input; // Parse animation classes if they were set\\n\\n      if (this.options.animate) {\\n        input = this.options.animate.split(\\' \\');\\n        this.animationIn = input[0];\\n        this.animationOut = input[1] || null;\\n      } // Otherwise, parse toggle class\\n      else {\\n          input = this.$element.data(\\'toggler\\'); // Allow for a . at the beginning of the string\\n\\n          this.className = input[0] === \\'.\\' ? input.slice(1) : input;\\n        } // Add ARIA attributes to triggers:\\n\\n\\n      var id = this.$element[0].id,\\n          $triggers = jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"[data-open~=\\\\\"\".concat(id, \"\\\\\"], [data-close~=\\\\\"\").concat(id, \"\\\\\"], [data-toggle~=\\\\\"\").concat(id, \"\\\\\"]\")); // - aria-expanded: according to the element visibility.\\n\\n      $triggers.attr(\\'aria-expanded\\', !this.$element.is(\\':hidden\\')); // - aria-controls: adding the element id to it if not already in it.\\n\\n      $triggers.each(function (index, trigger) {\\n        var $trigger = jquery__WEBPACK_IMPORTED_MODULE_0___default()(trigger);\\n        var controls = $trigger.attr(\\'aria-controls\\') || \\'\\';\\n        var containsId = new RegExp(\"\\\\\\\\b\".concat(Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\"RegExpEscape\"])(id), \"\\\\\\\\b\")).test(controls);\\n        if (!containsId) $trigger.attr(\\'aria-controls\\', controls ? \"\".concat(controls, \" \").concat(id) : id);\\n      });\\n    }\\n    /**\\n     * Initializes events for the toggle trigger.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: \"_events\",\\n    value: function _events() {\\n      this.$element.off(\\'toggle.zf.trigger\\').on(\\'toggle.zf.trigger\\', this.toggle.bind(this));\\n    }\\n    /**\\n     * Toggles the target class on the target element. An event is fired from the original trigger depending on if the resultant state was \"on\" or \"off\".\\n     * @function\\n     * @fires Toggler#on\\n     * @fires Toggler#off\\n     */\\n\\n  }, {\\n    key: \"toggle\",\\n    value: function toggle() {\\n      this[this.options.animate ? \\'_toggleAnimate\\' : \\'_toggleClass\\']();\\n    }\\n  }, {\\n    key: \"_toggleClass\",\\n    value: function _toggleClass() {\\n      this.$element.toggleClass(this.className);\\n      var isOn = this.$element.hasClass(this.className);\\n\\n      if (isOn) {\\n        /**\\n         * Fires if the target element has the class after a toggle.\\n         * @event Toggler#on\\n         */\\n        this.$element.trigger(\\'on.zf.toggler\\');\\n      } else {\\n        /**\\n         * Fires if the target element does not have the class after a toggle.\\n         * @event Toggler#off\\n         */\\n        this.$element.trigger(\\'off.zf.toggler\\');\\n      }\\n\\n      this._updateARIA(isOn);\\n\\n      this.$element.find(\\'[data-mutate]\\').trigger(\\'mutateme.zf.trigger\\');\\n    }\\n  }, {\\n    key: \"_toggleAnimate\",\\n    value: function _toggleAnimate() {\\n      var _this = this;\\n\\n      if (this.$element.is(\\':hidden\\')) {\\n        _foundation_util_motion__WEBPACK_IMPORTED_MODULE_1__[\"Motion\"].animateIn(this.$element, this.animationIn, function () {\\n          _this._updateARIA(true);\\n\\n          this.trigger(\\'on.zf.toggler\\');\\n          this.find(\\'[data-mutate]\\').trigger(\\'mutateme.zf.trigger\\');\\n        });\\n      } else {\\n        _foundation_util_motion__WEBPACK_IMPORTED_MODULE_1__[\"Motion\"].animateOut(this.$element, this.animationOut, function () {\\n          _this._updateARIA(false);\\n\\n          this.trigger(\\'off.zf.toggler\\');\\n          this.find(\\'[data-mutate]\\').trigger(\\'mutateme.zf.trigger\\');\\n        });\\n      }\\n    }\\n  }, {\\n    key: \"_updateARIA\",\\n    value: function _updateARIA(isOn) {\\n      var id = this.$element[0].id;\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"[data-open=\\\\\"\".concat(id, \"\\\\\"], [data-close=\\\\\"\").concat(id, \"\\\\\"], [data-toggle=\\\\\"\").concat(id, \"\\\\\"]\")).attr({\\n        \\'aria-expanded\\': isOn ? true : false\\n      });\\n    }\\n    /**\\n     * Destroys the instance of Toggler on the element.\\n     * @function\\n     */\\n\\n  }, {\\n    key: \"_destroy\",\\n    value: function _destroy() {\\n      this.$element.off(\\'.zf.toggler\\');\\n    }\\n  }]);\\n\\n  return Toggler;\\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_2__[\"Plugin\"]);\\n\\nToggler.defaults = {\\n  /**\\n   * Tells the plugin if the element should animated when toggled.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  animate: false\\n};\\n\\n\\n//# sourceURL=webpack:///./js/foundation.toggler.js?');\n    }, \"./js/foundation.tooltip.js\": function jsFoundationTooltipJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Tooltip\\\", function() { return Tooltip; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.utils */ \\\"./js/foundation.core.utils.js\\\");\\n/* harmony import */ var _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.util.mediaQuery */ \\\"./js/foundation.util.mediaQuery.js\\\");\\n/* harmony import */ var _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.util.triggers */ \\\"./js/foundation.util.triggers.js\\\");\\n/* harmony import */ var _foundation_positionable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.positionable */ \\\"./js/foundation.positionable.js\\\");\\n\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _get(target, property, receiver) { if (typeof Reflect !== \\\"undefined\\\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\\n\\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n\\n\\n\\n\\n\\n/**\\n * Tooltip module.\\n * @module foundation.tooltip\\n * @requires foundation.util.box\\n * @requires foundation.util.mediaQuery\\n * @requires foundation.util.triggers\\n */\\n\\nvar Tooltip =\\n/*#__PURE__*/\\nfunction (_Positionable) {\\n  _inherits(Tooltip, _Positionable);\\n\\n  function Tooltip() {\\n    _classCallCheck(this, Tooltip);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(Tooltip).apply(this, arguments));\\n  }\\n\\n  _createClass(Tooltip, [{\\n    key: \\\"_setup\\\",\\n\\n    /**\\n     * Creates a new instance of a Tooltip.\\n     * @class\\n     * @name Tooltip\\n     * @fires Tooltip#init\\n     * @param {jQuery} element - jQuery object to attach a tooltip to.\\n     * @param {Object} options - object to extend the default configuration.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, Tooltip.defaults, this.$element.data(), options);\\n      this.className = 'Tooltip'; // ie9 back compat\\n\\n      this.isActive = false;\\n      this.isClick = false; // Triggers init is idempotent, just need to make sure it is initialized\\n\\n      _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_3__[\\\"Triggers\\\"].init(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\\n\\n      this._init();\\n    }\\n    /**\\n     * Initializes the tooltip by setting the creating the tip element, adding it's text, setting private variables and setting attributes on the anchor.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_init\\\",\\n    value: function _init() {\\n      _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_2__[\\\"MediaQuery\\\"]._init();\\n\\n      var elemId = this.$element.attr('aria-describedby') || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\\\"GetYoDigits\\\"])(6, 'tooltip');\\n      this.options.tipText = this.options.tipText || this.$element.attr('title');\\n      this.template = this.options.template ? jquery__WEBPACK_IMPORTED_MODULE_0___default()(this.options.template) : this._buildTemplate(elemId);\\n\\n      if (this.options.allowHtml) {\\n        this.template.appendTo(document.body).html(this.options.tipText).hide();\\n      } else {\\n        this.template.appendTo(document.body).text(this.options.tipText).hide();\\n      }\\n\\n      this.$element.attr({\\n        'title': '',\\n        'aria-describedby': elemId,\\n        'data-yeti-box': elemId,\\n        'data-toggle': elemId,\\n        'data-resize': elemId\\n      }).addClass(this.options.triggerClass);\\n\\n      _get(_getPrototypeOf(Tooltip.prototype), \\\"_init\\\", this).call(this);\\n\\n      this._events();\\n    }\\n  }, {\\n    key: \\\"_getDefaultPosition\\\",\\n    value: function _getDefaultPosition() {\\n      // handle legacy classnames\\n      var position = this.$element[0].className.match(/\\\\b(top|left|right|bottom)\\\\b/g);\\n      return position ? position[0] : 'top';\\n    }\\n  }, {\\n    key: \\\"_getDefaultAlignment\\\",\\n    value: function _getDefaultAlignment() {\\n      return 'center';\\n    }\\n  }, {\\n    key: \\\"_getHOffset\\\",\\n    value: function _getHOffset() {\\n      if (this.position === 'left' || this.position === 'right') {\\n        return this.options.hOffset + this.options.tooltipWidth;\\n      } else {\\n        return this.options.hOffset;\\n      }\\n    }\\n  }, {\\n    key: \\\"_getVOffset\\\",\\n    value: function _getVOffset() {\\n      if (this.position === 'top' || this.position === 'bottom') {\\n        return this.options.vOffset + this.options.tooltipHeight;\\n      } else {\\n        return this.options.vOffset;\\n      }\\n    }\\n    /**\\n     * builds the tooltip element, adds attributes, and returns the template.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_buildTemplate\\\",\\n    value: function _buildTemplate(id) {\\n      var templateClasses = \\\"\\\".concat(this.options.tooltipClass, \\\" \\\").concat(this.options.templateClasses).trim();\\n      var $template = jquery__WEBPACK_IMPORTED_MODULE_0___default()('<div></div>').addClass(templateClasses).attr({\\n        'role': 'tooltip',\\n        'aria-hidden': true,\\n        'data-is-active': false,\\n        'data-is-focus': false,\\n        'id': id\\n      });\\n      return $template;\\n    }\\n    /**\\n     * sets the position class of an element and recursively calls itself until there are no more possible positions to attempt, or the tooltip element is no longer colliding.\\n     * if the tooltip is larger than the screen width, default to full width - any user selected margin\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_setPosition\\\",\\n    value: function _setPosition() {\\n      _get(_getPrototypeOf(Tooltip.prototype), \\\"_setPosition\\\", this).call(this, this.$element, this.template);\\n    }\\n    /**\\n     * reveals the tooltip, and fires an event to close any other open tooltips on the page\\n     * @fires Tooltip#closeme\\n     * @fires Tooltip#show\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"show\\\",\\n    value: function show() {\\n      if (this.options.showOn !== 'all' && !_foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_2__[\\\"MediaQuery\\\"].is(this.options.showOn)) {\\n        // console.error('The screen is too small to display this tooltip');\\n        return false;\\n      }\\n\\n      var _this = this;\\n\\n      this.template.css('visibility', 'hidden').show();\\n\\n      this._setPosition();\\n\\n      this.template.removeClass('top bottom left right').addClass(this.position);\\n      this.template.removeClass('align-top align-bottom align-left align-right align-center').addClass('align-' + this.alignment);\\n      /**\\n       * Fires to close all other open tooltips on the page\\n       * @event Closeme#tooltip\\n       */\\n\\n      this.$element.trigger('closeme.zf.tooltip', this.template.attr('id'));\\n      this.template.attr({\\n        'data-is-active': true,\\n        'aria-hidden': false\\n      });\\n      _this.isActive = true; // console.log(this.template);\\n\\n      this.template.stop().hide().css('visibility', '').fadeIn(this.options.fadeInDuration, function () {//maybe do stuff?\\n      });\\n      /**\\n       * Fires when the tooltip is shown\\n       * @event Tooltip#show\\n       */\\n\\n      this.$element.trigger('show.zf.tooltip');\\n    }\\n    /**\\n     * Hides the current tooltip, and resets the positioning class if it was changed due to collision\\n     * @fires Tooltip#hide\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"hide\\\",\\n    value: function hide() {\\n      // console.log('hiding', this.$element.data('yeti-box'));\\n      var _this = this;\\n\\n      this.template.stop().attr({\\n        'aria-hidden': true,\\n        'data-is-active': false\\n      }).fadeOut(this.options.fadeOutDuration, function () {\\n        _this.isActive = false;\\n        _this.isClick = false;\\n      });\\n      /**\\n       * fires when the tooltip is hidden\\n       * @event Tooltip#hide\\n       */\\n\\n      this.$element.trigger('hide.zf.tooltip');\\n    }\\n    /**\\n     * adds event listeners for the tooltip and its anchor\\n     * TODO combine some of the listeners like focus and mouseenter, etc.\\n     * @private\\n     */\\n\\n  }, {\\n    key: \\\"_events\\\",\\n    value: function _events() {\\n      var _this = this;\\n\\n      var $template = this.template;\\n      var isFocus = false;\\n\\n      if (!this.options.disableHover) {\\n        this.$element.on('mouseenter.zf.tooltip', function (e) {\\n          if (!_this.isActive) {\\n            _this.timeout = setTimeout(function () {\\n              _this.show();\\n            }, _this.options.hoverDelay);\\n          }\\n        }).on('mouseleave.zf.tooltip', Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\\\"ignoreMousedisappear\\\"])(function (e) {\\n          clearTimeout(_this.timeout);\\n\\n          if (!isFocus || _this.isClick && !_this.options.clickOpen) {\\n            _this.hide();\\n          }\\n        }));\\n      }\\n\\n      if (this.options.clickOpen) {\\n        this.$element.on('mousedown.zf.tooltip', function (e) {\\n          e.stopImmediatePropagation();\\n\\n          if (_this.isClick) {//_this.hide();\\n            // _this.isClick = false;\\n          } else {\\n            _this.isClick = true;\\n\\n            if ((_this.options.disableHover || !_this.$element.attr('tabindex')) && !_this.isActive) {\\n              _this.show();\\n            }\\n          }\\n        });\\n      } else {\\n        this.$element.on('mousedown.zf.tooltip', function (e) {\\n          e.stopImmediatePropagation();\\n          _this.isClick = true;\\n        });\\n      }\\n\\n      if (!this.options.disableForTouch) {\\n        this.$element.on('tap.zf.tooltip touchend.zf.tooltip', function (e) {\\n          _this.isActive ? _this.hide() : _this.show();\\n        });\\n      }\\n\\n      this.$element.on({\\n        // 'toggle.zf.trigger': this.toggle.bind(this),\\n        // 'close.zf.trigger': this.hide.bind(this)\\n        'close.zf.trigger': this.hide.bind(this)\\n      });\\n      this.$element.on('focus.zf.tooltip', function (e) {\\n        isFocus = true;\\n\\n        if (_this.isClick) {\\n          // If we're not showing open on clicks, we need to pretend a click-launched focus isn't\\n          // a real focus, otherwise on hover and come back we get bad behavior\\n          if (!_this.options.clickOpen) {\\n            isFocus = false;\\n          }\\n\\n          return false;\\n        } else {\\n          _this.show();\\n        }\\n      }).on('focusout.zf.tooltip', function (e) {\\n        isFocus = false;\\n        _this.isClick = false;\\n\\n        _this.hide();\\n      }).on('resizeme.zf.trigger', function () {\\n        if (_this.isActive) {\\n          _this._setPosition();\\n        }\\n      });\\n    }\\n    /**\\n     * adds a toggle method, in addition to the static show() & hide() functions\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"toggle\\\",\\n    value: function toggle() {\\n      if (this.isActive) {\\n        this.hide();\\n      } else {\\n        this.show();\\n      }\\n    }\\n    /**\\n     * Destroys an instance of tooltip, removes template element from the view.\\n     * @function\\n     */\\n\\n  }, {\\n    key: \\\"_destroy\\\",\\n    value: function _destroy() {\\n      this.$element.attr('title', this.template.text()).off('.zf.trigger .zf.tooltip').removeClass(this.options.triggerClass).removeClass('top right left bottom').removeAttr('aria-describedby data-disable-hover data-resize data-toggle data-tooltip data-yeti-box');\\n      this.template.remove();\\n    }\\n  }]);\\n\\n  return Tooltip;\\n}(_foundation_positionable__WEBPACK_IMPORTED_MODULE_4__[\\\"Positionable\\\"]);\\n\\nTooltip.defaults = {\\n  disableForTouch: false,\\n\\n  /**\\n   * Time, in ms, before a tooltip should open on hover.\\n   * @option\\n   * @type {number}\\n   * @default 200\\n   */\\n  hoverDelay: 200,\\n\\n  /**\\n   * Time, in ms, a tooltip should take to fade into view.\\n   * @option\\n   * @type {number}\\n   * @default 150\\n   */\\n  fadeInDuration: 150,\\n\\n  /**\\n   * Time, in ms, a tooltip should take to fade out of view.\\n   * @option\\n   * @type {number}\\n   * @default 150\\n   */\\n  fadeOutDuration: 150,\\n\\n  /**\\n   * Disables hover events from opening the tooltip if set to true\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  disableHover: false,\\n\\n  /**\\n   * Optional addtional classes to apply to the tooltip template on init.\\n   * @option\\n   * @type {string}\\n   * @default ''\\n   */\\n  templateClasses: '',\\n\\n  /**\\n   * Non-optional class added to tooltip templates. Foundation default is 'tooltip'.\\n   * @option\\n   * @type {string}\\n   * @default 'tooltip'\\n   */\\n  tooltipClass: 'tooltip',\\n\\n  /**\\n   * Class applied to the tooltip anchor element.\\n   * @option\\n   * @type {string}\\n   * @default 'has-tip'\\n   */\\n  triggerClass: 'has-tip',\\n\\n  /**\\n   * Minimum breakpoint size at which to open the tooltip.\\n   * @option\\n   * @type {string}\\n   * @default 'small'\\n   */\\n  showOn: 'small',\\n\\n  /**\\n   * Custom template to be used to generate markup for tooltip.\\n   * @option\\n   * @type {string}\\n   * @default ''\\n   */\\n  template: '',\\n\\n  /**\\n   * Text displayed in the tooltip template on open.\\n   * @option\\n   * @type {string}\\n   * @default ''\\n   */\\n  tipText: '',\\n  touchCloseText: 'Tap to close.',\\n\\n  /**\\n   * Allows the tooltip to remain open if triggered with a click or touch event.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  clickOpen: true,\\n\\n  /**\\n   * Position of tooltip. Can be left, right, bottom, top, or auto.\\n   * @option\\n   * @type {string}\\n   * @default 'auto'\\n   */\\n  position: 'auto',\\n\\n  /**\\n   * Alignment of tooltip relative to anchor. Can be left, right, bottom, top, center, or auto.\\n   * @option\\n   * @type {string}\\n   * @default 'auto'\\n   */\\n  alignment: 'auto',\\n\\n  /**\\n   * Allow overlap of container/window. If false, tooltip will first try to\\n   * position as defined by data-position and data-alignment, but reposition if\\n   * it would cause an overflow.  @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  allowOverlap: false,\\n\\n  /**\\n   * Allow overlap of only the bottom of the container. This is the most common\\n   * behavior for dropdowns, allowing the dropdown to extend the bottom of the\\n   * screen but not otherwise influence or break out of the container.\\n   * Less common for tooltips.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  allowBottomOverlap: false,\\n\\n  /**\\n   * Distance, in pixels, the template should push away from the anchor on the Y axis.\\n   * @option\\n   * @type {number}\\n   * @default 0\\n   */\\n  vOffset: 0,\\n\\n  /**\\n   * Distance, in pixels, the template should push away from the anchor on the X axis\\n   * @option\\n   * @type {number}\\n   * @default 0\\n   */\\n  hOffset: 0,\\n\\n  /**\\n   * Distance, in pixels, the template spacing auto-adjust for a vertical tooltip\\n   * @option\\n   * @type {number}\\n   * @default 14\\n   */\\n  tooltipHeight: 14,\\n\\n  /**\\n   * Distance, in pixels, the template spacing auto-adjust for a horizontal tooltip\\n   * @option\\n   * @type {number}\\n   * @default 12\\n   */\\n  tooltipWidth: 12,\\n\\n  /**\\n  * Allow HTML in tooltip. Warning: If you are loading user-generated content into tooltips,\\n  * allowing HTML may open yourself up to XSS attacks.\\n  * @option\\n  * @type {boolean}\\n  * @default false\\n  */\\n  allowHtml: false\\n};\\n/**\\n * TODO utilize resize event trigger\\n */\\n\\n\\n\\n//# sourceURL=webpack:///./js/foundation.tooltip.js?\");\n    }, \"./js/foundation.util.box.js\": function jsFoundationUtilBoxJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Box\\\", function() { return Box; });\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./foundation.core.utils */ \\\"./js/foundation.core.utils.js\\\");\\n\\n\\n\\nvar Box = {\\n  ImNotTouchingYou: ImNotTouchingYou,\\n  OverlapArea: OverlapArea,\\n  GetDimensions: GetDimensions,\\n  GetOffsets: GetOffsets,\\n  GetExplicitOffsets: GetExplicitOffsets\\n  /**\\n   * Compares the dimensions of an element to a container and determines collision events with container.\\n   * @function\\n   * @param {jQuery} element - jQuery object to test for collisions.\\n   * @param {jQuery} parent - jQuery object to use as bounding container.\\n   * @param {Boolean} lrOnly - set to true to check left and right values only.\\n   * @param {Boolean} tbOnly - set to true to check top and bottom values only.\\n   * @default if no parent object passed, detects collisions with `window`.\\n   * @returns {Boolean} - true if collision free, false if a collision in any direction.\\n   */\\n\\n};\\n\\nfunction ImNotTouchingYou(element, parent, lrOnly, tbOnly, ignoreBottom) {\\n  return OverlapArea(element, parent, lrOnly, tbOnly, ignoreBottom) === 0;\\n}\\n\\n;\\n\\nfunction OverlapArea(element, parent, lrOnly, tbOnly, ignoreBottom) {\\n  var eleDims = GetDimensions(element),\\n      topOver,\\n      bottomOver,\\n      leftOver,\\n      rightOver;\\n\\n  if (parent) {\\n    var parDims = GetDimensions(parent);\\n    bottomOver = parDims.height + parDims.offset.top - (eleDims.offset.top + eleDims.height);\\n    topOver = eleDims.offset.top - parDims.offset.top;\\n    leftOver = eleDims.offset.left - parDims.offset.left;\\n    rightOver = parDims.width + parDims.offset.left - (eleDims.offset.left + eleDims.width);\\n  } else {\\n    bottomOver = eleDims.windowDims.height + eleDims.windowDims.offset.top - (eleDims.offset.top + eleDims.height);\\n    topOver = eleDims.offset.top - eleDims.windowDims.offset.top;\\n    leftOver = eleDims.offset.left - eleDims.windowDims.offset.left;\\n    rightOver = eleDims.windowDims.width - (eleDims.offset.left + eleDims.width);\\n  }\\n\\n  bottomOver = ignoreBottom ? 0 : Math.min(bottomOver, 0);\\n  topOver = Math.min(topOver, 0);\\n  leftOver = Math.min(leftOver, 0);\\n  rightOver = Math.min(rightOver, 0);\\n\\n  if (lrOnly) {\\n    return leftOver + rightOver;\\n  }\\n\\n  if (tbOnly) {\\n    return topOver + bottomOver;\\n  } // use sum of squares b/c we care about overlap area.\\n\\n\\n  return Math.sqrt(topOver * topOver + bottomOver * bottomOver + leftOver * leftOver + rightOver * rightOver);\\n}\\n/**\\n * Uses native methods to return an object of dimension values.\\n * @function\\n * @param {jQuery || HTML} element - jQuery object or DOM element for which to get the dimensions. Can be any element other that document or window.\\n * @returns {Object} - nested object of integer pixel values\\n * TODO - if element is window, return only those values.\\n */\\n\\n\\nfunction GetDimensions(elem) {\\n  elem = elem.length ? elem[0] : elem;\\n\\n  if (elem === window || elem === document) {\\n    throw new Error(\\\"I'm sorry, Dave. I'm afraid I can't do that.\\\");\\n  }\\n\\n  var rect = elem.getBoundingClientRect(),\\n      parRect = elem.parentNode.getBoundingClientRect(),\\n      winRect = document.body.getBoundingClientRect(),\\n      winY = window.pageYOffset,\\n      winX = window.pageXOffset;\\n  return {\\n    width: rect.width,\\n    height: rect.height,\\n    offset: {\\n      top: rect.top + winY,\\n      left: rect.left + winX\\n    },\\n    parentDims: {\\n      width: parRect.width,\\n      height: parRect.height,\\n      offset: {\\n        top: parRect.top + winY,\\n        left: parRect.left + winX\\n      }\\n    },\\n    windowDims: {\\n      width: winRect.width,\\n      height: winRect.height,\\n      offset: {\\n        top: winY,\\n        left: winX\\n      }\\n    }\\n  };\\n}\\n/**\\n * Returns an object of top and left integer pixel values for dynamically rendered elements,\\n * such as: Tooltip, Reveal, and Dropdown. Maintained for backwards compatibility, and where\\n * you don't know alignment, but generally from\\n * 6.4 forward you should use GetExplicitOffsets, as GetOffsets conflates position and alignment.\\n * @function\\n * @param {jQuery} element - jQuery object for the element being positioned.\\n * @param {jQuery} anchor - jQuery object for the element's anchor point.\\n * @param {String} position - a string relating to the desired position of the element, relative to it's anchor\\n * @param {Number} vOffset - integer pixel value of desired vertical separation between anchor and element.\\n * @param {Number} hOffset - integer pixel value of desired horizontal separation between anchor and element.\\n * @param {Boolean} isOverflow - if a collision event is detected, sets to true to default the element to full width - any desired offset.\\n * TODO alter/rewrite to work with `em` values as well/instead of pixels\\n */\\n\\n\\nfunction GetOffsets(element, anchor, position, vOffset, hOffset, isOverflow) {\\n  console.log(\\\"NOTE: GetOffsets is deprecated in favor of GetExplicitOffsets and will be removed in 6.5\\\");\\n\\n  switch (position) {\\n    case 'top':\\n      return Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_0__[\\\"rtl\\\"])() ? GetExplicitOffsets(element, anchor, 'top', 'left', vOffset, hOffset, isOverflow) : GetExplicitOffsets(element, anchor, 'top', 'right', vOffset, hOffset, isOverflow);\\n\\n    case 'bottom':\\n      return Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_0__[\\\"rtl\\\"])() ? GetExplicitOffsets(element, anchor, 'bottom', 'left', vOffset, hOffset, isOverflow) : GetExplicitOffsets(element, anchor, 'bottom', 'right', vOffset, hOffset, isOverflow);\\n\\n    case 'center top':\\n      return GetExplicitOffsets(element, anchor, 'top', 'center', vOffset, hOffset, isOverflow);\\n\\n    case 'center bottom':\\n      return GetExplicitOffsets(element, anchor, 'bottom', 'center', vOffset, hOffset, isOverflow);\\n\\n    case 'center left':\\n      return GetExplicitOffsets(element, anchor, 'left', 'center', vOffset, hOffset, isOverflow);\\n\\n    case 'center right':\\n      return GetExplicitOffsets(element, anchor, 'right', 'center', vOffset, hOffset, isOverflow);\\n\\n    case 'left bottom':\\n      return GetExplicitOffsets(element, anchor, 'bottom', 'left', vOffset, hOffset, isOverflow);\\n\\n    case 'right bottom':\\n      return GetExplicitOffsets(element, anchor, 'bottom', 'right', vOffset, hOffset, isOverflow);\\n    // Backwards compatibility... this along with the reveal and reveal full\\n    // classes are the only ones that didn't reference anchor\\n\\n    case 'center':\\n      return {\\n        left: $eleDims.windowDims.offset.left + $eleDims.windowDims.width / 2 - $eleDims.width / 2 + hOffset,\\n        top: $eleDims.windowDims.offset.top + $eleDims.windowDims.height / 2 - ($eleDims.height / 2 + vOffset)\\n      };\\n\\n    case 'reveal':\\n      return {\\n        left: ($eleDims.windowDims.width - $eleDims.width) / 2 + hOffset,\\n        top: $eleDims.windowDims.offset.top + vOffset\\n      };\\n\\n    case 'reveal full':\\n      return {\\n        left: $eleDims.windowDims.offset.left,\\n        top: $eleDims.windowDims.offset.top\\n      };\\n      break;\\n\\n    default:\\n      return {\\n        left: Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_0__[\\\"rtl\\\"])() ? $anchorDims.offset.left - $eleDims.width + $anchorDims.width - hOffset : $anchorDims.offset.left + hOffset,\\n        top: $anchorDims.offset.top + $anchorDims.height + vOffset\\n      };\\n  }\\n}\\n\\nfunction GetExplicitOffsets(element, anchor, position, alignment, vOffset, hOffset, isOverflow) {\\n  var $eleDims = GetDimensions(element),\\n      $anchorDims = anchor ? GetDimensions(anchor) : null;\\n  var topVal, leftVal; // set position related attribute\\n\\n  switch (position) {\\n    case 'top':\\n      topVal = $anchorDims.offset.top - ($eleDims.height + vOffset);\\n      break;\\n\\n    case 'bottom':\\n      topVal = $anchorDims.offset.top + $anchorDims.height + vOffset;\\n      break;\\n\\n    case 'left':\\n      leftVal = $anchorDims.offset.left - ($eleDims.width + hOffset);\\n      break;\\n\\n    case 'right':\\n      leftVal = $anchorDims.offset.left + $anchorDims.width + hOffset;\\n      break;\\n  } // set alignment related attribute\\n\\n\\n  switch (position) {\\n    case 'top':\\n    case 'bottom':\\n      switch (alignment) {\\n        case 'left':\\n          leftVal = $anchorDims.offset.left + hOffset;\\n          break;\\n\\n        case 'right':\\n          leftVal = $anchorDims.offset.left - $eleDims.width + $anchorDims.width - hOffset;\\n          break;\\n\\n        case 'center':\\n          leftVal = isOverflow ? hOffset : $anchorDims.offset.left + $anchorDims.width / 2 - $eleDims.width / 2 + hOffset;\\n          break;\\n      }\\n\\n      break;\\n\\n    case 'right':\\n    case 'left':\\n      switch (alignment) {\\n        case 'bottom':\\n          topVal = $anchorDims.offset.top - vOffset + $anchorDims.height - $eleDims.height;\\n          break;\\n\\n        case 'top':\\n          topVal = $anchorDims.offset.top + vOffset;\\n          break;\\n\\n        case 'center':\\n          topVal = $anchorDims.offset.top + vOffset + $anchorDims.height / 2 - $eleDims.height / 2;\\n          break;\\n      }\\n\\n      break;\\n  }\\n\\n  return {\\n    top: topVal,\\n    left: leftVal\\n  };\\n}\\n\\n\\n\\n//# sourceURL=webpack:///./js/foundation.util.box.js?\");\n    }, \"./js/foundation.util.imageLoader.js\": function jsFoundationUtilImageLoaderJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"onImagesLoaded\\\", function() { return onImagesLoaded; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n\\n\\n\\n/**\\n * Runs a callback function when images are fully loaded.\\n * @param {Object} images - Image(s) to check if loaded.\\n * @param {Func} callback - Function to execute when image is fully loaded.\\n */\\n\\nfunction onImagesLoaded(images, callback) {\\n  var self = this,\\n      unloaded = images.length;\\n\\n  if (unloaded === 0) {\\n    callback();\\n  }\\n\\n  images.each(function () {\\n    // Check if image is loaded\\n    if (this.complete && typeof this.naturalWidth !== 'undefined') {\\n      singleImageLoaded();\\n    } else {\\n      // If the above check failed, simulate loading on detached element.\\n      var image = new Image(); // Still count image as loaded if it finalizes with an error.\\n\\n      var events = \\\"load.zf.images error.zf.images\\\";\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(image).one(events, function me(event) {\\n        // Unbind the event listeners. We're using 'one' but only one of the two events will have fired.\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).off(events, me);\\n        singleImageLoaded();\\n      });\\n      image.src = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).attr('src');\\n    }\\n  });\\n\\n  function singleImageLoaded() {\\n    unloaded--;\\n\\n    if (unloaded === 0) {\\n      callback();\\n    }\\n  }\\n}\\n\\n\\n\\n//# sourceURL=webpack:///./js/foundation.util.imageLoader.js?\");\n    }, \"./js/foundation.util.keyboard.js\": function jsFoundationUtilKeyboardJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Keyboard\\\", function() { return Keyboard; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.utils */ \\\"./js/foundation.core.utils.js\\\");\\n/*******************************************\\n *                                         *\\n * This util was created by Marius Olbertz *\\n * Please thank Marius on GitHub /owlbertz *\\n * or the web http://www.mariusolbertz.de/ *\\n *                                         *\\n ******************************************/\\n\\n\\n\\n\\nvar keyCodes = {\\n  9: 'TAB',\\n  13: 'ENTER',\\n  27: 'ESCAPE',\\n  32: 'SPACE',\\n  35: 'END',\\n  36: 'HOME',\\n  37: 'ARROW_LEFT',\\n  38: 'ARROW_UP',\\n  39: 'ARROW_RIGHT',\\n  40: 'ARROW_DOWN'\\n};\\nvar commands = {}; // Functions pulled out to be referenceable from internals\\n\\nfunction findFocusable($element) {\\n  if (!$element) {\\n    return false;\\n  }\\n\\n  return $element.find('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]').filter(function () {\\n    if (!jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).is(':visible') || jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).attr('tabindex') < 0) {\\n      return false;\\n    } //only have visible elements and those that have a tabindex greater or equal 0\\n\\n\\n    return true;\\n  });\\n}\\n\\nfunction parseKey(event) {\\n  var key = keyCodes[event.which || event.keyCode] || String.fromCharCode(event.which).toUpperCase(); // Remove un-printable characters, e.g. for `fromCharCode` calls for CTRL only events\\n\\n  key = key.replace(/\\\\W+/, '');\\n  if (event.shiftKey) key = \\\"SHIFT_\\\".concat(key);\\n  if (event.ctrlKey) key = \\\"CTRL_\\\".concat(key);\\n  if (event.altKey) key = \\\"ALT_\\\".concat(key); // Remove trailing underscore, in case only modifiers were used (e.g. only `CTRL_ALT`)\\n\\n  key = key.replace(/_$/, '');\\n  return key;\\n}\\n\\nvar Keyboard = {\\n  keys: getKeyCodes(keyCodes),\\n\\n  /**\\n   * Parses the (keyboard) event and returns a String that represents its key\\n   * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE\\n   * @param {Event} event - the event generated by the event handler\\n   * @return String key - String that represents the key pressed\\n   */\\n  parseKey: parseKey,\\n\\n  /**\\n   * Handles the given (keyboard) event\\n   * @param {Event} event - the event generated by the event handler\\n   * @param {String} component - Foundation component's name, e.g. Slider or Reveal\\n   * @param {Objects} functions - collection of functions that are to be executed\\n   */\\n  handleKey: function handleKey(event, component, functions) {\\n    var commandList = commands[component],\\n        keyCode = this.parseKey(event),\\n        cmds,\\n        command,\\n        fn;\\n    if (!commandList) return console.warn('Component not defined!');\\n\\n    if (typeof commandList.ltr === 'undefined') {\\n      // this component does not differentiate between ltr and rtl\\n      cmds = commandList; // use plain list\\n    } else {\\n      // merge ltr and rtl: if document is rtl, rtl overwrites ltr and vice versa\\n      if (Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\\\"rtl\\\"])()) cmds = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, commandList.ltr, commandList.rtl);else cmds = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, commandList.rtl, commandList.ltr);\\n    }\\n\\n    command = cmds[keyCode];\\n    fn = functions[command];\\n\\n    if (fn && typeof fn === 'function') {\\n      // execute function  if exists\\n      var returnValue = fn.apply();\\n\\n      if (functions.handled || typeof functions.handled === 'function') {\\n        // execute function when event was handled\\n        functions.handled(returnValue);\\n      }\\n    } else {\\n      if (functions.unhandled || typeof functions.unhandled === 'function') {\\n        // execute function when event was not handled\\n        functions.unhandled();\\n      }\\n    }\\n  },\\n\\n  /**\\n   * Finds all focusable elements within the given `$element`\\n   * @param {jQuery} $element - jQuery object to search within\\n   * @return {jQuery} $focusable - all focusable elements within `$element`\\n   */\\n  findFocusable: findFocusable,\\n\\n  /**\\n   * Returns the component name name\\n   * @param {Object} component - Foundation component, e.g. Slider or Reveal\\n   * @return String componentName\\n   */\\n  register: function register(componentName, cmds) {\\n    commands[componentName] = cmds;\\n  },\\n  // TODO9438: These references to Keyboard need to not require global. Will 'this' work in this context?\\n  //\\n\\n  /**\\n   * Traps the focus in the given element.\\n   * @param  {jQuery} $element  jQuery object to trap the foucs into.\\n   */\\n  trapFocus: function trapFocus($element) {\\n    var $focusable = findFocusable($element),\\n        $firstFocusable = $focusable.eq(0),\\n        $lastFocusable = $focusable.eq(-1);\\n    $element.on('keydown.zf.trapfocus', function (event) {\\n      if (event.target === $lastFocusable[0] && parseKey(event) === 'TAB') {\\n        event.preventDefault();\\n        $firstFocusable.focus();\\n      } else if (event.target === $firstFocusable[0] && parseKey(event) === 'SHIFT_TAB') {\\n        event.preventDefault();\\n        $lastFocusable.focus();\\n      }\\n    });\\n  },\\n\\n  /**\\n   * Releases the trapped focus from the given element.\\n   * @param  {jQuery} $element  jQuery object to release the focus for.\\n   */\\n  releaseFocus: function releaseFocus($element) {\\n    $element.off('keydown.zf.trapfocus');\\n  }\\n};\\n/*\\n * Constants for easier comparing.\\n * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE\\n */\\n\\nfunction getKeyCodes(kcs) {\\n  var k = {};\\n\\n  for (var kc in kcs) {\\n    k[kcs[kc]] = kcs[kc];\\n  }\\n\\n  return k;\\n}\\n\\n\\n\\n//# sourceURL=webpack:///./js/foundation.util.keyboard.js?\");\n    }, \"./js/foundation.util.mediaQuery.js\": function jsFoundationUtilMediaQueryJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"MediaQuery\\\", function() { return MediaQuery; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\n // Default set of media queries\\n\\nvar defaultQueries = {\\n  'default': 'only screen',\\n  landscape: 'only screen and (orientation: landscape)',\\n  portrait: 'only screen and (orientation: portrait)',\\n  retina: 'only screen and (-webkit-min-device-pixel-ratio: 2),' + 'only screen and (min--moz-device-pixel-ratio: 2),' + 'only screen and (-o-min-device-pixel-ratio: 2/1),' + 'only screen and (min-device-pixel-ratio: 2),' + 'only screen and (min-resolution: 192dpi),' + 'only screen and (min-resolution: 2dppx)'\\n}; // matchMedia() polyfill - Test a CSS media type/query in JS.\\n// Authors & copyright(c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. MIT license\\n\\n/* eslint-disable */\\n\\nwindow.matchMedia || (window.matchMedia = function () {\\n  \\\"use strict\\\"; // For browsers that support matchMedium api such as IE 9 and webkit\\n\\n  var styleMedia = window.styleMedia || window.media; // For those that don't support matchMedium\\n\\n  if (!styleMedia) {\\n    var style = document.createElement('style'),\\n        script = document.getElementsByTagName('script')[0],\\n        info = null;\\n    style.type = 'text/css';\\n    style.id = 'matchmediajs-test';\\n\\n    if (!script) {\\n      document.head.appendChild(style);\\n    } else {\\n      script.parentNode.insertBefore(style, script);\\n    } // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers\\n\\n\\n    info = 'getComputedStyle' in window && window.getComputedStyle(style, null) || style.currentStyle;\\n    styleMedia = {\\n      matchMedium: function matchMedium(media) {\\n        var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }'; // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers\\n\\n        if (style.styleSheet) {\\n          style.styleSheet.cssText = text;\\n        } else {\\n          style.textContent = text;\\n        } // Test if media query is true or false\\n\\n\\n        return info.width === '1px';\\n      }\\n    };\\n  }\\n\\n  return function (media) {\\n    return {\\n      matches: styleMedia.matchMedium(media || 'all'),\\n      media: media || 'all'\\n    };\\n  };\\n}());\\n/* eslint-enable */\\n\\nvar MediaQuery = {\\n  queries: [],\\n  current: '',\\n\\n  /**\\n   * Initializes the media query helper, by extracting the breakpoint list from the CSS and activating the breakpoint watcher.\\n   * @function\\n   * @private\\n   */\\n  _init: function _init() {\\n    var self = this;\\n    var $meta = jquery__WEBPACK_IMPORTED_MODULE_0___default()('meta.foundation-mq');\\n\\n    if (!$meta.length) {\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()('<meta class=\\\"foundation-mq\\\">').appendTo(document.head);\\n    }\\n\\n    var extractedStyles = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.foundation-mq').css('font-family');\\n    var namedQueries;\\n    namedQueries = parseStyleToObject(extractedStyles);\\n\\n    for (var key in namedQueries) {\\n      if (namedQueries.hasOwnProperty(key)) {\\n        self.queries.push({\\n          name: key,\\n          value: \\\"only screen and (min-width: \\\".concat(namedQueries[key], \\\")\\\")\\n        });\\n      }\\n    }\\n\\n    this.current = this._getCurrentSize();\\n\\n    this._watcher();\\n  },\\n\\n  /**\\n   * Checks if the screen is at least as wide as a breakpoint.\\n   * @function\\n   * @param {String} size - Name of the breakpoint to check.\\n   * @returns {Boolean} `true` if the breakpoint matches, `false` if it's smaller.\\n   */\\n  atLeast: function atLeast(size) {\\n    var query = this.get(size);\\n\\n    if (query) {\\n      return window.matchMedia(query).matches;\\n    }\\n\\n    return false;\\n  },\\n\\n  /**\\n   * Checks if the screen matches to a breakpoint.\\n   * @function\\n   * @param {String} size - Name of the breakpoint to check, either 'small only' or 'small'. Omitting 'only' falls back to using atLeast() method.\\n   * @returns {Boolean} `true` if the breakpoint matches, `false` if it does not.\\n   */\\n  is: function is(size) {\\n    size = size.trim().split(' ');\\n\\n    if (size.length > 1 && size[1] === 'only') {\\n      if (size[0] === this._getCurrentSize()) return true;\\n    } else {\\n      return this.atLeast(size[0]);\\n    }\\n\\n    return false;\\n  },\\n\\n  /**\\n   * Gets the media query of a breakpoint.\\n   * @function\\n   * @param {String} size - Name of the breakpoint to get.\\n   * @returns {String|null} - The media query of the breakpoint, or `null` if the breakpoint doesn't exist.\\n   */\\n  get: function get(size) {\\n    for (var i in this.queries) {\\n      if (this.queries.hasOwnProperty(i)) {\\n        var query = this.queries[i];\\n        if (size === query.name) return query.value;\\n      }\\n    }\\n\\n    return null;\\n  },\\n\\n  /**\\n   * Gets the current breakpoint name by testing every breakpoint and returning the last one to match (the biggest one).\\n   * @function\\n   * @private\\n   * @returns {String} Name of the current breakpoint.\\n   */\\n  _getCurrentSize: function _getCurrentSize() {\\n    var matched;\\n\\n    for (var i = 0; i < this.queries.length; i++) {\\n      var query = this.queries[i];\\n\\n      if (window.matchMedia(query.value).matches) {\\n        matched = query;\\n      }\\n    }\\n\\n    if (_typeof(matched) === 'object') {\\n      return matched.name;\\n    } else {\\n      return matched;\\n    }\\n  },\\n\\n  /**\\n   * Activates the breakpoint watcher, which fires an event on the window whenever the breakpoint changes.\\n   * @function\\n   * @private\\n   */\\n  _watcher: function _watcher() {\\n    var _this = this;\\n\\n    jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off('resize.zf.mediaquery').on('resize.zf.mediaquery', function () {\\n      var newSize = _this._getCurrentSize(),\\n          currentSize = _this.current;\\n\\n      if (newSize !== currentSize) {\\n        // Change the current media query\\n        _this.current = newSize; // Broadcast the media query change on the window\\n\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).trigger('changed.zf.mediaquery', [newSize, currentSize]);\\n      }\\n    });\\n  }\\n}; // Thank you: https://github.com/sindresorhus/query-string\\n\\nfunction parseStyleToObject(str) {\\n  var styleObject = {};\\n\\n  if (typeof str !== 'string') {\\n    return styleObject;\\n  }\\n\\n  str = str.trim().slice(1, -1); // browsers re-quote string style values\\n\\n  if (!str) {\\n    return styleObject;\\n  }\\n\\n  styleObject = str.split('&').reduce(function (ret, param) {\\n    var parts = param.replace(/\\\\+/g, ' ').split('=');\\n    var key = parts[0];\\n    var val = parts[1];\\n    key = decodeURIComponent(key); // missing `=` should be `null`:\\n    // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\\n\\n    val = typeof val === 'undefined' ? null : decodeURIComponent(val);\\n\\n    if (!ret.hasOwnProperty(key)) {\\n      ret[key] = val;\\n    } else if (Array.isArray(ret[key])) {\\n      ret[key].push(val);\\n    } else {\\n      ret[key] = [ret[key], val];\\n    }\\n\\n    return ret;\\n  }, {});\\n  return styleObject;\\n}\\n\\n\\n\\n//# sourceURL=webpack:///./js/foundation.util.mediaQuery.js?\");\n    }, \"./js/foundation.util.motion.js\": function jsFoundationUtilMotionJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Move\\\", function() { return Move; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Motion\\\", function() { return Motion; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.utils */ \\\"./js/foundation.core.utils.js\\\");\\n\\n\\n\\n\\n/**\\n * Motion module.\\n * @module foundation.motion\\n */\\n\\nvar initClasses = ['mui-enter', 'mui-leave'];\\nvar activeClasses = ['mui-enter-active', 'mui-leave-active'];\\nvar Motion = {\\n  animateIn: function animateIn(element, animation, cb) {\\n    animate(true, element, animation, cb);\\n  },\\n  animateOut: function animateOut(element, animation, cb) {\\n    animate(false, element, animation, cb);\\n  }\\n};\\n\\nfunction Move(duration, elem, fn) {\\n  var anim,\\n      prog,\\n      start = null; // console.log('called');\\n\\n  if (duration === 0) {\\n    fn.apply(elem);\\n    elem.trigger('finished.zf.animate', [elem]).triggerHandler('finished.zf.animate', [elem]);\\n    return;\\n  }\\n\\n  function move(ts) {\\n    if (!start) start = ts; // console.log(start, ts);\\n\\n    prog = ts - start;\\n    fn.apply(elem);\\n\\n    if (prog < duration) {\\n      anim = window.requestAnimationFrame(move, elem);\\n    } else {\\n      window.cancelAnimationFrame(anim);\\n      elem.trigger('finished.zf.animate', [elem]).triggerHandler('finished.zf.animate', [elem]);\\n    }\\n  }\\n\\n  anim = window.requestAnimationFrame(move);\\n}\\n/**\\n * Animates an element in or out using a CSS transition class.\\n * @function\\n * @private\\n * @param {Boolean} isIn - Defines if the animation is in or out.\\n * @param {Object} element - jQuery or HTML object to animate.\\n * @param {String} animation - CSS class to use.\\n * @param {Function} cb - Callback to run when animation is finished.\\n */\\n\\n\\nfunction animate(isIn, element, animation, cb) {\\n  element = jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).eq(0);\\n  if (!element.length) return;\\n  var initClass = isIn ? initClasses[0] : initClasses[1];\\n  var activeClass = isIn ? activeClasses[0] : activeClasses[1]; // Set up the animation\\n\\n  reset();\\n  element.addClass(animation).css('transition', 'none');\\n  requestAnimationFrame(function () {\\n    element.addClass(initClass);\\n    if (isIn) element.show();\\n  }); // Start the animation\\n\\n  requestAnimationFrame(function () {\\n    element[0].offsetWidth;\\n    element.css('transition', '').addClass(activeClass);\\n  }); // Clean up the animation when it finishes\\n\\n  element.one(Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\\\"transitionend\\\"])(element), finish); // Hides the element (for out animations), resets the element, and runs a callback\\n\\n  function finish() {\\n    if (!isIn) element.hide();\\n    reset();\\n    if (cb) cb.apply(element);\\n  } // Resets transitions and removes motion-specific classes\\n\\n\\n  function reset() {\\n    element[0].style.transitionDuration = 0;\\n    element.removeClass(\\\"\\\".concat(initClass, \\\" \\\").concat(activeClass, \\\" \\\").concat(animation));\\n  }\\n}\\n\\n\\n\\n//# sourceURL=webpack:///./js/foundation.util.motion.js?\");\n    }, \"./js/foundation.util.nest.js\": function jsFoundationUtilNestJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Nest\\\", function() { return Nest; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n\\n\\n\\nvar Nest = {\\n  Feather: function Feather(menu) {\\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'zf';\\n    menu.attr('role', 'menubar');\\n    var items = menu.find('li').attr({\\n      'role': 'menuitem'\\n    }),\\n        subMenuClass = \\\"is-\\\".concat(type, \\\"-submenu\\\"),\\n        subItemClass = \\\"\\\".concat(subMenuClass, \\\"-item\\\"),\\n        hasSubClass = \\\"is-\\\".concat(type, \\\"-submenu-parent\\\"),\\n        applyAria = type !== 'accordion'; // Accordions handle their own ARIA attriutes.\\n\\n    items.each(function () {\\n      var $item = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\\n          $sub = $item.children('ul');\\n\\n      if ($sub.length) {\\n        $item.addClass(hasSubClass);\\n        $sub.addClass(\\\"submenu \\\".concat(subMenuClass)).attr({\\n          'data-submenu': ''\\n        });\\n\\n        if (applyAria) {\\n          $item.attr({\\n            'aria-haspopup': true,\\n            'aria-label': $item.children('a:first').text()\\n          }); // Note:  Drilldowns behave differently in how they hide, and so need\\n          // additional attributes.  We should look if this possibly over-generalized\\n          // utility (Nest) is appropriate when we rework menus in 6.4\\n\\n          if (type === 'drilldown') {\\n            $item.attr({\\n              'aria-expanded': false\\n            });\\n          }\\n        }\\n\\n        $sub.addClass(\\\"submenu \\\".concat(subMenuClass)).attr({\\n          'data-submenu': '',\\n          'role': 'menubar'\\n        });\\n\\n        if (type === 'drilldown') {\\n          $sub.attr({\\n            'aria-hidden': true\\n          });\\n        }\\n      }\\n\\n      if ($item.parent('[data-submenu]').length) {\\n        $item.addClass(\\\"is-submenu-item \\\".concat(subItemClass));\\n      }\\n    });\\n    return;\\n  },\\n  Burn: function Burn(menu, type) {\\n    var //items = menu.find('li'),\\n    subMenuClass = \\\"is-\\\".concat(type, \\\"-submenu\\\"),\\n        subItemClass = \\\"\\\".concat(subMenuClass, \\\"-item\\\"),\\n        hasSubClass = \\\"is-\\\".concat(type, \\\"-submenu-parent\\\");\\n    menu.find('>li, > li > ul, .menu, .menu > li, [data-submenu] > li').removeClass(\\\"\\\".concat(subMenuClass, \\\" \\\").concat(subItemClass, \\\" \\\").concat(hasSubClass, \\\" is-submenu-item submenu is-active\\\")).removeAttr('data-submenu').css('display', '');\\n  }\\n};\\n\\n\\n//# sourceURL=webpack:///./js/foundation.util.nest.js?\");\n    }, \"./js/foundation.util.timer.js\": function jsFoundationUtilTimerJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Timer\\\", function() { return Timer; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n\\n\\n\\n\\nfunction Timer(elem, options, cb) {\\n  var _this = this,\\n      duration = options.duration,\\n      //options is an object for easily adding features later.\\n  nameSpace = Object.keys(elem.data())[0] || 'timer',\\n      remain = -1,\\n      start,\\n      timer;\\n\\n  this.isPaused = false;\\n\\n  this.restart = function () {\\n    remain = -1;\\n    clearTimeout(timer);\\n    this.start();\\n  };\\n\\n  this.start = function () {\\n    this.isPaused = false; // if(!elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.\\n\\n    clearTimeout(timer);\\n    remain = remain <= 0 ? duration : remain;\\n    elem.data('paused', false);\\n    start = Date.now();\\n    timer = setTimeout(function () {\\n      if (options.infinite) {\\n        _this.restart(); //rerun the timer.\\n\\n      }\\n\\n      if (cb && typeof cb === 'function') {\\n        cb();\\n      }\\n    }, remain);\\n    elem.trigger(\\\"timerstart.zf.\\\".concat(nameSpace));\\n  };\\n\\n  this.pause = function () {\\n    this.isPaused = true; //if(elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.\\n\\n    clearTimeout(timer);\\n    elem.data('paused', true);\\n    var end = Date.now();\\n    remain = remain - (end - start);\\n    elem.trigger(\\\"timerpaused.zf.\\\".concat(nameSpace));\\n  };\\n}\\n\\n\\n\\n//# sourceURL=webpack:///./js/foundation.util.timer.js?\");\n    }, \"./js/foundation.util.touch.js\": function jsFoundationUtilTouchJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Touch\\\", function() { return Touch; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\n//**************************************************\\n//**Work inspired by multiple jquery swipe plugins**\\n//**Done by Yohai Ararat ***************************\\n//**************************************************\\n\\nvar Touch = {};\\nvar startPosX,\\n    startPosY,\\n    startTime,\\n    elapsedTime,\\n    startEvent,\\n    isMoving = false,\\n    didMoved = false;\\n\\nfunction onTouchEnd(e) {\\n  this.removeEventListener('touchmove', onTouchMove);\\n  this.removeEventListener('touchend', onTouchEnd); // If the touch did not move, consider it as a \\\"tap\\\"\\n\\n  if (!didMoved) {\\n    var tapEvent = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.Event('tap', startEvent || e);\\n    jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).trigger(tapEvent);\\n  }\\n\\n  startEvent = null;\\n  isMoving = false;\\n  didMoved = false;\\n}\\n\\nfunction onTouchMove(e) {\\n  if (jquery__WEBPACK_IMPORTED_MODULE_0___default.a.spotSwipe.preventDefault) {\\n    e.preventDefault();\\n  }\\n\\n  if (isMoving) {\\n    var x = e.touches[0].pageX;\\n    var y = e.touches[0].pageY;\\n    var dx = startPosX - x;\\n    var dy = startPosY - y;\\n    var dir;\\n    didMoved = true;\\n    elapsedTime = new Date().getTime() - startTime;\\n\\n    if (Math.abs(dx) >= jquery__WEBPACK_IMPORTED_MODULE_0___default.a.spotSwipe.moveThreshold && elapsedTime <= jquery__WEBPACK_IMPORTED_MODULE_0___default.a.spotSwipe.timeThreshold) {\\n      dir = dx > 0 ? 'left' : 'right';\\n    } // else if(Math.abs(dy) >= $.spotSwipe.moveThreshold && elapsedTime <= $.spotSwipe.timeThreshold) {\\n    //   dir = dy > 0 ? 'down' : 'up';\\n    // }\\n\\n\\n    if (dir) {\\n      e.preventDefault();\\n      onTouchEnd.apply(this, arguments);\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).trigger(jquery__WEBPACK_IMPORTED_MODULE_0___default.a.Event('swipe', e), dir).trigger(jquery__WEBPACK_IMPORTED_MODULE_0___default.a.Event(\\\"swipe\\\".concat(dir), e));\\n    }\\n  }\\n}\\n\\nfunction onTouchStart(e) {\\n  if (e.touches.length == 1) {\\n    startPosX = e.touches[0].pageX;\\n    startPosY = e.touches[0].pageY;\\n    startEvent = e;\\n    isMoving = true;\\n    didMoved = false;\\n    startTime = new Date().getTime();\\n    this.addEventListener('touchmove', onTouchMove, false);\\n    this.addEventListener('touchend', onTouchEnd, false);\\n  }\\n}\\n\\nfunction init() {\\n  this.addEventListener && this.addEventListener('touchstart', onTouchStart, false);\\n}\\n\\nfunction teardown() {\\n  this.removeEventListener('touchstart', onTouchStart);\\n}\\n\\nvar SpotSwipe =\\n/*#__PURE__*/\\nfunction () {\\n  function SpotSwipe($) {\\n    _classCallCheck(this, SpotSwipe);\\n\\n    this.version = '1.0.0';\\n    this.enabled = 'ontouchstart' in document.documentElement;\\n    this.preventDefault = false;\\n    this.moveThreshold = 75;\\n    this.timeThreshold = 200;\\n    this.$ = $;\\n\\n    this._init();\\n  }\\n\\n  _createClass(SpotSwipe, [{\\n    key: \\\"_init\\\",\\n    value: function _init() {\\n      var $ = this.$;\\n      $.event.special.swipe = {\\n        setup: init\\n      };\\n      $.event.special.tap = {\\n        setup: init\\n      };\\n      $.each(['left', 'up', 'down', 'right'], function () {\\n        $.event.special[\\\"swipe\\\".concat(this)] = {\\n          setup: function setup() {\\n            $(this).on('swipe', $.noop);\\n          }\\n        };\\n      });\\n    }\\n  }]);\\n\\n  return SpotSwipe;\\n}();\\n/****************************************************\\n * As far as I can tell, both setupSpotSwipe and    *\\n * setupTouchHandler should be idempotent,          *\\n * because they directly replace functions &        *\\n * values, and do not add event handlers directly.  *\\n ****************************************************/\\n\\n\\nTouch.setupSpotSwipe = function ($) {\\n  $.spotSwipe = new SpotSwipe($);\\n};\\n/****************************************************\\n * Method for adding pseudo drag events to elements *\\n ***************************************************/\\n\\n\\nTouch.setupTouchHandler = function ($) {\\n  $.fn.addTouch = function () {\\n    this.each(function (i, el) {\\n      $(el).bind('touchstart touchmove touchend touchcancel', function (event) {\\n        //we pass the original event object because the jQuery event\\n        //object is normalized to w3c specs and does not provide the TouchList\\n        handleTouch(event);\\n      });\\n    });\\n\\n    var handleTouch = function handleTouch(event) {\\n      var touches = event.changedTouches,\\n          first = touches[0],\\n          eventTypes = {\\n        touchstart: 'mousedown',\\n        touchmove: 'mousemove',\\n        touchend: 'mouseup'\\n      },\\n          type = eventTypes[event.type],\\n          simulatedEvent;\\n\\n      if ('MouseEvent' in window && typeof window.MouseEvent === 'function') {\\n        simulatedEvent = new window.MouseEvent(type, {\\n          'bubbles': true,\\n          'cancelable': true,\\n          'screenX': first.screenX,\\n          'screenY': first.screenY,\\n          'clientX': first.clientX,\\n          'clientY': first.clientY\\n        });\\n      } else {\\n        simulatedEvent = document.createEvent('MouseEvent');\\n        simulatedEvent.initMouseEvent(type, true, true, window, 1, first.screenX, first.screenY, first.clientX, first.clientY, false, false, false, false, 0\\n        /*left*/\\n        , null);\\n      }\\n\\n      first.target.dispatchEvent(simulatedEvent);\\n    };\\n  };\\n};\\n\\nTouch.init = function ($) {\\n  if (typeof $.spotSwipe === 'undefined') {\\n    Touch.setupSpotSwipe($);\\n    Touch.setupTouchHandler($);\\n  }\\n};\\n\\n\\n\\n//# sourceURL=webpack:///./js/foundation.util.touch.js?\");\n    }, \"./js/foundation.util.triggers.js\": function jsFoundationUtilTriggersJs(module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n      eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Triggers\\\", function() { return Triggers; });\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \\\"jquery\\\");\\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.utils */ \\\"./js/foundation.core.utils.js\\\");\\n/* harmony import */ var _foundation_util_motion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.util.motion */ \\\"./js/foundation.util.motion.js\\\");\\n\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\n\\n\\n\\n\\nvar MutationObserver = function () {\\n  var prefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];\\n\\n  for (var i = 0; i < prefixes.length; i++) {\\n    if (\\\"\\\".concat(prefixes[i], \\\"MutationObserver\\\") in window) {\\n      return window[\\\"\\\".concat(prefixes[i], \\\"MutationObserver\\\")];\\n    }\\n  }\\n\\n  return false;\\n}();\\n\\nvar triggers = function triggers(el, type) {\\n  el.data(type).split(' ').forEach(function (id) {\\n    jquery__WEBPACK_IMPORTED_MODULE_0___default()(\\\"#\\\".concat(id))[type === 'close' ? 'trigger' : 'triggerHandler'](\\\"\\\".concat(type, \\\".zf.trigger\\\"), [el]);\\n  });\\n};\\n\\nvar Triggers = {\\n  Listeners: {\\n    Basic: {},\\n    Global: {}\\n  },\\n  Initializers: {}\\n};\\nTriggers.Listeners.Basic = {\\n  openListener: function openListener() {\\n    triggers(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this), 'open');\\n  },\\n  closeListener: function closeListener() {\\n    var id = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data('close');\\n\\n    if (id) {\\n      triggers(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this), 'close');\\n    } else {\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).trigger('close.zf.trigger');\\n    }\\n  },\\n  toggleListener: function toggleListener() {\\n    var id = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data('toggle');\\n\\n    if (id) {\\n      triggers(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this), 'toggle');\\n    } else {\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).trigger('toggle.zf.trigger');\\n    }\\n  },\\n  closeableListener: function closeableListener(e) {\\n    e.stopPropagation();\\n    var animation = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data('closable');\\n\\n    if (animation !== '') {\\n      _foundation_util_motion__WEBPACK_IMPORTED_MODULE_2__[\\\"Motion\\\"].animateOut(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this), animation, function () {\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).trigger('closed.zf');\\n      });\\n    } else {\\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).fadeOut().trigger('closed.zf');\\n    }\\n  },\\n  toggleFocusListener: function toggleFocusListener() {\\n    var id = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data('toggle-focus');\\n    jquery__WEBPACK_IMPORTED_MODULE_0___default()(\\\"#\\\".concat(id)).triggerHandler('toggle.zf.trigger', [jquery__WEBPACK_IMPORTED_MODULE_0___default()(this)]);\\n  }\\n}; // Elements with [data-open] will reveal a plugin that supports it when clicked.\\n\\nTriggers.Initializers.addOpenListener = function ($elem) {\\n  $elem.off('click.zf.trigger', Triggers.Listeners.Basic.openListener);\\n  $elem.on('click.zf.trigger', '[data-open]', Triggers.Listeners.Basic.openListener);\\n}; // Elements with [data-close] will close a plugin that supports it when clicked.\\n// If used without a value on [data-close], the event will bubble, allowing it to close a parent component.\\n\\n\\nTriggers.Initializers.addCloseListener = function ($elem) {\\n  $elem.off('click.zf.trigger', Triggers.Listeners.Basic.closeListener);\\n  $elem.on('click.zf.trigger', '[data-close]', Triggers.Listeners.Basic.closeListener);\\n}; // Elements with [data-toggle] will toggle a plugin that supports it when clicked.\\n\\n\\nTriggers.Initializers.addToggleListener = function ($elem) {\\n  $elem.off('click.zf.trigger', Triggers.Listeners.Basic.toggleListener);\\n  $elem.on('click.zf.trigger', '[data-toggle]', Triggers.Listeners.Basic.toggleListener);\\n}; // Elements with [data-closable] will respond to close.zf.trigger events.\\n\\n\\nTriggers.Initializers.addCloseableListener = function ($elem) {\\n  $elem.off('close.zf.trigger', Triggers.Listeners.Basic.closeableListener);\\n  $elem.on('close.zf.trigger', '[data-closeable], [data-closable]', Triggers.Listeners.Basic.closeableListener);\\n}; // Elements with [data-toggle-focus] will respond to coming in and out of focus\\n\\n\\nTriggers.Initializers.addToggleFocusListener = function ($elem) {\\n  $elem.off('focus.zf.trigger blur.zf.trigger', Triggers.Listeners.Basic.toggleFocusListener);\\n  $elem.on('focus.zf.trigger blur.zf.trigger', '[data-toggle-focus]', Triggers.Listeners.Basic.toggleFocusListener);\\n}; // More Global/complex listeners and triggers\\n\\n\\nTriggers.Listeners.Global = {\\n  resizeListener: function resizeListener($nodes) {\\n    if (!MutationObserver) {\\n      //fallback for IE 9\\n      $nodes.each(function () {\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).triggerHandler('resizeme.zf.trigger');\\n      });\\n    } //trigger all listening elements and signal a resize event\\n\\n\\n    $nodes.attr('data-events', \\\"resize\\\");\\n  },\\n  scrollListener: function scrollListener($nodes) {\\n    if (!MutationObserver) {\\n      //fallback for IE 9\\n      $nodes.each(function () {\\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).triggerHandler('scrollme.zf.trigger');\\n      });\\n    } //trigger all listening elements and signal a scroll event\\n\\n\\n    $nodes.attr('data-events', \\\"scroll\\\");\\n  },\\n  closeMeListener: function closeMeListener(e, pluginId) {\\n    var plugin = e.namespace.split('.')[0];\\n    var plugins = jquery__WEBPACK_IMPORTED_MODULE_0___default()(\\\"[data-\\\".concat(plugin, \\\"]\\\")).not(\\\"[data-yeti-box=\\\\\\\"\\\".concat(pluginId, \\\"\\\\\\\"]\\\"));\\n    plugins.each(function () {\\n      var _this = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);\\n\\n      _this.triggerHandler('close.zf.trigger', [_this]);\\n    });\\n  } // Global, parses whole document.\\n\\n};\\n\\nTriggers.Initializers.addClosemeListener = function (pluginName) {\\n  var yetiBoxes = jquery__WEBPACK_IMPORTED_MODULE_0___default()('[data-yeti-box]'),\\n      plugNames = ['dropdown', 'tooltip', 'reveal'];\\n\\n  if (pluginName) {\\n    if (typeof pluginName === 'string') {\\n      plugNames.push(pluginName);\\n    } else if (_typeof(pluginName) === 'object' && typeof pluginName[0] === 'string') {\\n      plugNames.concat(pluginName);\\n    } else {\\n      console.error('Plugin names must be strings');\\n    }\\n  }\\n\\n  if (yetiBoxes.length) {\\n    var listeners = plugNames.map(function (name) {\\n      return \\\"closeme.zf.\\\".concat(name);\\n    }).join(' ');\\n    jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off(listeners).on(listeners, Triggers.Listeners.Global.closeMeListener);\\n  }\\n};\\n\\nfunction debounceGlobalListener(debounce, trigger, listener) {\\n  var timer,\\n      args = Array.prototype.slice.call(arguments, 3);\\n  jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off(trigger).on(trigger, function (e) {\\n    if (timer) {\\n      clearTimeout(timer);\\n    }\\n\\n    timer = setTimeout(function () {\\n      listener.apply(null, args);\\n    }, debounce || 10); //default time to emit scroll event\\n  });\\n}\\n\\nTriggers.Initializers.addResizeListener = function (debounce) {\\n  var $nodes = jquery__WEBPACK_IMPORTED_MODULE_0___default()('[data-resize]');\\n\\n  if ($nodes.length) {\\n    debounceGlobalListener(debounce, 'resize.zf.trigger', Triggers.Listeners.Global.resizeListener, $nodes);\\n  }\\n};\\n\\nTriggers.Initializers.addScrollListener = function (debounce) {\\n  var $nodes = jquery__WEBPACK_IMPORTED_MODULE_0___default()('[data-scroll]');\\n\\n  if ($nodes.length) {\\n    debounceGlobalListener(debounce, 'scroll.zf.trigger', Triggers.Listeners.Global.scrollListener, $nodes);\\n  }\\n};\\n\\nTriggers.Initializers.addMutationEventsListener = function ($elem) {\\n  if (!MutationObserver) {\\n    return false;\\n  }\\n\\n  var $nodes = $elem.find('[data-resize], [data-scroll], [data-mutate]'); //element callback\\n\\n  var listeningElementsMutation = function listeningElementsMutation(mutationRecordsList) {\\n    var $target = jquery__WEBPACK_IMPORTED_MODULE_0___default()(mutationRecordsList[0].target); //trigger the event handler for the element depending on type\\n\\n    switch (mutationRecordsList[0].type) {\\n      case \\\"attributes\\\":\\n        if ($target.attr(\\\"data-events\\\") === \\\"scroll\\\" && mutationRecordsList[0].attributeName === \\\"data-events\\\") {\\n          $target.triggerHandler('scrollme.zf.trigger', [$target, window.pageYOffset]);\\n        }\\n\\n        if ($target.attr(\\\"data-events\\\") === \\\"resize\\\" && mutationRecordsList[0].attributeName === \\\"data-events\\\") {\\n          $target.triggerHandler('resizeme.zf.trigger', [$target]);\\n        }\\n\\n        if (mutationRecordsList[0].attributeName === \\\"style\\\") {\\n          $target.closest(\\\"[data-mutate]\\\").attr(\\\"data-events\\\", \\\"mutate\\\");\\n          $target.closest(\\\"[data-mutate]\\\").triggerHandler('mutateme.zf.trigger', [$target.closest(\\\"[data-mutate]\\\")]);\\n        }\\n\\n        break;\\n\\n      case \\\"childList\\\":\\n        $target.closest(\\\"[data-mutate]\\\").attr(\\\"data-events\\\", \\\"mutate\\\");\\n        $target.closest(\\\"[data-mutate]\\\").triggerHandler('mutateme.zf.trigger', [$target.closest(\\\"[data-mutate]\\\")]);\\n        break;\\n\\n      default:\\n        return false;\\n      //nothing\\n    }\\n  };\\n\\n  if ($nodes.length) {\\n    //for each element that needs to listen for resizing, scrolling, or mutation add a single observer\\n    for (var i = 0; i <= $nodes.length - 1; i++) {\\n      var elementObserver = new MutationObserver(listeningElementsMutation);\\n      elementObserver.observe($nodes[i], {\\n        attributes: true,\\n        childList: true,\\n        characterData: false,\\n        subtree: true,\\n        attributeFilter: [\\\"data-events\\\", \\\"style\\\"]\\n      });\\n    }\\n  }\\n};\\n\\nTriggers.Initializers.addSimpleListeners = function () {\\n  var $document = jquery__WEBPACK_IMPORTED_MODULE_0___default()(document);\\n  Triggers.Initializers.addOpenListener($document);\\n  Triggers.Initializers.addCloseListener($document);\\n  Triggers.Initializers.addToggleListener($document);\\n  Triggers.Initializers.addCloseableListener($document);\\n  Triggers.Initializers.addToggleFocusListener($document);\\n};\\n\\nTriggers.Initializers.addGlobalListeners = function () {\\n  var $document = jquery__WEBPACK_IMPORTED_MODULE_0___default()(document);\\n  Triggers.Initializers.addMutationEventsListener($document);\\n  Triggers.Initializers.addResizeListener();\\n  Triggers.Initializers.addScrollListener();\\n  Triggers.Initializers.addClosemeListener();\\n};\\n\\nTriggers.init = function ($, Foundation) {\\n  Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\\\"onLoad\\\"])($(window), function () {\\n    if ($.triggersInitialized !== true) {\\n      Triggers.Initializers.addSimpleListeners();\\n      Triggers.Initializers.addGlobalListeners();\\n      $.triggersInitialized = true;\\n    }\\n  });\\n\\n  if (Foundation) {\\n    Foundation.Triggers = Triggers; // Legacy included to be backwards compatible for now.\\n\\n    Foundation.IHearYou = Triggers.Initializers.addGlobalListeners;\\n  }\\n};\\n\\n\\n\\n//# sourceURL=webpack:///./js/foundation.util.triggers.js?\");\n    }, jquery: function jquery(module, exports) {\n      eval(\"module.exports = __WEBPACK_EXTERNAL_MODULE_jquery__;\\n\\n//# sourceURL=webpack:///external_%7B%22root%22:%5B%22jQuery%22%5D,%22amd%22:%22jquery%22,%22commonjs%22:%22jquery%22,%22commonjs2%22:%22jquery%22%7D?\");\n    } });\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(1)(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvdmVuZG9yL2ZvdW5kYXRpb24ubWluLmpzPzZkODQiXSwibmFtZXMiOlsibiIsImUiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsIndpbmRvdyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfanF1ZXJ5X18iLCJ0IiwibyIsImkiLCJsIiwiY2FsbCIsIm0iLCJjIiwiZCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsInIiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInZhbHVlIiwiX19lc01vZHVsZSIsImNyZWF0ZSIsImJpbmQiLCJkZWZhdWx0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJwIiwicyIsIl9fd2VicGFja19leHBvcnRzX18iLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwiZXZhbCIsImpxdWVyeSJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLENBQUMsVUFBU0EsQ0FBVCxFQUFXQyxDQUFYLEVBQWE7QUFBQyxNQUFHLDBDQUFpQkMsT0FBakIsTUFBMEIsMENBQWlCQyxNQUFqQixFQUE3QixFQUFxREEsT0FBT0QsT0FBUCxHQUFlRCxFQUFFRyxtQkFBT0EsQ0FBQyxDQUFSLENBQUYsQ0FBZixDQUFyRCxLQUE4RixJQUFHLElBQUgsRUFBeUNDLGlDQUFPLENBQUMsc0JBQUQsQ0FBUCxvQ0FBa0JKLENBQWxCO0FBQUE7QUFBQTtBQUFBLHFHQUF6QyxLQUFrRSxhQUE2SDtBQUFDLENBQTVTLENBQTZTSyxNQUE3UyxFQUFvVCxVQUFTQyxrQ0FBVCxFQUE0QztBQUFDLFNBQU8sVUFBU0MsQ0FBVCxFQUFXO0FBQUMsUUFBSUMsSUFBRSxFQUFOLENBQVMsU0FBU0MsQ0FBVCxDQUFXVixDQUFYLEVBQWE7QUFBQyxVQUFHUyxFQUFFVCxDQUFGLENBQUgsRUFBUSxPQUFPUyxFQUFFVCxDQUFGLEVBQUtFLE9BQVosQ0FBb0IsSUFBSUQsSUFBRVEsRUFBRVQsQ0FBRixJQUFLLEVBQUNVLEdBQUVWLENBQUgsRUFBS1csR0FBRSxDQUFDLENBQVIsRUFBVVQsU0FBUSxFQUFsQixFQUFYLENBQWlDLE9BQU9NLEVBQUVSLENBQUYsRUFBS1ksSUFBTCxDQUFVWCxFQUFFQyxPQUFaLEVBQW9CRCxDQUFwQixFQUFzQkEsRUFBRUMsT0FBeEIsRUFBZ0NRLENBQWhDLEdBQW1DVCxFQUFFVSxDQUFGLEdBQUksQ0FBQyxDQUF4QyxFQUEwQ1YsRUFBRUMsT0FBbkQ7QUFBMkQsWUFBT1EsRUFBRUcsQ0FBRixHQUFJTCxDQUFKLEVBQU1FLEVBQUVJLENBQUYsR0FBSUwsQ0FBVixFQUFZQyxFQUFFSyxDQUFGLEdBQUksVUFBU2YsQ0FBVCxFQUFXQyxDQUFYLEVBQWFPLENBQWIsRUFBZTtBQUFDRSxRQUFFRCxDQUFGLENBQUlULENBQUosRUFBTUMsQ0FBTixLQUFVZSxPQUFPQyxjQUFQLENBQXNCakIsQ0FBdEIsRUFBd0JDLENBQXhCLEVBQTBCLEVBQUNpQixZQUFXLENBQUMsQ0FBYixFQUFlQyxLQUFJWCxDQUFuQixFQUExQixDQUFWO0FBQTJELEtBQTNGLEVBQTRGRSxFQUFFVSxDQUFGLEdBQUksVUFBU3BCLENBQVQsRUFBVztBQUFDLHFCQUFhLE9BQU9xQixNQUFwQixJQUE0QkEsT0FBT0MsV0FBbkMsSUFBZ0ROLE9BQU9DLGNBQVAsQ0FBc0JqQixDQUF0QixFQUF3QnFCLE9BQU9DLFdBQS9CLEVBQTJDLEVBQUNDLE9BQU0sUUFBUCxFQUEzQyxDQUFoRCxFQUE2R1AsT0FBT0MsY0FBUCxDQUFzQmpCLENBQXRCLEVBQXdCLFlBQXhCLEVBQXFDLEVBQUN1QixPQUFNLENBQUMsQ0FBUixFQUFyQyxDQUE3RztBQUE4SixLQUExUSxFQUEyUWIsRUFBRUYsQ0FBRixHQUFJLFVBQVNQLENBQVQsRUFBV0QsQ0FBWCxFQUFhO0FBQUMsVUFBRyxJQUFFQSxDQUFGLEtBQU1DLElBQUVTLEVBQUVULENBQUYsQ0FBUixHQUFjLElBQUVELENBQW5CLEVBQXFCLE9BQU9DLENBQVAsQ0FBUyxJQUFHLElBQUVELENBQUYsSUFBSyxvQkFBaUJDLENBQWpCLHlDQUFpQkEsQ0FBakIsRUFBTCxJQUF5QkEsQ0FBekIsSUFBNEJBLEVBQUV1QixVQUFqQyxFQUE0QyxPQUFPdkIsQ0FBUCxDQUFTLElBQUlPLElBQUVRLE9BQU9TLE1BQVAsQ0FBYyxJQUFkLENBQU4sQ0FBMEIsSUFBR2YsRUFBRVUsQ0FBRixDQUFJWixDQUFKLEdBQU9RLE9BQU9DLGNBQVAsQ0FBc0JULENBQXRCLEVBQXdCLFNBQXhCLEVBQWtDLEVBQUNVLFlBQVcsQ0FBQyxDQUFiLEVBQWVLLE9BQU10QixDQUFyQixFQUFsQyxDQUFQLEVBQWtFLElBQUVELENBQUYsSUFBSyxZQUFVLE9BQU9DLENBQTNGLEVBQTZGLEtBQUksSUFBSVEsQ0FBUixJQUFhUixDQUFiO0FBQWVTLFVBQUVLLENBQUYsQ0FBSVAsQ0FBSixFQUFNQyxDQUFOLEVBQVEsVUFBU1QsQ0FBVCxFQUFXO0FBQUMsaUJBQU9DLEVBQUVELENBQUYsQ0FBUDtBQUFZLFNBQXhCLENBQXlCMEIsSUFBekIsQ0FBOEIsSUFBOUIsRUFBbUNqQixDQUFuQyxDQUFSO0FBQWYsT0FBOEQsT0FBT0QsQ0FBUDtBQUFTLEtBQTlpQixFQUEraUJFLEVBQUVWLENBQUYsR0FBSSxVQUFTQSxDQUFULEVBQVc7QUFBQyxVQUFJQyxJQUFFRCxLQUFHQSxFQUFFd0IsVUFBTCxHQUFnQixZQUFVO0FBQUMsZUFBT3hCLEVBQUUyQixPQUFUO0FBQWlCLE9BQTVDLEdBQTZDLFlBQVU7QUFBQyxlQUFPM0IsQ0FBUDtBQUFTLE9BQXZFLENBQXdFLE9BQU9VLEVBQUVLLENBQUYsQ0FBSWQsQ0FBSixFQUFNLEdBQU4sRUFBVUEsQ0FBVixHQUFhQSxDQUFwQjtBQUFzQixLQUE3cEIsRUFBOHBCUyxFQUFFRCxDQUFGLEdBQUksVUFBU1QsQ0FBVCxFQUFXQyxDQUFYLEVBQWE7QUFBQyxhQUFPZSxPQUFPWSxTQUFQLENBQWlCQyxjQUFqQixDQUFnQ2pCLElBQWhDLENBQXFDWixDQUFyQyxFQUF1Q0MsQ0FBdkMsQ0FBUDtBQUFpRCxLQUFqdUIsRUFBa3VCUyxFQUFFb0IsQ0FBRixHQUFJLEVBQXR1QixFQUF5dUJwQixFQUFFQSxFQUFFcUIsQ0FBRixHQUFJLDBGQUFOLENBQWh2QjtBQUFrMUIsR0FBNytCLENBQTgrQixFQUFDLDRGQUEyRix1RUFBUzVCLE1BQVQsRUFBZ0I2QixtQkFBaEIsRUFBb0NDLG1CQUFwQyxFQUF3RDtBQUFDO0FBQWFDLFdBQUssKzZjQUFMO0FBQXM3YyxLQUF4bGQsRUFBeWxkLDRCQUEyQiw2QkFBUy9CLE1BQVQsRUFBZ0I2QixtQkFBaEIsRUFBb0NDLG1CQUFwQyxFQUF3RDtBQUFDO0FBQWFDLFdBQUssMDc1QkFBTDtBQUFpODVCLEtBQTNuM0MsRUFBNG4zQyxnQ0FBK0IsaUNBQVMvQixNQUFULEVBQWdCNkIsbUJBQWhCLEVBQW9DQyxtQkFBcEMsRUFBd0Q7QUFBQztBQUFhQyxXQUFLLCs0Z0JBQUw7QUFBczVnQixLQUF2bjRELEVBQXduNEQsb0NBQW1DLHFDQUFTL0IsTUFBVCxFQUFnQjZCLG1CQUFoQixFQUFvQ0MsbUJBQXBDLEVBQXdEO0FBQUM7QUFBYUMsV0FBSywwaWZBQUw7QUFBaWpmLEtBQWx4M0UsRUFBbXgzRSwyQkFBMEIsNEJBQVMvQixNQUFULEVBQWdCNkIsbUJBQWhCLEVBQW9DQyxtQkFBcEMsRUFBd0Q7QUFBQztBQUFhQyxXQUFLLHVsYkFBTDtBQUE4bGIsS0FBajl5RixFQUFrOXlGLGtDQUFpQyxrQ0FBUy9CLE1BQVQsRUFBZ0I2QixtQkFBaEIsRUFBb0NDLG1CQUFwQyxFQUF3RDtBQUFDO0FBQWFDLFdBQUssc25HQUFMO0FBQTZuRyxLQUF0cjVGLEVBQXVyNUYsaUNBQWdDLGlDQUFTL0IsTUFBVCxFQUFnQjZCLG1CQUFoQixFQUFvQ0MsbUJBQXBDLEVBQXdEO0FBQUM7QUFBYUMsV0FBSywwb05BQUw7QUFBaXBOLEtBQTk2bUcsRUFBKzZtRyxnQ0FBK0IsaUNBQVMvQixNQUFULEVBQWdCNkIsbUJBQWhCLEVBQW9DQyxtQkFBcEMsRUFBd0Q7QUFBQztBQUFhQyxXQUFLLGs5M0JBQUw7QUFBeTkzQixLQUE3KytILEVBQTgrK0gsK0JBQThCLGdDQUFTL0IsTUFBVCxFQUFnQjZCLG1CQUFoQixFQUFvQ0MsbUJBQXBDLEVBQXdEO0FBQUM7QUFBYUMsV0FBSywyOGpCQUFMO0FBQWs5akIsS0FBcGlqSixFQUFxaWpKLG1DQUFrQyxvQ0FBUy9CLE1BQVQsRUFBZ0I2QixtQkFBaEIsRUFBb0NDLG1CQUFwQyxFQUF3RDtBQUFDO0FBQWFDLFdBQUssZ3VvQkFBTDtBQUF1dW9CLEtBQXAzckssRUFBcTNySyxnQ0FBK0IsaUNBQVMvQixNQUFULEVBQWdCNkIsbUJBQWhCLEVBQW9DQyxtQkFBcEMsRUFBd0Q7QUFBQztBQUFhQyxXQUFLLDhzZEFBTDtBQUFxdGQsS0FBL3FwTCxFQUFncnBMLGtDQUFpQyxtQ0FBUy9CLE1BQVQsRUFBZ0I2QixtQkFBaEIsRUFBb0NDLG1CQUFwQyxFQUF3RDtBQUFDO0FBQWFDLFdBQUssMDlUQUFMO0FBQWkrVCxLQUF4djlMLEVBQXl2OUwsK0JBQThCLGdDQUFTL0IsTUFBVCxFQUFnQjZCLG1CQUFoQixFQUFvQ0MsbUJBQXBDLEVBQXdEO0FBQUM7QUFBYUMsV0FBSyx5MFpBQUw7QUFBZzFaLEtBQTdxM00sRUFBOHEzTSxnQ0FBK0IsaUNBQVMvQixNQUFULEVBQWdCNkIsbUJBQWhCLEVBQW9DQyxtQkFBcEMsRUFBd0Q7QUFBQztBQUFhQyxXQUFLLCs0d0JBQUw7QUFBczV3QixLQUF6cW9PLEVBQTBxb08sNEJBQTJCLDZCQUFTL0IsTUFBVCxFQUFnQjZCLG1CQUFoQixFQUFvQ0MsbUJBQXBDLEVBQXdEO0FBQUM7QUFBYUMsV0FBSyxxa3JCQUFMO0FBQTRrckIsS0FBdjF6UCxFQUF3MXpQLG1DQUFrQyxvQ0FBUy9CLE1BQVQsRUFBZ0I2QixtQkFBaEIsRUFBb0NDLG1CQUFwQyxFQUF3RDtBQUFDO0FBQWFDLFdBQUssbTdWQUFMO0FBQTA3VixLQUExM3BRLEVBQTIzcFEsOENBQTZDLCtDQUFTL0IsTUFBVCxFQUFnQjZCLG1CQUFoQixFQUFvQ0MsbUJBQXBDLEVBQXdEO0FBQUM7QUFBYUMsV0FBSywrb2NBQUw7QUFBc3BjLEtBQXBvbVIsRUFBcW9tUixxQ0FBb0Msc0NBQVMvQixNQUFULEVBQWdCNkIsbUJBQWhCLEVBQW9DQyxtQkFBcEMsRUFBd0Q7QUFBQztBQUFhQyxXQUFLLDg0UkFBTDtBQUFxNVIsS0FBcG80UixFQUFxbzRSLHVDQUFzQyx3Q0FBUy9CLE1BQVQsRUFBZ0I2QixtQkFBaEIsRUFBb0NDLG1CQUFwQyxFQUF3RDtBQUFDO0FBQWFDLFdBQUssOHBSQUFMO0FBQXFxUixLQUF0NXBTLEVBQXU1cFMsNkJBQTRCLDhCQUFTL0IsTUFBVCxFQUFnQjZCLG1CQUFoQixFQUFvQ0MsbUJBQXBDLEVBQXdEO0FBQUM7QUFBYUMsV0FBSyw0bjBCQUFMO0FBQW1vMEIsS0FBNW4rVCxFQUE2bitULDZCQUE0Qiw4QkFBUy9CLE1BQVQsRUFBZ0I2QixtQkFBaEIsRUFBb0NDLG1CQUFwQyxFQUF3RDtBQUFDO0FBQWFDLFdBQUssaXM4QkFBTDtBQUF3czhCLEtBQXY2NlYsRUFBdzY2VixtQ0FBa0Msb0NBQVMvQixNQUFULEVBQWdCNkIsbUJBQWhCLEVBQW9DQyxtQkFBcEMsRUFBd0Q7QUFBQztBQUFhQyxXQUFLLDBuUEFBTDtBQUFpb1AsS0FBanBxVyxFQUFrcHFXLDZCQUE0Qiw4QkFBUy9CLE1BQVQsRUFBZ0I2QixtQkFBaEIsRUFBb0NDLG1CQUFwQyxFQUF3RDtBQUFDO0FBQWFDLFdBQUsseTRwQkFBTDtBQUFnNXBCLEtBQXBvMFgsRUFBcW8wWCwyQkFBMEIsNEJBQVMvQixNQUFULEVBQWdCNkIsbUJBQWhCLEVBQW9DQyxtQkFBcEMsRUFBd0Q7QUFBQztBQUFhQyxXQUFLLDI4b0JBQUw7QUFBazlvQixLQUF2cjlZLEVBQXdyOVksOEJBQTZCLCtCQUFTL0IsTUFBVCxFQUFnQjZCLG1CQUFoQixFQUFvQ0MsbUJBQXBDLEVBQXdEO0FBQUM7QUFBYUMsV0FBSyxzalNBQUw7QUFBNmpTLEtBQXgxdlosRUFBeTF2Wiw4QkFBNkIsK0JBQVMvQixNQUFULEVBQWdCNkIsbUJBQWhCLEVBQW9DQyxtQkFBcEMsRUFBd0Q7QUFBQztBQUFhQyxXQUFLLDg1akJBQUw7QUFBcTZqQixLQUFqMnphLEVBQWsyemEsK0JBQThCLCtCQUFTL0IsTUFBVCxFQUFnQjZCLG1CQUFoQixFQUFvQ0MsbUJBQXBDLEVBQXdEO0FBQUM7QUFBYUMsV0FBSyx1dVNBQUw7QUFBOHVTLEtBQXBybWIsRUFBcXJtYix1Q0FBc0MsdUNBQVMvQixNQUFULEVBQWdCNkIsbUJBQWhCLEVBQW9DQyxtQkFBcEMsRUFBd0Q7QUFBQztBQUFhQyxXQUFLLHV3REFBTDtBQUE4d0QsS0FBL2lxYixFQUFnanFiLG9DQUFtQyxvQ0FBUy9CLE1BQVQsRUFBZ0I2QixtQkFBaEIsRUFBb0NDLG1CQUFwQyxFQUF3RDtBQUFDO0FBQWFDLFdBQUssa3BNQUFMO0FBQXlwTSxLQUFsejJiLEVBQW16MmIsc0NBQXFDLHNDQUFTL0IsTUFBVCxFQUFnQjZCLG1CQUFoQixFQUFvQ0MsbUJBQXBDLEVBQXdEO0FBQUM7QUFBYUMsV0FBSyxpcVBBQUw7QUFBd3FQLEtBQXRrbWMsRUFBdWttYyxrQ0FBaUMsa0NBQVMvQixNQUFULEVBQWdCNkIsbUJBQWhCLEVBQW9DQyxtQkFBcEMsRUFBd0Q7QUFBQztBQUFhQyxXQUFLLDA1R0FBTDtBQUFpNkcsS0FBL2t0YyxFQUFnbHRjLGdDQUErQixnQ0FBUy9CLE1BQVQsRUFBZ0I2QixtQkFBaEIsRUFBb0NDLG1CQUFwQyxFQUF3RDtBQUFDO0FBQWFDLFdBQUssZ3dGQUFMO0FBQXV3RixLQUE1N3ljLEVBQTY3eWMsaUNBQWdDLGlDQUFTL0IsTUFBVCxFQUFnQjZCLG1CQUFoQixFQUFvQ0MsbUJBQXBDLEVBQXdEO0FBQUM7QUFBYUMsV0FBSyxteERBQUw7QUFBMHhELEtBQTd6MmMsRUFBOHoyYyxpQ0FBZ0MsaUNBQVMvQixNQUFULEVBQWdCNkIsbUJBQWhCLEVBQW9DQyxtQkFBcEMsRUFBd0Q7QUFBQztBQUFhQyxXQUFLLCtnTkFBTDtBQUFzaE4sS0FBMTdqZCxFQUEyN2pkLG9DQUFtQyxvQ0FBUy9CLE1BQVQsRUFBZ0I2QixtQkFBaEIsRUFBb0NDLG1CQUFwQyxFQUF3RDtBQUFDO0FBQWFDLFdBQUssdW1YQUFMO0FBQThtWCxLQUFscDdkLEVBQW1wN2RDLFFBQU8sZ0JBQVNoQyxNQUFULEVBQWdCRCxPQUFoQixFQUF3QjtBQUFDZ0MsV0FBSyxnTkFBTDtBQUF1TixLQUExNDdkLEVBQTkrQixDQUFQO0FBQWs0OWQsQ0FBbnUrZCxDQUFELEMiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiFmdW5jdGlvbihuLGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPWUocmVxdWlyZShcImpxdWVyeVwiKSk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtcImpxdWVyeVwiXSxlKTtlbHNle3ZhciB0PVwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2UocmVxdWlyZShcImpxdWVyeVwiKSk6ZShuLmpRdWVyeSk7Zm9yKHZhciBvIGluIHQpKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHM6bilbb109dFtvXX19KHdpbmRvdyxmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2pxdWVyeV9fKXtyZXR1cm4gZnVuY3Rpb24odCl7dmFyIG89e307ZnVuY3Rpb24gaShuKXtpZihvW25dKXJldHVybiBvW25dLmV4cG9ydHM7dmFyIGU9b1tuXT17aTpuLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIHRbbl0uY2FsbChlLmV4cG9ydHMsZSxlLmV4cG9ydHMsaSksZS5sPSEwLGUuZXhwb3J0c31yZXR1cm4gaS5tPXQsaS5jPW8saS5kPWZ1bmN0aW9uKG4sZSx0KXtpLm8obixlKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sZSx7ZW51bWVyYWJsZTohMCxnZXQ6dH0pfSxpLnI9ZnVuY3Rpb24obil7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkobixTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0saS50PWZ1bmN0aW9uKGUsbil7aWYoMSZuJiYoZT1pKGUpKSw4Jm4pcmV0dXJuIGU7aWYoNCZuJiZcIm9iamVjdFwiPT10eXBlb2YgZSYmZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciB0PU9iamVjdC5jcmVhdGUobnVsbCk7aWYoaS5yKHQpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KSwyJm4mJlwic3RyaW5nXCIhPXR5cGVvZiBlKWZvcih2YXIgbyBpbiBlKWkuZCh0LG8sZnVuY3Rpb24obil7cmV0dXJuIGVbbl19LmJpbmQobnVsbCxvKSk7cmV0dXJuIHR9LGkubj1mdW5jdGlvbihuKXt2YXIgZT1uJiZuLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gbi5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBufTtyZXR1cm4gaS5kKGUsXCJhXCIsZSksZX0saS5vPWZ1bmN0aW9uKG4sZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLGUpfSxpLnA9XCJcIixpKGkucz1cIi4uLy4uLy4uLy4uLy4uLy4uL3RtcC90bXAuNi41LjEuNTEzNzQyNzRlZGVkMDgxMGJhYWUyNzVmNDg4Yjc3MGEvanMvdmVuZG9yL2ZvdW5kYXRpb24uanNcIil9KHtcIi4uLy4uLy4uLy4uLy4uLy4uL3RtcC90bXAuNi41LjEuNTEzNzQyNzRlZGVkMDgxMGJhYWUyNzVmNDg4Yjc3MGEvanMvdmVuZG9yL2ZvdW5kYXRpb24uanNcIjpmdW5jdGlvbihtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKCdfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganF1ZXJ5ICovIFwianF1ZXJ5XCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX2RlcGxveWVyX3NpdGVzX25vZGVfZm91bmRhdGlvbl9jdXN0b21pemVyX25vZGVfZm91bmRhdGlvbl9jdXN0b21pemVyX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9jb3JlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2pzL2ZvdW5kYXRpb24uY29yZSAqLyBcIi4vanMvZm91bmRhdGlvbi5jb3JlLmpzXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2pzL2ZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5ICovIFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeS5qc1wiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX3V0aWxfdHJpZ2dlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vanMvZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzICovIFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnMuanNcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX2RlcGxveWVyX3NpdGVzX25vZGVfZm91bmRhdGlvbl9jdXN0b21pemVyX25vZGVfZm91bmRhdGlvbl9jdXN0b21pemVyX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9zbGlkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vanMvZm91bmRhdGlvbi5zbGlkZXIgKi8gXCIuL2pzL2ZvdW5kYXRpb24uc2xpZGVyLmpzXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fZHJpbGxkb3duX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2pzL2ZvdW5kYXRpb24uZHJpbGxkb3duICovIFwiLi9qcy9mb3VuZGF0aW9uLmRyaWxsZG93bi5qc1wiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX2FjY29yZGlvbk1lbnVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vanMvZm91bmRhdGlvbi5hY2NvcmRpb25NZW51ICovIFwiLi9qcy9mb3VuZGF0aW9uLmFjY29yZGlvbk1lbnUuanNcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX2RlcGxveWVyX3NpdGVzX25vZGVfZm91bmRhdGlvbl9jdXN0b21pemVyX25vZGVfZm91bmRhdGlvbl9jdXN0b21pemVyX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9kcm9wZG93bk1lbnVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vanMvZm91bmRhdGlvbi5kcm9wZG93bk1lbnUgKi8gXCIuL2pzL2ZvdW5kYXRpb24uZHJvcGRvd25NZW51LmpzXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fbWFnZWxsYW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vanMvZm91bmRhdGlvbi5tYWdlbGxhbiAqLyBcIi4vanMvZm91bmRhdGlvbi5tYWdlbGxhbi5qc1wiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX3Jlc3BvbnNpdmVNZW51X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2pzL2ZvdW5kYXRpb24ucmVzcG9uc2l2ZU1lbnUgKi8gXCIuL2pzL2ZvdW5kYXRpb24ucmVzcG9uc2l2ZU1lbnUuanNcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX2RlcGxveWVyX3NpdGVzX25vZGVfZm91bmRhdGlvbl9jdXN0b21pemVyX25vZGVfZm91bmRhdGlvbl9jdXN0b21pemVyX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9hY2NvcmRpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2pzL2ZvdW5kYXRpb24uYWNjb3JkaW9uICovIFwiLi9qcy9mb3VuZGF0aW9uLmFjY29yZGlvbi5qc1wiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX2Ryb3Bkb3duX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9qcy9mb3VuZGF0aW9uLmRyb3Bkb3duICovIFwiLi9qcy9mb3VuZGF0aW9uLmRyb3Bkb3duLmpzXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fb2ZmY2FudmFzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9qcy9mb3VuZGF0aW9uLm9mZmNhbnZhcyAqLyBcIi4vanMvZm91bmRhdGlvbi5vZmZjYW52YXMuanNcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX2RlcGxveWVyX3NpdGVzX25vZGVfZm91bmRhdGlvbl9jdXN0b21pemVyX25vZGVfZm91bmRhdGlvbl9jdXN0b21pemVyX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl90YWJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9qcy9mb3VuZGF0aW9uLnRhYnMgKi8gXCIuL2pzL2ZvdW5kYXRpb24udGFicy5qc1wiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX3JldmVhbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vanMvZm91bmRhdGlvbi5yZXZlYWwgKi8gXCIuL2pzL2ZvdW5kYXRpb24ucmV2ZWFsLmpzXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fcmVzcG9uc2l2ZUFjY29yZGlvblRhYnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE1X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2pzL2ZvdW5kYXRpb24ucmVzcG9uc2l2ZUFjY29yZGlvblRhYnMgKi8gXCIuL2pzL2ZvdW5kYXRpb24ucmVzcG9uc2l2ZUFjY29yZGlvblRhYnMuanNcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX2RlcGxveWVyX3NpdGVzX25vZGVfZm91bmRhdGlvbl9jdXN0b21pemVyX25vZGVfZm91bmRhdGlvbl9jdXN0b21pemVyX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl90b29sdGlwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9qcy9mb3VuZGF0aW9uLnRvb2x0aXAgKi8gXCIuL2pzL2ZvdW5kYXRpb24udG9vbHRpcC5qc1wiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX29yYml0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9qcy9mb3VuZGF0aW9uLm9yYml0ICovIFwiLi9qcy9mb3VuZGF0aW9uLm9yYml0LmpzXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fc3RpY2t5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9qcy9mb3VuZGF0aW9uLnN0aWNreSAqLyBcIi4vanMvZm91bmRhdGlvbi5zdGlja3kuanNcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX2RlcGxveWVyX3NpdGVzX25vZGVfZm91bmRhdGlvbl9jdXN0b21pemVyX25vZGVfZm91bmRhdGlvbl9jdXN0b21pemVyX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9pbnRlcmNoYW5nZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vanMvZm91bmRhdGlvbi5pbnRlcmNoYW5nZSAqLyBcIi4vanMvZm91bmRhdGlvbi5pbnRlcmNoYW5nZS5qc1wiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX3Jlc3BvbnNpdmVUb2dnbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzIwX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2pzL2ZvdW5kYXRpb24ucmVzcG9uc2l2ZVRvZ2dsZSAqLyBcIi4vanMvZm91bmRhdGlvbi5yZXNwb25zaXZlVG9nZ2xlLmpzXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fdG9nZ2xlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vanMvZm91bmRhdGlvbi50b2dnbGVyICovIFwiLi9qcy9mb3VuZGF0aW9uLnRvZ2dsZXIuanNcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX2RlcGxveWVyX3NpdGVzX25vZGVfZm91bmRhdGlvbl9jdXN0b21pemVyX25vZGVfZm91bmRhdGlvbl9jdXN0b21pemVyX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9hYmlkZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vanMvZm91bmRhdGlvbi5hYmlkZSAqLyBcIi4vanMvZm91bmRhdGlvbi5hYmlkZS5qc1wiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX2VxdWFsaXplcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vanMvZm91bmRhdGlvbi5lcXVhbGl6ZXIgKi8gXCIuL2pzL2ZvdW5kYXRpb24uZXF1YWxpemVyLmpzXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fc21vb3RoU2Nyb2xsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9qcy9mb3VuZGF0aW9uLnNtb290aFNjcm9sbCAqLyBcIi4vanMvZm91bmRhdGlvbi5zbW9vdGhTY3JvbGwuanNcIik7XFxuXFxuXFxuX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX2NvcmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkZvdW5kYXRpb25cIl0uYWRkVG9KcXVlcnkoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hKTtcXG5cXG5faG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRm91bmRhdGlvblwiXS5NZWRpYVF1ZXJ5ID0gX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiTWVkaWFRdWVyeVwiXTtcXG5cXG5faG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fdXRpbF90cmlnZ2Vyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiVHJpZ2dlcnNcIl0uaW5pdChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEsIF9ob21lX2RlcGxveWVyX3NpdGVzX25vZGVfZm91bmRhdGlvbl9jdXN0b21pemVyX25vZGVfZm91bmRhdGlvbl9jdXN0b21pemVyX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9jb3JlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJGb3VuZGF0aW9uXCJdKTtcXG5cXG5faG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRm91bmRhdGlvblwiXS5wbHVnaW4oX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX3NsaWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiU2xpZGVyXCJdLCBcXCdTbGlkZXJcXCcpO1xcblxcbl9ob21lX2RlcGxveWVyX3NpdGVzX25vZGVfZm91bmRhdGlvbl9jdXN0b21pemVyX25vZGVfZm91bmRhdGlvbl9jdXN0b21pemVyX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9jb3JlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJGb3VuZGF0aW9uXCJdLnBsdWdpbihfaG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fZHJpbGxkb3duX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJEcmlsbGRvd25cIl0sIFxcJ0RyaWxsZG93blxcJyk7XFxuXFxuX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX2NvcmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkZvdW5kYXRpb25cIl0ucGx1Z2luKF9ob21lX2RlcGxveWVyX3NpdGVzX25vZGVfZm91bmRhdGlvbl9jdXN0b21pemVyX25vZGVfZm91bmRhdGlvbl9jdXN0b21pemVyX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9hY2NvcmRpb25NZW51X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJBY2NvcmRpb25NZW51XCJdLCBcXCdBY2NvcmRpb25NZW51XFwnKTtcXG5cXG5faG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRm91bmRhdGlvblwiXS5wbHVnaW4oX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX2Ryb3Bkb3duTWVudV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiRHJvcGRvd25NZW51XCJdLCBcXCdEcm9wZG93bk1lbnVcXCcpO1xcblxcbl9ob21lX2RlcGxveWVyX3NpdGVzX25vZGVfZm91bmRhdGlvbl9jdXN0b21pemVyX25vZGVfZm91bmRhdGlvbl9jdXN0b21pemVyX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9jb3JlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJGb3VuZGF0aW9uXCJdLnBsdWdpbihfaG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fbWFnZWxsYW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcIk1hZ2VsbGFuXCJdLCBcXCdNYWdlbGxhblxcJyk7XFxuXFxuX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX2NvcmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkZvdW5kYXRpb25cIl0ucGx1Z2luKF9ob21lX2RlcGxveWVyX3NpdGVzX25vZGVfZm91bmRhdGlvbl9jdXN0b21pemVyX25vZGVfZm91bmRhdGlvbl9jdXN0b21pemVyX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9yZXNwb25zaXZlTWVudV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1wiUmVzcG9uc2l2ZU1lbnVcIl0sIFxcJ1Jlc3BvbnNpdmVNZW51XFwnKTtcXG5cXG5faG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRm91bmRhdGlvblwiXS5wbHVnaW4oX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX2FjY29yZGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1tcIkFjY29yZGlvblwiXSwgXFwnQWNjb3JkaW9uXFwnKTtcXG5cXG5faG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRm91bmRhdGlvblwiXS5wbHVnaW4oX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX2Ryb3Bkb3duX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1wiRHJvcGRvd25cIl0sIFxcJ0Ryb3Bkb3duXFwnKTtcXG5cXG5faG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRm91bmRhdGlvblwiXS5wbHVnaW4oX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX29mZmNhbnZhc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX1tcIk9mZkNhbnZhc1wiXSwgXFwnT2ZmQ2FudmFzXFwnKTtcXG5cXG5faG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRm91bmRhdGlvblwiXS5wbHVnaW4oX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX3RhYnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX19bXCJUYWJzXCJdLCBcXCdUYWJzXFwnKTtcXG5cXG5faG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRm91bmRhdGlvblwiXS5wbHVnaW4oX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX3JldmVhbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTRfX1tcIlJldmVhbFwiXSwgXFwnUmV2ZWFsXFwnKTtcXG5cXG5faG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRm91bmRhdGlvblwiXS5wbHVnaW4oX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX3Jlc3BvbnNpdmVBY2NvcmRpb25UYWJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNV9fW1wiUmVzcG9uc2l2ZUFjY29yZGlvblRhYnNcIl0sIFxcJ1Jlc3BvbnNpdmVBY2NvcmRpb25UYWJzXFwnKTtcXG5cXG5faG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRm91bmRhdGlvblwiXS5wbHVnaW4oX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX3Rvb2x0aXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X19bXCJUb29sdGlwXCJdLCBcXCdUb29sdGlwXFwnKTtcXG5cXG5faG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRm91bmRhdGlvblwiXS5wbHVnaW4oX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX29yYml0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xN19fW1wiT3JiaXRcIl0sIFxcJ09yYml0XFwnKTtcXG5cXG5faG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRm91bmRhdGlvblwiXS5wbHVnaW4oX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX3N0aWNreV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMThfX1tcIlN0aWNreVwiXSwgXFwnU3RpY2t5XFwnKTtcXG5cXG5faG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRm91bmRhdGlvblwiXS5wbHVnaW4oX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX2ludGVyY2hhbmdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xOV9fW1wiSW50ZXJjaGFuZ2VcIl0sIFxcJ0ludGVyY2hhbmdlXFwnKTtcXG5cXG5faG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRm91bmRhdGlvblwiXS5wbHVnaW4oX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX3Jlc3BvbnNpdmVUb2dnbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzIwX19bXCJSZXNwb25zaXZlVG9nZ2xlXCJdLCBcXCdSZXNwb25zaXZlVG9nZ2xlXFwnKTtcXG5cXG5faG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRm91bmRhdGlvblwiXS5wbHVnaW4oX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX3RvZ2dsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzIxX19bXCJUb2dnbGVyXCJdLCBcXCdUb2dnbGVyXFwnKTtcXG5cXG5faG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRm91bmRhdGlvblwiXS5wbHVnaW4oX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX2FiaWRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yMl9fW1wiQWJpZGVcIl0sIFxcJ0FiaWRlXFwnKTtcXG5cXG5faG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRm91bmRhdGlvblwiXS5wbHVnaW4oX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX2VxdWFsaXplcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjNfX1tcIkVxdWFsaXplclwiXSwgXFwnRXF1YWxpemVyXFwnKTtcXG5cXG5faG9tZV9kZXBsb3llcl9zaXRlc19ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9ub2RlX2ZvdW5kYXRpb25fY3VzdG9taXplcl9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRm91bmRhdGlvblwiXS5wbHVnaW4oX2hvbWVfZGVwbG95ZXJfc2l0ZXNfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfbm9kZV9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX3Ntb290aFNjcm9sbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjRfX1tcIlNtb290aFNjcm9sbFwiXSwgXFwnU21vb3RoU2Nyb2xsXFwnKTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vL3RtcC90bXAuNi41LjEuNTEzNzQyNzRlZGVkMDgxMGJhYWUyNzVmNDg4Yjc3MGEvanMvdmVuZG9yL2ZvdW5kYXRpb24uanM/Jyl9LFwiLi9qcy9mb3VuZGF0aW9uLmFiaWRlLmpzXCI6ZnVuY3Rpb24obW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJBYmlkZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQWJpZGU7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGpxdWVyeSAqLyBcXFwianF1ZXJ5XFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnBsdWdpbiAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUucGx1Z2luLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnV0aWxzICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS51dGlscy5qc1xcXCIpO1xcblxcblxcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXFxcImZ1bmN0aW9uXFxcIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cXG5cXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXFxcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFxcXCIpOyB9IHJldHVybiBzZWxmOyB9XFxuXFxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblxcXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cXG5cXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxcblxcblxcblxcblxcbi8qKlxcbiAqIEFiaWRlIG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uYWJpZGVcXG4gKi9cXG5cXG52YXIgQWJpZGUgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoX1BsdWdpbikge1xcbiAgX2luaGVyaXRzKEFiaWRlLCBfUGx1Z2luKTtcXG5cXG4gIGZ1bmN0aW9uIEFiaWRlKCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJpZGUpO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFiaWRlKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhBYmlkZSwgW3tcXG4gICAga2V5OiBcXFwiX3NldHVwXFxcIixcXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgQWJpZGUuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAbmFtZSBBYmlkZVxcbiAgICAgKiBAZmlyZXMgQWJpZGUjaW5pdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYWRkIHRoZSB0cmlnZ2VyIHRvLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQpIHtcXG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XFxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XFxuICAgICAgdGhpcy5vcHRpb25zID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCh0cnVlLCB7fSwgQWJpZGUuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdBYmlkZSc7IC8vIGllOSBiYWNrIGNvbXBhdFxcblxcbiAgICAgIHRoaXMuX2luaXQoKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIEFiaWRlIHBsdWdpbiBhbmQgY2FsbHMgZnVuY3Rpb25zIHRvIGdldCBBYmlkZSBmdW5jdGlvbmluZyBvbiBsb2FkLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2luaXRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy4kaW5wdXRzID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLm1lcmdlKCAvLyBDb25zaWRlciBhcyBpbnB1dCB0byB2YWxpZGF0ZTpcXG4gICAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ2lucHV0Jykubm90KCdbdHlwZT1zdWJtaXRdJyksIC8vICogYWxsIGlucHV0IGZpZWxkcyBleHBlY3Qgc3VibWl0XFxuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCd0ZXh0YXJlYSwgc2VsZWN0JykgLy8gKiBhbGwgdGV4dGFyZWFzIGFuZCBzZWxlY3QgZmllbGRzXFxuICAgICAgKTtcXG4gICAgICB2YXIgJGdsb2JhbEVycm9ycyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtYWJpZGUtZXJyb3JdJyk7IC8vIEFkZCBhMTF5IGF0dHJpYnV0ZXMgdG8gYWxsIGZpZWxkc1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYTExeUF0dHJpYnV0ZXMpIHtcXG4gICAgICAgIHRoaXMuJGlucHV0cy5lYWNoKGZ1bmN0aW9uIChpLCBpbnB1dCkge1xcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLmFkZEExMXlBdHRyaWJ1dGVzKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShpbnB1dCkpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICAkZ2xvYmFsRXJyb3JzLmVhY2goZnVuY3Rpb24gKGksIGVycm9yKSB7XFxuICAgICAgICAgIHJldHVybiBfdGhpczIuYWRkR2xvYmFsRXJyb3JBMTF5QXR0cmlidXRlcyhqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZXJyb3IpKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9ldmVudHMoKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgZXZlbnRzIGZvciBBYmlkZS5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9ldmVudHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcXG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZignLmFiaWRlJykub24oJ3Jlc2V0LnpmLmFiaWRlJywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgX3RoaXMzLnJlc2V0Rm9ybSgpO1xcbiAgICAgIH0pLm9uKCdzdWJtaXQuemYuYWJpZGUnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gX3RoaXMzLnZhbGlkYXRlRm9ybSgpO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudmFsaWRhdGVPbiA9PT0gJ2ZpZWxkQ2hhbmdlJykge1xcbiAgICAgICAgdGhpcy4kaW5wdXRzLm9mZignY2hhbmdlLnpmLmFiaWRlJykub24oJ2NoYW5nZS56Zi5hYmlkZScsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIF90aGlzMy52YWxpZGF0ZUlucHV0KGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShlLnRhcmdldCkpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGl2ZVZhbGlkYXRlKSB7XFxuICAgICAgICB0aGlzLiRpbnB1dHMub2ZmKCdpbnB1dC56Zi5hYmlkZScpLm9uKCdpbnB1dC56Zi5hYmlkZScsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIF90aGlzMy52YWxpZGF0ZUlucHV0KGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShlLnRhcmdldCkpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudmFsaWRhdGVPbkJsdXIpIHtcXG4gICAgICAgIHRoaXMuJGlucHV0cy5vZmYoJ2JsdXIuemYuYWJpZGUnKS5vbignYmx1ci56Zi5hYmlkZScsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIF90aGlzMy52YWxpZGF0ZUlucHV0KGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShlLnRhcmdldCkpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDYWxscyBuZWNlc3NhcnkgZnVuY3Rpb25zIHRvIHVwZGF0ZSBBYmlkZSB1cG9uIERPTSBjaGFuZ2VcXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9yZWZsb3dcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZmxvdygpIHtcXG4gICAgICB0aGlzLl9pbml0KCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCBhIGZvcm0gZWxlbWVudCBoYXMgdGhlIHJlcXVpcmVkIGF0dHJpYnV0ZSBhbmQgaWYgaXQncyBjaGVja2VkIG9yIG5vdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gY2hlY2sgZm9yIHJlcXVpcmVkIGF0dHJpYnV0ZVxcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gQm9vbGVhbiB2YWx1ZSBkZXBlbmRzIG9uIHdoZXRoZXIgb3Igbm90IGF0dHJpYnV0ZSBpcyBjaGVja2VkIG9yIGVtcHR5XFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJyZXF1aXJlZENoZWNrXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcXVpcmVkQ2hlY2soJGVsKSB7XFxuICAgICAgaWYgKCEkZWwuYXR0cigncmVxdWlyZWQnKSkgcmV0dXJuIHRydWU7XFxuICAgICAgdmFyIGlzR29vZCA9IHRydWU7XFxuXFxuICAgICAgc3dpdGNoICgkZWxbMF0udHlwZSkge1xcbiAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxcbiAgICAgICAgICBpc0dvb2QgPSAkZWxbMF0uY2hlY2tlZDtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlICdzZWxlY3QnOlxcbiAgICAgICAgY2FzZSAnc2VsZWN0LW9uZSc6XFxuICAgICAgICBjYXNlICdzZWxlY3QtbXVsdGlwbGUnOlxcbiAgICAgICAgICB2YXIgb3B0ID0gJGVsLmZpbmQoJ29wdGlvbjpzZWxlY3RlZCcpO1xcbiAgICAgICAgICBpZiAoIW9wdC5sZW5ndGggfHwgIW9wdC52YWwoKSkgaXNHb29kID0gZmFsc2U7XFxuICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgaWYgKCEkZWwudmFsKCkgfHwgISRlbC52YWwoKS5sZW5ndGgpIGlzR29vZCA9IGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gaXNHb29kO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBHZXQ6XFxuICAgICAqIC0gQmFzZWQgb24gJGVsLCB0aGUgZmlyc3QgZWxlbWVudChzKSBjb3JyZXNwb25kaW5nIHRvIGBmb3JtRXJyb3JTZWxlY3RvcmAgaW4gdGhpcyBvcmRlcjpcXG4gICAgICogICAxLiBUaGUgZWxlbWVudCdzIGRpcmVjdCBzaWJsaW5nKCdzKS5cXG4gICAgICogICAyLiBUaGUgZWxlbWVudCdzIHBhcmVudCdzIGNoaWxkcmVuLlxcbiAgICAgKiAtIEVsZW1lbnQocykgd2l0aCB0aGUgYXR0cmlidXRlIGBbZGF0YS1mb3JtLWVycm9yLWZvcl1gIHNldCB3aXRoIHRoZSBlbGVtZW50J3MgaWQuXFxuICAgICAqXFxuICAgICAqIFRoaXMgYWxsb3dzIGZvciBtdWx0aXBsZSBmb3JtIGVycm9ycyBwZXIgaW5wdXQsIHRob3VnaCBpZiBub25lIGFyZSBmb3VuZCwgbm8gZm9ybSBlcnJvcnMgd2lsbCBiZSBzaG93bi5cXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICRlbCAtIGpRdWVyeSBvYmplY3QgdG8gdXNlIGFzIHJlZmVyZW5jZSB0byBmaW5kIHRoZSBmb3JtIGVycm9yIHNlbGVjdG9yLlxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBqUXVlcnkgb2JqZWN0IHdpdGggdGhlIHNlbGVjdG9yLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZmluZEZvcm1FcnJvclxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kRm9ybUVycm9yKCRlbCkge1xcbiAgICAgIHZhciBpZCA9ICRlbFswXS5pZDtcXG4gICAgICB2YXIgJGVycm9yID0gJGVsLnNpYmxpbmdzKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JTZWxlY3Rvcik7XFxuXFxuICAgICAgaWYgKCEkZXJyb3IubGVuZ3RoKSB7XFxuICAgICAgICAkZXJyb3IgPSAkZWwucGFyZW50KCkuZmluZCh0aGlzLm9wdGlvbnMuZm9ybUVycm9yU2VsZWN0b3IpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaWQpIHtcXG4gICAgICAgICRlcnJvciA9ICRlcnJvci5hZGQodGhpcy4kZWxlbWVudC5maW5kKFxcXCJbZGF0YS1mb3JtLWVycm9yLWZvcj1cXFxcXFxcIlxcXCIuY29uY2F0KGlkLCBcXFwiXFxcXFxcXCJdXFxcIikpKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuICRlcnJvcjtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogR2V0IHRoZSBmaXJzdCBlbGVtZW50IGluIHRoaXMgb3JkZXI6XFxuICAgICAqIDIuIFRoZSA8bGFiZWw+IHdpdGggdGhlIGF0dHJpYnV0ZSBgW2Zvcj1cXFwic29tZUlucHV0SWRcXFwiXWBcXG4gICAgICogMy4gVGhlIGAuY2xvc2VzdCgpYCA8bGFiZWw+XFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgb2JqZWN0IHRvIGNoZWNrIGZvciByZXF1aXJlZCBhdHRyaWJ1dGVcXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IEJvb2xlYW4gdmFsdWUgZGVwZW5kcyBvbiB3aGV0aGVyIG9yIG5vdCBhdHRyaWJ1dGUgaXMgY2hlY2tlZCBvciBlbXB0eVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZmluZExhYmVsXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRMYWJlbCgkZWwpIHtcXG4gICAgICB2YXIgaWQgPSAkZWxbMF0uaWQ7XFxuICAgICAgdmFyICRsYWJlbCA9IHRoaXMuJGVsZW1lbnQuZmluZChcXFwibGFiZWxbZm9yPVxcXFxcXFwiXFxcIi5jb25jYXQoaWQsIFxcXCJcXFxcXFxcIl1cXFwiKSk7XFxuXFxuICAgICAgaWYgKCEkbGFiZWwubGVuZ3RoKSB7XFxuICAgICAgICByZXR1cm4gJGVsLmNsb3Nlc3QoJ2xhYmVsJyk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiAkbGFiZWw7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEdldCB0aGUgc2V0IG9mIGxhYmVscyBhc3NvY2lhdGVkIHdpdGggYSBzZXQgb2YgcmFkaW8gZWxzIGluIHRoaXMgb3JkZXJcXG4gICAgICogMi4gVGhlIDxsYWJlbD4gd2l0aCB0aGUgYXR0cmlidXRlIGBbZm9yPVxcXCJzb21lSW5wdXRJZFxcXCJdYFxcbiAgICAgKiAzLiBUaGUgYC5jbG9zZXN0KClgIDxsYWJlbD5cXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICRlbCAtIGpRdWVyeSBvYmplY3QgdG8gY2hlY2sgZm9yIHJlcXVpcmVkIGF0dHJpYnV0ZVxcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gQm9vbGVhbiB2YWx1ZSBkZXBlbmRzIG9uIHdoZXRoZXIgb3Igbm90IGF0dHJpYnV0ZSBpcyBjaGVja2VkIG9yIGVtcHR5XFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJmaW5kUmFkaW9MYWJlbHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZFJhZGlvTGFiZWxzKCRlbHMpIHtcXG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcXG5cXG4gICAgICB2YXIgbGFiZWxzID0gJGVscy5tYXAoZnVuY3Rpb24gKGksIGVsKSB7XFxuICAgICAgICB2YXIgaWQgPSBlbC5pZDtcXG5cXG4gICAgICAgIHZhciAkbGFiZWwgPSBfdGhpczQuJGVsZW1lbnQuZmluZChcXFwibGFiZWxbZm9yPVxcXFxcXFwiXFxcIi5jb25jYXQoaWQsIFxcXCJcXFxcXFxcIl1cXFwiKSk7XFxuXFxuICAgICAgICBpZiAoISRsYWJlbC5sZW5ndGgpIHtcXG4gICAgICAgICAgJGxhYmVsID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGVsKS5jbG9zZXN0KCdsYWJlbCcpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuICRsYWJlbFswXTtcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGxhYmVscyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEFkZHMgdGhlIENTUyBlcnJvciBjbGFzcyBhcyBzcGVjaWZpZWQgYnkgdGhlIEFiaWRlIHNldHRpbmdzIHRvIHRoZSBsYWJlbCwgaW5wdXQsIGFuZCB0aGUgZm9ybVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIGNsYXNzIHRvXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJhZGRFcnJvckNsYXNzZXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXJyb3JDbGFzc2VzKCRlbCkge1xcbiAgICAgIHZhciAkbGFiZWwgPSB0aGlzLmZpbmRMYWJlbCgkZWwpO1xcbiAgICAgIHZhciAkZm9ybUVycm9yID0gdGhpcy5maW5kRm9ybUVycm9yKCRlbCk7XFxuXFxuICAgICAgaWYgKCRsYWJlbC5sZW5ndGgpIHtcXG4gICAgICAgICRsYWJlbC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMubGFiZWxFcnJvckNsYXNzKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCRmb3JtRXJyb3IubGVuZ3RoKSB7XFxuICAgICAgICAkZm9ybUVycm9yLmFkZENsYXNzKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JDbGFzcyk7XFxuICAgICAgfVxcblxcbiAgICAgICRlbC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuaW5wdXRFcnJvckNsYXNzKS5hdHRyKHtcXG4gICAgICAgICdkYXRhLWludmFsaWQnOiAnJyxcXG4gICAgICAgICdhcmlhLWludmFsaWQnOiB0cnVlXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEFkZHMgW2Zvcl0gYW5kIFtyb2xlPWFsZXJ0XSBhdHRyaWJ1dGVzIHRvIGFsbCBmb3JtIGVycm9yIHRhcmdldHRpbmcgJGVsLFxcbiAgICAgKiBhbmQgW2FyaWEtZGVzY3JpYmVkYnldIGF0dHJpYnV0ZSB0byAkZWwgdG93YXJkIHRoZSBmaXJzdCBmb3JtIGVycm9yLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IG9iamVjdFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiYWRkQTExeUF0dHJpYnV0ZXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQTExeUF0dHJpYnV0ZXMoJGVsKSB7XFxuICAgICAgdmFyICRlcnJvcnMgPSB0aGlzLmZpbmRGb3JtRXJyb3IoJGVsKTtcXG4gICAgICB2YXIgJGxhYmVscyA9ICRlcnJvcnMuZmlsdGVyKCdsYWJlbCcpO1xcbiAgICAgIHZhciAkZXJyb3IgPSAkZXJyb3JzLmZpcnN0KCk7XFxuICAgICAgaWYgKCEkZXJyb3JzLmxlbmd0aCkgcmV0dXJuOyAvLyBTZXQgW2FyaWEtZGVzY3JpYmVkYnldIG9uIHRoZSBpbnB1dCB0b3dhcmQgdGhlIGZpcnN0IGZvcm0gZXJyb3IgaWYgaXQgaXMgbm90IHNldFxcblxcbiAgICAgIGlmICh0eXBlb2YgJGVsLmF0dHIoJ2FyaWEtZGVzY3JpYmVkYnknKSA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIC8vIEdldCB0aGUgZmlyc3QgZXJyb3IgSUQgb3IgY3JlYXRlIG9uZVxcbiAgICAgICAgdmFyIGVycm9ySWQgPSAkZXJyb3IuYXR0cignaWQnKTtcXG5cXG4gICAgICAgIGlmICh0eXBlb2YgZXJyb3JJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgZXJyb3JJZCA9IE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIkdldFlvRGlnaXRzXFxcIl0pKDYsICdhYmlkZS1lcnJvcicpO1xcbiAgICAgICAgICAkZXJyb3IuYXR0cignaWQnLCBlcnJvcklkKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIDtcXG4gICAgICAgICRlbC5hdHRyKCdhcmlhLWRlc2NyaWJlZGJ5JywgZXJyb3JJZCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICgkbGFiZWxzLmZpbHRlcignW2Zvcl0nKS5sZW5ndGggPCAkbGFiZWxzLmxlbmd0aCkge1xcbiAgICAgICAgLy8gR2V0IHRoZSBpbnB1dCBJRCBvciBjcmVhdGUgb25lXFxuICAgICAgICB2YXIgZWxlbUlkID0gJGVsLmF0dHIoJ2lkJyk7XFxuXFxuICAgICAgICBpZiAodHlwZW9mIGVsZW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgZWxlbUlkID0gT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiR2V0WW9EaWdpdHNcXFwiXSkoNiwgJ2FiaWRlLWlucHV0Jyk7XFxuICAgICAgICAgICRlbC5hdHRyKCdpZCcsIGVsZW1JZCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICA7IC8vIEZvciBlYWNoIGxhYmVsIHRhcmdldGluZyAkZWwsIHNldCBbZm9yXSBpZiBpdCBpcyBub3Qgc2V0LlxcblxcbiAgICAgICAgJGxhYmVscy5lYWNoKGZ1bmN0aW9uIChpLCBsYWJlbCkge1xcbiAgICAgICAgICB2YXIgJGxhYmVsID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGxhYmVsKTtcXG4gICAgICAgICAgaWYgKHR5cGVvZiAkbGFiZWwuYXR0cignZm9yJykgPT09ICd1bmRlZmluZWQnKSAkbGFiZWwuYXR0cignZm9yJywgZWxlbUlkKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gLy8gRm9yIGVhY2ggZXJyb3IgdGFyZ2V0aW5nICRlbCwgc2V0IFtyb2xlPWFsZXJ0XSBpZiBpdCBpcyBub3Qgc2V0LlxcblxcblxcbiAgICAgICRlcnJvcnMuZWFjaChmdW5jdGlvbiAoaSwgbGFiZWwpIHtcXG4gICAgICAgIHZhciAkbGFiZWwgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkobGFiZWwpO1xcbiAgICAgICAgaWYgKHR5cGVvZiAkbGFiZWwuYXR0cigncm9sZScpID09PSAndW5kZWZpbmVkJykgJGxhYmVsLmF0dHIoJ3JvbGUnLCAnYWxlcnQnKTtcXG4gICAgICB9KS5lbmQoKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQWRkcyBbYXJpYS1saXZlXSBhdHRyaWJ1dGUgdG8gdGhlIGdpdmVuIGdsb2JhbCBmb3JtIGVycm9yICRlbC5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICRlbCAtIGpRdWVyeSBvYmplY3QgdG8gYWRkIHRoZSBhdHRyaWJ1dGUgdG9cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImFkZEdsb2JhbEVycm9yQTExeUF0dHJpYnV0ZXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkR2xvYmFsRXJyb3JBMTF5QXR0cmlidXRlcygkZWwpIHtcXG4gICAgICBpZiAodHlwZW9mICRlbC5hdHRyKCdhcmlhLWxpdmUnKSA9PT0gJ3VuZGVmaW5lZCcpICRlbC5hdHRyKCdhcmlhLWxpdmUnLCB0aGlzLm9wdGlvbnMuYTExeUVycm9yTGV2ZWwpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBSZW1vdmUgQ1NTIGVycm9yIGNsYXNzZXMgZXRjIGZyb20gYW4gZW50aXJlIHJhZGlvIGJ1dHRvbiBncm91cFxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBOYW1lIC0gQSBzdHJpbmcgdGhhdCBzcGVjaWZpZXMgdGhlIG5hbWUgb2YgYSByYWRpbyBidXR0b24gZ3JvdXBcXG4gICAgICpcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInJlbW92ZVJhZGlvRXJyb3JDbGFzc2VzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVJhZGlvRXJyb3JDbGFzc2VzKGdyb3VwTmFtZSkge1xcbiAgICAgIHZhciAkZWxzID0gdGhpcy4kZWxlbWVudC5maW5kKFxcXCI6cmFkaW9bbmFtZT1cXFxcXFxcIlxcXCIuY29uY2F0KGdyb3VwTmFtZSwgXFxcIlxcXFxcXFwiXVxcXCIpKTtcXG4gICAgICB2YXIgJGxhYmVscyA9IHRoaXMuZmluZFJhZGlvTGFiZWxzKCRlbHMpO1xcbiAgICAgIHZhciAkZm9ybUVycm9ycyA9IHRoaXMuZmluZEZvcm1FcnJvcigkZWxzKTtcXG5cXG4gICAgICBpZiAoJGxhYmVscy5sZW5ndGgpIHtcXG4gICAgICAgICRsYWJlbHMucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmxhYmVsRXJyb3JDbGFzcyk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICgkZm9ybUVycm9ycy5sZW5ndGgpIHtcXG4gICAgICAgICRmb3JtRXJyb3JzLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JDbGFzcyk7XFxuICAgICAgfVxcblxcbiAgICAgICRlbHMucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmlucHV0RXJyb3JDbGFzcykuYXR0cih7XFxuICAgICAgICAnZGF0YS1pbnZhbGlkJzogbnVsbCxcXG4gICAgICAgICdhcmlhLWludmFsaWQnOiBudWxsXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFJlbW92ZXMgQ1NTIGVycm9yIGNsYXNzIGFzIHNwZWNpZmllZCBieSB0aGUgQWJpZGUgc2V0dGluZ3MgZnJvbSB0aGUgbGFiZWwsIGlucHV0LCBhbmQgdGhlIGZvcm1cXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICRlbCAtIGpRdWVyeSBvYmplY3QgdG8gcmVtb3ZlIHRoZSBjbGFzcyBmcm9tXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJyZW1vdmVFcnJvckNsYXNzZXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRXJyb3JDbGFzc2VzKCRlbCkge1xcbiAgICAgIC8vIHJhZGlvcyBuZWVkIHRvIGNsZWFyIGFsbCBvZiB0aGUgZWxzXFxuICAgICAgaWYgKCRlbFswXS50eXBlID09ICdyYWRpbycpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZVJhZGlvRXJyb3JDbGFzc2VzKCRlbC5hdHRyKCduYW1lJykpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgJGxhYmVsID0gdGhpcy5maW5kTGFiZWwoJGVsKTtcXG4gICAgICB2YXIgJGZvcm1FcnJvciA9IHRoaXMuZmluZEZvcm1FcnJvcigkZWwpO1xcblxcbiAgICAgIGlmICgkbGFiZWwubGVuZ3RoKSB7XFxuICAgICAgICAkbGFiZWwucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmxhYmVsRXJyb3JDbGFzcyk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICgkZm9ybUVycm9yLmxlbmd0aCkge1xcbiAgICAgICAgJGZvcm1FcnJvci5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZm9ybUVycm9yQ2xhc3MpO1xcbiAgICAgIH1cXG5cXG4gICAgICAkZWwucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmlucHV0RXJyb3JDbGFzcykuYXR0cih7XFxuICAgICAgICAnZGF0YS1pbnZhbGlkJzogbnVsbCxcXG4gICAgICAgICdhcmlhLWludmFsaWQnOiBudWxsXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEdvZXMgdGhyb3VnaCBhIGZvcm0gdG8gZmluZCBpbnB1dHMgYW5kIHByb2NlZWRzIHRvIHZhbGlkYXRlIHRoZW0gaW4gd2F5cyBzcGVjaWZpYyB0byB0aGVpciB0eXBlLlxcbiAgICAgKiBJZ25vcmVzIGlucHV0cyB3aXRoIGRhdGEtYWJpZGUtaWdub3JlLCB0eXBlPVxcXCJoaWRkZW5cXFwiIG9yIGRpc2FibGVkIGF0dHJpYnV0ZXMgc2V0XFxuICAgICAqIEBmaXJlcyBBYmlkZSNpbnZhbGlkXFxuICAgICAqIEBmaXJlcyBBYmlkZSN2YWxpZFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gdmFsaWRhdGUsIHNob3VsZCBiZSBhbiBIVE1MIGlucHV0XFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBnb29kVG9HbyAtIElmIHRoZSBpbnB1dCBpcyB2YWxpZCBvciBub3QuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ2YWxpZGF0ZUlucHV0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlSW5wdXQoJGVsKSB7XFxuICAgICAgdmFyIGNsZWFyUmVxdWlyZSA9IHRoaXMucmVxdWlyZWRDaGVjaygkZWwpLFxcbiAgICAgICAgICB2YWxpZGF0ZWQgPSBmYWxzZSxcXG4gICAgICAgICAgY3VzdG9tVmFsaWRhdG9yID0gdHJ1ZSxcXG4gICAgICAgICAgdmFsaWRhdG9yID0gJGVsLmF0dHIoJ2RhdGEtdmFsaWRhdG9yJyksXFxuICAgICAgICAgIGVxdWFsVG8gPSB0cnVlOyAvLyBkb24ndCB2YWxpZGF0ZSBpZ25vcmVkIGlucHV0cyBvciBoaWRkZW4gaW5wdXRzIG9yIGRpc2FibGVkIGlucHV0c1xcblxcbiAgICAgIGlmICgkZWwuaXMoJ1tkYXRhLWFiaWRlLWlnbm9yZV0nKSB8fCAkZWwuaXMoJ1t0eXBlPVxcXCJoaWRkZW5cXFwiXScpIHx8ICRlbC5pcygnW2Rpc2FibGVkXScpKSB7XFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgc3dpdGNoICgkZWxbMF0udHlwZSkge1xcbiAgICAgICAgY2FzZSAncmFkaW8nOlxcbiAgICAgICAgICB2YWxpZGF0ZWQgPSB0aGlzLnZhbGlkYXRlUmFkaW8oJGVsLmF0dHIoJ25hbWUnKSk7XFxuICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxcbiAgICAgICAgICB2YWxpZGF0ZWQgPSBjbGVhclJlcXVpcmU7XFxuICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgY2FzZSAnc2VsZWN0JzpcXG4gICAgICAgIGNhc2UgJ3NlbGVjdC1vbmUnOlxcbiAgICAgICAgY2FzZSAnc2VsZWN0LW11bHRpcGxlJzpcXG4gICAgICAgICAgdmFsaWRhdGVkID0gY2xlYXJSZXF1aXJlO1xcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgIHZhbGlkYXRlZCA9IHRoaXMudmFsaWRhdGVUZXh0KCRlbCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh2YWxpZGF0b3IpIHtcXG4gICAgICAgIGN1c3RvbVZhbGlkYXRvciA9IHRoaXMubWF0Y2hWYWxpZGF0aW9uKCRlbCwgdmFsaWRhdG9yLCAkZWwuYXR0cigncmVxdWlyZWQnKSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICgkZWwuYXR0cignZGF0YS1lcXVhbHRvJykpIHtcXG4gICAgICAgIGVxdWFsVG8gPSB0aGlzLm9wdGlvbnMudmFsaWRhdG9ycy5lcXVhbFRvKCRlbCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBnb29kVG9HbyA9IFtjbGVhclJlcXVpcmUsIHZhbGlkYXRlZCwgY3VzdG9tVmFsaWRhdG9yLCBlcXVhbFRvXS5pbmRleE9mKGZhbHNlKSA9PT0gLTE7XFxuICAgICAgdmFyIG1lc3NhZ2UgPSAoZ29vZFRvR28gPyAndmFsaWQnIDogJ2ludmFsaWQnKSArICcuemYuYWJpZGUnO1xcblxcbiAgICAgIGlmIChnb29kVG9Hbykge1xcbiAgICAgICAgLy8gUmUtdmFsaWRhdGUgaW5wdXRzIHRoYXQgZGVwZW5kIG9uIHRoaXMgb25lIHdpdGggZXF1YWx0b1xcbiAgICAgICAgdmFyIGRlcGVuZGVudEVsZW1lbnRzID0gdGhpcy4kZWxlbWVudC5maW5kKFxcXCJbZGF0YS1lcXVhbHRvPVxcXFxcXFwiXFxcIi5jb25jYXQoJGVsLmF0dHIoJ2lkJyksIFxcXCJcXFxcXFxcIl1cXFwiKSk7XFxuXFxuICAgICAgICBpZiAoZGVwZW5kZW50RWxlbWVudHMubGVuZ3RoKSB7XFxuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgICAgIGRlcGVuZGVudEVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGlmIChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykudmFsKCkpIHtcXG4gICAgICAgICAgICAgIF90aGlzLnZhbGlkYXRlSW5wdXQoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzW2dvb2RUb0dvID8gJ3JlbW92ZUVycm9yQ2xhc3NlcycgOiAnYWRkRXJyb3JDbGFzc2VzJ10oJGVsKTtcXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBpbnB1dCBpcyBkb25lIGNoZWNraW5nIGZvciB2YWxpZGF0aW9uLiBFdmVudCB0cmlnZ2VyIGlzIGVpdGhlciBgdmFsaWQuemYuYWJpZGVgIG9yIGBpbnZhbGlkLnpmLmFiaWRlYFxcbiAgICAgICAqIFRyaWdnZXIgaW5jbHVkZXMgdGhlIERPTSBlbGVtZW50IG9mIHRoZSBpbnB1dC5cXG4gICAgICAgKiBAZXZlbnQgQWJpZGUjdmFsaWRcXG4gICAgICAgKiBAZXZlbnQgQWJpZGUjaW52YWxpZFxcbiAgICAgICAqL1xcblxcbiAgICAgICRlbC50cmlnZ2VyKG1lc3NhZ2UsIFskZWxdKTtcXG4gICAgICByZXR1cm4gZ29vZFRvR287XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEdvZXMgdGhyb3VnaCBhIGZvcm0gYW5kIGlmIHRoZXJlIGFyZSBhbnkgaW52YWxpZCBpbnB1dHMsIGl0IHdpbGwgZGlzcGxheSB0aGUgZm9ybSBlcnJvciBlbGVtZW50XFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBub0Vycm9yIC0gdHJ1ZSBpZiBubyBlcnJvcnMgd2VyZSBkZXRlY3RlZC4uLlxcbiAgICAgKiBAZmlyZXMgQWJpZGUjZm9ybXZhbGlkXFxuICAgICAqIEBmaXJlcyBBYmlkZSNmb3JtaW52YWxpZFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidmFsaWRhdGVGb3JtXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybSgpIHtcXG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcXG5cXG4gICAgICB2YXIgYWNjID0gW107XFxuXFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLiRpbnB1dHMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBhY2MucHVzaChfdGhpcy52YWxpZGF0ZUlucHV0KGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKSkpO1xcbiAgICAgIH0pO1xcbiAgICAgIHZhciBub0Vycm9yID0gYWNjLmluZGV4T2YoZmFsc2UpID09PSAtMTtcXG4gICAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLWFiaWRlLWVycm9yXScpLmVhY2goZnVuY3Rpb24gKGksIGVsZW0pIHtcXG4gICAgICAgIHZhciAkZWxlbSA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShlbGVtKTsgLy8gRW5zdXJlIGExMXkgYXR0cmlidXRlcyBhcmUgc2V0XFxuXFxuICAgICAgICBpZiAoX3RoaXM1Lm9wdGlvbnMuYTExeUF0dHJpYnV0ZXMpIF90aGlzNS5hZGRHbG9iYWxFcnJvckExMXlBdHRyaWJ1dGVzKCRlbGVtKTsgLy8gU2hvdyBvciBoaWRlIHRoZSBlcnJvclxcblxcbiAgICAgICAgJGVsZW0uY3NzKCdkaXNwbGF5Jywgbm9FcnJvciA/ICdub25lJyA6ICdibG9jaycpO1xcbiAgICAgIH0pO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGZvcm0gaXMgZmluaXNoZWQgdmFsaWRhdGluZy4gRXZlbnQgdHJpZ2dlciBpcyBlaXRoZXIgYGZvcm12YWxpZC56Zi5hYmlkZWAgb3IgYGZvcm1pbnZhbGlkLnpmLmFiaWRlYC5cXG4gICAgICAgKiBUcmlnZ2VyIGluY2x1ZGVzIHRoZSBlbGVtZW50IG9mIHRoZSBmb3JtLlxcbiAgICAgICAqIEBldmVudCBBYmlkZSNmb3JtdmFsaWRcXG4gICAgICAgKiBAZXZlbnQgQWJpZGUjZm9ybWludmFsaWRcXG4gICAgICAgKi9cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoKG5vRXJyb3IgPyAnZm9ybXZhbGlkJyA6ICdmb3JtaW52YWxpZCcpICsgJy56Zi5hYmlkZScsIFt0aGlzLiRlbGVtZW50XSk7XFxuICAgICAgcmV0dXJuIG5vRXJyb3I7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBhIG5vdCBhIHRleHQgaW5wdXQgaXMgdmFsaWQgYmFzZWQgb24gdGhlIHBhdHRlcm4gc3BlY2lmaWVkIGluIHRoZSBhdHRyaWJ1dGUuIElmIG5vIG1hdGNoaW5nIHBhdHRlcm4gaXMgZm91bmQsIHJldHVybnMgdHJ1ZS5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICRlbCAtIGpRdWVyeSBvYmplY3QgdG8gdmFsaWRhdGUsIHNob3VsZCBiZSBhIHRleHQgaW5wdXQgSFRNTCBlbGVtZW50XFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXR0ZXJuIC0gc3RyaW5nIHZhbHVlIG9mIG9uZSBvZiB0aGUgUmVnRXggcGF0dGVybnMgaW4gQWJpZGUub3B0aW9ucy5wYXR0ZXJuc1xcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gQm9vbGVhbiB2YWx1ZSBkZXBlbmRzIG9uIHdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCB2YWx1ZSBtYXRjaGVzIHRoZSBwYXR0ZXJuIHNwZWNpZmllZFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidmFsaWRhdGVUZXh0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlVGV4dCgkZWwsIHBhdHRlcm4pIHtcXG4gICAgICAvLyBBIHBhdHRlcm4gY2FuIGJlIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uLCBvciBpdCB3aWxsIGJlIGluZmVyZWQgZnJvbSB0aGUgaW5wdXQncyBcXFwicGF0dGVyblxcXCIgYXR0cmlidXRlLCBvciBpdCdzIFxcXCJ0eXBlXFxcIiBhdHRyaWJ1dGVcXG4gICAgICBwYXR0ZXJuID0gcGF0dGVybiB8fCAkZWwuYXR0cigncGF0dGVybicpIHx8ICRlbC5hdHRyKCd0eXBlJyk7XFxuICAgICAgdmFyIGlucHV0VGV4dCA9ICRlbC52YWwoKTtcXG4gICAgICB2YXIgdmFsaWQgPSBmYWxzZTtcXG5cXG4gICAgICBpZiAoaW5wdXRUZXh0Lmxlbmd0aCkge1xcbiAgICAgICAgLy8gSWYgdGhlIHBhdHRlcm4gYXR0cmlidXRlIG9uIHRoZSBlbGVtZW50IGlzIGluIEFiaWRlJ3MgbGlzdCBvZiBwYXR0ZXJucywgdGhlbiB0ZXN0IHRoYXQgcmVnZXhwXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBhdHRlcm5zLmhhc093blByb3BlcnR5KHBhdHRlcm4pKSB7XFxuICAgICAgICAgIHZhbGlkID0gdGhpcy5vcHRpb25zLnBhdHRlcm5zW3BhdHRlcm5dLnRlc3QoaW5wdXRUZXh0KTtcXG4gICAgICAgIH0gLy8gSWYgdGhlIHBhdHRlcm4gbmFtZSBpc24ndCBhbHNvIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiB0aGUgZmllbGQsIHRoZW4gdGVzdCBpdCBhcyBhIHJlZ2V4cFxcbiAgICAgICAgZWxzZSBpZiAocGF0dGVybiAhPT0gJGVsLmF0dHIoJ3R5cGUnKSkge1xcbiAgICAgICAgICAgIHZhbGlkID0gbmV3IFJlZ0V4cChwYXR0ZXJuKS50ZXN0KGlucHV0VGV4dCk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgfSAvLyBBbiBlbXB0eSBmaWVsZCBpcyB2YWxpZCBpZiBpdCdzIG5vdCByZXF1aXJlZFxcbiAgICAgIGVsc2UgaWYgKCEkZWwucHJvcCgncmVxdWlyZWQnKSkge1xcbiAgICAgICAgICB2YWxpZCA9IHRydWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHZhbGlkO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3IgYSBub3QgYSByYWRpbyBpbnB1dCBpcyB2YWxpZCBiYXNlZCBvbiB3aGV0aGVyIG9yIG5vdCBpdCBpcyByZXF1aXJlZCBhbmQgc2VsZWN0ZWQuIEFsdGhvdWdoIHRoZSBmdW5jdGlvbiB0YXJnZXRzIGEgc2luZ2xlIGA8aW5wdXQ+YCwgaXQgdmFsaWRhdGVzIGJ5IGNoZWNraW5nIHRoZSBgcmVxdWlyZWRgIGFuZCBgY2hlY2tlZGAgcHJvcGVydGllcyBvZiBhbGwgcmFkaW8gYnV0dG9ucyBpbiBpdHMgZ3JvdXAuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBncm91cE5hbWUgLSBBIHN0cmluZyB0aGF0IHNwZWNpZmllcyB0aGUgbmFtZSBvZiBhIHJhZGlvIGJ1dHRvbiBncm91cFxcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gQm9vbGVhbiB2YWx1ZSBkZXBlbmRzIG9uIHdoZXRoZXIgb3Igbm90IGF0IGxlYXN0IG9uZSByYWRpbyBpbnB1dCBoYXMgYmVlbiBzZWxlY3RlZCAoaWYgaXQncyByZXF1aXJlZClcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInZhbGlkYXRlUmFkaW9cXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGVSYWRpbyhncm91cE5hbWUpIHtcXG4gICAgICAvLyBJZiBhdCBsZWFzdCBvbmUgcmFkaW8gaW4gdGhlIGdyb3VwIGhhcyB0aGUgYHJlcXVpcmVkYCBhdHRyaWJ1dGUsIHRoZSBncm91cCBpcyBjb25zaWRlcmVkIHJlcXVpcmVkXFxuICAgICAgLy8gUGVyIFczQyBzcGVjLCBhbGwgcmFkaW8gYnV0dG9ucyBpbiBhIGdyb3VwIHNob3VsZCBoYXZlIGByZXF1aXJlZGAsIGJ1dCB3ZSdyZSBiZWluZyBuaWNlXFxuICAgICAgdmFyICRncm91cCA9IHRoaXMuJGVsZW1lbnQuZmluZChcXFwiOnJhZGlvW25hbWU9XFxcXFxcXCJcXFwiLmNvbmNhdChncm91cE5hbWUsIFxcXCJcXFxcXFxcIl1cXFwiKSk7XFxuICAgICAgdmFyIHZhbGlkID0gZmFsc2UsXFxuICAgICAgICAgIHJlcXVpcmVkID0gZmFsc2U7IC8vIEZvciB0aGUgZ3JvdXAgdG8gYmUgcmVxdWlyZWQsIGF0IGxlYXN0IG9uZSByYWRpbyBuZWVkcyB0byBiZSByZXF1aXJlZFxcblxcbiAgICAgICRncm91cC5lYWNoKGZ1bmN0aW9uIChpLCBlKSB7XFxuICAgICAgICBpZiAoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGUpLmF0dHIoJ3JlcXVpcmVkJykpIHtcXG4gICAgICAgICAgcmVxdWlyZWQgPSB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICAgIGlmICghcmVxdWlyZWQpIHZhbGlkID0gdHJ1ZTtcXG5cXG4gICAgICBpZiAoIXZhbGlkKSB7XFxuICAgICAgICAvLyBGb3IgdGhlIGdyb3VwIHRvIGJlIHZhbGlkLCBhdCBsZWFzdCBvbmUgcmFkaW8gbmVlZHMgdG8gYmUgY2hlY2tlZFxcbiAgICAgICAgJGdyb3VwLmVhY2goZnVuY3Rpb24gKGksIGUpIHtcXG4gICAgICAgICAgaWYgKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShlKS5wcm9wKCdjaGVja2VkJykpIHtcXG4gICAgICAgICAgICB2YWxpZCA9IHRydWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICA7XFxuICAgICAgcmV0dXJuIHZhbGlkO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGEgc2VsZWN0ZWQgaW5wdXQgcGFzc2VzIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24uIE11bHRpcGxlIHZhbGlkYXRpb25zIGNhbiBiZSB1c2VkLCBpZiBwYXNzZWQgdG8gdGhlIGVsZW1lbnQgd2l0aCBgZGF0YS12YWxpZGF0b3I9XFxcImZvbyBiYXIgYmF6XFxcImAgaW4gYSBzcGFjZSBzZXBhcmF0ZWQgbGlzdGVkLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IGlucHV0IGVsZW1lbnQuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWxpZGF0b3JzIC0gYSBzdHJpbmcgb2YgZnVuY3Rpb24gbmFtZXMgbWF0Y2hpbmcgZnVuY3Rpb25zIGluIHRoZSBBYmlkZS5vcHRpb25zLnZhbGlkYXRvcnMgb2JqZWN0LlxcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlcXVpcmVkIC0gc2VsZiBleHBsYW5hdG9yeT9cXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IC0gdHJ1ZSBpZiB2YWxpZGF0aW9ucyBwYXNzZWQuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJtYXRjaFZhbGlkYXRpb25cXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2hWYWxpZGF0aW9uKCRlbCwgdmFsaWRhdG9ycywgcmVxdWlyZWQpIHtcXG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcXG5cXG4gICAgICByZXF1aXJlZCA9IHJlcXVpcmVkID8gdHJ1ZSA6IGZhbHNlO1xcbiAgICAgIHZhciBjbGVhciA9IHZhbGlkYXRvcnMuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24gKHYpIHtcXG4gICAgICAgIHJldHVybiBfdGhpczYub3B0aW9ucy52YWxpZGF0b3JzW3ZdKCRlbCwgcmVxdWlyZWQsICRlbC5wYXJlbnQoKSk7XFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuIGNsZWFyLmluZGV4T2YoZmFsc2UpID09PSAtMTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogUmVzZXRzIGZvcm0gaW5wdXRzIGFuZCBzdHlsZXNcXG4gICAgICogQGZpcmVzIEFiaWRlI2Zvcm1yZXNldFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicmVzZXRGb3JtXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0Rm9ybSgpIHtcXG4gICAgICB2YXIgJGZvcm0gPSB0aGlzLiRlbGVtZW50LFxcbiAgICAgICAgICBvcHRzID0gdGhpcy5vcHRpb25zO1xcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShcXFwiLlxcXCIuY29uY2F0KG9wdHMubGFiZWxFcnJvckNsYXNzKSwgJGZvcm0pLm5vdCgnc21hbGwnKS5yZW1vdmVDbGFzcyhvcHRzLmxhYmVsRXJyb3JDbGFzcyk7XFxuICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKFxcXCIuXFxcIi5jb25jYXQob3B0cy5pbnB1dEVycm9yQ2xhc3MpLCAkZm9ybSkubm90KCdzbWFsbCcpLnJlbW92ZUNsYXNzKG9wdHMuaW5wdXRFcnJvckNsYXNzKTtcXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoXFxcIlxcXCIuY29uY2F0KG9wdHMuZm9ybUVycm9yU2VsZWN0b3IsIFxcXCIuXFxcIikuY29uY2F0KG9wdHMuZm9ybUVycm9yQ2xhc3MpKS5yZW1vdmVDbGFzcyhvcHRzLmZvcm1FcnJvckNsYXNzKTtcXG4gICAgICAkZm9ybS5maW5kKCdbZGF0YS1hYmlkZS1lcnJvcl0nKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnOmlucHV0JywgJGZvcm0pLm5vdCgnOmJ1dHRvbiwgOnN1Ym1pdCwgOnJlc2V0LCA6aGlkZGVuLCA6cmFkaW8sIDpjaGVja2JveCwgW2RhdGEtYWJpZGUtaWdub3JlXScpLnZhbCgnJykuYXR0cih7XFxuICAgICAgICAnZGF0YS1pbnZhbGlkJzogbnVsbCxcXG4gICAgICAgICdhcmlhLWludmFsaWQnOiBudWxsXFxuICAgICAgfSk7XFxuICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCc6aW5wdXQ6cmFkaW8nLCAkZm9ybSkubm90KCdbZGF0YS1hYmlkZS1pZ25vcmVdJykucHJvcCgnY2hlY2tlZCcsIGZhbHNlKS5hdHRyKHtcXG4gICAgICAgICdkYXRhLWludmFsaWQnOiBudWxsLFxcbiAgICAgICAgJ2FyaWEtaW52YWxpZCc6IG51bGxcXG4gICAgICB9KTtcXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoJzppbnB1dDpjaGVja2JveCcsICRmb3JtKS5ub3QoJ1tkYXRhLWFiaWRlLWlnbm9yZV0nKS5wcm9wKCdjaGVja2VkJywgZmFsc2UpLmF0dHIoe1xcbiAgICAgICAgJ2RhdGEtaW52YWxpZCc6IG51bGwsXFxuICAgICAgICAnYXJpYS1pbnZhbGlkJzogbnVsbFxcbiAgICAgIH0pO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGZvcm0gaGFzIGJlZW4gcmVzZXQuXFxuICAgICAgICogQGV2ZW50IEFiaWRlI2Zvcm1yZXNldFxcbiAgICAgICAqL1xcblxcbiAgICAgICRmb3JtLnRyaWdnZXIoJ2Zvcm1yZXNldC56Zi5hYmlkZScsIFskZm9ybV0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBBYmlkZS5cXG4gICAgICogUmVtb3ZlcyBlcnJvciBzdHlsZXMgYW5kIGNsYXNzZXMgZnJvbSBlbGVtZW50cywgd2l0aG91dCByZXNldHRpbmcgdGhlaXIgdmFsdWVzLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2Rlc3Ryb3lcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZignLmFiaWRlJykuZmluZCgnW2RhdGEtYWJpZGUtZXJyb3JdJykuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcXG4gICAgICB0aGlzLiRpbnB1dHMub2ZmKCcuYWJpZGUnKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIF90aGlzLnJlbW92ZUVycm9yQ2xhc3NlcyhqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gQWJpZGU7XFxufShfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJQbHVnaW5cXFwiXSk7XFxuLyoqXFxuICogRGVmYXVsdCBzZXR0aW5ncyBmb3IgcGx1Z2luXFxuICovXFxuXFxuXFxuQWJpZGUuZGVmYXVsdHMgPSB7XFxuICAvKipcXG4gICAqIFRoZSBkZWZhdWx0IGV2ZW50IHRvIHZhbGlkYXRlIGlucHV0cy4gQ2hlY2tib3hlcyBhbmQgcmFkaW9zIHZhbGlkYXRlIGltbWVkaWF0ZWx5LlxcbiAgICogUmVtb3ZlIG9yIGNoYW5nZSB0aGlzIHZhbHVlIGZvciBtYW51YWwgdmFsaWRhdGlvbi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHs/c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ2ZpZWxkQ2hhbmdlJ1xcbiAgICovXFxuICB2YWxpZGF0ZU9uOiAnZmllbGRDaGFuZ2UnLFxcblxcbiAgLyoqXFxuICAgKiBDbGFzcyB0byBiZSBhcHBsaWVkIHRvIGlucHV0IGxhYmVscyBvbiBmYWlsZWQgdmFsaWRhdGlvbi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnaXMtaW52YWxpZC1sYWJlbCdcXG4gICAqL1xcbiAgbGFiZWxFcnJvckNsYXNzOiAnaXMtaW52YWxpZC1sYWJlbCcsXFxuXFxuICAvKipcXG4gICAqIENsYXNzIHRvIGJlIGFwcGxpZWQgdG8gaW5wdXRzIG9uIGZhaWxlZCB2YWxpZGF0aW9uLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICdpcy1pbnZhbGlkLWlucHV0J1xcbiAgICovXFxuICBpbnB1dEVycm9yQ2xhc3M6ICdpcy1pbnZhbGlkLWlucHV0JyxcXG5cXG4gIC8qKlxcbiAgICogQ2xhc3Mgc2VsZWN0b3IgdG8gdXNlIHRvIHRhcmdldCBGb3JtIEVycm9ycyBmb3Igc2hvdy9oaWRlLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICcuZm9ybS1lcnJvcidcXG4gICAqL1xcbiAgZm9ybUVycm9yU2VsZWN0b3I6ICcuZm9ybS1lcnJvcicsXFxuXFxuICAvKipcXG4gICAqIENsYXNzIGFkZGVkIHRvIEZvcm0gRXJyb3JzIG9uIGZhaWxlZCB2YWxpZGF0aW9uLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICdpcy12aXNpYmxlJ1xcbiAgICovXFxuICBmb3JtRXJyb3JDbGFzczogJ2lzLXZpc2libGUnLFxcblxcbiAgLyoqXFxuICAgKiBJZiB0cnVlLCBhdXRvbWF0aWNhbGx5IGluc2VydCB3aGVuIHBvc3NpYmxlOlxcbiAgICogLSBgW2FyaWEtZGVzY3JpYmVkYnldYCBvbiBmaWVsZHNcXG4gICAqIC0gYFtyb2xlPWFsZXJ0XWAgb24gZm9ybSBlcnJvcnMgYW5kIGBbZm9yXWAgb24gZm9ybSBlcnJvciBsYWJlbHNcXG4gICAqIC0gYFthcmlhLWxpdmVdYCBvbiBnbG9iYWwgZXJyb3JzIGBbZGF0YS1hYmlkZS1lcnJvcl1gIChzZWUgb3B0aW9uIGBhMTF5RXJyb3JMZXZlbGApLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCB0cnVlXFxuICAgKi9cXG4gIGExMXlBdHRyaWJ1dGVzOiB0cnVlLFxcblxcbiAgLyoqXFxuICAgKiBbYXJpYS1saXZlXSBhdHRyaWJ1dGUgdmFsdWUgdG8gYmUgYXBwbGllZCBvbiBnbG9iYWwgZXJyb3JzIGBbZGF0YS1hYmlkZS1lcnJvcl1gLlxcbiAgICogT3B0aW9ucyBhcmU6ICdhc3NlcnRpdmUnLCAncG9saXRlJyBhbmQgJ29mZicvbnVsbFxcbiAgICogQG9wdGlvblxcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BY2Nlc3NpYmlsaXR5L0FSSUEvQVJJQV9MaXZlX1JlZ2lvbnNcXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnYXNzZXJ0aXZlJ1xcbiAgICovXFxuICBhMTF5RXJyb3JMZXZlbDogJ2Fzc2VydGl2ZScsXFxuXFxuICAvKipcXG4gICAqIFNldCB0byB0cnVlIHRvIHZhbGlkYXRlIHRleHQgaW5wdXRzIG9uIGFueSB2YWx1ZSBjaGFuZ2UuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGxpdmVWYWxpZGF0ZTogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIFNldCB0byB0cnVlIHRvIHZhbGlkYXRlIGlucHV0cyBvbiBibHVyLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICB2YWxpZGF0ZU9uQmx1cjogZmFsc2UsXFxuICBwYXR0ZXJuczoge1xcbiAgICBhbHBoYTogL15bYS16QS1aXSskLyxcXG4gICAgYWxwaGFfbnVtZXJpYzogL15bYS16QS1aMC05XSskLyxcXG4gICAgaW50ZWdlcjogL15bLStdP1xcXFxkKyQvLFxcbiAgICBudW1iZXI6IC9eWy0rXT9cXFxcZCooPzpbXFxcXC5cXFxcLF1cXFxcZCspPyQvLFxcbiAgICAvLyBhbWV4LCB2aXNhLCBkaW5lcnNcXG4gICAgY2FyZDogL14oPzo0WzAtOV17MTJ9KD86WzAtOV17M30pP3w1WzEtNV1bMC05XXsxNH18KD86MjIyWzEtOV18MlszLTZdWzAtOV17Mn18MjdbMC0xXVswLTldfDI3MjApWzAtOV17MTJ9fDYoPzowMTF8NVswLTldWzAtOV0pWzAtOV17MTJ9fDNbNDddWzAtOV17MTN9fDMoPzowWzAtNV18WzY4XVswLTldKVswLTldezExfXwoPzoyMTMxfDE4MDB8MzVcXFxcZHszfSlcXFxcZHsxMX0pJC8sXFxuICAgIGN2djogL14oWzAtOV0pezMsNH0kLyxcXG4gICAgLy8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2Uvc3RhdGVzLW9mLXRoZS10eXBlLWF0dHJpYnV0ZS5odG1sI3ZhbGlkLWUtbWFpbC1hZGRyZXNzXFxuICAgIGVtYWlsOiAvXlthLXpBLVowLTkuISMkJSYnKitcXFxcLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXFxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykrJC8sXFxuICAgIC8vIEZyb20gQ29tbW9uUmVnZXhKUyAoQHRhbHlzc29ub2MpXFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YWx5c3Nvbm9jL0NvbW1vblJlZ2V4SlMvYmxvYi9lMjkwMWI5ZjU3MjIyYmMxNDA2OWRjOGYwNTk4ZDVmNDEyNTU1NDExL2xpYi9jb21tb25yZWdleC5qcyNMNzZcXG4gICAgLy8gRm9yIG1vcmUgcmVzdHJpY3RpdmUgVVJMIFJlZ2V4cywgc2VlIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9kZW1vL3VybC1yZWdleC5cXG4gICAgdXJsOiAvXigoPzooaHR0cHM/fGZ0cHM/fGZpbGV8c3NofHNmdHApOlxcXFwvXFxcXC98d3d3XFxcXGR7MCwzfVsuXXxbYS16MC05LlxcXFwtXStbLl1bYS16XXsyLDR9XFxcXC8pKD86W15cXFxccygpPD5dK3xcXFxcKCg/OlteXFxcXHMoKTw+XSt8KD86XFxcXChbXlxcXFxzKCk8Pl0rXFxcXCkpKSpcXFxcKSkrKD86XFxcXCgoPzpbXlxcXFxzKCk8Pl0rfCg/OlxcXFwoW15cXFxccygpPD5dK1xcXFwpKSkqXFxcXCl8W15cXFxcc2AhKClcXFxcW1xcXFxde307OlxcXFwnXFxcIi4sPD4/XFxcXHhhYlxcXFx4YmJcXFxcdTIwMWNcXFxcdTIwMWRcXFxcdTIwMThcXFxcdTIwMTldKSkkLyxcXG4gICAgLy8gYWJjLmRlXFxuICAgIGRvbWFpbjogL14oW2EtekEtWjAtOV0oW2EtekEtWjAtOVxcXFwtXXswLDYxfVthLXpBLVowLTldKT9cXFxcLikrW2EtekEtWl17Miw4fSQvLFxcbiAgICBkYXRldGltZTogL14oWzAtMl1bMC05XXszfSlcXFxcLShbMC0xXVswLTldKVxcXFwtKFswLTNdWzAtOV0pVChbMC01XVswLTldKVxcXFw6KFswLTVdWzAtOV0pXFxcXDooWzAtNV1bMC05XSkoWnwoW1xcXFwtXFxcXCtdKFswLTFdWzAtOV0pXFxcXDowMCkpJC8sXFxuICAgIC8vIFlZWVktTU0tRERcXG4gICAgZGF0ZTogLyg/OjE5fDIwKVswLTldezJ9LSg/Oig/OjBbMS05XXwxWzAtMl0pLSg/OjBbMS05XXwxWzAtOV18MlswLTldKXwoPzooPyEwMikoPzowWzEtOV18MVswLTJdKS0oPzozMCkpfCg/Oig/OjBbMTM1NzhdfDFbMDJdKS0zMSkpJC8sXFxuICAgIC8vIEhIOk1NOlNTXFxuICAgIHRpbWU6IC9eKDBbMC05XXwxWzAtOV18MlswLTNdKSg6WzAtNV1bMC05XSl7Mn0kLyxcXG4gICAgZGF0ZUlTTzogL15cXFxcZHs0fVtcXFxcL1xcXFwtXVxcXFxkezEsMn1bXFxcXC9cXFxcLV1cXFxcZHsxLDJ9JC8sXFxuICAgIC8vIE1NL0REL1lZWVlcXG4gICAgbW9udGhfZGF5X3llYXI6IC9eKDBbMS05XXwxWzAxMl0pWy0gXFxcXC8uXSgwWzEtOV18WzEyXVswLTldfDNbMDFdKVstIFxcXFwvLl1cXFxcZHs0fSQvLFxcbiAgICAvLyBERC9NTS9ZWVlZXFxuICAgIGRheV9tb250aF95ZWFyOiAvXigwWzEtOV18WzEyXVswLTldfDNbMDFdKVstIFxcXFwvLl0oMFsxLTldfDFbMDEyXSlbLSBcXFxcLy5dXFxcXGR7NH0kLyxcXG4gICAgLy8gI0ZGRiBvciAjRkZGRkZGXFxuICAgIGNvbG9yOiAvXiM/KFthLWZBLUYwLTldezZ9fFthLWZBLUYwLTldezN9KSQvLFxcbiAgICAvLyBEb21haW4gfHwgVVJMXFxuICAgIHdlYnNpdGU6IHtcXG4gICAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHRleHQpIHtcXG4gICAgICAgIHJldHVybiBBYmlkZS5kZWZhdWx0cy5wYXR0ZXJuc1snZG9tYWluJ10udGVzdCh0ZXh0KSB8fCBBYmlkZS5kZWZhdWx0cy5wYXR0ZXJuc1sndXJsJ10udGVzdCh0ZXh0KTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0sXFxuXFxuICAvKipcXG4gICAqIE9wdGlvbmFsIHZhbGlkYXRpb24gZnVuY3Rpb25zIHRvIGJlIHVzZWQuIGBlcXVhbFRvYCBiZWluZyB0aGUgb25seSBkZWZhdWx0IGluY2x1ZGVkIGZ1bmN0aW9uLlxcbiAgICogRnVuY3Rpb25zIHNob3VsZCByZXR1cm4gb25seSBhIGJvb2xlYW4gaWYgdGhlIGlucHV0IGlzIHZhbGlkIG9yIG5vdC4gRnVuY3Rpb25zIGFyZSBnaXZlbiB0aGUgZm9sbG93aW5nIGFyZ3VtZW50czpcXG4gICAqIGVsIDogVGhlIGpRdWVyeSBlbGVtZW50IHRvIHZhbGlkYXRlLlxcbiAgICogcmVxdWlyZWQgOiBCb29sZWFuIHZhbHVlIG9mIHRoZSByZXF1aXJlZCBhdHRyaWJ1dGUgYmUgcHJlc2VudCBvciBub3QuXFxuICAgKiBwYXJlbnQgOiBUaGUgZGlyZWN0IHBhcmVudCBvZiB0aGUgaW5wdXQuXFxuICAgKiBAb3B0aW9uXFxuICAgKi9cXG4gIHZhbGlkYXRvcnM6IHtcXG4gICAgZXF1YWxUbzogZnVuY3Rpb24gZXF1YWxUbyhlbCwgcmVxdWlyZWQsIHBhcmVudCkge1xcbiAgICAgIHJldHVybiBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoXFxcIiNcXFwiLmNvbmNhdChlbC5hdHRyKCdkYXRhLWVxdWFsdG8nKSkpLnZhbCgpID09PSBlbC52YWwoKTtcXG4gICAgfVxcbiAgfVxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi5hYmlkZS5qcz9cIil9LFwiLi9qcy9mb3VuZGF0aW9uLmFjY29yZGlvbi5qc1wiOmZ1bmN0aW9uKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiQWNjb3JkaW9uXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBBY2NvcmRpb247IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGpxdWVyeSAqLyBcXFwianF1ZXJ5XFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUudXRpbHMgKi8gXFxcIi4vanMvZm91bmRhdGlvbi5jb3JlLnV0aWxzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi51dGlsLmtleWJvYXJkICovIFxcXCIuL2pzL2ZvdW5kYXRpb24udXRpbC5rZXlib2FyZC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUucGx1Z2luICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS5wbHVnaW4uanNcXFwiKTtcXG5cXG5cXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxcblxcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XFxuXFxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXFxcIm9iamVjdFxcXCIgfHwgdHlwZW9mIGNhbGwgPT09IFxcXCJmdW5jdGlvblxcXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XFxuXFxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcXFwiKTsgfSByZXR1cm4gc2VsZjsgfVxcblxcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cXFwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XFxuXFxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cXG5cXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBBY2NvcmRpb24gbW9kdWxlLlxcbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5hY2NvcmRpb25cXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXFxuICovXFxuXFxudmFyIEFjY29yZGlvbiA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uIChfUGx1Z2luKSB7XFxuICBfaW5oZXJpdHMoQWNjb3JkaW9uLCBfUGx1Z2luKTtcXG5cXG4gIGZ1bmN0aW9uIEFjY29yZGlvbigpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFjY29yZGlvbik7XFxuXFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQWNjb3JkaW9uKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhBY2NvcmRpb24sIFt7XFxuICAgIGtleTogXFxcIl9zZXR1cFxcXCIsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGFuIGFjY29yZGlvbi5cXG4gICAgICogQGNsYXNzXFxuICAgICAqIEBuYW1lIEFjY29yZGlvblxcbiAgICAgKiBAZmlyZXMgQWNjb3JkaW9uI2luaXRcXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBhbiBhY2NvcmRpb24uXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gYSBwbGFpbiBvYmplY3Qgd2l0aCBzZXR0aW5ncyB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBvcHRpb25zLlxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XFxuICAgICAgdGhpcy5vcHRpb25zID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCh7fSwgQWNjb3JkaW9uLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XFxuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnQWNjb3JkaW9uJzsgLy8gaWU5IGJhY2sgY29tcGF0XFxuXFxuICAgICAgdGhpcy5faW5pdCgpO1xcblxcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiS2V5Ym9hcmRcXFwiXS5yZWdpc3RlcignQWNjb3JkaW9uJywge1xcbiAgICAgICAgJ0VOVEVSJzogJ3RvZ2dsZScsXFxuICAgICAgICAnU1BBQ0UnOiAndG9nZ2xlJyxcXG4gICAgICAgICdBUlJPV19ET1dOJzogJ25leHQnLFxcbiAgICAgICAgJ0FSUk9XX1VQJzogJ3ByZXZpb3VzJ1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgYWNjb3JkaW9uIGJ5IGFuaW1hdGluZyB0aGUgcHJlc2V0IGFjdGl2ZSBwYW5lKHMpLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2luaXRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy5faXNJbml0aWFsaXppbmcgPSB0cnVlO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cigncm9sZScsICd0YWJsaXN0Jyk7XFxuICAgICAgdGhpcy4kdGFicyA9IHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oJ1tkYXRhLWFjY29yZGlvbi1pdGVtXScpO1xcbiAgICAgIHRoaXMuJHRhYnMuZWFjaChmdW5jdGlvbiAoaWR4LCBlbCkge1xcbiAgICAgICAgdmFyICRlbCA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShlbCksXFxuICAgICAgICAgICAgJGNvbnRlbnQgPSAkZWwuY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpLFxcbiAgICAgICAgICAgIGlkID0gJGNvbnRlbnRbMF0uaWQgfHwgT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiR2V0WW9EaWdpdHNcXFwiXSkoNiwgJ2FjY29yZGlvbicpLFxcbiAgICAgICAgICAgIGxpbmtJZCA9IGVsLmlkID8gXFxcIlxcXCIuY29uY2F0KGVsLmlkLCBcXFwiLWxhYmVsXFxcIikgOiBcXFwiXFxcIi5jb25jYXQoaWQsIFxcXCItbGFiZWxcXFwiKTtcXG4gICAgICAgICRlbC5maW5kKCdhOmZpcnN0JykuYXR0cih7XFxuICAgICAgICAgICdhcmlhLWNvbnRyb2xzJzogaWQsXFxuICAgICAgICAgICdyb2xlJzogJ3RhYicsXFxuICAgICAgICAgICdpZCc6IGxpbmtJZCxcXG4gICAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBmYWxzZSxcXG4gICAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiBmYWxzZVxcbiAgICAgICAgfSk7XFxuICAgICAgICAkY29udGVudC5hdHRyKHtcXG4gICAgICAgICAgJ3JvbGUnOiAndGFicGFuZWwnLFxcbiAgICAgICAgICAnYXJpYS1sYWJlbGxlZGJ5JzogbGlua0lkLFxcbiAgICAgICAgICAnYXJpYS1oaWRkZW4nOiB0cnVlLFxcbiAgICAgICAgICAnaWQnOiBpZFxcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgICAgdmFyICRpbml0QWN0aXZlID0gdGhpcy4kZWxlbWVudC5maW5kKCcuaXMtYWN0aXZlJykuY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpO1xcblxcbiAgICAgIGlmICgkaW5pdEFjdGl2ZS5sZW5ndGgpIHtcXG4gICAgICAgIC8vIFNhdmUgdXAgdGhlIGluaXRpYWwgaGFzaCB0byByZXR1cm4gdG8gaXQgbGF0ZXIgd2hlbiBnb2luZyBiYWNrIGluIGhpc3RvcnlcXG4gICAgICAgIHRoaXMuX2luaXRpYWxBbmNob3IgPSAkaW5pdEFjdGl2ZS5wcmV2KCdhJykuYXR0cignaHJlZicpO1xcblxcbiAgICAgICAgdGhpcy5fb3BlblNpbmdsZVRhYigkaW5pdEFjdGl2ZSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2NoZWNrRGVlcExpbmsgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYW5jaG9yID0gd2luZG93LmxvY2F0aW9uLmhhc2g7XFxuXFxuICAgICAgICBpZiAoIWFuY2hvci5sZW5ndGgpIHtcXG4gICAgICAgICAgLy8gSWYgd2UgYXJlIHN0aWxsIGluaXRpYWxpemluZyBhbmQgdGhlcmUgaXMgbm8gYW5jaG9yLCB0aGVuIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG9cXG4gICAgICAgICAgaWYgKF90aGlzMi5faXNJbml0aWFsaXppbmcpIHJldHVybjsgLy8gT3RoZXJ3aXNlLCBtb3ZlIHRvIHRoZSBpbml0aWFsIGFuY2hvclxcblxcbiAgICAgICAgICBpZiAoX3RoaXMyLl9pbml0aWFsQW5jaG9yKSBhbmNob3IgPSBfdGhpczIuX2luaXRpYWxBbmNob3I7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgJGFuY2hvciA9IGFuY2hvciAmJiBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoYW5jaG9yKTtcXG5cXG4gICAgICAgIHZhciAkbGluayA9IGFuY2hvciAmJiBfdGhpczIuJGVsZW1lbnQuZmluZChcXFwiW2hyZWYkPVxcXFxcXFwiXFxcIi5jb25jYXQoYW5jaG9yLCBcXFwiXFxcXFxcXCJdXFxcIikpOyAvLyBXaGV0aGVyIHRoZSBhbmNob3IgZWxlbWVudCB0aGF0IGhhcyBiZWVuIGZvdW5kIGlzIHBhcnQgb2YgdGhpcyBlbGVtZW50XFxuXFxuXFxuICAgICAgICB2YXIgaXNPd25BbmNob3IgPSAhISgkYW5jaG9yLmxlbmd0aCAmJiAkbGluay5sZW5ndGgpOyAvLyBJZiB0aGVyZSBpcyBhbiBhbmNob3IgZm9yIHRoZSBoYXNoLCBvcGVuIGl0IChpZiBub3QgYWxyZWFkeSBhY3RpdmUpXFxuXFxuICAgICAgICBpZiAoJGFuY2hvciAmJiAkbGluayAmJiAkbGluay5sZW5ndGgpIHtcXG4gICAgICAgICAgaWYgKCEkbGluay5wYXJlbnQoJ1tkYXRhLWFjY29yZGlvbi1pdGVtXScpLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSkge1xcbiAgICAgICAgICAgIF90aGlzMi5fb3BlblNpbmdsZVRhYigkYW5jaG9yKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICA7XFxuICAgICAgICB9IC8vIE90aGVyd2lzZSwgY2xvc2UgZXZlcnl0aGluZ1xcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgX3RoaXMyLl9jbG9zZUFsbFRhYnMoKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGlzT3duQW5jaG9yKSB7XFxuICAgICAgICAgIC8vIFJvbGwgdXAgYSBsaXR0bGUgdG8gc2hvdyB0aGUgdGl0bGVzXFxuICAgICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5kZWVwTGlua1NtdWRnZSkge1xcbiAgICAgICAgICAgIE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIm9uTG9hZFxcXCJdKShqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IF90aGlzMi4kZWxlbWVudC5vZmZzZXQoKTtcXG5cXG4gICAgICAgICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnaHRtbCwgYm9keScpLmFuaW1hdGUoe1xcbiAgICAgICAgICAgICAgICBzY3JvbGxUb3A6IG9mZnNldC50b3BcXG4gICAgICAgICAgICAgIH0sIF90aGlzMi5vcHRpb25zLmRlZXBMaW5rU211ZGdlRGVsYXkpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIC8qKlxcbiAgICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBwbHVnaW4gaGFzIGRlZXBsaW5rZWQgYXQgcGFnZWxvYWRcXG4gICAgICAgICAgICogQGV2ZW50IEFjY29yZGlvbiNkZWVwbGlua1xcbiAgICAgICAgICAgKi9cXG5cXG5cXG4gICAgICAgICAgX3RoaXMyLiRlbGVtZW50LnRyaWdnZXIoJ2RlZXBsaW5rLnpmLmFjY29yZGlvbicsIFskbGluaywgJGFuY2hvcl0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07IC8vdXNlIGJyb3dzZXIgdG8gb3BlbiBhIHRhYiwgaWYgaXQgZXhpc3RzIGluIHRoaXMgdGFic2V0XFxuXFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluaykge1xcbiAgICAgICAgdGhpcy5fY2hlY2tEZWVwTGluaygpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9ldmVudHMoKTtcXG5cXG4gICAgICB0aGlzLl9pc0luaXRpYWxpemluZyA9IGZhbHNlO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciBpdGVtcyB3aXRoaW4gdGhlIGFjY29yZGlvbi5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9ldmVudHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgIHRoaXMuJHRhYnMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgJGVsZW0gPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcyk7XFxuICAgICAgICB2YXIgJHRhYkNvbnRlbnQgPSAkZWxlbS5jaGlsZHJlbignW2RhdGEtdGFiLWNvbnRlbnRdJyk7XFxuXFxuICAgICAgICBpZiAoJHRhYkNvbnRlbnQubGVuZ3RoKSB7XFxuICAgICAgICAgICRlbGVtLmNoaWxkcmVuKCdhJykub2ZmKCdjbGljay56Zi5hY2NvcmRpb24ga2V5ZG93bi56Zi5hY2NvcmRpb24nKS5vbignY2xpY2suemYuYWNjb3JkaW9uJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuXFxuICAgICAgICAgICAgX3RoaXMudG9nZ2xlKCR0YWJDb250ZW50KTtcXG4gICAgICAgICAgfSkub24oJ2tleWRvd24uemYuYWNjb3JkaW9uJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIktleWJvYXJkXFxcIl0uaGFuZGxlS2V5KGUsICdBY2NvcmRpb24nLCB7XFxuICAgICAgICAgICAgICB0b2dnbGU6IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcXG4gICAgICAgICAgICAgICAgX3RoaXMudG9nZ2xlKCR0YWJDb250ZW50KTtcXG4gICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xcbiAgICAgICAgICAgICAgICB2YXIgJGEgPSAkZWxlbS5uZXh0KCkuZmluZCgnYScpLmZvY3VzKCk7XFxuXFxuICAgICAgICAgICAgICAgIGlmICghX3RoaXMub3B0aW9ucy5tdWx0aUV4cGFuZCkge1xcbiAgICAgICAgICAgICAgICAgICRhLnRyaWdnZXIoJ2NsaWNrLnpmLmFjY29yZGlvbicpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgcHJldmlvdXM6IGZ1bmN0aW9uIHByZXZpb3VzKCkge1xcbiAgICAgICAgICAgICAgICB2YXIgJGEgPSAkZWxlbS5wcmV2KCkuZmluZCgnYScpLmZvY3VzKCk7XFxuXFxuICAgICAgICAgICAgICAgIGlmICghX3RoaXMub3B0aW9ucy5tdWx0aUV4cGFuZCkge1xcbiAgICAgICAgICAgICAgICAgICRhLnRyaWdnZXIoJ2NsaWNrLnpmLmFjY29yZGlvbicpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24gaGFuZGxlZCgpIHtcXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5rKSB7XFxuICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS5vbignaGFzaGNoYW5nZScsIHRoaXMuX2NoZWNrRGVlcExpbmspO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogVG9nZ2xlcyB0aGUgc2VsZWN0ZWQgY29udGVudCBwYW5lJ3Mgb3Blbi9jbG9zZSBzdGF0ZS5cXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSBqUXVlcnkgb2JqZWN0IG9mIHRoZSBwYW5lIHRvIHRvZ2dsZSAoYC5hY2NvcmRpb24tY29udGVudGApLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInRvZ2dsZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGUoJHRhcmdldCkge1xcbiAgICAgIGlmICgkdGFyZ2V0LmNsb3Nlc3QoJ1tkYXRhLWFjY29yZGlvbl0nKS5pcygnW2Rpc2FibGVkXScpKSB7XFxuICAgICAgICBjb25zb2xlLmluZm8oJ0Nhbm5vdCB0b2dnbGUgYW4gYWNjb3JkaW9uIHRoYXQgaXMgZGlzYWJsZWQuJyk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICgkdGFyZ2V0LnBhcmVudCgpLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSkge1xcbiAgICAgICAgdGhpcy51cCgkdGFyZ2V0KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5kb3duKCR0YXJnZXQpO1xcbiAgICAgIH0gLy9laXRoZXIgcmVwbGFjZSBvciB1cGRhdGUgYnJvd3NlciBoaXN0b3J5XFxuXFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluaykge1xcbiAgICAgICAgdmFyIGFuY2hvciA9ICR0YXJnZXQucHJldignYScpLmF0dHIoJ2hyZWYnKTtcXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBkYXRlSGlzdG9yeSkge1xcbiAgICAgICAgICBoaXN0b3J5LnB1c2hTdGF0ZSh7fSwgJycsIGFuY2hvcik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZSh7fSwgJycsIGFuY2hvcik7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBPcGVucyB0aGUgYWNjb3JkaW9uIHRhYiBkZWZpbmVkIGJ5IGAkdGFyZ2V0YC5cXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSBBY2NvcmRpb24gcGFuZSB0byBvcGVuIChgLmFjY29yZGlvbi1jb250ZW50YCkuXFxuICAgICAqIEBmaXJlcyBBY2NvcmRpb24jZG93blxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImRvd25cXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG93bigkdGFyZ2V0KSB7XFxuICAgICAgaWYgKCR0YXJnZXQuY2xvc2VzdCgnW2RhdGEtYWNjb3JkaW9uXScpLmlzKCdbZGlzYWJsZWRdJykpIHtcXG4gICAgICAgIGNvbnNvbGUuaW5mbygnQ2Fubm90IGNhbGwgZG93biBvbiBhbiBhY2NvcmRpb24gdGhhdCBpcyBkaXNhYmxlZC4nKTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5tdWx0aUV4cGFuZCkgdGhpcy5fb3BlblRhYigkdGFyZ2V0KTtlbHNlIHRoaXMuX29wZW5TaW5nbGVUYWIoJHRhcmdldCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENsb3NlcyB0aGUgdGFiIGRlZmluZWQgYnkgYCR0YXJnZXRgLlxcbiAgICAgKiBJdCBtYXkgYmUgaWdub3JlZCBpZiB0aGUgQWNjb3JkaW9uIG9wdGlvbnMgZG9uJ3QgYWxsb3cgaXQuXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gQWNjb3JkaW9uIHRhYiB0byBjbG9zZSAoYC5hY2NvcmRpb24tY29udGVudGApLlxcbiAgICAgKiBAZmlyZXMgQWNjb3JkaW9uI3VwXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidXBcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXAoJHRhcmdldCkge1xcbiAgICAgIGlmICh0aGlzLiRlbGVtZW50LmlzKCdbZGlzYWJsZWRdJykpIHtcXG4gICAgICAgIGNvbnNvbGUuaW5mbygnQ2Fubm90IGNhbGwgdXAgb24gYW4gYWNjb3JkaW9uIHRoYXQgaXMgZGlzYWJsZWQuJyk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfSAvLyBEb24ndCBjbG9zZSB0aGUgaXRlbSBpZiBpdCBpcyBhbHJlYWR5IGNsb3NlZFxcblxcblxcbiAgICAgIHZhciAkdGFyZ2V0SXRlbSA9ICR0YXJnZXQucGFyZW50KCk7XFxuICAgICAgaWYgKCEkdGFyZ2V0SXRlbS5oYXNDbGFzcygnaXMtYWN0aXZlJykpIHJldHVybjsgLy8gRG9uJ3QgY2xvc2UgdGhlIGl0ZW0gaWYgdGhlcmUgaXMgbm8gb3RoZXIgYWN0aXZlIGl0ZW0gKHVubGVzcyB3aXRoIGBhbGxvd0FsbENsb3NlZGApXFxuXFxuICAgICAgdmFyICRvdGhlcnNJdGVtcyA9ICR0YXJnZXRJdGVtLnNpYmxpbmdzKCk7XFxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxsb3dBbGxDbG9zZWQgJiYgISRvdGhlcnNJdGVtcy5oYXNDbGFzcygnaXMtYWN0aXZlJykpIHJldHVybjtcXG5cXG4gICAgICB0aGlzLl9jbG9zZVRhYigkdGFyZ2V0KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogTWFrZSB0aGUgdGFiIGRlZmluZWQgYnkgYCR0YXJnZXRgIHRoZSBvbmx5IG9wZW5lZCB0YWIsIGNsb3NpbmcgYWxsIG90aGVycyB0YWJzLlxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIEFjY29yZGlvbiB0YWIgdG8gb3BlbiAoYC5hY2NvcmRpb24tY29udGVudGApLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9vcGVuU2luZ2xlVGFiXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vcGVuU2luZ2xlVGFiKCR0YXJnZXQpIHtcXG4gICAgICAvLyBDbG9zZSBhbGwgdGhlIG90aGVycyBhY3RpdmUgdGFicy5cXG4gICAgICB2YXIgJGFjdGl2ZUNvbnRlbnRzID0gdGhpcy4kZWxlbWVudC5jaGlsZHJlbignLmlzLWFjdGl2ZScpLmNoaWxkcmVuKCdbZGF0YS10YWItY29udGVudF0nKTtcXG5cXG4gICAgICBpZiAoJGFjdGl2ZUNvbnRlbnRzLmxlbmd0aCkge1xcbiAgICAgICAgdGhpcy5fY2xvc2VUYWIoJGFjdGl2ZUNvbnRlbnRzLm5vdCgkdGFyZ2V0KSk7XFxuICAgICAgfSAvLyBUaGVuIG9wZW4gdGhlIHRhcmdldC5cXG5cXG5cXG4gICAgICB0aGlzLl9vcGVuVGFiKCR0YXJnZXQpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBPcGVucyB0aGUgdGFiIGRlZmluZWQgYnkgYCR0YXJnZXRgLlxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIEFjY29yZGlvbiB0YWIgdG8gb3BlbiAoYC5hY2NvcmRpb24tY29udGVudGApLlxcbiAgICAgKiBAZmlyZXMgQWNjb3JkaW9uI2Rvd25cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfb3BlblRhYlxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb3BlblRhYigkdGFyZ2V0KSB7XFxuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XFxuXFxuICAgICAgdmFyICR0YXJnZXRJdGVtID0gJHRhcmdldC5wYXJlbnQoKTtcXG4gICAgICB2YXIgdGFyZ2V0Q29udGVudElkID0gJHRhcmdldC5hdHRyKCdhcmlhLWxhYmVsbGVkYnknKTtcXG4gICAgICAkdGFyZ2V0LmF0dHIoJ2FyaWEtaGlkZGVuJywgZmFsc2UpO1xcbiAgICAgICR0YXJnZXRJdGVtLmFkZENsYXNzKCdpcy1hY3RpdmUnKTtcXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoXFxcIiNcXFwiLmNvbmNhdCh0YXJnZXRDb250ZW50SWQpKS5hdHRyKHtcXG4gICAgICAgICdhcmlhLWV4cGFuZGVkJzogdHJ1ZSxcXG4gICAgICAgICdhcmlhLXNlbGVjdGVkJzogdHJ1ZVxcbiAgICAgIH0pO1xcbiAgICAgICR0YXJnZXQuc2xpZGVEb3duKHRoaXMub3B0aW9ucy5zbGlkZVNwZWVkLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHRhYiBpcyBkb25lIG9wZW5pbmcuXFxuICAgICAgICAgKiBAZXZlbnQgQWNjb3JkaW9uI2Rvd25cXG4gICAgICAgICAqL1xcbiAgICAgICAgX3RoaXMzLiRlbGVtZW50LnRyaWdnZXIoJ2Rvd24uemYuYWNjb3JkaW9uJywgWyR0YXJnZXRdKTtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2xvc2VzIHRoZSB0YWIgZGVmaW5lZCBieSBgJHRhcmdldGAuXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gQWNjb3JkaW9uIHRhYiB0byBjbG9zZSAoYC5hY2NvcmRpb24tY29udGVudGApLlxcbiAgICAgKiBAZmlyZXMgQWNjb3JkaW9uI3VwXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2Nsb3NlVGFiXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbG9zZVRhYigkdGFyZ2V0KSB7XFxuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XFxuXFxuICAgICAgdmFyICR0YXJnZXRJdGVtID0gJHRhcmdldC5wYXJlbnQoKTtcXG4gICAgICB2YXIgdGFyZ2V0Q29udGVudElkID0gJHRhcmdldC5hdHRyKCdhcmlhLWxhYmVsbGVkYnknKTtcXG4gICAgICAkdGFyZ2V0LmF0dHIoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XFxuICAgICAgJHRhcmdldEl0ZW0ucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpO1xcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShcXFwiI1xcXCIuY29uY2F0KHRhcmdldENvbnRlbnRJZCkpLmF0dHIoe1xcbiAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBmYWxzZSxcXG4gICAgICAgICdhcmlhLXNlbGVjdGVkJzogZmFsc2VcXG4gICAgICB9KTtcXG4gICAgICAkdGFyZ2V0LnNsaWRlVXAodGhpcy5vcHRpb25zLnNsaWRlU3BlZWQsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdGFiIGlzIGRvbmUgY29sbGFwc2luZyB1cC5cXG4gICAgICAgICAqIEBldmVudCBBY2NvcmRpb24jdXBcXG4gICAgICAgICAqL1xcbiAgICAgICAgX3RoaXM0LiRlbGVtZW50LnRyaWdnZXIoJ3VwLnpmLmFjY29yZGlvbicsIFskdGFyZ2V0XSk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENsb3NlcyBhbGwgYWN0aXZlIHRhYnNcXG4gICAgICogQGZpcmVzIEFjY29yZGlvbiN1cFxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9jbG9zZUFsbFRhYnNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Nsb3NlQWxsVGFicygpIHtcXG4gICAgICB2YXIgJGFjdGl2ZVRhYnMgPSB0aGlzLiRlbGVtZW50LmNoaWxkcmVuKCcuaXMtYWN0aXZlJykuY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpO1xcblxcbiAgICAgIGlmICgkYWN0aXZlVGFicy5sZW5ndGgpIHtcXG4gICAgICAgIHRoaXMuX2Nsb3NlVGFiKCRhY3RpdmVUYWJzKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIGFuIGFjY29yZGlvbi5cXG4gICAgICogQGZpcmVzIEFjY29yZGlvbiNkZXN0cm95ZWRcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZGVzdHJveVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXRhYi1jb250ZW50XScpLnN0b3AodHJ1ZSkuc2xpZGVVcCgwKS5jc3MoJ2Rpc3BsYXknLCAnJyk7XFxuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdhJykub2ZmKCcuemYuYWNjb3JkaW9uJyk7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluaykge1xcbiAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub2ZmKCdoYXNoY2hhbmdlJywgdGhpcy5fY2hlY2tEZWVwTGluayk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gQWNjb3JkaW9uO1xcbn0oX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiUGx1Z2luXFxcIl0pO1xcblxcbkFjY29yZGlvbi5kZWZhdWx0cyA9IHtcXG4gIC8qKlxcbiAgICogQW1vdW50IG9mIHRpbWUgdG8gYW5pbWF0ZSB0aGUgb3BlbmluZyBvZiBhbiBhY2NvcmRpb24gcGFuZS5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAyNTBcXG4gICAqL1xcbiAgc2xpZGVTcGVlZDogMjUwLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvdyB0aGUgYWNjb3JkaW9uIHRvIGhhdmUgbXVsdGlwbGUgb3BlbiBwYW5lcy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgbXVsdGlFeHBhbmQ6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvdyB0aGUgYWNjb3JkaW9uIHRvIGNsb3NlIGFsbCBwYW5lcy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgYWxsb3dBbGxDbG9zZWQ6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBMaW5rIHRoZSBsb2NhdGlvbiBoYXNoIHRvIHRoZSBvcGVuIHBhbmUuXFxuICAgKiBTZXQgdGhlIGxvY2F0aW9uIGhhc2ggd2hlbiB0aGUgb3BlbmVkIHBhbmUgY2hhbmdlcywgYW5kIG9wZW4gYW5kIHNjcm9sbCB0byB0aGUgY29ycmVzcG9uZGluZyBwYW5lIHdoZW4gdGhlIGxvY2F0aW9uIGNoYW5nZXMuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGRlZXBMaW5rOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogSWYgYGRlZXBMaW5rYCBpcyBlbmFibGVkLCBhZGp1c3QgdGhlIGRlZXAgbGluayBzY3JvbGwgdG8gbWFrZSBzdXJlIHRoZSB0b3Agb2YgdGhlIGFjY29yZGlvbiBwYW5lbCBpcyB2aXNpYmxlXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGRlZXBMaW5rU211ZGdlOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogSWYgYGRlZXBMaW5rU211ZGdlYCBpcyBlbmFibGVkLCBhbmltYXRpb24gdGltZSAobXMpIGZvciB0aGUgZGVlcCBsaW5rIGFkanVzdG1lbnRcXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAzMDBcXG4gICAqL1xcbiAgZGVlcExpbmtTbXVkZ2VEZWxheTogMzAwLFxcblxcbiAgLyoqXFxuICAgKiBJZiBgZGVlcExpbmtgIGlzIGVuYWJsZWQsIHVwZGF0ZSB0aGUgYnJvd3NlciBoaXN0b3J5IHdpdGggdGhlIG9wZW4gYWNjb3JkaW9uXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIHVwZGF0ZUhpc3Rvcnk6IGZhbHNlXFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9qcy9mb3VuZGF0aW9uLmFjY29yZGlvbi5qcz9cIil9LFwiLi9qcy9mb3VuZGF0aW9uLmFjY29yZGlvbk1lbnUuanNcIjpmdW5jdGlvbihtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkFjY29yZGlvbk1lbnVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEFjY29yZGlvbk1lbnU7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGpxdWVyeSAqLyBcXFwianF1ZXJ5XFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmQgKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLmtleWJvYXJkLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3V0aWxfbmVzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwubmVzdCAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwubmVzdC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uY29yZS51dGlscyAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUudXRpbHMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnBsdWdpbiAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUucGx1Z2luLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxcblxcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXFxcIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxcblxcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XFxuXFxuXFxuXFxuXFxuXFxuXFxuLyoqXFxuICogQWNjb3JkaW9uTWVudSBtb2R1bGUuXFxuICogQG1vZHVsZSBmb3VuZGF0aW9uLmFjY29yZGlvbk1lbnVcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5uZXN0XFxuICovXFxuXFxudmFyIEFjY29yZGlvbk1lbnUgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoX1BsdWdpbikge1xcbiAgX2luaGVyaXRzKEFjY29yZGlvbk1lbnUsIF9QbHVnaW4pO1xcblxcbiAgZnVuY3Rpb24gQWNjb3JkaW9uTWVudSgpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFjY29yZGlvbk1lbnUpO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFjY29yZGlvbk1lbnUpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKEFjY29yZGlvbk1lbnUsIFt7XFxuICAgIGtleTogXFxcIl9zZXR1cFxcXCIsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGFuIGFjY29yZGlvbiBtZW51LlxcbiAgICAgKiBAY2xhc3NcXG4gICAgICogQG5hbWUgQWNjb3JkaW9uTWVudVxcbiAgICAgKiBAZmlyZXMgQWNjb3JkaW9uTWVudSNpbml0XFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYW4gYWNjb3JkaW9uIG1lbnUuXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cXG4gICAgICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMub3B0aW9ucyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoe30sIEFjY29yZGlvbk1lbnUuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdBY2NvcmRpb25NZW51JzsgLy8gaWU5IGJhY2sgY29tcGF0XFxuXFxuICAgICAgdGhpcy5faW5pdCgpO1xcblxcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiS2V5Ym9hcmRcXFwiXS5yZWdpc3RlcignQWNjb3JkaW9uTWVudScsIHtcXG4gICAgICAgICdFTlRFUic6ICd0b2dnbGUnLFxcbiAgICAgICAgJ1NQQUNFJzogJ3RvZ2dsZScsXFxuICAgICAgICAnQVJST1dfUklHSFQnOiAnb3BlbicsXFxuICAgICAgICAnQVJST1dfVVAnOiAndXAnLFxcbiAgICAgICAgJ0FSUk9XX0RPV04nOiAnZG93bicsXFxuICAgICAgICAnQVJST1dfTEVGVCc6ICdjbG9zZScsXFxuICAgICAgICAnRVNDQVBFJzogJ2Nsb3NlQWxsJ1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgYWNjb3JkaW9uIG1lbnUgYnkgaGlkaW5nIGFsbCBuZXN0ZWQgbWVudXMuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfaW5pdFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcXG4gICAgICBfZm91bmRhdGlvbl91dGlsX25lc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiTmVzdFxcXCJdLkZlYXRoZXIodGhpcy4kZWxlbWVudCwgJ2FjY29yZGlvbicpO1xcblxcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1zdWJtZW51XScpLm5vdCgnLmlzLWFjdGl2ZScpLnNsaWRlVXAoMCk7IC8vLmZpbmQoJ2EnKS5jc3MoJ3BhZGRpbmctbGVmdCcsICcxcmVtJyk7XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcXG4gICAgICAgICdyb2xlJzogJ3RyZWUnLFxcbiAgICAgICAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogdGhpcy5vcHRpb25zLm11bHRpT3BlblxcbiAgICAgIH0pO1xcbiAgICAgIHRoaXMuJG1lbnVMaW5rcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLmlzLWFjY29yZGlvbi1zdWJtZW51LXBhcmVudCcpO1xcbiAgICAgIHRoaXMuJG1lbnVMaW5rcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBsaW5rSWQgPSB0aGlzLmlkIHx8IE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcIkdldFlvRGlnaXRzXFxcIl0pKDYsICdhY2MtbWVudS1saW5rJyksXFxuICAgICAgICAgICAgJGVsZW0gPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcyksXFxuICAgICAgICAgICAgJHN1YiA9ICRlbGVtLmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpLFxcbiAgICAgICAgICAgIHN1YklkID0gJHN1YlswXS5pZCB8fCBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJHZXRZb0RpZ2l0c1xcXCJdKSg2LCAnYWNjLW1lbnUnKSxcXG4gICAgICAgICAgICBpc0FjdGl2ZSA9ICRzdWIuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpO1xcblxcbiAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMucGFyZW50TGluaykge1xcbiAgICAgICAgICB2YXIgJGFuY2hvciA9ICRlbGVtLmNoaWxkcmVuKCdhJyk7XFxuICAgICAgICAgICRhbmNob3IuY2xvbmUoKS5wcmVwZW5kVG8oJHN1Yikud3JhcCgnPGxpIGRhdGEtaXMtcGFyZW50LWxpbmsgY2xhc3M9XFxcImlzLXN1Ym1lbnUtcGFyZW50LWl0ZW0gaXMtc3VibWVudS1pdGVtIGlzLWFjY29yZGlvbi1zdWJtZW51LWl0ZW1cXFwiPjwvbGk+Jyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5zdWJtZW51VG9nZ2xlKSB7XFxuICAgICAgICAgICRlbGVtLmFkZENsYXNzKCdoYXMtc3VibWVudS10b2dnbGUnKTtcXG4gICAgICAgICAgJGVsZW0uY2hpbGRyZW4oJ2EnKS5hZnRlcignPGJ1dHRvbiBpZD1cXFwiJyArIGxpbmtJZCArICdcXFwiIGNsYXNzPVxcXCJzdWJtZW51LXRvZ2dsZVxcXCIgYXJpYS1jb250cm9scz1cXFwiJyArIHN1YklkICsgJ1xcXCIgYXJpYS1leHBhbmRlZD1cXFwiJyArIGlzQWN0aXZlICsgJ1xcXCIgdGl0bGU9XFxcIicgKyBfdGhpcy5vcHRpb25zLnN1Ym1lbnVUb2dnbGVUZXh0ICsgJ1xcXCI+PHNwYW4gY2xhc3M9XFxcInN1Ym1lbnUtdG9nZ2xlLXRleHRcXFwiPicgKyBfdGhpcy5vcHRpb25zLnN1Ym1lbnVUb2dnbGVUZXh0ICsgJzwvc3Bhbj48L2J1dHRvbj4nKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICRlbGVtLmF0dHIoe1xcbiAgICAgICAgICAgICdhcmlhLWNvbnRyb2xzJzogc3ViSWQsXFxuICAgICAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBpc0FjdGl2ZSxcXG4gICAgICAgICAgICAnaWQnOiBsaW5rSWRcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAkc3ViLmF0dHIoe1xcbiAgICAgICAgICAnYXJpYS1sYWJlbGxlZGJ5JzogbGlua0lkLFxcbiAgICAgICAgICAnYXJpYS1oaWRkZW4nOiAhaXNBY3RpdmUsXFxuICAgICAgICAgICdyb2xlJzogJ2dyb3VwJyxcXG4gICAgICAgICAgJ2lkJzogc3ViSWRcXG4gICAgICAgIH0pO1xcbiAgICAgIH0pO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnbGknKS5hdHRyKHtcXG4gICAgICAgICdyb2xlJzogJ3RyZWVpdGVtJ1xcbiAgICAgIH0pO1xcbiAgICAgIHZhciBpbml0UGFuZXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5pcy1hY3RpdmUnKTtcXG5cXG4gICAgICBpZiAoaW5pdFBhbmVzLmxlbmd0aCkge1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICAgIGluaXRQYW5lcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgX3RoaXMuZG93bihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2V2ZW50cygpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciBpdGVtcyB3aXRoaW4gdGhlIG1lbnUuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZXZlbnRzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ2xpJykuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgJHN1Ym1lbnUgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJyk7XFxuXFxuICAgICAgICBpZiAoJHN1Ym1lbnUubGVuZ3RoKSB7XFxuICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnN1Ym1lbnVUb2dnbGUpIHtcXG4gICAgICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykuY2hpbGRyZW4oJy5zdWJtZW51LXRvZ2dsZScpLm9mZignY2xpY2suemYuYWNjb3JkaW9uTWVudScpLm9uKCdjbGljay56Zi5hY2NvcmRpb25NZW51JywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICAgIF90aGlzLnRvZ2dsZSgkc3VibWVudSk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLmNoaWxkcmVuKCdhJykub2ZmKCdjbGljay56Zi5hY2NvcmRpb25NZW51Jykub24oJ2NsaWNrLnpmLmFjY29yZGlvbk1lbnUnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcbiAgICAgICAgICAgICAgX3RoaXMudG9nZ2xlKCRzdWJtZW51KTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0pLm9uKCdrZXlkb3duLnpmLmFjY29yZGlvbm1lbnUnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgdmFyICRlbGVtZW50ID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLFxcbiAgICAgICAgICAgICRlbGVtZW50cyA9ICRlbGVtZW50LnBhcmVudCgndWwnKS5jaGlsZHJlbignbGknKSxcXG4gICAgICAgICAgICAkcHJldkVsZW1lbnQsXFxuICAgICAgICAgICAgJG5leHRFbGVtZW50LFxcbiAgICAgICAgICAgICR0YXJnZXQgPSAkZWxlbWVudC5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKTtcXG4gICAgICAgICRlbGVtZW50cy5lYWNoKGZ1bmN0aW9uIChpKSB7XFxuICAgICAgICAgIGlmIChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykuaXMoJGVsZW1lbnQpKSB7XFxuICAgICAgICAgICAgJHByZXZFbGVtZW50ID0gJGVsZW1lbnRzLmVxKE1hdGgubWF4KDAsIGkgLSAxKSkuZmluZCgnYScpLmZpcnN0KCk7XFxuICAgICAgICAgICAgJG5leHRFbGVtZW50ID0gJGVsZW1lbnRzLmVxKE1hdGgubWluKGkgKyAxLCAkZWxlbWVudHMubGVuZ3RoIC0gMSkpLmZpbmQoJ2EnKS5maXJzdCgpO1xcblxcbiAgICAgICAgICAgIGlmIChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdOnZpc2libGUnKS5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgIC8vIGhhcyBvcGVuIHN1YiBtZW51XFxuICAgICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudC5maW5kKCdsaTpmaXJzdC1jaGlsZCcpLmZpbmQoJ2EnKS5maXJzdCgpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLmlzKCc6Zmlyc3QtY2hpbGQnKSkge1xcbiAgICAgICAgICAgICAgLy8gaXMgZmlyc3QgZWxlbWVudCBvZiBzdWIgbWVudVxcbiAgICAgICAgICAgICAgJHByZXZFbGVtZW50ID0gJGVsZW1lbnQucGFyZW50cygnbGknKS5maXJzdCgpLmZpbmQoJ2EnKS5maXJzdCgpO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJHByZXZFbGVtZW50LnBhcmVudHMoJ2xpJykuZmlyc3QoKS5jaGlsZHJlbignW2RhdGEtc3VibWVudV06dmlzaWJsZScpLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgLy8gaWYgcHJldmlvdXMgZWxlbWVudCBoYXMgb3BlbiBzdWIgbWVudVxcbiAgICAgICAgICAgICAgJHByZXZFbGVtZW50ID0gJHByZXZFbGVtZW50LnBhcmVudHMoJ2xpJykuZmluZCgnbGk6bGFzdC1jaGlsZCcpLmZpbmQoJ2EnKS5maXJzdCgpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLmlzKCc6bGFzdC1jaGlsZCcpKSB7XFxuICAgICAgICAgICAgICAvLyBpcyBsYXN0IGVsZW1lbnQgb2Ygc3ViIG1lbnVcXG4gICAgICAgICAgICAgICRuZXh0RWxlbWVudCA9ICRlbGVtZW50LnBhcmVudHMoJ2xpJykuZmlyc3QoKS5uZXh0KCdsaScpLmZpbmQoJ2EnKS5maXJzdCgpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgICAgX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJLZXlib2FyZFxcXCJdLmhhbmRsZUtleShlLCAnQWNjb3JkaW9uTWVudScsIHtcXG4gICAgICAgICAgb3BlbjogZnVuY3Rpb24gb3BlbigpIHtcXG4gICAgICAgICAgICBpZiAoJHRhcmdldC5pcygnOmhpZGRlbicpKSB7XFxuICAgICAgICAgICAgICBfdGhpcy5kb3duKCR0YXJnZXQpO1xcblxcbiAgICAgICAgICAgICAgJHRhcmdldC5maW5kKCdsaScpLmZpcnN0KCkuZmluZCgnYScpLmZpcnN0KCkuZm9jdXMoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcXG4gICAgICAgICAgICBpZiAoJHRhcmdldC5sZW5ndGggJiYgISR0YXJnZXQuaXMoJzpoaWRkZW4nKSkge1xcbiAgICAgICAgICAgICAgLy8gY2xvc2UgYWN0aXZlIHN1YiBvZiB0aGlzIGl0ZW1cXG4gICAgICAgICAgICAgIF90aGlzLnVwKCR0YXJnZXQpO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJGVsZW1lbnQucGFyZW50KCdbZGF0YS1zdWJtZW51XScpLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgLy8gY2xvc2UgY3VycmVudGx5IG9wZW4gc3ViXFxuICAgICAgICAgICAgICBfdGhpcy51cCgkZWxlbWVudC5wYXJlbnQoJ1tkYXRhLXN1Ym1lbnVdJykpO1xcblxcbiAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50cygnbGknKS5maXJzdCgpLmZpbmQoJ2EnKS5maXJzdCgpLmZvY3VzKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9LFxcbiAgICAgICAgICB1cDogZnVuY3Rpb24gdXAoKSB7XFxuICAgICAgICAgICAgJHByZXZFbGVtZW50LmZvY3VzKCk7XFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIGRvd246IGZ1bmN0aW9uIGRvd24oKSB7XFxuICAgICAgICAgICAgJG5leHRFbGVtZW50LmZvY3VzKCk7XFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIHRvZ2dsZTogZnVuY3Rpb24gdG9nZ2xlKCkge1xcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnN1Ym1lbnVUb2dnbGUpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKCRlbGVtZW50LmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgX3RoaXMudG9nZ2xlKCRlbGVtZW50LmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpKTtcXG5cXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgY2xvc2VBbGw6IGZ1bmN0aW9uIGNsb3NlQWxsKCkge1xcbiAgICAgICAgICAgIF90aGlzLmhpZGVBbGwoKTtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24gaGFuZGxlZChwcmV2ZW50RGVmYXVsdCkge1xcbiAgICAgICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCkge1xcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9KTsgLy8uYXR0cigndGFiaW5kZXgnLCAwKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2xvc2VzIGFsbCBwYW5lcyBvZiB0aGUgbWVudS5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJoaWRlQWxsXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGVBbGwoKSB7XFxuICAgICAgdGhpcy51cCh0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXN1Ym1lbnVdJykpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBPcGVucyBhbGwgcGFuZXMgb2YgdGhlIG1lbnUuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwic2hvd0FsbFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93QWxsKCkge1xcbiAgICAgIHRoaXMuZG93bih0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXN1Ym1lbnVdJykpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBUb2dnbGVzIHRoZSBvcGVuL2Nsb3NlIHN0YXRlIG9mIGEgc3VibWVudS5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gdGhlIHN1Ym1lbnUgdG8gdG9nZ2xlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ0b2dnbGVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlKCR0YXJnZXQpIHtcXG4gICAgICBpZiAoISR0YXJnZXQuaXMoJzphbmltYXRlZCcpKSB7XFxuICAgICAgICBpZiAoISR0YXJnZXQuaXMoJzpoaWRkZW4nKSkge1xcbiAgICAgICAgICB0aGlzLnVwKCR0YXJnZXQpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy5kb3duKCR0YXJnZXQpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogT3BlbnMgdGhlIHN1Yi1tZW51IGRlZmluZWQgYnkgYCR0YXJnZXRgLlxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIFN1Yi1tZW51IHRvIG9wZW4uXFxuICAgICAqIEBmaXJlcyBBY2NvcmRpb25NZW51I2Rvd25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImRvd25cXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG93bigkdGFyZ2V0KSB7XFxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubXVsdGlPcGVuKSB7XFxuICAgICAgICB0aGlzLnVwKHRoaXMuJGVsZW1lbnQuZmluZCgnLmlzLWFjdGl2ZScpLm5vdCgkdGFyZ2V0LnBhcmVudHNVbnRpbCh0aGlzLiRlbGVtZW50KS5hZGQoJHRhcmdldCkpKTtcXG4gICAgICB9XFxuXFxuICAgICAgJHRhcmdldC5hZGRDbGFzcygnaXMtYWN0aXZlJykuYXR0cih7XFxuICAgICAgICAnYXJpYS1oaWRkZW4nOiBmYWxzZVxcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3VibWVudVRvZ2dsZSkge1xcbiAgICAgICAgJHRhcmdldC5wcmV2KCcuc3VibWVudS10b2dnbGUnKS5hdHRyKHtcXG4gICAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiB0cnVlXFxuICAgICAgICB9KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgJHRhcmdldC5wYXJlbnQoJy5pcy1hY2NvcmRpb24tc3VibWVudS1wYXJlbnQnKS5hdHRyKHtcXG4gICAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiB0cnVlXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgJHRhcmdldC5zbGlkZURvd24odGhpcy5vcHRpb25zLnNsaWRlU3BlZWQsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgbWVudSBpcyBkb25lIG9wZW5pbmcuXFxuICAgICAgICAgKiBAZXZlbnQgQWNjb3JkaW9uTWVudSNkb3duXFxuICAgICAgICAgKi9cXG4gICAgICAgIF90aGlzMi4kZWxlbWVudC50cmlnZ2VyKCdkb3duLnpmLmFjY29yZGlvbk1lbnUnLCBbJHRhcmdldF0pO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDbG9zZXMgdGhlIHN1Yi1tZW51IGRlZmluZWQgYnkgYCR0YXJnZXRgLiBBbGwgc3ViLW1lbnVzIGluc2lkZSB0aGUgdGFyZ2V0IHdpbGwgYmUgY2xvc2VkIGFzIHdlbGwuXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gU3ViLW1lbnUgdG8gY2xvc2UuXFxuICAgICAqIEBmaXJlcyBBY2NvcmRpb25NZW51I3VwXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ1cFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cCgkdGFyZ2V0KSB7XFxuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XFxuXFxuICAgICAgdmFyICRzdWJtZW51cyA9ICR0YXJnZXQuZmluZCgnW2RhdGEtc3VibWVudV0nKTtcXG4gICAgICB2YXIgJGFsbG1lbnVzID0gJHRhcmdldC5hZGQoJHN1Ym1lbnVzKTtcXG4gICAgICAkc3VibWVudXMuc2xpZGVVcCgwKTtcXG4gICAgICAkYWxsbWVudXMucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpLmF0dHIoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdWJtZW51VG9nZ2xlKSB7XFxuICAgICAgICAkYWxsbWVudXMucHJldignLnN1Ym1lbnUtdG9nZ2xlJykuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgJGFsbG1lbnVzLnBhcmVudCgnLmlzLWFjY29yZGlvbi1zdWJtZW51LXBhcmVudCcpLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XFxuICAgICAgfVxcblxcbiAgICAgICR0YXJnZXQuc2xpZGVVcCh0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBtZW51IGlzIGRvbmUgY29sbGFwc2luZyB1cC5cXG4gICAgICAgICAqIEBldmVudCBBY2NvcmRpb25NZW51I3VwXFxuICAgICAgICAgKi9cXG4gICAgICAgIF90aGlzMy4kZWxlbWVudC50cmlnZ2VyKCd1cC56Zi5hY2NvcmRpb25NZW51JywgWyR0YXJnZXRdKTtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgYWNjb3JkaW9uIG1lbnUuXFxuICAgICAqIEBmaXJlcyBBY2NvcmRpb25NZW51I2Rlc3Ryb3llZFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2Rlc3Ryb3lcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1zdWJtZW51XScpLnNsaWRlRG93bigwKS5jc3MoJ2Rpc3BsYXknLCAnJyk7XFxuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdhJykub2ZmKCdjbGljay56Zi5hY2NvcmRpb25NZW51Jyk7XFxuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1pcy1wYXJlbnQtbGlua10nKS5kZXRhY2goKTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN1Ym1lbnVUb2dnbGUpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnLmhhcy1zdWJtZW51LXRvZ2dsZScpLnJlbW92ZUNsYXNzKCdoYXMtc3VibWVudS10b2dnbGUnKTtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnLnN1Ym1lbnUtdG9nZ2xlJykucmVtb3ZlKCk7XFxuICAgICAgfVxcblxcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfbmVzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJOZXN0XFxcIl0uQnVybih0aGlzLiRlbGVtZW50LCAnYWNjb3JkaW9uJyk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBBY2NvcmRpb25NZW51O1xcbn0oX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiUGx1Z2luXFxcIl0pO1xcblxcbkFjY29yZGlvbk1lbnUuZGVmYXVsdHMgPSB7XFxuICAvKipcXG4gICAqIEFkZHMgdGhlIHBhcmVudCBsaW5rIHRvIHRoZSBzdWJtZW51LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBwYXJlbnRMaW5rOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogQW1vdW50IG9mIHRpbWUgdG8gYW5pbWF0ZSB0aGUgb3BlbmluZyBvZiBhIHN1Ym1lbnUgaW4gbXMuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgMjUwXFxuICAgKi9cXG4gIHNsaWRlU3BlZWQ6IDI1MCxcXG5cXG4gIC8qKlxcbiAgICogQWRkcyBhIHNlcGFyYXRlIHN1Ym1lbnUgdG9nZ2xlIGJ1dHRvbi4gVGhpcyBhbGxvd3MgdGhlIHBhcmVudCBpdGVtIHRvIGhhdmUgYSBsaW5rLlxcbiAgICogQG9wdGlvblxcbiAgICogQGV4YW1wbGUgdHJ1ZVxcbiAgICovXFxuICBzdWJtZW51VG9nZ2xlOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogVGhlIHRleHQgdXNlZCBmb3IgdGhlIHN1Ym1lbnUgdG9nZ2xlIGlmIGVuYWJsZWQuIFRoaXMgaXMgdXNlZCBmb3Igc2NyZWVuIHJlYWRlcnMgb25seS5cXG4gICAqIEBvcHRpb25cXG4gICAqIEBleGFtcGxlIHRydWVcXG4gICAqL1xcbiAgc3VibWVudVRvZ2dsZVRleHQ6ICdUb2dnbGUgbWVudScsXFxuXFxuICAvKipcXG4gICAqIEFsbG93IHRoZSBtZW51IHRvIGhhdmUgbXVsdGlwbGUgb3BlbiBwYW5lcy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgdHJ1ZVxcbiAgICovXFxuICBtdWx0aU9wZW46IHRydWVcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL2pzL2ZvdW5kYXRpb24uYWNjb3JkaW9uTWVudS5qcz9cIil9LFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUuanNcIjpmdW5jdGlvbihtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkZvdW5kYXRpb25cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEZvdW5kYXRpb247IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGpxdWVyeSAqLyBcXFwianF1ZXJ5XFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUudXRpbHMgKi8gXFxcIi4vanMvZm91bmRhdGlvbi5jb3JlLnV0aWxzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeSAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeS5qc1xcXCIpO1xcblxcblxcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxcblxcblxcblxcblxcbnZhciBGT1VOREFUSU9OX1ZFUlNJT04gPSAnNi41LjEnOyAvLyBHbG9iYWwgRm91bmRhdGlvbiBvYmplY3RcXG4vLyBUaGlzIGlzIGF0dGFjaGVkIHRvIHRoZSB3aW5kb3csIG9yIHVzZWQgYXMgYSBtb2R1bGUgZm9yIEFNRC9Ccm93c2VyaWZ5XFxuXFxudmFyIEZvdW5kYXRpb24gPSB7XFxuICB2ZXJzaW9uOiBGT1VOREFUSU9OX1ZFUlNJT04sXFxuXFxuICAvKipcXG4gICAqIFN0b3JlcyBpbml0aWFsaXplZCBwbHVnaW5zLlxcbiAgICovXFxuICBfcGx1Z2luczoge30sXFxuXFxuICAvKipcXG4gICAqIFN0b3JlcyBnZW5lcmF0ZWQgdW5pcXVlIGlkcyBmb3IgcGx1Z2luIGluc3RhbmNlc1xcbiAgICovXFxuICBfdXVpZHM6IFtdLFxcblxcbiAgLyoqXFxuICAgKiBEZWZpbmVzIGEgRm91bmRhdGlvbiBwbHVnaW4sIGFkZGluZyBpdCB0byB0aGUgYEZvdW5kYXRpb25gIG5hbWVzcGFjZSBhbmQgdGhlIGxpc3Qgb2YgcGx1Z2lucyB0byBpbml0aWFsaXplIHdoZW4gcmVmbG93aW5nLlxcbiAgICogQHBhcmFtIHtPYmplY3R9IHBsdWdpbiAtIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgcGx1Z2luLlxcbiAgICovXFxuICBwbHVnaW46IGZ1bmN0aW9uIHBsdWdpbihfcGx1Z2luLCBuYW1lKSB7XFxuICAgIC8vIE9iamVjdCBrZXkgdG8gdXNlIHdoZW4gYWRkaW5nIHRvIGdsb2JhbCBGb3VuZGF0aW9uIG9iamVjdFxcbiAgICAvLyBFeGFtcGxlczogRm91bmRhdGlvbi5SZXZlYWwsIEZvdW5kYXRpb24uT2ZmQ2FudmFzXFxuICAgIHZhciBjbGFzc05hbWUgPSBuYW1lIHx8IGZ1bmN0aW9uTmFtZShfcGx1Z2luKTsgLy8gT2JqZWN0IGtleSB0byB1c2Ugd2hlbiBzdG9yaW5nIHRoZSBwbHVnaW4sIGFsc28gdXNlZCB0byBjcmVhdGUgdGhlIGlkZW50aWZ5aW5nIGRhdGEgYXR0cmlidXRlIGZvciB0aGUgcGx1Z2luXFxuICAgIC8vIEV4YW1wbGVzOiBkYXRhLXJldmVhbCwgZGF0YS1vZmYtY2FudmFzXFxuXFxuICAgIHZhciBhdHRyTmFtZSA9IGh5cGhlbmF0ZShjbGFzc05hbWUpOyAvLyBBZGQgdG8gdGhlIEZvdW5kYXRpb24gb2JqZWN0IGFuZCB0aGUgcGx1Z2lucyBsaXN0IChmb3IgcmVmbG93aW5nKVxcblxcbiAgICB0aGlzLl9wbHVnaW5zW2F0dHJOYW1lXSA9IHRoaXNbY2xhc3NOYW1lXSA9IF9wbHVnaW47XFxuICB9LFxcblxcbiAgLyoqXFxuICAgKiBAZnVuY3Rpb25cXG4gICAqIFBvcHVsYXRlcyB0aGUgX3V1aWRzIGFycmF5IHdpdGggcG9pbnRlcnMgdG8gZWFjaCBpbmRpdmlkdWFsIHBsdWdpbiBpbnN0YW5jZS5cXG4gICAqIEFkZHMgdGhlIGB6ZlBsdWdpbmAgZGF0YS1hdHRyaWJ1dGUgdG8gcHJvZ3JhbW1hdGljYWxseSBjcmVhdGVkIHBsdWdpbnMgdG8gYWxsb3cgdXNlIG9mICQoc2VsZWN0b3IpLmZvdW5kYXRpb24obWV0aG9kKSBjYWxscy5cXG4gICAqIEFsc28gZmlyZXMgdGhlIGluaXRpYWxpemF0aW9uIGV2ZW50IGZvciBlYWNoIHBsdWdpbiwgY29uc29saWRhdGluZyByZXBldGl0aXZlIGNvZGUuXFxuICAgKiBAcGFyYW0ge09iamVjdH0gcGx1Z2luIC0gYW4gaW5zdGFuY2Ugb2YgYSBwbHVnaW4sIHVzdWFsbHkgYHRoaXNgIGluIGNvbnRleHQuXFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBwbHVnaW4sIHBhc3NlZCBhcyBhIGNhbWVsQ2FzZWQgc3RyaW5nLlxcbiAgICogQGZpcmVzIFBsdWdpbiNpbml0XFxuICAgKi9cXG4gIHJlZ2lzdGVyUGx1Z2luOiBmdW5jdGlvbiByZWdpc3RlclBsdWdpbihwbHVnaW4sIG5hbWUpIHtcXG4gICAgdmFyIHBsdWdpbk5hbWUgPSBuYW1lID8gaHlwaGVuYXRlKG5hbWUpIDogZnVuY3Rpb25OYW1lKHBsdWdpbi5jb25zdHJ1Y3RvcikudG9Mb3dlckNhc2UoKTtcXG4gICAgcGx1Z2luLnV1aWQgPSBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJHZXRZb0RpZ2l0c1xcXCJdKSg2LCBwbHVnaW5OYW1lKTtcXG5cXG4gICAgaWYgKCFwbHVnaW4uJGVsZW1lbnQuYXR0cihcXFwiZGF0YS1cXFwiLmNvbmNhdChwbHVnaW5OYW1lKSkpIHtcXG4gICAgICBwbHVnaW4uJGVsZW1lbnQuYXR0cihcXFwiZGF0YS1cXFwiLmNvbmNhdChwbHVnaW5OYW1lKSwgcGx1Z2luLnV1aWQpO1xcbiAgICB9XFxuXFxuICAgIGlmICghcGx1Z2luLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJykpIHtcXG4gICAgICBwbHVnaW4uJGVsZW1lbnQuZGF0YSgnemZQbHVnaW4nLCBwbHVnaW4pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBwbHVnaW4gaGFzIGluaXRpYWxpemVkLlxcbiAgICAgKiBAZXZlbnQgUGx1Z2luI2luaXRcXG4gICAgICovXFxuXFxuXFxuICAgIHBsdWdpbi4kZWxlbWVudC50cmlnZ2VyKFxcXCJpbml0LnpmLlxcXCIuY29uY2F0KHBsdWdpbk5hbWUpKTtcXG5cXG4gICAgdGhpcy5fdXVpZHMucHVzaChwbHVnaW4udXVpZCk7XFxuXFxuICAgIHJldHVybjtcXG4gIH0sXFxuXFxuICAvKipcXG4gICAqIEBmdW5jdGlvblxcbiAgICogUmVtb3ZlcyB0aGUgcGx1Z2lucyB1dWlkIGZyb20gdGhlIF91dWlkcyBhcnJheS5cXG4gICAqIFJlbW92ZXMgdGhlIHpmUGx1Z2luIGRhdGEgYXR0cmlidXRlLCBhcyB3ZWxsIGFzIHRoZSBkYXRhLXBsdWdpbi1uYW1lIGF0dHJpYnV0ZS5cXG4gICAqIEFsc28gZmlyZXMgdGhlIGRlc3Ryb3llZCBldmVudCBmb3IgdGhlIHBsdWdpbiwgY29uc29saWRhdGluZyByZXBldGl0aXZlIGNvZGUuXFxuICAgKiBAcGFyYW0ge09iamVjdH0gcGx1Z2luIC0gYW4gaW5zdGFuY2Ugb2YgYSBwbHVnaW4sIHVzdWFsbHkgYHRoaXNgIGluIGNvbnRleHQuXFxuICAgKiBAZmlyZXMgUGx1Z2luI2Rlc3Ryb3llZFxcbiAgICovXFxuICB1bnJlZ2lzdGVyUGx1Z2luOiBmdW5jdGlvbiB1bnJlZ2lzdGVyUGx1Z2luKHBsdWdpbikge1xcbiAgICB2YXIgcGx1Z2luTmFtZSA9IGh5cGhlbmF0ZShmdW5jdGlvbk5hbWUocGx1Z2luLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJykuY29uc3RydWN0b3IpKTtcXG5cXG4gICAgdGhpcy5fdXVpZHMuc3BsaWNlKHRoaXMuX3V1aWRzLmluZGV4T2YocGx1Z2luLnV1aWQpLCAxKTtcXG5cXG4gICAgcGx1Z2luLiRlbGVtZW50LnJlbW92ZUF0dHIoXFxcImRhdGEtXFxcIi5jb25jYXQocGx1Z2luTmFtZSkpLnJlbW92ZURhdGEoJ3pmUGx1Z2luJylcXG4gICAgLyoqXFxuICAgICAqIEZpcmVzIHdoZW4gdGhlIHBsdWdpbiBoYXMgYmVlbiBkZXN0cm95ZWQuXFxuICAgICAqIEBldmVudCBQbHVnaW4jZGVzdHJveWVkXFxuICAgICAqL1xcbiAgICAudHJpZ2dlcihcXFwiZGVzdHJveWVkLnpmLlxcXCIuY29uY2F0KHBsdWdpbk5hbWUpKTtcXG5cXG4gICAgZm9yICh2YXIgcHJvcCBpbiBwbHVnaW4pIHtcXG4gICAgICBwbHVnaW5bcHJvcF0gPSBudWxsOyAvL2NsZWFuIHVwIHNjcmlwdCB0byBwcmVwIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uXFxuICAgIH1cXG5cXG4gICAgcmV0dXJuO1xcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogQGZ1bmN0aW9uXFxuICAgKiBDYXVzZXMgb25lIG9yIG1vcmUgYWN0aXZlIHBsdWdpbnMgdG8gcmUtaW5pdGlhbGl6ZSwgcmVzZXR0aW5nIGV2ZW50IGxpc3RlbmVycywgcmVjYWxjdWxhdGluZyBwb3NpdGlvbnMsIGV0Yy5cXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwbHVnaW5zIC0gb3B0aW9uYWwgc3RyaW5nIG9mIGFuIGluZGl2aWR1YWwgcGx1Z2luIGtleSwgYXR0YWluZWQgYnkgY2FsbGluZyBgJChlbGVtZW50KS5kYXRhKCdwbHVnaW5OYW1lJylgLCBvciBzdHJpbmcgb2YgYSBwbHVnaW4gY2xhc3MgaS5lLiBgJ2Ryb3Bkb3duJ2BcXG4gICAqIEBkZWZhdWx0IElmIG5vIGFyZ3VtZW50IGlzIHBhc3NlZCwgcmVmbG93IGFsbCBjdXJyZW50bHkgYWN0aXZlIHBsdWdpbnMuXFxuICAgKi9cXG4gIHJlSW5pdDogZnVuY3Rpb24gcmVJbml0KHBsdWdpbnMpIHtcXG4gICAgdmFyIGlzSlEgPSBwbHVnaW5zIGluc3RhbmNlb2YganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hO1xcblxcbiAgICB0cnkge1xcbiAgICAgIGlmIChpc0pRKSB7XFxuICAgICAgICBwbHVnaW5zLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykuZGF0YSgnemZQbHVnaW4nKS5faW5pdCgpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHZhciB0eXBlID0gX3R5cGVvZihwbHVnaW5zKSxcXG4gICAgICAgICAgICBfdGhpcyA9IHRoaXMsXFxuICAgICAgICAgICAgZm5zID0ge1xcbiAgICAgICAgICAnb2JqZWN0JzogZnVuY3Rpb24gb2JqZWN0KHBsZ3MpIHtcXG4gICAgICAgICAgICBwbGdzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcXG4gICAgICAgICAgICAgIHAgPSBoeXBoZW5hdGUocCk7XFxuICAgICAgICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoJ1tkYXRhLScgKyBwICsgJ10nKS5mb3VuZGF0aW9uKCdfaW5pdCcpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICAnc3RyaW5nJzogZnVuY3Rpb24gc3RyaW5nKCkge1xcbiAgICAgICAgICAgIHBsdWdpbnMgPSBoeXBoZW5hdGUocGx1Z2lucyk7XFxuICAgICAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCdbZGF0YS0nICsgcGx1Z2lucyArICddJykuZm91bmRhdGlvbignX2luaXQnKTtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgJ3VuZGVmaW5lZCc6IGZ1bmN0aW9uIHVuZGVmaW5lZCgpIHtcXG4gICAgICAgICAgICB0aGlzWydvYmplY3QnXShPYmplY3Qua2V5cyhfdGhpcy5fcGx1Z2lucykpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgZm5zW3R5cGVdKHBsdWdpbnMpO1xcbiAgICAgIH1cXG4gICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xcbiAgICB9IGZpbmFsbHkge1xcbiAgICAgIHJldHVybiBwbHVnaW5zO1xcbiAgICB9XFxuICB9LFxcblxcbiAgLyoqXFxuICAgKiBJbml0aWFsaXplIHBsdWdpbnMgb24gYW55IGVsZW1lbnRzIHdpdGhpbiBgZWxlbWAgKGFuZCBgZWxlbWAgaXRzZWxmKSB0aGF0IGFyZW4ndCBhbHJlYWR5IGluaXRpYWxpemVkLlxcbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW0gLSBqUXVlcnkgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVsZW1lbnQgdG8gY2hlY2sgaW5zaWRlLiBBbHNvIGNoZWNrcyB0aGUgZWxlbWVudCBpdHNlbGYsIHVubGVzcyBpdCdzIHRoZSBgZG9jdW1lbnRgIG9iamVjdC5cXG4gICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBwbHVnaW5zIC0gQSBsaXN0IG9mIHBsdWdpbnMgdG8gaW5pdGlhbGl6ZS4gTGVhdmUgdGhpcyBvdXQgdG8gaW5pdGlhbGl6ZSBldmVyeXRoaW5nLlxcbiAgICovXFxuICByZWZsb3c6IGZ1bmN0aW9uIHJlZmxvdyhlbGVtLCBwbHVnaW5zKSB7XFxuICAgIC8vIElmIHBsdWdpbnMgaXMgdW5kZWZpbmVkLCBqdXN0IGdyYWIgZXZlcnl0aGluZ1xcbiAgICBpZiAodHlwZW9mIHBsdWdpbnMgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgcGx1Z2lucyA9IE9iamVjdC5rZXlzKHRoaXMuX3BsdWdpbnMpO1xcbiAgICB9IC8vIElmIHBsdWdpbnMgaXMgYSBzdHJpbmcsIGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkgd2l0aCBvbmUgaXRlbVxcbiAgICBlbHNlIGlmICh0eXBlb2YgcGx1Z2lucyA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgIHBsdWdpbnMgPSBbcGx1Z2luc107XFxuICAgICAgfVxcblxcbiAgICB2YXIgX3RoaXMgPSB0aGlzOyAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBwbHVnaW5cXG5cXG5cXG4gICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmVhY2gocGx1Z2lucywgZnVuY3Rpb24gKGksIG5hbWUpIHtcXG4gICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgcGx1Z2luXFxuICAgICAgdmFyIHBsdWdpbiA9IF90aGlzLl9wbHVnaW5zW25hbWVdOyAvLyBMb2NhbGl6ZSB0aGUgc2VhcmNoIHRvIGFsbCBlbGVtZW50cyBpbnNpZGUgZWxlbSwgYXMgd2VsbCBhcyBlbGVtIGl0c2VsZiwgdW5sZXNzIGVsZW0gPT09IGRvY3VtZW50XFxuXFxuICAgICAgdmFyICRlbGVtID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGVsZW0pLmZpbmQoJ1tkYXRhLScgKyBuYW1lICsgJ10nKS5hZGRCYWNrKCdbZGF0YS0nICsgbmFtZSArICddJyk7IC8vIEZvciBlYWNoIHBsdWdpbiBmb3VuZCwgaW5pdGlhbGl6ZSBpdFxcblxcbiAgICAgICRlbGVtLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyICRlbCA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKSxcXG4gICAgICAgICAgICBvcHRzID0ge307IC8vIERvbid0IGRvdWJsZS1kaXAgb24gcGx1Z2luc1xcblxcbiAgICAgICAgaWYgKCRlbC5kYXRhKCd6ZlBsdWdpbicpKSB7XFxuICAgICAgICAgIGNvbnNvbGUud2FybihcXFwiVHJpZWQgdG8gaW5pdGlhbGl6ZSBcXFwiICsgbmFtZSArIFxcXCIgb24gYW4gZWxlbWVudCB0aGF0IGFscmVhZHkgaGFzIGEgRm91bmRhdGlvbiBwbHVnaW4uXFxcIik7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICgkZWwuYXR0cignZGF0YS1vcHRpb25zJykpIHtcXG4gICAgICAgICAgdmFyIHRoaW5nID0gJGVsLmF0dHIoJ2RhdGEtb3B0aW9ucycpLnNwbGl0KCc7JykuZm9yRWFjaChmdW5jdGlvbiAoZSwgaSkge1xcbiAgICAgICAgICAgIHZhciBvcHQgPSBlLnNwbGl0KCc6JykubWFwKGZ1bmN0aW9uIChlbCkge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGVsLnRyaW0oKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBpZiAob3B0WzBdKSBvcHRzW29wdFswXV0gPSBwYXJzZVZhbHVlKG9wdFsxXSk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgJGVsLmRhdGEoJ3pmUGx1Z2luJywgbmV3IHBsdWdpbihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcyksIG9wdHMpKTtcXG4gICAgICAgIH0gY2F0Y2ggKGVyKSB7XFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXIpO1xcbiAgICAgICAgfSBmaW5hbGx5IHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9KTtcXG4gIH0sXFxuICBnZXRGbk5hbWU6IGZ1bmN0aW9uTmFtZSxcXG4gIGFkZFRvSnF1ZXJ5OiBmdW5jdGlvbiBhZGRUb0pxdWVyeSgkKSB7XFxuICAgIC8vIFRPRE86IGNvbnNpZGVyIG5vdCBtYWtpbmcgdGhpcyBhIGpRdWVyeSBmdW5jdGlvblxcbiAgICAvLyBUT0RPOiBuZWVkIHdheSB0byByZWZsb3cgdnMuIHJlLWluaXRpYWxpemVcXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBGb3VuZGF0aW9uIGpRdWVyeSBtZXRob2QuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBtZXRob2QgLSBBbiBhY3Rpb24gdG8gcGVyZm9ybSBvbiB0aGUgY3VycmVudCBqUXVlcnkgb2JqZWN0LlxcbiAgICAgKi9cXG4gICAgdmFyIGZvdW5kYXRpb24gPSBmdW5jdGlvbiBmb3VuZGF0aW9uKG1ldGhvZCkge1xcbiAgICAgIHZhciB0eXBlID0gX3R5cGVvZihtZXRob2QpLFxcbiAgICAgICAgICAkbm9KUyA9ICQoJy5uby1qcycpO1xcblxcbiAgICAgIGlmICgkbm9KUy5sZW5ndGgpIHtcXG4gICAgICAgICRub0pTLnJlbW92ZUNsYXNzKCduby1qcycpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIC8vbmVlZHMgdG8gaW5pdGlhbGl6ZSB0aGUgRm91bmRhdGlvbiBvYmplY3QsIG9yIGFuIGluZGl2aWR1YWwgcGx1Z2luLlxcbiAgICAgICAgX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIk1lZGlhUXVlcnlcXFwiXS5faW5pdCgpO1xcblxcbiAgICAgICAgRm91bmRhdGlvbi5yZWZsb3codGhpcyk7XFxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgLy9hbiBpbmRpdmlkdWFsIG1ldGhvZCB0byBpbnZva2Ugb24gYSBwbHVnaW4gb3IgZ3JvdXAgb2YgcGx1Z2luc1xcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyAvL2NvbGxlY3QgYWxsIHRoZSBhcmd1bWVudHMsIGlmIG5lY2Vzc2FyeVxcblxcbiAgICAgICAgdmFyIHBsdWdDbGFzcyA9IHRoaXMuZGF0YSgnemZQbHVnaW4nKTsgLy9kZXRlcm1pbmUgdGhlIGNsYXNzIG9mIHBsdWdpblxcblxcbiAgICAgICAgaWYgKHR5cGVvZiBwbHVnQ2xhc3MgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwbHVnQ2xhc3NbbWV0aG9kXSAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgLy9tYWtlIHN1cmUgYm90aCB0aGUgY2xhc3MgYW5kIG1ldGhvZCBleGlzdFxcbiAgICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHtcXG4gICAgICAgICAgICAvL2lmIHRoZXJlJ3Mgb25seSBvbmUsIGNhbGwgaXQgZGlyZWN0bHkuXFxuICAgICAgICAgICAgcGx1Z0NsYXNzW21ldGhvZF0uYXBwbHkocGx1Z0NsYXNzLCBhcmdzKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGksIGVsKSB7XFxuICAgICAgICAgICAgICAvL290aGVyd2lzZSBsb29wIHRocm91Z2ggdGhlIGpRdWVyeSBjb2xsZWN0aW9uIGFuZCBpbnZva2UgdGhlIG1ldGhvZCBvbiBlYWNoXFxuICAgICAgICAgICAgICBwbHVnQ2xhc3NbbWV0aG9kXS5hcHBseSgkKGVsKS5kYXRhKCd6ZlBsdWdpbicpLCBhcmdzKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgLy9lcnJvciBmb3Igbm8gY2xhc3Mgb3Igbm8gbWV0aG9kXFxuICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwiV2UncmUgc29ycnksICdcXFwiICsgbWV0aG9kICsgXFxcIicgaXMgbm90IGFuIGF2YWlsYWJsZSBtZXRob2QgZm9yIFxcXCIgKyAocGx1Z0NsYXNzID8gZnVuY3Rpb25OYW1lKHBsdWdDbGFzcykgOiAndGhpcyBlbGVtZW50JykgKyAnLicpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICAvL2Vycm9yIGZvciBpbnZhbGlkIGFyZ3VtZW50IHR5cGVcXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIldlJ3JlIHNvcnJ5LCBcXFwiLmNvbmNhdCh0eXBlLCBcXFwiIGlzIG5vdCBhIHZhbGlkIHBhcmFtZXRlci4gWW91IG11c3QgdXNlIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbWV0aG9kIHlvdSB3aXNoIHRvIGludm9rZS5cXFwiKSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9O1xcblxcbiAgICAkLmZuLmZvdW5kYXRpb24gPSBmb3VuZGF0aW9uO1xcbiAgICByZXR1cm4gJDtcXG4gIH1cXG59O1xcbkZvdW5kYXRpb24udXRpbCA9IHtcXG4gIC8qKlxcbiAgICogRnVuY3Rpb24gZm9yIGFwcGx5aW5nIGEgZGVib3VuY2UgZWZmZWN0IHRvIGEgZnVuY3Rpb24gY2FsbC5cXG4gICAqIEBmdW5jdGlvblxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBhdCBlbmQgb2YgdGltZW91dC5cXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheSAtIFRpbWUgaW4gbXMgdG8gZGVsYXkgdGhlIGNhbGwgb2YgYGZ1bmNgLlxcbiAgICogQHJldHVybnMgZnVuY3Rpb25cXG4gICAqL1xcbiAgdGhyb3R0bGU6IGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIGRlbGF5KSB7XFxuICAgIHZhciB0aW1lciA9IG51bGw7XFxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLFxcbiAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xcblxcbiAgICAgIGlmICh0aW1lciA9PT0gbnVsbCkge1xcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcXG4gICAgICAgICAgdGltZXIgPSBudWxsO1xcbiAgICAgICAgfSwgZGVsYXkpO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG59O1xcbndpbmRvdy5Gb3VuZGF0aW9uID0gRm91bmRhdGlvbjsgLy8gUG9seWZpbGwgZm9yIHJlcXVlc3RBbmltYXRpb25GcmFtZVxcblxcbihmdW5jdGlvbiAoKSB7XFxuICBpZiAoIURhdGUubm93IHx8ICF3aW5kb3cuRGF0ZS5ub3cpIHdpbmRvdy5EYXRlLm5vdyA9IERhdGUubm93ID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XFxuICB9O1xcbiAgdmFyIHZlbmRvcnMgPSBbJ3dlYmtpdCcsICdtb3onXTtcXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmVuZG9ycy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsraSkge1xcbiAgICB2YXIgdnAgPSB2ZW5kb3JzW2ldO1xcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZwICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xcbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdnAgKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXSB8fCB3aW5kb3dbdnAgKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XFxuICB9XFxuXFxuICBpZiAoL2lQKGFkfGhvbmV8b2QpLipPUyA2Ly50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSB8fCAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCAhd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XFxuICAgIHZhciBsYXN0VGltZSA9IDA7XFxuXFxuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcXG4gICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcXG4gICAgICB2YXIgbmV4dFRpbWUgPSBNYXRoLm1heChsYXN0VGltZSArIDE2LCBub3cpO1xcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGNhbGxiYWNrKGxhc3RUaW1lID0gbmV4dFRpbWUpO1xcbiAgICAgIH0sIG5leHRUaW1lIC0gbm93KTtcXG4gICAgfTtcXG5cXG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gY2xlYXJUaW1lb3V0O1xcbiAgfVxcbiAgLyoqXFxuICAgKiBQb2x5ZmlsbCBmb3IgcGVyZm9ybWFuY2Uubm93LCByZXF1aXJlZCBieSByQUZcXG4gICAqL1xcblxcblxcbiAgaWYgKCF3aW5kb3cucGVyZm9ybWFuY2UgfHwgIXdpbmRvdy5wZXJmb3JtYW5jZS5ub3cpIHtcXG4gICAgd2luZG93LnBlcmZvcm1hbmNlID0ge1xcbiAgICAgIHN0YXJ0OiBEYXRlLm5vdygpLFxcbiAgICAgIG5vdzogZnVuY3Rpb24gbm93KCkge1xcbiAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSB0aGlzLnN0YXJ0O1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG59KSgpO1xcblxcbmlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcXG4gIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKG9UaGlzKSB7XFxuICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIC8vIGNsb3Nlc3QgdGhpbmcgcG9zc2libGUgdG8gdGhlIEVDTUFTY3JpcHQgNVxcbiAgICAgIC8vIGludGVybmFsIElzQ2FsbGFibGUgZnVuY3Rpb25cXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAtIHdoYXQgaXMgdHJ5aW5nIHRvIGJlIGJvdW5kIGlzIG5vdCBjYWxsYWJsZScpO1xcbiAgICB9XFxuXFxuICAgIHZhciBhQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXFxuICAgICAgICBmVG9CaW5kID0gdGhpcyxcXG4gICAgICAgIGZOT1AgPSBmdW5jdGlvbiBmTk9QKCkge30sXFxuICAgICAgICBmQm91bmQgPSBmdW5jdGlvbiBmQm91bmQoKSB7XFxuICAgICAgcmV0dXJuIGZUb0JpbmQuYXBwbHkodGhpcyBpbnN0YW5jZW9mIGZOT1AgPyB0aGlzIDogb1RoaXMsIGFBcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XFxuICAgIH07XFxuXFxuICAgIGlmICh0aGlzLnByb3RvdHlwZSkge1xcbiAgICAgIC8vIG5hdGl2ZSBmdW5jdGlvbnMgZG9uJ3QgaGF2ZSBhIHByb3RvdHlwZVxcbiAgICAgIGZOT1AucHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XFxuICAgIH1cXG5cXG4gICAgZkJvdW5kLnByb3RvdHlwZSA9IG5ldyBmTk9QKCk7XFxuICAgIHJldHVybiBmQm91bmQ7XFxuICB9O1xcbn0gLy8gUG9seWZpbGwgdG8gZ2V0IHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gaW4gSUU5XFxuXFxuXFxuZnVuY3Rpb24gZnVuY3Rpb25OYW1lKGZuKSB7XFxuICBpZiAodHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZS5uYW1lID09PSAndW5kZWZpbmVkJykge1xcbiAgICB2YXIgZnVuY05hbWVSZWdleCA9IC9mdW5jdGlvblxcXFxzKFteKF17MSx9KVxcXFwoLztcXG4gICAgdmFyIHJlc3VsdHMgPSBmdW5jTmFtZVJlZ2V4LmV4ZWMoZm4udG9TdHJpbmcoKSk7XFxuICAgIHJldHVybiByZXN1bHRzICYmIHJlc3VsdHMubGVuZ3RoID4gMSA/IHJlc3VsdHNbMV0udHJpbSgpIDogXFxcIlxcXCI7XFxuICB9IGVsc2UgaWYgKHR5cGVvZiBmbi5wcm90b3R5cGUgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgIHJldHVybiBmbi5jb25zdHJ1Y3Rvci5uYW1lO1xcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIGZuLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBwYXJzZVZhbHVlKHN0cikge1xcbiAgaWYgKCd0cnVlJyA9PT0gc3RyKSByZXR1cm4gdHJ1ZTtlbHNlIGlmICgnZmFsc2UnID09PSBzdHIpIHJldHVybiBmYWxzZTtlbHNlIGlmICghaXNOYU4oc3RyICogMSkpIHJldHVybiBwYXJzZUZsb2F0KHN0cik7XFxuICByZXR1cm4gc3RyO1xcbn0gLy8gQ29udmVydCBQYXNjYWxDYXNlIHRvIGtlYmFiLWNhc2VcXG4vLyBUaGFuayB5b3U6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg5NTU1ODBcXG5cXG5cXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyKSB7XFxuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XFxufVxcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL2pzL2ZvdW5kYXRpb24uY29yZS5qcz9cIil9LFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUucGx1Z2luLmpzXCI6ZnVuY3Rpb24obW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbCgnX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJQbHVnaW5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBQbHVnaW47IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGpxdWVyeSAqLyBcImpxdWVyeVwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uY29yZS51dGlscyAqLyBcIi4vanMvZm91bmRhdGlvbi5jb3JlLnV0aWxzLmpzXCIpO1xcblxcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxcblxcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XFxuXFxuXFxuIC8vIEFic3RyYWN0IGNsYXNzIGZvciBwcm92aWRpbmcgbGlmZWN5Y2xlIGhvb2tzLiBFeHBlY3QgcGx1Z2lucyB0byBkZWZpbmUgQVQgTEVBU1RcXG4vLyB7ZnVuY3Rpb259IF9zZXR1cCAocmVwbGFjZXMgcHJldmlvdXMgY29uc3RydWN0b3IpLFxcbi8vIHtmdW5jdGlvbn0gX2Rlc3Ryb3kgKHJlcGxhY2VzIHByZXZpb3VzIGRlc3Ryb3kpXFxuXFxudmFyIFBsdWdpbiA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uICgpIHtcXG4gIGZ1bmN0aW9uIFBsdWdpbihlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQbHVnaW4pO1xcblxcbiAgICB0aGlzLl9zZXR1cChlbGVtZW50LCBvcHRpb25zKTtcXG5cXG4gICAgdmFyIHBsdWdpbk5hbWUgPSBnZXRQbHVnaW5OYW1lKHRoaXMpO1xcbiAgICB0aGlzLnV1aWQgPSBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiR2V0WW9EaWdpdHNcIl0pKDYsIHBsdWdpbk5hbWUpO1xcblxcbiAgICBpZiAoIXRoaXMuJGVsZW1lbnQuYXR0cihcImRhdGEtXCIuY29uY2F0KHBsdWdpbk5hbWUpKSkge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cihcImRhdGEtXCIuY29uY2F0KHBsdWdpbk5hbWUpLCB0aGlzLnV1aWQpO1xcbiAgICB9XFxuXFxuICAgIGlmICghdGhpcy4kZWxlbWVudC5kYXRhKFxcJ3pmUGx1Z2luXFwnKSkge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQuZGF0YShcXCd6ZlBsdWdpblxcJywgdGhpcyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEZpcmVzIHdoZW4gdGhlIHBsdWdpbiBoYXMgaW5pdGlhbGl6ZWQuXFxuICAgICAqIEBldmVudCBQbHVnaW4jaW5pdFxcbiAgICAgKi9cXG5cXG5cXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKFwiaW5pdC56Zi5cIi5jb25jYXQocGx1Z2luTmFtZSkpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKFBsdWdpbiwgW3tcXG4gICAga2V5OiBcImRlc3Ryb3lcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XFxuICAgICAgdGhpcy5fZGVzdHJveSgpO1xcblxcbiAgICAgIHZhciBwbHVnaW5OYW1lID0gZ2V0UGx1Z2luTmFtZSh0aGlzKTtcXG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUF0dHIoXCJkYXRhLVwiLmNvbmNhdChwbHVnaW5OYW1lKSkucmVtb3ZlRGF0YShcXCd6ZlBsdWdpblxcJylcXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBwbHVnaW4gaGFzIGJlZW4gZGVzdHJveWVkLlxcbiAgICAgICAqIEBldmVudCBQbHVnaW4jZGVzdHJveWVkXFxuICAgICAgICovXFxuICAgICAgLnRyaWdnZXIoXCJkZXN0cm95ZWQuemYuXCIuY29uY2F0KHBsdWdpbk5hbWUpKTtcXG5cXG4gICAgICBmb3IgKHZhciBwcm9wIGluIHRoaXMpIHtcXG4gICAgICAgIHRoaXNbcHJvcF0gPSBudWxsOyAvL2NsZWFuIHVwIHNjcmlwdCB0byBwcmVwIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uXFxuICAgICAgfVxcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gUGx1Z2luO1xcbn0oKTsgLy8gQ29udmVydCBQYXNjYWxDYXNlIHRvIGtlYmFiLWNhc2VcXG4vLyBUaGFuayB5b3U6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg5NTU1ODBcXG5cXG5cXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyKSB7XFxuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csIFxcJyQxLSQyXFwnKS50b0xvd2VyQ2FzZSgpO1xcbn1cXG5cXG5mdW5jdGlvbiBnZXRQbHVnaW5OYW1lKG9iaikge1xcbiAgaWYgKHR5cGVvZiBvYmouY29uc3RydWN0b3IubmFtZSAhPT0gXFwndW5kZWZpbmVkXFwnKSB7XFxuICAgIHJldHVybiBoeXBoZW5hdGUob2JqLmNvbnN0cnVjdG9yLm5hbWUpO1xcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIGh5cGhlbmF0ZShvYmouY2xhc3NOYW1lKTtcXG4gIH1cXG59XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi5jb3JlLnBsdWdpbi5qcz8nKX0sXCIuL2pzL2ZvdW5kYXRpb24uY29yZS51dGlscy5qc1wiOmZ1bmN0aW9uKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicnRsXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBydGw7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkdldFlvRGlnaXRzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBHZXRZb0RpZ2l0czsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiUmVnRXhwRXNjYXBlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBSZWdFeHBFc2NhcGU7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInRyYW5zaXRpb25lbmRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHRyYW5zaXRpb25lbmQ7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIm9uTG9hZFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gb25Mb2FkOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJpZ25vcmVNb3VzZWRpc2FwcGVhclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaWdub3JlTW91c2VkaXNhcHBlYXI7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGpxdWVyeSAqLyBcXFwianF1ZXJ5XFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG5cXG5cXG4gLy8gQ29yZSBGb3VuZGF0aW9uIFV0aWxpdGllcywgdXRpbGl6ZWQgaW4gYSBudW1iZXIgb2YgcGxhY2VzLlxcblxcbi8qKlxcbiAqIFJldHVybnMgYSBib29sZWFuIGZvciBSVEwgc3VwcG9ydFxcbiAqL1xcblxcbmZ1bmN0aW9uIHJ0bCgpIHtcXG4gIHJldHVybiBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoJ2h0bWwnKS5hdHRyKCdkaXInKSA9PT0gJ3J0bCc7XFxufVxcbi8qKlxcbiAqIHJldHVybnMgYSByYW5kb20gYmFzZS0zNiB1aWQgd2l0aCBuYW1lc3BhY2luZ1xcbiAqIEBmdW5jdGlvblxcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggLSBudW1iZXIgb2YgcmFuZG9tIGJhc2UtMzYgZGlnaXRzIGRlc2lyZWQuIEluY3JlYXNlIGZvciBtb3JlIHJhbmRvbSBzdHJpbmdzLlxcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgLSBuYW1lIG9mIHBsdWdpbiB0byBiZSBpbmNvcnBvcmF0ZWQgaW4gdWlkLCBvcHRpb25hbC5cXG4gKiBAZGVmYXVsdCB7U3RyaW5nfSAnJyAtIGlmIG5vIHBsdWdpbiBuYW1lIGlzIHByb3ZpZGVkLCBub3RoaW5nIGlzIGFwcGVuZGVkIHRvIHRoZSB1aWQuXFxuICogQHJldHVybnMge1N0cmluZ30gLSB1bmlxdWUgaWRcXG4gKi9cXG5cXG5cXG5mdW5jdGlvbiBHZXRZb0RpZ2l0cyhsZW5ndGgsIG5hbWVzcGFjZSkge1xcbiAgbGVuZ3RoID0gbGVuZ3RoIHx8IDY7XFxuICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLnBvdygzNiwgbGVuZ3RoICsgMSkgLSBNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMzYsIGxlbmd0aCkpLnRvU3RyaW5nKDM2KS5zbGljZSgxKSArIChuYW1lc3BhY2UgPyBcXFwiLVxcXCIuY29uY2F0KG5hbWVzcGFjZSkgOiAnJyk7XFxufVxcbi8qKlxcbiAqIEVzY2FwZSBhIHN0cmluZyBzbyBpdCBjYW4gYmUgdXNlZCBhcyBhIHJlZ2V4cCBwYXR0ZXJuXFxuICogQGZ1bmN0aW9uXFxuICogQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvOTMxMDc1Mi80MzE3Mzg0XFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gc3RyaW5nIHRvIGVzY2FwZS5cXG4gKiBAcmV0dXJucyB7U3RyaW5nfSAtIGVzY2FwZWQgc3RyaW5nXFxuICovXFxuXFxuXFxuZnVuY3Rpb24gUmVnRXhwRXNjYXBlKHN0cikge1xcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLVtcXFxcXXt9KCkqKz8uLFxcXFxcXFxcXiR8I1xcXFxzXS9nLCAnXFxcXFxcXFwkJicpO1xcbn1cXG5cXG5mdW5jdGlvbiB0cmFuc2l0aW9uZW5kKCRlbGVtKSB7XFxuICB2YXIgdHJhbnNpdGlvbnMgPSB7XFxuICAgICd0cmFuc2l0aW9uJzogJ3RyYW5zaXRpb25lbmQnLFxcbiAgICAnV2Via2l0VHJhbnNpdGlvbic6ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcXG4gICAgJ01velRyYW5zaXRpb24nOiAndHJhbnNpdGlvbmVuZCcsXFxuICAgICdPVHJhbnNpdGlvbic6ICdvdHJhbnNpdGlvbmVuZCdcXG4gIH07XFxuICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxcbiAgICAgIGVuZDtcXG5cXG4gIGZvciAodmFyIHQgaW4gdHJhbnNpdGlvbnMpIHtcXG4gICAgaWYgKHR5cGVvZiBlbGVtLnN0eWxlW3RdICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgIGVuZCA9IHRyYW5zaXRpb25zW3RdO1xcbiAgICB9XFxuICB9XFxuXFxuICBpZiAoZW5kKSB7XFxuICAgIHJldHVybiBlbmQ7XFxuICB9IGVsc2Uge1xcbiAgICBlbmQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAkZWxlbS50cmlnZ2VySGFuZGxlcigndHJhbnNpdGlvbmVuZCcsIFskZWxlbV0pO1xcbiAgICB9LCAxKTtcXG4gICAgcmV0dXJuICd0cmFuc2l0aW9uZW5kJztcXG4gIH1cXG59XFxuLyoqXFxuICogUmV0dXJuIGFuIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvciB3aW5kb3cgbG9hZC5cXG4gKlxcbiAqIElmIGAkZWxlbWAgaXMgcGFzc2VkLCBhbiBldmVudCB3aWxsIGJlIHRyaWdnZXJlZCBvbiBgJGVsZW1gLiBJZiB3aW5kb3cgaXMgYWxyZWFkeSBsb2FkZWQsIHRoZSBldmVudCB3aWxsIHN0aWxsIGJlIHRyaWdnZXJlZC5cXG4gKiBJZiBgaGFuZGxlcmAgaXMgcGFzc2VkLCBhdHRhY2ggaXQgdG8gdGhlIGV2ZW50IG9uIGAkZWxlbWAuXFxuICogQ2FsbGluZyBgb25Mb2FkYCB3aXRob3V0IGhhbmRsZXIgYWxsb3dzIHlvdSB0byBnZXQgdGhlIGV2ZW50IHR5cGUgdGhhdCB3aWxsIGJlIHRyaWdnZXJlZCBiZWZvcmUgYXR0YWNoaW5nIHRoZSBoYW5kbGVyIGJ5IHlvdXJzZWxmLlxcbiAqIEBmdW5jdGlvblxcbiAqXFxuICogQHBhcmFtIHtPYmplY3R9IFtdICRlbGVtIC0galF1ZXJ5IGVsZW1lbnQgb24gd2hpY2ggdGhlIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkIGlmIHBhc3NlZC5cXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbXSBoYW5kbGVyIC0gZnVuY3Rpb24gdG8gYXR0YWNoIHRvIHRoZSBldmVudC5cXG4gKiBAcmV0dXJucyB7U3RyaW5nfSAtIGV2ZW50IHR5cGUgdGhhdCBzaG91bGQgb3Igd2lsbCBiZSB0cmlnZ2VyZWQuXFxuICovXFxuXFxuXFxuZnVuY3Rpb24gb25Mb2FkKCRlbGVtLCBoYW5kbGVyKSB7XFxuICB2YXIgZGlkTG9hZCA9IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZSc7XFxuICB2YXIgZXZlbnRUeXBlID0gKGRpZExvYWQgPyAnX2RpZExvYWQnIDogJ2xvYWQnKSArICcuemYudXRpbC5vbkxvYWQnO1xcblxcbiAgdmFyIGNiID0gZnVuY3Rpb24gY2IoKSB7XFxuICAgIHJldHVybiAkZWxlbS50cmlnZ2VySGFuZGxlcihldmVudFR5cGUpO1xcbiAgfTtcXG5cXG4gIGlmICgkZWxlbSkge1xcbiAgICBpZiAoaGFuZGxlcikgJGVsZW0ub25lKGV2ZW50VHlwZSwgaGFuZGxlcik7XFxuICAgIGlmIChkaWRMb2FkKSBzZXRUaW1lb3V0KGNiKTtlbHNlIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLm9uZSgnbG9hZCcsIGNiKTtcXG4gIH1cXG5cXG4gIHJldHVybiBldmVudFR5cGU7XFxufVxcbi8qKlxcbiAqIFJldHVucyBhbiBoYW5kbGVyIGZvciB0aGUgYG1vdXNlbGVhdmVgIHRoYXQgaWdub3JlIGRpc2FwcGVhcmVkIG1vdXNlcy5cXG4gKlxcbiAqIElmIHRoZSBtb3VzZSBcXFwiZGlzYXBwZWFyZWRcXFwiIGZyb20gdGhlIGRvY3VtZW50IChsaWtlIHdoZW4gZ29pbmcgb24gYSBicm93c2VyIFVJIGVsZW1lbnQsIFNlZSBodHRwczovL2dpdC5pby96Zi0xMTQxMCksXFxuICogdGhlIGV2ZW50IGlzIGlnbm9yZWQuXFxuICogLSBJZiB0aGUgYGlnbm9yZUxlYXZlV2luZG93YCBpcyBgdHJ1ZWAsIHRoZSBldmVudCBpcyBpZ25vcmVkIHdoZW4gdGhlIHVzZXIgYWN0dWFsbHkgbGVmdCB0aGUgd2luZG93XFxuICogICAobGlrZSBieSBzd2l0Y2hpbmcgdG8gYW4gb3RoZXIgd2luZG93IHdpdGggW0FsdF0rW1RhYl0pLlxcbiAqIC0gSWYgdGhlIGBpZ25vcmVSZWFwcGVhcmAgaXMgYHRydWVgLCB0aGUgZXZlbnQgd2lsbCBiZSBpZ25vcmVkIHdoZW4gdGhlIG1vdXNlIHdpbGwgcmVhcHBlYXIgbGF0ZXIgb24gdGhlIGRvY3VtZW50XFxuICogICBvdXRzaWRlIG9mIHRoZSBlbGVtZW50IGl0IGxlZnQuXFxuICpcXG4gKiBAZnVuY3Rpb25cXG4gKlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtdIGhhbmRsZXIgLSBoYW5kbGVyIGZvciB0aGUgZmlsdGVyZWQgYG1vdXNlbGVhdmVgIGV2ZW50IHRvIHdhdGNoLlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbXSBvcHRpb25zIC0gb2JqZWN0IG9mIG9wdGlvbnM6XFxuICogLSB7Qm9vbGVhbn0gW2ZhbHNlXSBpZ25vcmVMZWF2ZVdpbmRvdyAtIGFsc28gaWdub3JlIHdoZW4gdGhlIHVzZXIgc3dpdGNoZWQgd2luZG93cy5cXG4gKiAtIHtCb29sZWFufSBbZmFsc2VdIGlnbm9yZVJlYXBwZWFyIC0gYWxzbyBpZ25vcmUgd2hlbiB0aGUgbW91c2UgcmVhcHBlYXJlZCBvdXRzaWRlIG9mIHRoZSBlbGVtZW50IGl0IGxlZnQuXFxuICogQHJldHVybnMge0Z1bmN0aW9ufSAtIGZpbHRlcmVkIGhhbmRsZXIgdG8gdXNlIHRvIGxpc3RlbiBvbiB0aGUgYG1vdXNlbGVhdmVgIGV2ZW50LlxcbiAqL1xcblxcblxcbmZ1bmN0aW9uIGlnbm9yZU1vdXNlZGlzYXBwZWFyKGhhbmRsZXIpIHtcXG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcXG4gICAgICBfcmVmJGlnbm9yZUxlYXZlV2luZG8gPSBfcmVmLmlnbm9yZUxlYXZlV2luZG93LFxcbiAgICAgIGlnbm9yZUxlYXZlV2luZG93ID0gX3JlZiRpZ25vcmVMZWF2ZVdpbmRvID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkaWdub3JlTGVhdmVXaW5kbyxcXG4gICAgICBfcmVmJGlnbm9yZVJlYXBwZWFyID0gX3JlZi5pZ25vcmVSZWFwcGVhcixcXG4gICAgICBpZ25vcmVSZWFwcGVhciA9IF9yZWYkaWdub3JlUmVhcHBlYXIgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRpZ25vcmVSZWFwcGVhcjtcXG5cXG4gIHJldHVybiBmdW5jdGlvbiBsZWF2ZUV2ZW50SGFuZGxlcihlTGVhdmUpIHtcXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xcbiAgICAgIHJlc3RbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xcbiAgICB9XFxuXFxuICAgIHZhciBjYWxsYmFjayA9IGhhbmRsZXIuYmluZC5hcHBseShoYW5kbGVyLCBbdGhpcywgZUxlYXZlXS5jb25jYXQocmVzdCkpOyAvLyBUaGUgbW91c2UgbGVmdDogY2FsbCB0aGUgZ2l2ZW4gY2FsbGJhY2sgaWYgdGhlIG1vdXNlIGVudGVyZWQgZWxzZXdoZXJlXFxuXFxuICAgIGlmIChlTGVhdmUucmVsYXRlZFRhcmdldCAhPT0gbnVsbCkge1xcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xcbiAgICB9IC8vIE90aGVyd2lzZSwgY2hlY2sgaWYgdGhlIG1vdXNlIGFjdHVhbGx5IGxlZnQgdGhlIHdpbmRvdy5cXG4gICAgLy8gSW4gZmlyZWZveCBpZiB0aGUgdXNlciBzd2l0Y2hlZCBiZXR3ZWVuIHdpbmRvd3MsIHRoZSB3aW5kb3cgc2lsbCBoYXZlIHRoZSBmb2N1cyBieSB0aGUgdGltZVxcbiAgICAvLyB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLiBXZSBoYXZlIHRvIGRlYm91bmNlIHRoZSBldmVudCB0byB0ZXN0IHRoaXMgY2FzZS5cXG5cXG5cXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiBsZWF2ZUV2ZW50RGVib3VuY2VyKCkge1xcbiAgICAgIGlmICghaWdub3JlTGVhdmVXaW5kb3cgJiYgZG9jdW1lbnQuaGFzRm9jdXMgJiYgIWRvY3VtZW50Lmhhc0ZvY3VzKCkpIHtcXG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xcbiAgICAgIH0gLy8gT3RoZXJ3aXNlLCB3YWl0IGZvciB0aGUgbW91c2UgdG8gcmVlYXBlYXIgb3V0c2lkZSBvZiB0aGUgZWxlbWVudCxcXG5cXG5cXG4gICAgICBpZiAoIWlnbm9yZVJlYXBwZWFyKSB7XFxuICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZG9jdW1lbnQpLm9uZSgnbW91c2VlbnRlcicsIGZ1bmN0aW9uIHJlZW50ZXJFdmVudEhhbmRsZXIoZVJlZW50ZXIpIHtcXG4gICAgICAgICAgaWYgKCFqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZUxlYXZlLmN1cnJlbnRUYXJnZXQpLmhhcyhlUmVlbnRlci50YXJnZXQpLmxlbmd0aCkge1xcbiAgICAgICAgICAgIC8vIEZpbGwgd2hlcmUgdGhlIG1vdXNlIGZpbmFsbHkgZW50ZXJlZC5cXG4gICAgICAgICAgICBlTGVhdmUucmVsYXRlZFRhcmdldCA9IGVSZWVudGVyLnRhcmdldDtcXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH0sIDApO1xcbiAgfTtcXG59XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi5jb3JlLnV0aWxzLmpzP1wiKX0sXCIuL2pzL2ZvdW5kYXRpb24uZHJpbGxkb3duLmpzXCI6ZnVuY3Rpb24obW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJEcmlsbGRvd25cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERyaWxsZG93bjsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganF1ZXJ5ICovIFxcXCJqcXVlcnlcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC5rZXlib2FyZCAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF9uZXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC5uZXN0ICovIFxcXCIuL2pzL2ZvdW5kYXRpb24udXRpbC5uZXN0LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnV0aWxzICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS51dGlscy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX2JveF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwuYm94ICovIFxcXCIuL2pzL2ZvdW5kYXRpb24udXRpbC5ib3guanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnBsdWdpbiAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUucGx1Z2luLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxcblxcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXFxcIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxcblxcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuLyoqXFxuICogRHJpbGxkb3duIG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uZHJpbGxkb3duXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubmVzdFxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuYm94XFxuICovXFxuXFxudmFyIERyaWxsZG93biA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uIChfUGx1Z2luKSB7XFxuICBfaW5oZXJpdHMoRHJpbGxkb3duLCBfUGx1Z2luKTtcXG5cXG4gIGZ1bmN0aW9uIERyaWxsZG93bigpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERyaWxsZG93bik7XFxuXFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoRHJpbGxkb3duKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhEcmlsbGRvd24sIFt7XFxuICAgIGtleTogXFxcIl9zZXR1cFxcXCIsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgZHJpbGxkb3duIG1lbnUuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAbmFtZSBEcmlsbGRvd25cXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBhbiBhY2NvcmRpb24gbWVudS5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XFxuICAgICAgdGhpcy5vcHRpb25zID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCh7fSwgRHJpbGxkb3duLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XFxuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnRHJpbGxkb3duJzsgLy8gaWU5IGJhY2sgY29tcGF0XFxuXFxuICAgICAgdGhpcy5faW5pdCgpO1xcblxcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiS2V5Ym9hcmRcXFwiXS5yZWdpc3RlcignRHJpbGxkb3duJywge1xcbiAgICAgICAgJ0VOVEVSJzogJ29wZW4nLFxcbiAgICAgICAgJ1NQQUNFJzogJ29wZW4nLFxcbiAgICAgICAgJ0FSUk9XX1JJR0hUJzogJ25leHQnLFxcbiAgICAgICAgJ0FSUk9XX1VQJzogJ3VwJyxcXG4gICAgICAgICdBUlJPV19ET1dOJzogJ2Rvd24nLFxcbiAgICAgICAgJ0FSUk9XX0xFRlQnOiAncHJldmlvdXMnLFxcbiAgICAgICAgJ0VTQ0FQRSc6ICdjbG9zZScsXFxuICAgICAgICAnVEFCJzogJ2Rvd24nLFxcbiAgICAgICAgJ1NISUZUX1RBQic6ICd1cCdcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGRyaWxsZG93biBieSBjcmVhdGluZyBqUXVlcnkgY29sbGVjdGlvbnMgb2YgZWxlbWVudHNcXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9pbml0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfbmVzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJOZXN0XFxcIl0uRmVhdGhlcih0aGlzLiRlbGVtZW50LCAnZHJpbGxkb3duJyk7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvQXBwbHlDbGFzcykge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnZHJpbGxkb3duJyk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cih7XFxuICAgICAgICAncm9sZSc6ICd0cmVlJyxcXG4gICAgICAgICdhcmlhLW11bHRpc2VsZWN0YWJsZSc6IGZhbHNlXFxuICAgICAgfSk7XFxuICAgICAgdGhpcy4kc3VibWVudUFuY2hvcnMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2xpLmlzLWRyaWxsZG93bi1zdWJtZW51LXBhcmVudCcpLmNoaWxkcmVuKCdhJyk7XFxuICAgICAgdGhpcy4kc3VibWVudXMgPSB0aGlzLiRzdWJtZW51QW5jaG9ycy5wYXJlbnQoJ2xpJykuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJykuYXR0cigncm9sZScsICdncm91cCcpO1xcbiAgICAgIHRoaXMuJG1lbnVJdGVtcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnbGknKS5ub3QoJy5qcy1kcmlsbGRvd24tYmFjaycpLmF0dHIoJ3JvbGUnLCAndHJlZWl0ZW0nKS5maW5kKCdhJyk7IC8vIFNldCB0aGUgbWFpbiBtZW51IGFzIGN1cnJlbnQgYnkgZGVmYXVsdCAodW5sZXNzIGEgc3VibWVudSBpcyBzZWxlY3RlZClcXG4gICAgICAvLyBVc2VkIHRvIHNldCB0aGUgd3JhcHBlciBoZWlnaHQgd2hlbiB0aGUgZHJpbGxkb3duIGlzIGNsb3NlZC9yZW9wZW5lZCBmcm9tIGFueSAoc3ViKW1lbnVcXG5cXG4gICAgICB0aGlzLiRjdXJyZW50TWVudSA9IHRoaXMuJGVsZW1lbnQ7XFxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdkYXRhLW11dGF0ZScsIHRoaXMuJGVsZW1lbnQuYXR0cignZGF0YS1kcmlsbGRvd24nKSB8fCBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJHZXRZb0RpZ2l0c1xcXCJdKSg2LCAnZHJpbGxkb3duJykpO1xcblxcbiAgICAgIHRoaXMuX3ByZXBhcmVNZW51KCk7XFxuXFxuICAgICAgdGhpcy5fcmVnaXN0ZXJFdmVudHMoKTtcXG5cXG4gICAgICB0aGlzLl9rZXlib2FyZEV2ZW50cygpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBwcmVwYXJlcyBkcmlsbGRvd24gbWVudSBieSBzZXR0aW5nIGF0dHJpYnV0ZXMgdG8gbGlua3MgYW5kIGVsZW1lbnRzXFxuICAgICAqIHNldHMgYSBtaW4gaGVpZ2h0IHRvIHByZXZlbnQgY29udGVudCBqdW1waW5nXFxuICAgICAqIHdyYXBzIHRoZSBlbGVtZW50IGlmIG5vdCBhbHJlYWR5IHdyYXBwZWRcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfcHJlcGFyZU1lbnVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ByZXBhcmVNZW51KCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7IC8vIGlmKCF0aGlzLm9wdGlvbnMuaG9sZE9wZW4pe1xcbiAgICAgIC8vICAgdGhpcy5fbWVudUxpbmtFdmVudHMoKTtcXG4gICAgICAvLyB9XFxuXFxuXFxuICAgICAgdGhpcy4kc3VibWVudUFuY2hvcnMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgJGxpbmsgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcyk7XFxuICAgICAgICB2YXIgJHN1YiA9ICRsaW5rLnBhcmVudCgpO1xcblxcbiAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMucGFyZW50TGluaykge1xcbiAgICAgICAgICAkbGluay5jbG9uZSgpLnByZXBlbmRUbygkc3ViLmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpKS53cmFwKCc8bGkgZGF0YS1pcy1wYXJlbnQtbGluayBjbGFzcz1cXFwiaXMtc3VibWVudS1wYXJlbnQtaXRlbSBpcy1zdWJtZW51LWl0ZW0gaXMtZHJpbGxkb3duLXN1Ym1lbnUtaXRlbVxcXCIgcm9sZT1cXFwibWVudWl0ZW1cXFwiPjwvbGk+Jyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAkbGluay5kYXRhKCdzYXZlZEhyZWYnLCAkbGluay5hdHRyKCdocmVmJykpLnJlbW92ZUF0dHIoJ2hyZWYnKS5hdHRyKCd0YWJpbmRleCcsIDApO1xcbiAgICAgICAgJGxpbmsuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJykuYXR0cih7XFxuICAgICAgICAgICdhcmlhLWhpZGRlbic6IHRydWUsXFxuICAgICAgICAgICd0YWJpbmRleCc6IDAsXFxuICAgICAgICAgICdyb2xlJzogJ2dyb3VwJ1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBfdGhpcy5fZXZlbnRzKCRsaW5rKTtcXG4gICAgICB9KTtcXG4gICAgICB0aGlzLiRzdWJtZW51cy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciAkbWVudSA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKSxcXG4gICAgICAgICAgICAkYmFjayA9ICRtZW51LmZpbmQoJy5qcy1kcmlsbGRvd24tYmFjaycpO1xcblxcbiAgICAgICAgaWYgKCEkYmFjay5sZW5ndGgpIHtcXG4gICAgICAgICAgc3dpdGNoIChfdGhpcy5vcHRpb25zLmJhY2tCdXR0b25Qb3NpdGlvbikge1xcbiAgICAgICAgICAgIGNhc2UgXFxcImJvdHRvbVxcXCI6XFxuICAgICAgICAgICAgICAkbWVudS5hcHBlbmQoX3RoaXMub3B0aW9ucy5iYWNrQnV0dG9uKTtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgIGNhc2UgXFxcInRvcFxcXCI6XFxuICAgICAgICAgICAgICAkbWVudS5wcmVwZW5kKF90aGlzLm9wdGlvbnMuYmFja0J1dHRvbik7XFxuICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcXFwiVW5zdXBwb3J0ZWQgYmFja0J1dHRvblBvc2l0aW9uIHZhbHVlICdcXFwiICsgX3RoaXMub3B0aW9ucy5iYWNrQnV0dG9uUG9zaXRpb24gKyBcXFwiJ1xcXCIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBfdGhpcy5fYmFjaygkbWVudSk7XFxuICAgICAgfSk7XFxuICAgICAgdGhpcy4kc3VibWVudXMuYWRkQ2xhc3MoJ2ludmlzaWJsZScpO1xcblxcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmF1dG9IZWlnaHQpIHtcXG4gICAgICAgIHRoaXMuJHN1Ym1lbnVzLmFkZENsYXNzKCdkcmlsbGRvd24tc3VibWVudS1jb3Zlci1wcmV2aW91cycpO1xcbiAgICAgIH0gLy8gY3JlYXRlIGEgd3JhcHBlciBvbiBlbGVtZW50IGlmIGl0IGRvZXNuJ3QgZXhpc3QuXFxuXFxuXFxuICAgICAgaWYgKCF0aGlzLiRlbGVtZW50LnBhcmVudCgpLmhhc0NsYXNzKCdpcy1kcmlsbGRvd24nKSkge1xcbiAgICAgICAgdGhpcy4kd3JhcHBlciA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzLm9wdGlvbnMud3JhcHBlcikuYWRkQ2xhc3MoJ2lzLWRyaWxsZG93bicpO1xcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRlSGVpZ2h0KSB0aGlzLiR3cmFwcGVyLmFkZENsYXNzKCdhbmltYXRlLWhlaWdodCcpO1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC53cmFwKHRoaXMuJHdyYXBwZXIpO1xcbiAgICAgIH0gLy8gc2V0IHdyYXBwZXJcXG5cXG5cXG4gICAgICB0aGlzLiR3cmFwcGVyID0gdGhpcy4kZWxlbWVudC5wYXJlbnQoKTtcXG4gICAgICB0aGlzLiR3cmFwcGVyLmNzcyh0aGlzLl9nZXRNYXhEaW1zKCkpO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9yZXNpemVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2l6ZSgpIHtcXG4gICAgICB0aGlzLiR3cmFwcGVyLmNzcyh7XFxuICAgICAgICAnbWF4LXdpZHRoJzogJ25vbmUnLFxcbiAgICAgICAgJ21pbi1oZWlnaHQnOiAnbm9uZSdcXG4gICAgICB9KTsgLy8gX2dldE1heERpbXMgaGFzIHNpZGUgZWZmZWN0cyAoYm9vKSBidXQgY2FsbGluZyBpdCBzaG91bGQgdXBkYXRlIGFsbCBvdGhlciBuZWNlc3NhcnkgaGVpZ2h0cyAmIHdpZHRoc1xcblxcbiAgICAgIHRoaXMuJHdyYXBwZXIuY3NzKHRoaXMuX2dldE1heERpbXMoKSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgdG8gZWxlbWVudHMgaW4gdGhlIG1lbnUuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW0gLSB0aGUgY3VycmVudCBtZW51IGl0ZW0gdG8gYWRkIGhhbmRsZXJzIHRvLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2V2ZW50c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCRlbGVtKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICAkZWxlbS5vZmYoJ2NsaWNrLnpmLmRyaWxsZG93bicpLm9uKCdjbGljay56Zi5kcmlsbGRvd24nLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgaWYgKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShlLnRhcmdldCkucGFyZW50c1VudGlsKCd1bCcsICdsaScpLmhhc0NsYXNzKCdpcy1kcmlsbGRvd24tc3VibWVudS1wYXJlbnQnKSkge1xcbiAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICB9IC8vIGlmKGUudGFyZ2V0ICE9PSBlLmN1cnJlbnRUYXJnZXQuZmlyc3RFbGVtZW50Q2hpbGQpe1xcbiAgICAgICAgLy8gICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAvLyB9XFxuXFxuXFxuICAgICAgICBfdGhpcy5fc2hvdygkZWxlbS5wYXJlbnQoJ2xpJykpO1xcblxcbiAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKSB7XFxuICAgICAgICAgIHZhciAkYm9keSA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnYm9keScpO1xcbiAgICAgICAgICAkYm9keS5vZmYoJy56Zi5kcmlsbGRvd24nKS5vbignY2xpY2suemYuZHJpbGxkb3duJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgPT09IF90aGlzLiRlbGVtZW50WzBdIHx8IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jb250YWlucyhfdGhpcy4kZWxlbWVudFswXSwgZS50YXJnZXQpKSB7XFxuICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG5cXG4gICAgICAgICAgICBfdGhpcy5faGlkZUFsbCgpO1xcblxcbiAgICAgICAgICAgICRib2R5Lm9mZignLnpmLmRyaWxsZG93bicpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQWRkcyBldmVudCBoYW5kbGVycyB0byB0aGUgbWVudSBlbGVtZW50LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9yZWdpc3RlckV2ZW50c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVnaXN0ZXJFdmVudHMoKSB7XFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zY3JvbGxUb3ApIHtcXG4gICAgICAgIHRoaXMuX2JpbmRIYW5kbGVyID0gdGhpcy5fc2Nyb2xsVG9wLmJpbmQodGhpcyk7XFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCdvcGVuLnpmLmRyaWxsZG93biBoaWRlLnpmLmRyaWxsZG93biBjbG9zZWQuemYuZHJpbGxkb3duJywgdGhpcy5fYmluZEhhbmRsZXIpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKCdtdXRhdGVtZS56Zi50cmlnZ2VyJywgdGhpcy5fcmVzaXplLmJpbmQodGhpcykpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBTY3JvbGwgdG8gVG9wIG9mIEVsZW1lbnQgb3IgZGF0YS1zY3JvbGwtdG9wLWVsZW1lbnRcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBmaXJlcyBEcmlsbGRvd24jc2Nyb2xsbWVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9zY3JvbGxUb3BcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Njcm9sbFRvcCgpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgIHZhciAkc2Nyb2xsVG9wRWxlbWVudCA9IF90aGlzLm9wdGlvbnMuc2Nyb2xsVG9wRWxlbWVudCAhPSAnJyA/IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShfdGhpcy5vcHRpb25zLnNjcm9sbFRvcEVsZW1lbnQpIDogX3RoaXMuJGVsZW1lbnQsXFxuICAgICAgICAgIHNjcm9sbFBvcyA9IHBhcnNlSW50KCRzY3JvbGxUb3BFbGVtZW50Lm9mZnNldCgpLnRvcCArIF90aGlzLm9wdGlvbnMuc2Nyb2xsVG9wT2Zmc2V0LCAxMCk7XFxuICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCdodG1sLCBib2R5Jykuc3RvcCh0cnVlKS5hbmltYXRlKHtcXG4gICAgICAgIHNjcm9sbFRvcDogc2Nyb2xsUG9zXFxuICAgICAgfSwgX3RoaXMub3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbiwgX3RoaXMub3B0aW9ucy5hbmltYXRpb25FYXNpbmcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICAqIEZpcmVzIGFmdGVyIHRoZSBtZW51IGhhcyBzY3JvbGxlZFxcbiAgICAgICAgICAqIEBldmVudCBEcmlsbGRvd24jc2Nyb2xsbWVcXG4gICAgICAgICAgKi9cXG4gICAgICAgIGlmICh0aGlzID09PSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoJ2h0bWwnKVswXSkgX3RoaXMuJGVsZW1lbnQudHJpZ2dlcignc2Nyb2xsbWUuemYuZHJpbGxkb3duJyk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEFkZHMga2V5ZG93biBldmVudCBsaXN0ZW5lciB0byBgbGlgJ3MgaW4gdGhlIG1lbnUuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfa2V5Ym9hcmRFdmVudHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2tleWJvYXJkRXZlbnRzKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy4kbWVudUl0ZW1zLmFkZCh0aGlzLiRlbGVtZW50LmZpbmQoJy5qcy1kcmlsbGRvd24tYmFjayA+IGEsIC5pcy1zdWJtZW51LXBhcmVudC1pdGVtID4gYScpKS5vbigna2V5ZG93bi56Zi5kcmlsbGRvd24nLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgdmFyICRlbGVtZW50ID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLFxcbiAgICAgICAgICAgICRlbGVtZW50cyA9ICRlbGVtZW50LnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykuY2hpbGRyZW4oJ2xpJykuY2hpbGRyZW4oJ2EnKSxcXG4gICAgICAgICAgICAkcHJldkVsZW1lbnQsXFxuICAgICAgICAgICAgJG5leHRFbGVtZW50O1xcbiAgICAgICAgJGVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKGkpIHtcXG4gICAgICAgICAgaWYgKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS5pcygkZWxlbWVudCkpIHtcXG4gICAgICAgICAgICAkcHJldkVsZW1lbnQgPSAkZWxlbWVudHMuZXEoTWF0aC5tYXgoMCwgaSAtIDEpKTtcXG4gICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudHMuZXEoTWF0aC5taW4oaSArIDEsICRlbGVtZW50cy5sZW5ndGggLSAxKSk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiS2V5Ym9hcmRcXFwiXS5oYW5kbGVLZXkoZSwgJ0RyaWxsZG93bicsIHtcXG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcXG4gICAgICAgICAgICBpZiAoJGVsZW1lbnQuaXMoX3RoaXMuJHN1Ym1lbnVBbmNob3JzKSkge1xcbiAgICAgICAgICAgICAgX3RoaXMuX3Nob3coJGVsZW1lbnQucGFyZW50KCdsaScpKTtcXG5cXG4gICAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgnbGknKS5vbmUoT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwidHJhbnNpdGlvbmVuZFxcXCJdKSgkZWxlbWVudCksIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLmZpbmQoJ3VsIGxpIGEnKS5ub3QoJy5qcy1kcmlsbGRvd24tYmFjayBhJykuZmlyc3QoKS5mb2N1cygpO1xcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIHByZXZpb3VzOiBmdW5jdGlvbiBwcmV2aW91cygpIHtcXG4gICAgICAgICAgICBfdGhpcy5faGlkZSgkZWxlbWVudC5wYXJlbnQoJ2xpJykucGFyZW50KCd1bCcpKTtcXG5cXG4gICAgICAgICAgICAkZWxlbWVudC5wYXJlbnQoJ2xpJykucGFyZW50KCd1bCcpLm9uZShPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJ0cmFuc2l0aW9uZW5kXFxcIl0pKCRlbGVtZW50KSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykucGFyZW50KCdsaScpLmNoaWxkcmVuKCdhJykuZmlyc3QoKS5mb2N1cygpO1xcbiAgICAgICAgICAgICAgfSwgMSk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIHVwOiBmdW5jdGlvbiB1cCgpIHtcXG4gICAgICAgICAgICAkcHJldkVsZW1lbnQuZm9jdXMoKTsgLy8gRG9uJ3QgdGFwIGZvY3VzIG9uIGZpcnN0IGVsZW1lbnQgaW4gcm9vdCB1bFxcblxcbiAgICAgICAgICAgIHJldHVybiAhJGVsZW1lbnQuaXMoX3RoaXMuJGVsZW1lbnQuZmluZCgnPiBsaTpmaXJzdC1jaGlsZCA+IGEnKSk7XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIGRvd246IGZ1bmN0aW9uIGRvd24oKSB7XFxuICAgICAgICAgICAgJG5leHRFbGVtZW50LmZvY3VzKCk7IC8vIERvbid0IHRhcCBmb2N1cyBvbiBsYXN0IGVsZW1lbnQgaW4gcm9vdCB1bFxcblxcbiAgICAgICAgICAgIHJldHVybiAhJGVsZW1lbnQuaXMoX3RoaXMuJGVsZW1lbnQuZmluZCgnPiBsaTpsYXN0LWNoaWxkID4gYScpKTtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xcbiAgICAgICAgICAgIC8vIERvbid0IGNsb3NlIG9uIGVsZW1lbnQgaW4gcm9vdCB1bFxcbiAgICAgICAgICAgIGlmICghJGVsZW1lbnQuaXMoX3RoaXMuJGVsZW1lbnQuZmluZCgnPiBsaSA+IGEnKSkpIHtcXG4gICAgICAgICAgICAgIF90aGlzLl9oaWRlKCRlbGVtZW50LnBhcmVudCgpLnBhcmVudCgpKTtcXG5cXG4gICAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgpLnBhcmVudCgpLnNpYmxpbmdzKCdhJykuZm9jdXMoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIG9wZW46IGZ1bmN0aW9uIG9wZW4oKSB7XFxuICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMucGFyZW50TGluayAmJiAkZWxlbWVudC5hdHRyKCdocmVmJykpIHtcXG4gICAgICAgICAgICAgIC8vIExpbmsgd2l0aCBocmVmXFxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgICAgfSBlbHNlIGlmICghJGVsZW1lbnQuaXMoX3RoaXMuJG1lbnVJdGVtcykpIHtcXG4gICAgICAgICAgICAgIC8vIG5vdCBtZW51IGl0ZW0gbWVhbnMgYmFjayBidXR0b25cXG4gICAgICAgICAgICAgIF90aGlzLl9oaWRlKCRlbGVtZW50LnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykpO1xcblxcbiAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLnBhcmVudCgndWwnKS5vbmUoT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwidHJhbnNpdGlvbmVuZFxcXCJdKSgkZWxlbWVudCksIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLnBhcmVudCgndWwnKS5wYXJlbnQoJ2xpJykuY2hpbGRyZW4oJ2EnKS5maXJzdCgpLmZvY3VzKCk7XFxuICAgICAgICAgICAgICAgIH0sIDEpO1xcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRlbGVtZW50LmlzKF90aGlzLiRzdWJtZW51QW5jaG9ycykpIHtcXG4gICAgICAgICAgICAgIC8vIFN1YiBtZW51IGl0ZW1cXG4gICAgICAgICAgICAgIF90aGlzLl9zaG93KCRlbGVtZW50LnBhcmVudCgnbGknKSk7XFxuXFxuICAgICAgICAgICAgICAkZWxlbWVudC5wYXJlbnQoJ2xpJykub25lKE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcInRyYW5zaXRpb25lbmRcXFwiXSkoJGVsZW1lbnQpLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgnbGknKS5maW5kKCd1bCBsaSBhJykubm90KCcuanMtZHJpbGxkb3duLWJhY2sgYScpLmZpcnN0KCkuZm9jdXMoKTtcXG4gICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBoYW5kbGVkOiBmdW5jdGlvbiBoYW5kbGVkKHByZXZlbnREZWZhdWx0KSB7XFxuICAgICAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0KSB7XFxuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH0pOyAvLyBlbmQga2V5Ym9hcmRBY2Nlc3NcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2xvc2VzIGFsbCBvcGVuIGVsZW1lbnRzLCBhbmQgcmV0dXJucyB0byByb290IG1lbnUuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAZmlyZXMgRHJpbGxkb3duI2Nsb3NlZFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2hpZGVBbGxcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hpZGVBbGwoKSB7XFxuICAgICAgdmFyICRlbGVtID0gdGhpcy4kZWxlbWVudC5maW5kKCcuaXMtZHJpbGxkb3duLXN1Ym1lbnUuaXMtYWN0aXZlJykuYWRkQ2xhc3MoJ2lzLWNsb3NpbmcnKTtcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9IZWlnaHQpIHRoaXMuJHdyYXBwZXIuY3NzKHtcXG4gICAgICAgIGhlaWdodDogJGVsZW0ucGFyZW50KCkuY2xvc2VzdCgndWwnKS5kYXRhKCdjYWxjSGVpZ2h0JylcXG4gICAgICB9KTtcXG4gICAgICAkZWxlbS5vbmUoT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwidHJhbnNpdGlvbmVuZFxcXCJdKSgkZWxlbSksIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAkZWxlbS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlIGlzLWNsb3NpbmcnKTtcXG4gICAgICB9KTtcXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBtZW51IGlzIGZ1bGx5IGNsb3NlZC5cXG4gICAgICAgKiBAZXZlbnQgRHJpbGxkb3duI2Nsb3NlZFxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignY2xvc2VkLnpmLmRyaWxsZG93bicpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVyIGZvciBlYWNoIGBiYWNrYCBidXR0b24sIGFuZCBjbG9zZXMgb3BlbiBtZW51cy5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBmaXJlcyBEcmlsbGRvd24jYmFja1xcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW0gLSB0aGUgY3VycmVudCBzdWItbWVudSB0byBhZGQgYGJhY2tgIGV2ZW50LlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2JhY2tcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JhY2soJGVsZW0pIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgICRlbGVtLm9mZignY2xpY2suemYuZHJpbGxkb3duJyk7XFxuICAgICAgJGVsZW0uY2hpbGRyZW4oJy5qcy1kcmlsbGRvd24tYmFjaycpLm9uKCdjbGljay56Zi5kcmlsbGRvd24nLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTsgLy8gY29uc29sZS5sb2coJ21vdXNldXAgb24gYmFjaycpO1xcblxcbiAgICAgICAgX3RoaXMuX2hpZGUoJGVsZW0pOyAvLyBJZiB0aGVyZSBpcyBhIHBhcmVudCBzdWJtZW51LCBjYWxsIHNob3dcXG5cXG5cXG4gICAgICAgIHZhciBwYXJlbnRTdWJNZW51ID0gJGVsZW0ucGFyZW50KCdsaScpLnBhcmVudCgndWwnKS5wYXJlbnQoJ2xpJyk7XFxuXFxuICAgICAgICBpZiAocGFyZW50U3ViTWVudS5sZW5ndGgpIHtcXG4gICAgICAgICAgX3RoaXMuX3Nob3cocGFyZW50U3ViTWVudSk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEFkZHMgZXZlbnQgbGlzdGVuZXIgdG8gbWVudSBpdGVtcyB3L28gc3VibWVudXMgdG8gY2xvc2Ugb3BlbiBtZW51cyBvbiBjbGljay5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfbWVudUxpbmtFdmVudHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21lbnVMaW5rRXZlbnRzKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy4kbWVudUl0ZW1zLm5vdCgnLmlzLWRyaWxsZG93bi1zdWJtZW51LXBhcmVudCcpLm9mZignY2xpY2suemYuZHJpbGxkb3duJykub24oJ2NsaWNrLnpmLmRyaWxsZG93bicsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAvLyBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIF90aGlzLl9oaWRlQWxsKCk7XFxuICAgICAgICB9LCAwKTtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogU2V0cyB0aGUgQ1NTIGNsYXNzZXMgZm9yIHN1Ym1lbnUgdG8gc2hvdyBpdC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbSAtIHRoZSB0YXJnZXQgc3VibWVudSAoYHVsYCB0YWcpXFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdHJpZ2dlciAtIHRyaWdnZXIgZHJpbGxkb3duIGV2ZW50XFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfc2V0U2hvd1N1Yk1lbnVDbGFzc2VzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRTaG93U3ViTWVudUNsYXNzZXMoJGVsZW0sIHRyaWdnZXIpIHtcXG4gICAgICAkZWxlbS5hZGRDbGFzcygnaXMtYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2ludmlzaWJsZScpLmF0dHIoJ2FyaWEtaGlkZGVuJywgZmFsc2UpO1xcbiAgICAgICRlbGVtLnBhcmVudCgnbGknKS5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSk7XFxuXFxuICAgICAgaWYgKHRyaWdnZXIgPT09IHRydWUpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignb3Blbi56Zi5kcmlsbGRvd24nLCBbJGVsZW1dKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFNldHMgdGhlIENTUyBjbGFzc2VzIGZvciBzdWJtZW51IHRvIGhpZGUgaXQuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW0gLSB0aGUgdGFyZ2V0IHN1Ym1lbnUgKGB1bGAgdGFnKVxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHRyaWdnZXIgLSB0cmlnZ2VyIGRyaWxsZG93biBldmVudFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3NldEhpZGVTdWJNZW51Q2xhc3Nlc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0SGlkZVN1Yk1lbnVDbGFzc2VzKCRlbGVtLCB0cmlnZ2VyKSB7XFxuICAgICAgJGVsZW0ucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpLmFkZENsYXNzKCdpbnZpc2libGUnKS5hdHRyKCdhcmlhLWhpZGRlbicsIHRydWUpO1xcbiAgICAgICRlbGVtLnBhcmVudCgnbGknKS5hdHRyKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpO1xcblxcbiAgICAgIGlmICh0cmlnZ2VyID09PSB0cnVlKSB7XFxuICAgICAgICAkZWxlbS50cmlnZ2VyKCdoaWRlLnpmLmRyaWxsZG93bicsIFskZWxlbV0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogT3BlbnMgYSBzcGVjaWZpYyBkcmlsbGRvd24gKHN1YiltZW51IG5vIG1hdHRlciB3aGljaCAoc3ViKW1lbnUgaW4gaXQgaXMgY3VycmVudGx5IHZpc2libGUuXFxuICAgICAqIENvbXBhcmVkIHRvIF9zaG93KCkgdGhpcyBsZXRzIHlvdSBqdW1wIGludG8gYW55IHN1Ym1lbnUgd2l0aG91dCBjbGlja2luZyB0aHJvdWdoIGV2ZXJ5IHN1Ym1lbnUgb24gdGhlIHdheSB0byBpdC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBmaXJlcyBEcmlsbGRvd24jb3BlblxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW0gLSB0aGUgdGFyZ2V0IChzdWIpbWVudSAoYHVsYCB0YWcpXFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYXV0b0ZvY3VzIC0gaWYgdHJ1ZSB0aGUgZmlyc3QgbGluayBpbiB0aGUgdGFyZ2V0IChzdWIpbWVudSBnZXRzIGF1dG8gZm9jdXNlZFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3Nob3dNZW51XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zaG93TWVudSgkZWxlbSwgYXV0b0ZvY3VzKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpczsgLy8gUmVzZXQgZHJpbGxkb3duXFxuXFxuXFxuICAgICAgdmFyICRleHBhbmRlZFN1Ym1lbnVzID0gdGhpcy4kZWxlbWVudC5maW5kKCdsaVthcmlhLWV4cGFuZGVkPVxcXCJ0cnVlXFxcIl0gPiB1bFtkYXRhLXN1Ym1lbnVdJyk7XFxuICAgICAgJGV4cGFuZGVkU3VibWVudXMuZWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcXG4gICAgICAgIF90aGlzLl9zZXRIaWRlU3ViTWVudUNsYXNzZXMoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpKTtcXG4gICAgICB9KTsgLy8gU2F2ZSB0aGUgbWVudSBhcyB0aGUgY3VycmVudGx5IGRpc3BsYXllZCBvbmUuXFxuXFxuICAgICAgdGhpcy4kY3VycmVudE1lbnUgPSAkZWxlbTsgLy8gSWYgdGFyZ2V0IG1lbnUgaXMgcm9vdCwgZm9jdXMgZmlyc3QgbGluayAmIGV4aXRcXG5cXG4gICAgICBpZiAoJGVsZW0uaXMoJ1tkYXRhLWRyaWxsZG93bl0nKSkge1xcbiAgICAgICAgaWYgKGF1dG9Gb2N1cyA9PT0gdHJ1ZSkgJGVsZW0uZmluZCgnbGlbcm9sZT1cXFwidHJlZWl0ZW1cXFwiXSA+IGEnKS5maXJzdCgpLmZvY3VzKCk7XFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9IZWlnaHQpIHRoaXMuJHdyYXBwZXIuY3NzKCdoZWlnaHQnLCAkZWxlbS5kYXRhKCdjYWxjSGVpZ2h0JykpO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH0gLy8gRmluZCBhbGwgc3VibWVudXMgb24gd2F5IHRvIHJvb3QgaW5jbC4gdGhlIGVsZW1lbnQgaXRzZWxmXFxuXFxuXFxuICAgICAgdmFyICRzdWJtZW51cyA9ICRlbGVtLmNoaWxkcmVuKCkuZmlyc3QoKS5wYXJlbnRzVW50aWwoJ1tkYXRhLWRyaWxsZG93bl0nLCAnW2RhdGEtc3VibWVudV0nKTsgLy8gT3BlbiB0YXJnZXQgbWVudSBhbmQgYWxsIHN1Ym1lbnVzIG9uIGl0cyB3YXkgdG8gcm9vdFxcblxcbiAgICAgICRzdWJtZW51cy5lYWNoKGZ1bmN0aW9uIChpbmRleCkge1xcbiAgICAgICAgLy8gVXBkYXRlIGhlaWdodCBvZiBmaXJzdCBjaGlsZCAodGFyZ2V0IG1lbnUpIGlmIGF1dG9IZWlnaHQgb3B0aW9uIHRydWVcXG4gICAgICAgIGlmIChpbmRleCA9PT0gMCAmJiBfdGhpcy5vcHRpb25zLmF1dG9IZWlnaHQpIHtcXG4gICAgICAgICAgX3RoaXMuJHdyYXBwZXIuY3NzKCdoZWlnaHQnLCBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykuZGF0YSgnY2FsY0hlaWdodCcpKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBpc0xhc3RDaGlsZCA9IGluZGV4ID09ICRzdWJtZW51cy5sZW5ndGggLSAxOyAvLyBBZGQgdHJhbnNpdGlvbnNlbmQgbGlzdGVuZXIgdG8gbGFzdCBjaGlsZCAocm9vdCBkdWUgdG8gcmV2ZXJzZSBvcmRlcikgdG8gb3BlbiB0YXJnZXQgbWVudSdzIGZpcnN0IGxpbmtcXG4gICAgICAgIC8vIExhc3QgY2hpbGQgbWFrZXMgc3VyZSB0aGUgZXZlbnQgZ2V0cyBhbHdheXMgdHJpZ2dlcmVkIGV2ZW4gaWYgZ29pbmcgdGhyb3VnaCBzZXZlcmFsIG1lbnVzXFxuXFxuICAgICAgICBpZiAoaXNMYXN0Q2hpbGQgPT09IHRydWUpIHtcXG4gICAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLm9uZShPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJ0cmFuc2l0aW9uZW5kXFxcIl0pKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKSksIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpZiAoYXV0b0ZvY3VzID09PSB0cnVlKSB7XFxuICAgICAgICAgICAgICAkZWxlbS5maW5kKCdsaVtyb2xlPVxcXCJ0cmVlaXRlbVxcXCJdID4gYScpLmZpcnN0KCkuZm9jdXMoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgX3RoaXMuX3NldFNob3dTdWJNZW51Q2xhc3NlcyhqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcyksIGlzTGFzdENoaWxkKTtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogT3BlbnMgYSBzdWJtZW51LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQGZpcmVzIERyaWxsZG93biNvcGVuXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbSAtIHRoZSBjdXJyZW50IGVsZW1lbnQgd2l0aCBhIHN1Ym1lbnUgdG8gb3BlbiwgaS5lLiB0aGUgYGxpYCB0YWcuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfc2hvd1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2hvdygkZWxlbSkge1xcbiAgICAgIHZhciAkc3VibWVudSA9ICRlbGVtLmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpO1xcbiAgICAgICRlbGVtLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKTtcXG4gICAgICB0aGlzLiRjdXJyZW50TWVudSA9ICRzdWJtZW51O1xcbiAgICAgICRzdWJtZW51LmFkZENsYXNzKCdpcy1hY3RpdmUnKS5yZW1vdmVDbGFzcygnaW52aXNpYmxlJykuYXR0cignYXJpYS1oaWRkZW4nLCBmYWxzZSk7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvSGVpZ2h0KSB7XFxuICAgICAgICB0aGlzLiR3cmFwcGVyLmNzcyh7XFxuICAgICAgICAgIGhlaWdodDogJHN1Ym1lbnUuZGF0YSgnY2FsY0hlaWdodCcpXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgc3VibWVudSBoYXMgb3BlbmVkLlxcbiAgICAgICAqIEBldmVudCBEcmlsbGRvd24jb3BlblxcbiAgICAgICAqL1xcblxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignb3Blbi56Zi5kcmlsbGRvd24nLCBbJGVsZW1dKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSGlkZXMgYSBzdWJtZW51XFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAZmlyZXMgRHJpbGxkb3duI2hpZGVcXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICRlbGVtIC0gdGhlIGN1cnJlbnQgc3ViLW1lbnUgdG8gaGlkZSwgaS5lLiB0aGUgYHVsYCB0YWcuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfaGlkZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGlkZSgkZWxlbSkge1xcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0hlaWdodCkgdGhpcy4kd3JhcHBlci5jc3Moe1xcbiAgICAgICAgaGVpZ2h0OiAkZWxlbS5wYXJlbnQoKS5jbG9zZXN0KCd1bCcpLmRhdGEoJ2NhbGNIZWlnaHQnKVxcbiAgICAgIH0pO1xcblxcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgJGVsZW0ucGFyZW50KCdsaScpLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XFxuICAgICAgJGVsZW0uYXR0cignYXJpYS1oaWRkZW4nLCB0cnVlKTtcXG4gICAgICAkZWxlbS5hZGRDbGFzcygnaXMtY2xvc2luZycpLm9uZShPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJ0cmFuc2l0aW9uZW5kXFxcIl0pKCRlbGVtKSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgJGVsZW0ucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZSBpcy1jbG9zaW5nJyk7XFxuICAgICAgICAkZWxlbS5ibHVyKCkuYWRkQ2xhc3MoJ2ludmlzaWJsZScpO1xcbiAgICAgIH0pO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHN1Ym1lbnUgaGFzIGNsb3NlZC5cXG4gICAgICAgKiBAZXZlbnQgRHJpbGxkb3duI2hpZGVcXG4gICAgICAgKi9cXG5cXG4gICAgICAkZWxlbS50cmlnZ2VyKCdoaWRlLnpmLmRyaWxsZG93bicsIFskZWxlbV0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJdGVyYXRlcyB0aHJvdWdoIHRoZSBuZXN0ZWQgbWVudXMgdG8gY2FsY3VsYXRlIHRoZSBtaW4taGVpZ2h0LCBhbmQgbWF4LXdpZHRoIGZvciB0aGUgbWVudS5cXG4gICAgICogUHJldmVudHMgY29udGVudCBqdW1waW5nLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9nZXRNYXhEaW1zXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRNYXhEaW1zKCkge1xcbiAgICAgIHZhciBtYXhIZWlnaHQgPSAwLFxcbiAgICAgICAgICByZXN1bHQgPSB7fSxcXG4gICAgICAgICAgX3RoaXMgPSB0aGlzOyAvLyBSZWNhbGN1bGF0ZSBtZW51IGhlaWdodHMgYW5kIHRvdGFsIG1heCBoZWlnaHRcXG5cXG5cXG4gICAgICB0aGlzLiRzdWJtZW51cy5hZGQodGhpcy4kZWxlbWVudCkuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgbnVtT2ZFbGVtcyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS5jaGlsZHJlbignbGknKS5sZW5ndGg7XFxuICAgICAgICB2YXIgaGVpZ2h0ID0gX2ZvdW5kYXRpb25fdXRpbF9ib3hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiQm94XFxcIl0uR2V0RGltZW5zaW9ucyh0aGlzKS5oZWlnaHQ7XFxuICAgICAgICBtYXhIZWlnaHQgPSBoZWlnaHQgPiBtYXhIZWlnaHQgPyBoZWlnaHQgOiBtYXhIZWlnaHQ7XFxuXFxuICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5hdXRvSGVpZ2h0KSB7XFxuICAgICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS5kYXRhKCdjYWxjSGVpZ2h0JywgaGVpZ2h0KTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9IZWlnaHQpIHJlc3VsdFsnaGVpZ2h0J10gPSB0aGlzLiRjdXJyZW50TWVudS5kYXRhKCdjYWxjSGVpZ2h0Jyk7ZWxzZSByZXN1bHRbJ21pbi1oZWlnaHQnXSA9IFxcXCJcXFwiLmNvbmNhdChtYXhIZWlnaHQsIFxcXCJweFxcXCIpO1xcbiAgICAgIHJlc3VsdFsnbWF4LXdpZHRoJ10gPSBcXFwiXFxcIi5jb25jYXQodGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCwgXFxcInB4XFxcIik7XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogRGVzdHJveXMgdGhlIERyaWxsZG93biBNZW51XFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2Rlc3Ryb3lcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zY3JvbGxUb3ApIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYuZHJpbGxkb3duJywgdGhpcy5fYmluZEhhbmRsZXIpO1xcblxcbiAgICAgIHRoaXMuX2hpZGVBbGwoKTtcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZignbXV0YXRlbWUuemYudHJpZ2dlcicpO1xcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfbmVzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJOZXN0XFxcIl0uQnVybih0aGlzLiRlbGVtZW50LCAnZHJpbGxkb3duJyk7XFxuICAgICAgdGhpcy4kZWxlbWVudC51bndyYXAoKS5maW5kKCcuanMtZHJpbGxkb3duLWJhY2ssIC5pcy1zdWJtZW51LXBhcmVudC1pdGVtJykucmVtb3ZlKCkuZW5kKCkuZmluZCgnLmlzLWFjdGl2ZSwgLmlzLWNsb3NpbmcsIC5pcy1kcmlsbGRvd24tc3VibWVudScpLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUgaXMtY2xvc2luZyBpcy1kcmlsbGRvd24tc3VibWVudScpLmVuZCgpLmZpbmQoJ1tkYXRhLXN1Ym1lbnVdJykucmVtb3ZlQXR0cignYXJpYS1oaWRkZW4gdGFiaW5kZXggcm9sZScpO1xcbiAgICAgIHRoaXMuJHN1Ym1lbnVBbmNob3JzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLm9mZignLnpmLmRyaWxsZG93bicpO1xcbiAgICAgIH0pO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtaXMtcGFyZW50LWxpbmtdJykuZGV0YWNoKCk7XFxuICAgICAgdGhpcy4kc3VibWVudXMucmVtb3ZlQ2xhc3MoJ2RyaWxsZG93bi1zdWJtZW51LWNvdmVyLXByZXZpb3VzIGludmlzaWJsZScpO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnYScpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyICRsaW5rID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpO1xcbiAgICAgICAgJGxpbmsucmVtb3ZlQXR0cigndGFiaW5kZXgnKTtcXG5cXG4gICAgICAgIGlmICgkbGluay5kYXRhKCdzYXZlZEhyZWYnKSkge1xcbiAgICAgICAgICAkbGluay5hdHRyKCdocmVmJywgJGxpbmsuZGF0YSgnc2F2ZWRIcmVmJykpLnJlbW92ZURhdGEoJ3NhdmVkSHJlZicpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gRHJpbGxkb3duO1xcbn0oX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwiUGx1Z2luXFxcIl0pO1xcblxcbkRyaWxsZG93bi5kZWZhdWx0cyA9IHtcXG4gIC8qKlxcbiAgICogRHJpbGxkb3ducyBkZXBlbmQgb24gc3R5bGVzIGluIG9yZGVyIHRvIGZ1bmN0aW9uIHByb3Blcmx5OyBpbiB0aGUgZGVmYXVsdCBidWlsZCBvZiBGb3VuZGF0aW9uIHRoZXNlIGFyZVxcbiAgICogb24gdGhlIGBkcmlsbGRvd25gIGNsYXNzLiBUaGlzIG9wdGlvbiBhdXRvLWFwcGxpZXMgdGhpcyBjbGFzcyB0byB0aGUgZHJpbGxkb3duIHVwb24gaW5pdGlhbGl6YXRpb24uXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGlhbn1cXG4gICAqIEBkZWZhdWx0IHRydWVcXG4gICAqL1xcbiAgYXV0b0FwcGx5Q2xhc3M6IHRydWUsXFxuXFxuICAvKipcXG4gICAqIE1hcmt1cCB1c2VkIGZvciBKUyBnZW5lcmF0ZWQgYmFjayBidXR0b24uIFByZXBlbmRlZCAgb3IgYXBwZW5kZWQgKHNlZSBiYWNrQnV0dG9uUG9zaXRpb24pIHRvIHN1Ym1lbnUgbGlzdHMgYW5kIGRlbGV0ZWQgb24gYGRlc3Ryb3lgIG1ldGhvZCwgJ2pzLWRyaWxsZG93bi1iYWNrJyBjbGFzcyByZXF1aXJlZC4gUmVtb3ZlIHRoZSBiYWNrc2xhc2ggKGBcXFxcYCkgaWYgY29weSBhbmQgcGFzdGluZy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnPGxpIGNsYXNzPVxcXCJqcy1kcmlsbGRvd24tYmFja1xcXCI+PGEgdGFiaW5kZXg9XFxcIjBcXFwiPkJhY2s8L2E+PC9saT4nXFxuICAgKi9cXG4gIGJhY2tCdXR0b246ICc8bGkgY2xhc3M9XFxcImpzLWRyaWxsZG93bi1iYWNrXFxcIj48YSB0YWJpbmRleD1cXFwiMFxcXCI+QmFjazwvYT48L2xpPicsXFxuXFxuICAvKipcXG4gICAqIFBvc2l0aW9uIHRoZSBiYWNrIGJ1dHRvbiBlaXRoZXIgYXQgdGhlIHRvcCBvciBib3R0b20gb2YgZHJpbGxkb3duIHN1Ym1lbnVzLiBDYW4gYmUgYCdsZWZ0J2Agb3IgYCdib3R0b20nYC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCB0b3BcXG4gICAqL1xcbiAgYmFja0J1dHRvblBvc2l0aW9uOiAndG9wJyxcXG5cXG4gIC8qKlxcbiAgICogTWFya3VwIHVzZWQgdG8gd3JhcCBkcmlsbGRvd24gbWVudS4gVXNlIGEgY2xhc3MgbmFtZSBmb3IgaW5kZXBlbmRlbnQgc3R5bGluZzsgdGhlIEpTIGFwcGxpZWQgY2xhc3M6IGBpcy1kcmlsbGRvd25gIGlzIHJlcXVpcmVkLiBSZW1vdmUgdGhlIGJhY2tzbGFzaCAoYFxcXFxgKSBpZiBjb3B5IGFuZCBwYXN0aW5nLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICc8ZGl2PjwvZGl2PidcXG4gICAqL1xcbiAgd3JhcHBlcjogJzxkaXY+PC9kaXY+JyxcXG5cXG4gIC8qKlxcbiAgICogQWRkcyB0aGUgcGFyZW50IGxpbmsgdG8gdGhlIHN1Ym1lbnUuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIHBhcmVudExpbms6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvdyB0aGUgbWVudSB0byByZXR1cm4gdG8gcm9vdCBsaXN0IG9uIGJvZHkgY2xpY2suXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGNsb3NlT25DbGljazogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIEFsbG93IHRoZSBtZW51IHRvIGF1dG8gYWRqdXN0IGhlaWdodC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgYXV0b0hlaWdodDogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIEFuaW1hdGUgdGhlIGF1dG8gYWRqdXN0IGhlaWdodC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgYW5pbWF0ZUhlaWdodDogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIFNjcm9sbCB0byB0aGUgdG9wIG9mIHRoZSBtZW51IGFmdGVyIG9wZW5pbmcgYSBzdWJtZW51IG9yIG5hdmlnYXRpbmcgYmFjayB1c2luZyB0aGUgbWVudSBiYWNrIGJ1dHRvblxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBzY3JvbGxUb3A6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBTdHJpbmcganF1ZXJ5IHNlbGVjdG9yIChmb3IgZXhhbXBsZSAnYm9keScpIG9mIGVsZW1lbnQgdG8gdGFrZSBvZmZzZXQoKS50b3AgZnJvbSwgaWYgZW1wdHkgc3RyaW5nIHRoZSBkcmlsbGRvd24gbWVudSBvZmZzZXQoKS50b3AgaXMgdGFrZW5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnJ1xcbiAgICovXFxuICBzY3JvbGxUb3BFbGVtZW50OiAnJyxcXG5cXG4gIC8qKlxcbiAgICogU2Nyb2xsVG9wIG9mZnNldFxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDBcXG4gICAqL1xcbiAgc2Nyb2xsVG9wT2Zmc2V0OiAwLFxcblxcbiAgLyoqXFxuICAgKiBTY3JvbGwgYW5pbWF0aW9uIGR1cmF0aW9uXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgNTAwXFxuICAgKi9cXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXFxuXFxuICAvKipcXG4gICAqIFNjcm9sbCBhbmltYXRpb24gZWFzaW5nLiBDYW4gYmUgYCdzd2luZydgIG9yIGAnbGluZWFyJ2AuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9hbmltYXRlfEpRdWVyeSBhbmltYXRlfVxcbiAgICogQGRlZmF1bHQgJ3N3aW5nJ1xcbiAgICovXFxuICBhbmltYXRpb25FYXNpbmc6ICdzd2luZycgLy8gaG9sZE9wZW46IGZhbHNlXFxuXFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9qcy9mb3VuZGF0aW9uLmRyaWxsZG93bi5qcz9cIil9LFwiLi9qcy9mb3VuZGF0aW9uLmRyb3Bkb3duLmpzXCI6ZnVuY3Rpb24obW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJEcm9wZG93blxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gRHJvcGRvd247IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGpxdWVyeSAqLyBcXFwianF1ZXJ5XFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmQgKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLmtleWJvYXJkLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnV0aWxzICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS51dGlscy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9wb3NpdGlvbmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5wb3NpdGlvbmFibGUgKi8gXFxcIi4vanMvZm91bmRhdGlvbi5wb3NpdGlvbmFibGUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF90cmlnZ2Vyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnMgKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxcblxcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XFxuXFxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxcblxcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cXFwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XFxuXFxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cXG5cXG5cXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBEcm9wZG93biBtb2R1bGUuXFxuICogQG1vZHVsZSBmb3VuZGF0aW9uLmRyb3Bkb3duXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuYm94XFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xcbiAqL1xcblxcbnZhciBEcm9wZG93biA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uIChfUG9zaXRpb25hYmxlKSB7XFxuICBfaW5oZXJpdHMoRHJvcGRvd24sIF9Qb3NpdGlvbmFibGUpO1xcblxcbiAgZnVuY3Rpb24gRHJvcGRvd24oKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcm9wZG93bik7XFxuXFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoRHJvcGRvd24pLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKERyb3Bkb3duLCBbe1xcbiAgICBrZXk6IFxcXCJfc2V0dXBcXFwiLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIGRyb3Bkb3duLlxcbiAgICAgKiBAY2xhc3NcXG4gICAgICogQG5hbWUgRHJvcGRvd25cXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBhIGRyb3Bkb3duLlxcbiAgICAgKiAgICAgICAgT2JqZWN0IHNob3VsZCBiZSBvZiB0aGUgZHJvcGRvd24gcGFuZWwsIHJhdGhlciB0aGFuIGl0cyBhbmNob3IuXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cXG4gICAgICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMub3B0aW9ucyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoe30sIERyb3Bkb3duLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XFxuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnRHJvcGRvd24nOyAvLyBpZTkgYmFjayBjb21wYXRcXG4gICAgICAvLyBUcmlnZ2VycyBpbml0IGlzIGlkZW1wb3RlbnQsIGp1c3QgbmVlZCB0byBtYWtlIHN1cmUgaXQgaXMgaW5pdGlhbGl6ZWRcXG5cXG4gICAgICBfZm91bmRhdGlvbl91dGlsX3RyaWdnZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcIlRyaWdnZXJzXFxcIl0uaW5pdChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEpO1xcblxcbiAgICAgIHRoaXMuX2luaXQoKTtcXG5cXG4gICAgICBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIktleWJvYXJkXFxcIl0ucmVnaXN0ZXIoJ0Ryb3Bkb3duJywge1xcbiAgICAgICAgJ0VOVEVSJzogJ3RvZ2dsZScsXFxuICAgICAgICAnU1BBQ0UnOiAndG9nZ2xlJyxcXG4gICAgICAgICdFU0NBUEUnOiAnY2xvc2UnXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIHRoZSBwbHVnaW4gYnkgc2V0dGluZy9jaGVja2luZyBvcHRpb25zIGFuZCBhdHRyaWJ1dGVzLCBhZGRpbmcgaGVscGVyIHZhcmlhYmxlcywgYW5kIHNhdmluZyB0aGUgYW5jaG9yLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9pbml0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgIHZhciAkaWQgPSB0aGlzLiRlbGVtZW50LmF0dHIoJ2lkJyk7XFxuICAgICAgdGhpcy4kYW5jaG9ycyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShcXFwiW2RhdGEtdG9nZ2xlPVxcXFxcXFwiXFxcIi5jb25jYXQoJGlkLCBcXFwiXFxcXFxcXCJdXFxcIikpLmxlbmd0aCA/IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShcXFwiW2RhdGEtdG9nZ2xlPVxcXFxcXFwiXFxcIi5jb25jYXQoJGlkLCBcXFwiXFxcXFxcXCJdXFxcIikpIDoganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKFxcXCJbZGF0YS1vcGVuPVxcXFxcXFwiXFxcIi5jb25jYXQoJGlkLCBcXFwiXFxcXFxcXCJdXFxcIikpO1xcbiAgICAgIHRoaXMuJGFuY2hvcnMuYXR0cih7XFxuICAgICAgICAnYXJpYS1jb250cm9scyc6ICRpZCxcXG4gICAgICAgICdkYXRhLWlzLWZvY3VzJzogZmFsc2UsXFxuICAgICAgICAnZGF0YS15ZXRpLWJveCc6ICRpZCxcXG4gICAgICAgICdhcmlhLWhhc3BvcHVwJzogdHJ1ZSxcXG4gICAgICAgICdhcmlhLWV4cGFuZGVkJzogZmFsc2VcXG4gICAgICB9KTtcXG5cXG4gICAgICB0aGlzLl9zZXRDdXJyZW50QW5jaG9yKHRoaXMuJGFuY2hvcnMuZmlyc3QoKSk7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wYXJlbnRDbGFzcykge1xcbiAgICAgICAgdGhpcy4kcGFyZW50ID0gdGhpcy4kZWxlbWVudC5wYXJlbnRzKCcuJyArIHRoaXMub3B0aW9ucy5wYXJlbnRDbGFzcyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuJHBhcmVudCA9IG51bGw7XFxuICAgICAgfSAvLyBTZXQgW2FyaWEtbGFiZWxsZWRieV0gb24gdGhlIERyb3Bkb3duIGlmIGl0IGlzIG5vdCBzZXRcXG5cXG5cXG4gICAgICBpZiAodHlwZW9mIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1sYWJlbGxlZGJ5JykgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAvLyBHZXQgdGhlIGFuY2hvciBJRCBvciBjcmVhdGUgb25lXFxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuJGN1cnJlbnRBbmNob3IuYXR0cignaWQnKSA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgdGhpcy4kY3VycmVudEFuY2hvci5hdHRyKCdpZCcsIE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIkdldFlvRGlnaXRzXFxcIl0pKDYsICdkZC1hbmNob3InKSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICA7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtbGFiZWxsZWRieScsIHRoaXMuJGN1cnJlbnRBbmNob3IuYXR0cignaWQnKSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cih7XFxuICAgICAgICAnYXJpYS1oaWRkZW4nOiAndHJ1ZScsXFxuICAgICAgICAnZGF0YS15ZXRpLWJveCc6ICRpZCxcXG4gICAgICAgICdkYXRhLXJlc2l6ZSc6ICRpZFxcbiAgICAgIH0pO1xcblxcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKERyb3Bkb3duLnByb3RvdHlwZSksIFxcXCJfaW5pdFxcXCIsIHRoaXMpLmNhbGwodGhpcyk7XFxuXFxuICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2dldERlZmF1bHRQb3NpdGlvblxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGVmYXVsdFBvc2l0aW9uKCkge1xcbiAgICAgIC8vIGhhbmRsZSBsZWdhY3kgY2xhc3NuYW1lc1xcbiAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuJGVsZW1lbnRbMF0uY2xhc3NOYW1lLm1hdGNoKC8odG9wfGxlZnR8cmlnaHR8Ym90dG9tKS9nKTtcXG5cXG4gICAgICBpZiAocG9zaXRpb24pIHtcXG4gICAgICAgIHJldHVybiBwb3NpdGlvblswXTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuICdib3R0b20nO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZ2V0RGVmYXVsdEFsaWdubWVudFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGVmYXVsdEFsaWdubWVudCgpIHtcXG4gICAgICAvLyBoYW5kbGUgbGVnYWN5IGZsb2F0IGFwcHJvYWNoXFxuICAgICAgdmFyIGhvcml6b250YWxQb3NpdGlvbiA9IC9mbG9hdC0oXFxcXFMrKS8uZXhlYyh0aGlzLiRjdXJyZW50QW5jaG9yLmF0dHIoJ2NsYXNzJykpO1xcblxcbiAgICAgIGlmIChob3Jpem9udGFsUG9zaXRpb24pIHtcXG4gICAgICAgIHJldHVybiBob3Jpem9udGFsUG9zaXRpb25bMV07XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihEcm9wZG93bi5wcm90b3R5cGUpLCBcXFwiX2dldERlZmF1bHRBbGlnbm1lbnRcXFwiLCB0aGlzKS5jYWxsKHRoaXMpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24gb2YgdGhlIGRyb3Bkb3duIHBhbmUsIGNoZWNrcyBmb3IgY29sbGlzaW9ucyBpZiBhbGxvdy1vdmVybGFwIGlzIG5vdCB0cnVlLlxcbiAgICAgKiBSZWN1cnNpdmVseSBjYWxscyBpdHNlbGYgaWYgYSBjb2xsaXNpb24gaXMgZGV0ZWN0ZWQsIHdpdGggYSBuZXcgcG9zaXRpb24gY2xhc3MuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3NldFBvc2l0aW9uXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRQb3NpdGlvbigpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJoYXMtcG9zaXRpb24tXFxcIi5jb25jYXQodGhpcy5wb3NpdGlvbiwgXFxcIiBoYXMtYWxpZ25tZW50LVxcXCIpLmNvbmNhdCh0aGlzLmFsaWdubWVudCkpO1xcblxcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKERyb3Bkb3duLnByb3RvdHlwZSksIFxcXCJfc2V0UG9zaXRpb25cXFwiLCB0aGlzKS5jYWxsKHRoaXMsIHRoaXMuJGN1cnJlbnRBbmNob3IsIHRoaXMuJGVsZW1lbnQsIHRoaXMuJHBhcmVudCk7XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcyhcXFwiaGFzLXBvc2l0aW9uLVxcXCIuY29uY2F0KHRoaXMucG9zaXRpb24sIFxcXCIgaGFzLWFsaWdubWVudC1cXFwiKS5jb25jYXQodGhpcy5hbGlnbm1lbnQpKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogTWFrZSBpdCBhIGN1cnJlbnQgYW5jaG9yLlxcbiAgICAgKiBDdXJyZW50IGFuY2hvciBhcyB0aGUgcmVmZXJlbmNlIGZvciB0aGUgcG9zaXRpb24gb2YgRHJvcGRvd24gcGFuZXMuXFxuICAgICAqIEBwYXJhbSB7SFRNTH0gZWwgLSBET00gZWxlbWVudCBvZiB0aGUgYW5jaG9yLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9zZXRDdXJyZW50QW5jaG9yXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRDdXJyZW50QW5jaG9yKGVsKSB7XFxuICAgICAgdGhpcy4kY3VycmVudEFuY2hvciA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShlbCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBlbGVtZW50IHV0aWxpemluZyB0aGUgdHJpZ2dlcnMgdXRpbGl0eSBsaWJyYXJ5LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9ldmVudHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQub24oe1xcbiAgICAgICAgJ29wZW4uemYudHJpZ2dlcic6IHRoaXMub3Blbi5iaW5kKHRoaXMpLFxcbiAgICAgICAgJ2Nsb3NlLnpmLnRyaWdnZXInOiB0aGlzLmNsb3NlLmJpbmQodGhpcyksXFxuICAgICAgICAndG9nZ2xlLnpmLnRyaWdnZXInOiB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpLFxcbiAgICAgICAgJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInOiB0aGlzLl9zZXRQb3NpdGlvbi5iaW5kKHRoaXMpXFxuICAgICAgfSk7XFxuICAgICAgdGhpcy4kYW5jaG9ycy5vZmYoJ2NsaWNrLnpmLnRyaWdnZXInKS5vbignY2xpY2suemYudHJpZ2dlcicsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIF90aGlzLl9zZXRDdXJyZW50QW5jaG9yKHRoaXMpO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaG92ZXIpIHtcXG4gICAgICAgIHRoaXMuJGFuY2hvcnMub2ZmKCdtb3VzZWVudGVyLnpmLmRyb3Bkb3duIG1vdXNlbGVhdmUuemYuZHJvcGRvd24nKS5vbignbW91c2VlbnRlci56Zi5kcm9wZG93bicsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgX3RoaXMuX3NldEN1cnJlbnRBbmNob3IodGhpcyk7XFxuXFxuICAgICAgICAgIHZhciBib2R5RGF0YSA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnYm9keScpLmRhdGEoKTtcXG5cXG4gICAgICAgICAgaWYgKHR5cGVvZiBib2R5RGF0YS53aGF0aW5wdXQgPT09ICd1bmRlZmluZWQnIHx8IGJvZHlEYXRhLndoYXRpbnB1dCA9PT0gJ21vdXNlJykge1xcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy50aW1lb3V0KTtcXG4gICAgICAgICAgICBfdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICBfdGhpcy5vcGVuKCk7XFxuXFxuICAgICAgICAgICAgICBfdGhpcy4kYW5jaG9ycy5kYXRhKCdob3ZlcicsIHRydWUpO1xcbiAgICAgICAgICAgIH0sIF90aGlzLm9wdGlvbnMuaG92ZXJEZWxheSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pLm9uKCdtb3VzZWxlYXZlLnpmLmRyb3Bkb3duJywgT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiaWdub3JlTW91c2VkaXNhcHBlYXJcXFwiXSkoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XFxuICAgICAgICAgIF90aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xcblxcbiAgICAgICAgICAgIF90aGlzLiRhbmNob3JzLmRhdGEoJ2hvdmVyJywgZmFsc2UpO1xcbiAgICAgICAgICB9LCBfdGhpcy5vcHRpb25zLmhvdmVyRGVsYXkpO1xcbiAgICAgICAgfSkpO1xcblxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ob3ZlclBhbmUpIHtcXG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ21vdXNlZW50ZXIuemYuZHJvcGRvd24gbW91c2VsZWF2ZS56Zi5kcm9wZG93bicpLm9uKCdtb3VzZWVudGVyLnpmLmRyb3Bkb3duJywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy50aW1lb3V0KTtcXG4gICAgICAgICAgfSkub24oJ21vdXNlbGVhdmUuemYuZHJvcGRvd24nLCBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJpZ25vcmVNb3VzZWRpc2FwcGVhclxcXCJdKShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXQpO1xcbiAgICAgICAgICAgIF90aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XFxuXFxuICAgICAgICAgICAgICBfdGhpcy4kYW5jaG9ycy5kYXRhKCdob3ZlcicsIGZhbHNlKTtcXG4gICAgICAgICAgICB9LCBfdGhpcy5vcHRpb25zLmhvdmVyRGVsYXkpO1xcbiAgICAgICAgICB9KSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuJGFuY2hvcnMuYWRkKHRoaXMuJGVsZW1lbnQpLm9uKCdrZXlkb3duLnpmLmRyb3Bkb3duJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIHZhciAkdGFyZ2V0ID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLFxcbiAgICAgICAgICAgIHZpc2libGVGb2N1c2FibGVFbGVtZW50cyA9IF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiS2V5Ym9hcmRcXFwiXS5maW5kRm9jdXNhYmxlKF90aGlzLiRlbGVtZW50KTtcXG4gICAgICAgIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiS2V5Ym9hcmRcXFwiXS5oYW5kbGVLZXkoZSwgJ0Ryb3Bkb3duJywge1xcbiAgICAgICAgICBvcGVuOiBmdW5jdGlvbiBvcGVuKCkge1xcbiAgICAgICAgICAgIGlmICgkdGFyZ2V0LmlzKF90aGlzLiRhbmNob3JzKSAmJiAhJHRhcmdldC5pcygnaW5wdXQsIHRleHRhcmVhJykpIHtcXG4gICAgICAgICAgICAgIF90aGlzLm9wZW4oKTtcXG5cXG4gICAgICAgICAgICAgIF90aGlzLiRlbGVtZW50LmF0dHIoJ3RhYmluZGV4JywgLTEpLmZvY3VzKCk7XFxuXFxuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XFxuICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcXG5cXG4gICAgICAgICAgICBfdGhpcy4kYW5jaG9ycy5mb2N1cygpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQWRkcyBhbiBldmVudCBoYW5kbGVyIHRvIHRoZSBib2R5IHRvIGNsb3NlIGFueSBkcm9wZG93bnMgb24gYSBjbGljay5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfYWRkQm9keUhhbmRsZXJcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEJvZHlIYW5kbGVyKCkge1xcbiAgICAgIHZhciAkYm9keSA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShkb2N1bWVudC5ib2R5KS5ub3QodGhpcy4kZWxlbWVudCksXFxuICAgICAgICAgIF90aGlzID0gdGhpcztcXG5cXG4gICAgICAkYm9keS5vZmYoJ2NsaWNrLnpmLmRyb3Bkb3duJykub24oJ2NsaWNrLnpmLmRyb3Bkb3duJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIGlmIChfdGhpcy4kYW5jaG9ycy5pcyhlLnRhcmdldCkgfHwgX3RoaXMuJGFuY2hvcnMuZmluZChlLnRhcmdldCkubGVuZ3RoKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChfdGhpcy4kZWxlbWVudC5pcyhlLnRhcmdldCkgfHwgX3RoaXMuJGVsZW1lbnQuZmluZChlLnRhcmdldCkubGVuZ3RoKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIF90aGlzLmNsb3NlKCk7XFxuXFxuICAgICAgICAkYm9keS5vZmYoJ2NsaWNrLnpmLmRyb3Bkb3duJyk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIE9wZW5zIHRoZSBkcm9wZG93biBwYW5lLCBhbmQgZmlyZXMgYSBidWJibGluZyBldmVudCB0byBjbG9zZSBvdGhlciBkcm9wZG93bnMuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAZmlyZXMgRHJvcGRvd24jY2xvc2VtZVxcbiAgICAgKiBAZmlyZXMgRHJvcGRvd24jc2hvd1xcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwib3BlblxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuKCkge1xcbiAgICAgIC8vIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgdG8gY2xvc2Ugb3RoZXIgb3BlbiBkcm9wZG93bnMsIHR5cGljYWxseSB3aGVuIGRyb3Bkb3duIGlzIG9wZW5pbmdcXG4gICAgICAgKiBAZXZlbnQgRHJvcGRvd24jY2xvc2VtZVxcbiAgICAgICAqL1xcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignY2xvc2VtZS56Zi5kcm9wZG93bicsIHRoaXMuJGVsZW1lbnQuYXR0cignaWQnKSk7XFxuICAgICAgdGhpcy4kYW5jaG9ycy5hZGRDbGFzcygnaG92ZXInKS5hdHRyKHtcXG4gICAgICAgICdhcmlhLWV4cGFuZGVkJzogdHJ1ZVxcbiAgICAgIH0pOyAvLyB0aGlzLiRlbGVtZW50Lyouc2hvdygpKi87XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnaXMtb3BlbmluZycpO1xcblxcbiAgICAgIHRoaXMuX3NldFBvc2l0aW9uKCk7XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcygnaXMtb3BlbmluZycpLmFkZENsYXNzKCdpcy1vcGVuJykuYXR0cih7XFxuICAgICAgICAnYXJpYS1oaWRkZW4nOiBmYWxzZVxcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0ZvY3VzKSB7XFxuICAgICAgICB2YXIgJGZvY3VzYWJsZSA9IF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiS2V5Ym9hcmRcXFwiXS5maW5kRm9jdXNhYmxlKHRoaXMuJGVsZW1lbnQpO1xcblxcbiAgICAgICAgaWYgKCRmb2N1c2FibGUubGVuZ3RoKSB7XFxuICAgICAgICAgICRmb2N1c2FibGUuZXEoMCkuZm9jdXMoKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spIHtcXG4gICAgICAgIHRoaXMuX2FkZEJvZHlIYW5kbGVyKCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhcEZvY3VzKSB7XFxuICAgICAgICBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIktleWJvYXJkXFxcIl0udHJhcEZvY3VzKHRoaXMuJGVsZW1lbnQpO1xcbiAgICAgIH1cXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyBvbmNlIHRoZSBkcm9wZG93biBpcyB2aXNpYmxlLlxcbiAgICAgICAqIEBldmVudCBEcm9wZG93biNzaG93XFxuICAgICAgICovXFxuXFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdzaG93LnpmLmRyb3Bkb3duJywgW3RoaXMuJGVsZW1lbnRdKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2xvc2VzIHRoZSBvcGVuIGRyb3Bkb3duIHBhbmUuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAZmlyZXMgRHJvcGRvd24jaGlkZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiY2xvc2VcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XFxuICAgICAgaWYgKCF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpcy1vcGVuJykpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcygnaXMtb3BlbicpLmF0dHIoe1xcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZVxcbiAgICAgIH0pO1xcbiAgICAgIHRoaXMuJGFuY2hvcnMucmVtb3ZlQ2xhc3MoJ2hvdmVyJykuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKTtcXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyBvbmNlIHRoZSBkcm9wZG93biBpcyBubyBsb25nZXIgdmlzaWJsZS5cXG4gICAgICAgKiBAZXZlbnQgRHJvcGRvd24jaGlkZVxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignaGlkZS56Zi5kcm9wZG93bicsIFt0aGlzLiRlbGVtZW50XSk7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFwRm9jdXMpIHtcXG4gICAgICAgIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiS2V5Ym9hcmRcXFwiXS5yZWxlYXNlRm9jdXModGhpcy4kZWxlbWVudCk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBUb2dnbGVzIHRoZSBkcm9wZG93biBwYW5lJ3MgdmlzaWJpbGl0eS5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ0b2dnbGVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlKCkge1xcbiAgICAgIGlmICh0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpcy1vcGVuJykpIHtcXG4gICAgICAgIGlmICh0aGlzLiRhbmNob3JzLmRhdGEoJ2hvdmVyJykpIHJldHVybjtcXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5vcGVuKCk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBEZXN0cm95cyB0aGUgZHJvcGRvd24uXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2Rlc3Ryb3lcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi50cmlnZ2VyJykuaGlkZSgpO1xcbiAgICAgIHRoaXMuJGFuY2hvcnMub2ZmKCcuemYuZHJvcGRvd24nKTtcXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZG9jdW1lbnQuYm9keSkub2ZmKCdjbGljay56Zi5kcm9wZG93bicpO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gRHJvcGRvd247XFxufShfZm91bmRhdGlvbl9wb3NpdGlvbmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiUG9zaXRpb25hYmxlXFxcIl0pO1xcblxcbkRyb3Bkb3duLmRlZmF1bHRzID0ge1xcbiAgLyoqXFxuICAgKiBDbGFzcyB0aGF0IGRlc2lnbmF0ZXMgYm91bmRpbmcgY29udGFpbmVyIG9mIERyb3Bkb3duIChkZWZhdWx0OiB3aW5kb3cpXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7P3N0cmluZ31cXG4gICAqIEBkZWZhdWx0IG51bGxcXG4gICAqL1xcbiAgcGFyZW50Q2xhc3M6IG51bGwsXFxuXFxuICAvKipcXG4gICAqIEFtb3VudCBvZiB0aW1lIHRvIGRlbGF5IG9wZW5pbmcgYSBzdWJtZW51IG9uIGhvdmVyIGV2ZW50LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDI1MFxcbiAgICovXFxuICBob3ZlckRlbGF5OiAyNTAsXFxuXFxuICAvKipcXG4gICAqIEFsbG93IHN1Ym1lbnVzIHRvIG9wZW4gb24gaG92ZXIgZXZlbnRzXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGhvdmVyOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogRG9uJ3QgY2xvc2UgZHJvcGRvd24gd2hlbiBob3ZlcmluZyBvdmVyIGRyb3Bkb3duIHBhbmVcXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgaG92ZXJQYW5lOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogTnVtYmVyIG9mIHBpeGVscyBiZXR3ZWVuIHRoZSBkcm9wZG93biBwYW5lIGFuZCB0aGUgdHJpZ2dlcmluZyBlbGVtZW50IG9uIG9wZW4uXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgMFxcbiAgICovXFxuICB2T2Zmc2V0OiAwLFxcblxcbiAgLyoqXFxuICAgKiBOdW1iZXIgb2YgcGl4ZWxzIGJldHdlZW4gdGhlIGRyb3Bkb3duIHBhbmUgYW5kIHRoZSB0cmlnZ2VyaW5nIGVsZW1lbnQgb24gb3Blbi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAwXFxuICAgKi9cXG4gIGhPZmZzZXQ6IDAsXFxuXFxuICAvKipcXG4gICAqIFBvc2l0aW9uIG9mIGRyb3Bkb3duLiBDYW4gYmUgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBvciBhdXRvLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICdhdXRvJ1xcbiAgICovXFxuICBwb3NpdGlvbjogJ2F1dG8nLFxcblxcbiAgLyoqXFxuICAgKiBBbGlnbm1lbnQgb2YgZHJvcGRvd24gcmVsYXRpdmUgdG8gYW5jaG9yLiBDYW4gYmUgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBjZW50ZXIsIG9yIGF1dG8uXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ2F1dG8nXFxuICAgKi9cXG4gIGFsaWdubWVudDogJ2F1dG8nLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvdyBvdmVybGFwIG9mIGNvbnRhaW5lci93aW5kb3cuIElmIGZhbHNlLCBkcm9wZG93biB3aWxsIGZpcnN0IHRyeSB0byBwb3NpdGlvbiBhcyBkZWZpbmVkIGJ5IGRhdGEtcG9zaXRpb24gYW5kIGRhdGEtYWxpZ25tZW50LCBidXQgcmVwb3NpdGlvbiBpZiBpdCB3b3VsZCBjYXVzZSBhbiBvdmVyZmxvdy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgYWxsb3dPdmVybGFwOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogQWxsb3cgb3ZlcmxhcCBvZiBvbmx5IHRoZSBib3R0b20gb2YgdGhlIGNvbnRhaW5lci4gVGhpcyBpcyB0aGUgbW9zdCBjb21tb25cXG4gICAqIGJlaGF2aW9yIGZvciBkcm9wZG93bnMsIGFsbG93aW5nIHRoZSBkcm9wZG93biB0byBleHRlbmQgdGhlIGJvdHRvbSBvZiB0aGVcXG4gICAqIHNjcmVlbiBidXQgbm90IG90aGVyd2lzZSBpbmZsdWVuY2Ugb3IgYnJlYWsgb3V0IG9mIHRoZSBjb250YWluZXIuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IHRydWVcXG4gICAqL1xcbiAgYWxsb3dCb3R0b21PdmVybGFwOiB0cnVlLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvdyB0aGUgcGx1Z2luIHRvIHRyYXAgZm9jdXMgdG8gdGhlIGRyb3Bkb3duIHBhbmUgaWYgb3BlbmVkIHdpdGgga2V5Ym9hcmQgY29tbWFuZHMuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIHRyYXBGb2N1czogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIEFsbG93IHRoZSBwbHVnaW4gdG8gc2V0IGZvY3VzIHRvIHRoZSBmaXJzdCBmb2N1c2FibGUgZWxlbWVudCB3aXRoaW4gdGhlIHBhbmUsIHJlZ2FyZGxlc3Mgb2YgbWV0aG9kIG9mIG9wZW5pbmcuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGF1dG9Gb2N1czogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIEFsbG93cyBhIGNsaWNrIG9uIHRoZSBib2R5IHRvIGNsb3NlIHRoZSBkcm9wZG93bi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgY2xvc2VPbkNsaWNrOiBmYWxzZVxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi5kcm9wZG93bi5qcz9cIil9LFwiLi9qcy9mb3VuZGF0aW9uLmRyb3Bkb3duTWVudS5qc1wiOmZ1bmN0aW9uKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiRHJvcGRvd25NZW51XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBEcm9wZG93bk1lbnU7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGpxdWVyeSAqLyBcXFwianF1ZXJ5XFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnBsdWdpbiAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUucGx1Z2luLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnV0aWxzICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS51dGlscy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC5rZXlib2FyZCAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF9uZXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC5uZXN0ICovIFxcXCIuL2pzL2ZvdW5kYXRpb24udXRpbC5uZXN0LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3V0aWxfYm94X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC5ib3ggKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLmJveC5qc1xcXCIpO1xcblxcblxcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXFxcImZ1bmN0aW9uXFxcIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cXG5cXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXFxcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFxcXCIpOyB9IHJldHVybiBzZWxmOyB9XFxuXFxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblxcXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cXG5cXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxcblxcblxcblxcblxcblxcblxcblxcbi8qKlxcbiAqIERyb3Bkb3duTWVudSBtb2R1bGUuXFxuICogQG1vZHVsZSBmb3VuZGF0aW9uLmRyb3Bkb3duLW1lbnVcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5ib3hcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm5lc3RcXG4gKi9cXG5cXG52YXIgRHJvcGRvd25NZW51ID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKF9QbHVnaW4pIHtcXG4gIF9pbmhlcml0cyhEcm9wZG93bk1lbnUsIF9QbHVnaW4pO1xcblxcbiAgZnVuY3Rpb24gRHJvcGRvd25NZW51KCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJvcGRvd25NZW51KTtcXG5cXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihEcm9wZG93bk1lbnUpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKERyb3Bkb3duTWVudSwgW3tcXG4gICAga2V5OiBcXFwiX3NldHVwXFxcIixcXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgRHJvcGRvd25NZW51LlxcbiAgICAgKiBAY2xhc3NcXG4gICAgICogQG5hbWUgRHJvcGRvd25NZW51XFxuICAgICAqIEBmaXJlcyBEcm9wZG93bk1lbnUjaW5pdFxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIGEgZHJvcGRvd24gbWVudS5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XFxuICAgICAgdGhpcy5vcHRpb25zID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCh7fSwgRHJvcGRvd25NZW51LmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XFxuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnRHJvcGRvd25NZW51JzsgLy8gaWU5IGJhY2sgY29tcGF0XFxuXFxuICAgICAgdGhpcy5faW5pdCgpO1xcblxcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiS2V5Ym9hcmRcXFwiXS5yZWdpc3RlcignRHJvcGRvd25NZW51Jywge1xcbiAgICAgICAgJ0VOVEVSJzogJ29wZW4nLFxcbiAgICAgICAgJ1NQQUNFJzogJ29wZW4nLFxcbiAgICAgICAgJ0FSUk9XX1JJR0hUJzogJ25leHQnLFxcbiAgICAgICAgJ0FSUk9XX1VQJzogJ3VwJyxcXG4gICAgICAgICdBUlJPV19ET1dOJzogJ2Rvd24nLFxcbiAgICAgICAgJ0FSUk9XX0xFRlQnOiAncHJldmlvdXMnLFxcbiAgICAgICAgJ0VTQ0FQRSc6ICdjbG9zZSdcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHBsdWdpbiwgYW5kIGNhbGxzIF9wcmVwYXJlTWVudVxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9pbml0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfbmVzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJOZXN0XFxcIl0uRmVhdGhlcih0aGlzLiRlbGVtZW50LCAnZHJvcGRvd24nKTtcXG4gICAgICB2YXIgc3VicyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnbGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnKTtcXG4gICAgICB0aGlzLiRlbGVtZW50LmNoaWxkcmVuKCcuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnKS5jaGlsZHJlbignLmlzLWRyb3Bkb3duLXN1Ym1lbnUnKS5hZGRDbGFzcygnZmlyc3Qtc3ViJyk7XFxuICAgICAgdGhpcy4kbWVudUl0ZW1zID0gdGhpcy4kZWxlbWVudC5maW5kKCdbcm9sZT1cXFwibWVudWl0ZW1cXFwiXScpO1xcbiAgICAgIHRoaXMuJHRhYnMgPSB0aGlzLiRlbGVtZW50LmNoaWxkcmVuKCdbcm9sZT1cXFwibWVudWl0ZW1cXFwiXScpO1xcbiAgICAgIHRoaXMuJHRhYnMuZmluZCgndWwuaXMtZHJvcGRvd24tc3VibWVudScpLmFkZENsYXNzKHRoaXMub3B0aW9ucy52ZXJ0aWNhbENsYXNzKTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFsaWdubWVudCA9PT0gJ2F1dG8nKSB7XFxuICAgICAgICBpZiAodGhpcy4kZWxlbWVudC5oYXNDbGFzcyh0aGlzLm9wdGlvbnMucmlnaHRDbGFzcykgfHwgT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwicnRsXFxcIl0pKCkgfHwgdGhpcy4kZWxlbWVudC5wYXJlbnRzKCcudG9wLWJhci1yaWdodCcpLmlzKCcqJykpIHtcXG4gICAgICAgICAgdGhpcy5vcHRpb25zLmFsaWdubWVudCA9ICdyaWdodCc7XFxuICAgICAgICAgIHN1YnMuYWRkQ2xhc3MoJ29wZW5zLWxlZnQnKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5hbGlnbm1lbnQgPSAnbGVmdCc7XFxuICAgICAgICAgIHN1YnMuYWRkQ2xhc3MoJ29wZW5zLXJpZ2h0Jyk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWxpZ25tZW50ID09PSAncmlnaHQnKSB7XFxuICAgICAgICAgIHN1YnMuYWRkQ2xhc3MoJ29wZW5zLWxlZnQnKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHN1YnMuYWRkQ2xhc3MoJ29wZW5zLXJpZ2h0Jyk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuY2hhbmdlZCA9IGZhbHNlO1xcblxcbiAgICAgIHRoaXMuX2V2ZW50cygpO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9pc1ZlcnRpY2FsXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc1ZlcnRpY2FsKCkge1xcbiAgICAgIHJldHVybiB0aGlzLiR0YWJzLmNzcygnZGlzcGxheScpID09PSAnYmxvY2snIHx8IHRoaXMuJGVsZW1lbnQuY3NzKCdmbGV4LWRpcmVjdGlvbicpID09PSAnY29sdW1uJztcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfaXNSdGxcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzUnRsKCkge1xcbiAgICAgIHJldHVybiB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdhbGlnbi1yaWdodCcpIHx8IE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcInJ0bFxcXCJdKSgpICYmICF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdhbGlnbi1sZWZ0Jyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIGVsZW1lbnRzIHdpdGhpbiB0aGUgbWVudVxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9ldmVudHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxcbiAgICAgICAgICBoYXNUb3VjaCA9ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fCB0eXBlb2Ygd2luZG93Lm9udG91Y2hzdGFydCAhPT0gJ3VuZGVmaW5lZCcsXFxuICAgICAgICAgIHBhckNsYXNzID0gJ2lzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50JzsgLy8gdXNlZCBmb3Igb25DbGljayBhbmQgaW4gdGhlIGtleWJvYXJkIGhhbmRsZXJzXFxuXFxuXFxuICAgICAgdmFyIGhhbmRsZUNsaWNrRm4gPSBmdW5jdGlvbiBoYW5kbGVDbGlja0ZuKGUpIHtcXG4gICAgICAgIHZhciAkZWxlbSA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShlLnRhcmdldCkucGFyZW50c1VudGlsKCd1bCcsIFxcXCIuXFxcIi5jb25jYXQocGFyQ2xhc3MpKSxcXG4gICAgICAgICAgICBoYXNTdWIgPSAkZWxlbS5oYXNDbGFzcyhwYXJDbGFzcyksXFxuICAgICAgICAgICAgaGFzQ2xpY2tlZCA9ICRlbGVtLmF0dHIoJ2RhdGEtaXMtY2xpY2snKSA9PT0gJ3RydWUnLFxcbiAgICAgICAgICAgICRzdWIgPSAkZWxlbS5jaGlsZHJlbignLmlzLWRyb3Bkb3duLXN1Ym1lbnUnKTtcXG5cXG4gICAgICAgIGlmIChoYXNTdWIpIHtcXG4gICAgICAgICAgaWYgKGhhc0NsaWNrZWQpIHtcXG4gICAgICAgICAgICBpZiAoIV90aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrIHx8ICFfdGhpcy5vcHRpb25zLmNsaWNrT3BlbiAmJiAhaGFzVG91Y2ggfHwgX3RoaXMub3B0aW9ucy5mb3JjZUZvbGxvdyAmJiBoYXNUb3VjaCkge1xcbiAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcbiAgICAgICAgICAgICAgX3RoaXMuX2hpZGUoJGVsZW0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG5cXG4gICAgICAgICAgICBfdGhpcy5fc2hvdygkc3ViKTtcXG5cXG4gICAgICAgICAgICAkZWxlbS5hZGQoJGVsZW0ucGFyZW50c1VudGlsKF90aGlzLiRlbGVtZW50LCBcXFwiLlxcXCIuY29uY2F0KHBhckNsYXNzKSkpLmF0dHIoJ2RhdGEtaXMtY2xpY2snLCB0cnVlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH07XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbGlja09wZW4gfHwgaGFzVG91Y2gpIHtcXG4gICAgICAgIHRoaXMuJG1lbnVJdGVtcy5vbignY2xpY2suemYuZHJvcGRvd25tZW51IHRvdWNoc3RhcnQuemYuZHJvcGRvd25tZW51JywgaGFuZGxlQ2xpY2tGbik7XFxuICAgICAgfSAvLyBIYW5kbGUgTGVhZiBlbGVtZW50IENsaWNrc1xcblxcblxcbiAgICAgIGlmIChfdGhpcy5vcHRpb25zLmNsb3NlT25DbGlja0luc2lkZSkge1xcbiAgICAgICAgdGhpcy4kbWVudUl0ZW1zLm9uKCdjbGljay56Zi5kcm9wZG93bm1lbnUnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICB2YXIgJGVsZW0gPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcyksXFxuICAgICAgICAgICAgICBoYXNTdWIgPSAkZWxlbS5oYXNDbGFzcyhwYXJDbGFzcyk7XFxuXFxuICAgICAgICAgIGlmICghaGFzU3ViKSB7XFxuICAgICAgICAgICAgX3RoaXMuX2hpZGUoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVIb3Zlcikge1xcbiAgICAgICAgdGhpcy4kbWVudUl0ZW1zLm9uKCdtb3VzZWVudGVyLnpmLmRyb3Bkb3dubWVudScsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIHZhciAkZWxlbSA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKSxcXG4gICAgICAgICAgICAgIGhhc1N1YiA9ICRlbGVtLmhhc0NsYXNzKHBhckNsYXNzKTtcXG5cXG4gICAgICAgICAgaWYgKGhhc1N1Yikge1xcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCgkZWxlbS5kYXRhKCdfZGVsYXknKSk7XFxuICAgICAgICAgICAgJGVsZW0uZGF0YSgnX2RlbGF5Jywgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICBfdGhpcy5fc2hvdygkZWxlbS5jaGlsZHJlbignLmlzLWRyb3Bkb3duLXN1Ym1lbnUnKSk7XFxuICAgICAgICAgICAgfSwgX3RoaXMub3B0aW9ucy5ob3ZlckRlbGF5KSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pLm9uKCdtb3VzZWxlYXZlLnpmLmRyb3Bkb3duTWVudScsIE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImlnbm9yZU1vdXNlZGlzYXBwZWFyXFxcIl0pKGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIHZhciAkZWxlbSA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKSxcXG4gICAgICAgICAgICAgIGhhc1N1YiA9ICRlbGVtLmhhc0NsYXNzKHBhckNsYXNzKTtcXG5cXG4gICAgICAgICAgaWYgKGhhc1N1YiAmJiBfdGhpcy5vcHRpb25zLmF1dG9jbG9zZSkge1xcbiAgICAgICAgICAgIGlmICgkZWxlbS5hdHRyKCdkYXRhLWlzLWNsaWNrJykgPT09ICd0cnVlJyAmJiBfdGhpcy5vcHRpb25zLmNsaWNrT3Blbikge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoJGVsZW0uZGF0YSgnX2RlbGF5JykpO1xcbiAgICAgICAgICAgICRlbGVtLmRhdGEoJ19kZWxheScsIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgX3RoaXMuX2hpZGUoJGVsZW0pO1xcbiAgICAgICAgICAgIH0sIF90aGlzLm9wdGlvbnMuY2xvc2luZ1RpbWUpKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSkpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLiRtZW51SXRlbXMub24oJ2tleWRvd24uemYuZHJvcGRvd25tZW51JywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIHZhciAkZWxlbWVudCA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShlLnRhcmdldCkucGFyZW50c1VudGlsKCd1bCcsICdbcm9sZT1cXFwibWVudWl0ZW1cXFwiXScpLFxcbiAgICAgICAgICAgIGlzVGFiID0gX3RoaXMuJHRhYnMuaW5kZXgoJGVsZW1lbnQpID4gLTEsXFxuICAgICAgICAgICAgJGVsZW1lbnRzID0gaXNUYWIgPyBfdGhpcy4kdGFicyA6ICRlbGVtZW50LnNpYmxpbmdzKCdsaScpLmFkZCgkZWxlbWVudCksXFxuICAgICAgICAgICAgJHByZXZFbGVtZW50LFxcbiAgICAgICAgICAgICRuZXh0RWxlbWVudDtcXG4gICAgICAgICRlbGVtZW50cy5lYWNoKGZ1bmN0aW9uIChpKSB7XFxuICAgICAgICAgIGlmIChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykuaXMoJGVsZW1lbnQpKSB7XFxuICAgICAgICAgICAgJHByZXZFbGVtZW50ID0gJGVsZW1lbnRzLmVxKGkgLSAxKTtcXG4gICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudHMuZXEoaSArIDEpO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBmdW5jdGlvbiBuZXh0U2libGluZygpIHtcXG4gICAgICAgICAgJG5leHRFbGVtZW50LmNoaWxkcmVuKCdhOmZpcnN0JykuZm9jdXMoKTtcXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgfSxcXG4gICAgICAgICAgICBwcmV2U2libGluZyA9IGZ1bmN0aW9uIHByZXZTaWJsaW5nKCkge1xcbiAgICAgICAgICAkcHJldkVsZW1lbnQuY2hpbGRyZW4oJ2E6Zmlyc3QnKS5mb2N1cygpO1xcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICB9LFxcbiAgICAgICAgICAgIG9wZW5TdWIgPSBmdW5jdGlvbiBvcGVuU3ViKCkge1xcbiAgICAgICAgICB2YXIgJHN1YiA9ICRlbGVtZW50LmNoaWxkcmVuKCd1bC5pcy1kcm9wZG93bi1zdWJtZW51Jyk7XFxuXFxuICAgICAgICAgIGlmICgkc3ViLmxlbmd0aCkge1xcbiAgICAgICAgICAgIF90aGlzLl9zaG93KCRzdWIpO1xcblxcbiAgICAgICAgICAgICRlbGVtZW50LmZpbmQoJ2xpID4gYTpmaXJzdCcpLmZvY3VzKCk7XFxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgICAgICBjbG9zZVN1YiA9IGZ1bmN0aW9uIGNsb3NlU3ViKCkge1xcbiAgICAgICAgICAvL2lmICgkZWxlbWVudC5pcygnOmZpcnN0LWNoaWxkJykpIHtcXG4gICAgICAgICAgdmFyIGNsb3NlID0gJGVsZW1lbnQucGFyZW50KCd1bCcpLnBhcmVudCgnbGknKTtcXG4gICAgICAgICAgY2xvc2UuY2hpbGRyZW4oJ2E6Zmlyc3QnKS5mb2N1cygpO1xcblxcbiAgICAgICAgICBfdGhpcy5faGlkZShjbG9zZSk7XFxuXFxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy99XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgdmFyIGZ1bmN0aW9ucyA9IHtcXG4gICAgICAgICAgb3Blbjogb3BlblN1YixcXG4gICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xcbiAgICAgICAgICAgIF90aGlzLl9oaWRlKF90aGlzLiRlbGVtZW50KTtcXG5cXG4gICAgICAgICAgICBfdGhpcy4kbWVudUl0ZW1zLmVxKDApLmNoaWxkcmVuKCdhJykuZm9jdXMoKTsgLy8gZm9jdXMgdG8gZmlyc3QgZWxlbWVudFxcblxcblxcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24gaGFuZGxlZCgpIHtcXG4gICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgaWYgKGlzVGFiKSB7XFxuICAgICAgICAgIGlmIChfdGhpcy5faXNWZXJ0aWNhbCgpKSB7XFxuICAgICAgICAgICAgLy8gdmVydGljYWwgbWVudVxcbiAgICAgICAgICAgIGlmIChfdGhpcy5faXNSdGwoKSkge1xcbiAgICAgICAgICAgICAgLy8gcmlnaHQgYWxpZ25lZFxcbiAgICAgICAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZChmdW5jdGlvbnMsIHtcXG4gICAgICAgICAgICAgICAgZG93bjogbmV4dFNpYmxpbmcsXFxuICAgICAgICAgICAgICAgIHVwOiBwcmV2U2libGluZyxcXG4gICAgICAgICAgICAgICAgbmV4dDogY2xvc2VTdWIsXFxuICAgICAgICAgICAgICAgIHByZXZpb3VzOiBvcGVuU3ViXFxuICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgLy8gbGVmdCBhbGlnbmVkXFxuICAgICAgICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZXh0ZW5kKGZ1bmN0aW9ucywge1xcbiAgICAgICAgICAgICAgICBkb3duOiBuZXh0U2libGluZyxcXG4gICAgICAgICAgICAgICAgdXA6IHByZXZTaWJsaW5nLFxcbiAgICAgICAgICAgICAgICBuZXh0OiBvcGVuU3ViLFxcbiAgICAgICAgICAgICAgICBwcmV2aW91czogY2xvc2VTdWJcXG4gICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAvLyBob3Jpem9udGFsIG1lbnVcXG4gICAgICAgICAgICBpZiAoX3RoaXMuX2lzUnRsKCkpIHtcXG4gICAgICAgICAgICAgIC8vIHJpZ2h0IGFsaWduZWRcXG4gICAgICAgICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoZnVuY3Rpb25zLCB7XFxuICAgICAgICAgICAgICAgIG5leHQ6IHByZXZTaWJsaW5nLFxcbiAgICAgICAgICAgICAgICBwcmV2aW91czogbmV4dFNpYmxpbmcsXFxuICAgICAgICAgICAgICAgIGRvd246IG9wZW5TdWIsXFxuICAgICAgICAgICAgICAgIHVwOiBjbG9zZVN1YlxcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIC8vIGxlZnQgYWxpZ25lZFxcbiAgICAgICAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZChmdW5jdGlvbnMsIHtcXG4gICAgICAgICAgICAgICAgbmV4dDogbmV4dFNpYmxpbmcsXFxuICAgICAgICAgICAgICAgIHByZXZpb3VzOiBwcmV2U2libGluZyxcXG4gICAgICAgICAgICAgICAgZG93bjogb3BlblN1YixcXG4gICAgICAgICAgICAgICAgdXA6IGNsb3NlU3ViXFxuICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vIG5vdCB0YWJzIC0+IG9uZSBzdWJcXG4gICAgICAgICAgaWYgKF90aGlzLl9pc1J0bCgpKSB7XFxuICAgICAgICAgICAgLy8gcmlnaHQgYWxpZ25lZFxcbiAgICAgICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoZnVuY3Rpb25zLCB7XFxuICAgICAgICAgICAgICBuZXh0OiBjbG9zZVN1YixcXG4gICAgICAgICAgICAgIHByZXZpb3VzOiBvcGVuU3ViLFxcbiAgICAgICAgICAgICAgZG93bjogbmV4dFNpYmxpbmcsXFxuICAgICAgICAgICAgICB1cDogcHJldlNpYmxpbmdcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAvLyBsZWZ0IGFsaWduZWRcXG4gICAgICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZXh0ZW5kKGZ1bmN0aW9ucywge1xcbiAgICAgICAgICAgICAgbmV4dDogb3BlblN1YixcXG4gICAgICAgICAgICAgIHByZXZpb3VzOiBjbG9zZVN1YixcXG4gICAgICAgICAgICAgIGRvd246IG5leHRTaWJsaW5nLFxcbiAgICAgICAgICAgICAgdXA6IHByZXZTaWJsaW5nXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiS2V5Ym9hcmRcXFwiXS5oYW5kbGVLZXkoZSwgJ0Ryb3Bkb3duTWVudScsIGZ1bmN0aW9ucyk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEFkZHMgYW4gZXZlbnQgaGFuZGxlciB0byB0aGUgYm9keSB0byBjbG9zZSBhbnkgZHJvcGRvd25zIG9uIGEgY2xpY2suXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2FkZEJvZHlIYW5kbGVyXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRCb2R5SGFuZGxlcigpIHtcXG4gICAgICB2YXIgJGJvZHkgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZG9jdW1lbnQuYm9keSksXFxuICAgICAgICAgIF90aGlzID0gdGhpcztcXG5cXG4gICAgICAkYm9keS5vZmYoJ21vdXNldXAuemYuZHJvcGRvd25tZW51IHRvdWNoZW5kLnpmLmRyb3Bkb3dubWVudScpLm9uKCdtb3VzZXVwLnpmLmRyb3Bkb3dubWVudSB0b3VjaGVuZC56Zi5kcm9wZG93bm1lbnUnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgdmFyICRsaW5rID0gX3RoaXMuJGVsZW1lbnQuZmluZChlLnRhcmdldCk7XFxuXFxuICAgICAgICBpZiAoJGxpbmsubGVuZ3RoKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIF90aGlzLl9oaWRlKCk7XFxuXFxuICAgICAgICAkYm9keS5vZmYoJ21vdXNldXAuemYuZHJvcGRvd25tZW51IHRvdWNoZW5kLnpmLmRyb3Bkb3dubWVudScpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBPcGVucyBhIGRyb3Bkb3duIHBhbmUsIGFuZCBjaGVja3MgZm9yIGNvbGxpc2lvbnMgZmlyc3QuXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkc3ViIC0gdWwgZWxlbWVudCB0aGF0IGlzIGEgc3VibWVudSB0byBzaG93XFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAZmlyZXMgRHJvcGRvd25tZW51I3Nob3dcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9zaG93XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zaG93KCRzdWIpIHtcXG4gICAgICB2YXIgaWR4ID0gdGhpcy4kdGFicy5pbmRleCh0aGlzLiR0YWJzLmZpbHRlcihmdW5jdGlvbiAoaSwgZWwpIHtcXG4gICAgICAgIHJldHVybiBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZWwpLmZpbmQoJHN1YikubGVuZ3RoID4gMDtcXG4gICAgICB9KSk7XFxuICAgICAgdmFyICRzaWJzID0gJHN1Yi5wYXJlbnQoJ2xpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50Jykuc2libGluZ3MoJ2xpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50Jyk7XFxuXFxuICAgICAgdGhpcy5faGlkZSgkc2licywgaWR4KTtcXG5cXG4gICAgICAkc3ViLmNzcygndmlzaWJpbGl0eScsICdoaWRkZW4nKS5hZGRDbGFzcygnanMtZHJvcGRvd24tYWN0aXZlJykucGFyZW50KCdsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCcpLmFkZENsYXNzKCdpcy1hY3RpdmUnKTtcXG4gICAgICB2YXIgY2xlYXIgPSBfZm91bmRhdGlvbl91dGlsX2JveF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJCb3hcXFwiXS5JbU5vdFRvdWNoaW5nWW91KCRzdWIsIG51bGwsIHRydWUpO1xcblxcbiAgICAgIGlmICghY2xlYXIpIHtcXG4gICAgICAgIHZhciBvbGRDbGFzcyA9IHRoaXMub3B0aW9ucy5hbGlnbm1lbnQgPT09ICdsZWZ0JyA/ICctcmlnaHQnIDogJy1sZWZ0JyxcXG4gICAgICAgICAgICAkcGFyZW50TGkgPSAkc3ViLnBhcmVudCgnLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50Jyk7XFxuICAgICAgICAkcGFyZW50TGkucmVtb3ZlQ2xhc3MoXFxcIm9wZW5zXFxcIi5jb25jYXQob2xkQ2xhc3MpKS5hZGRDbGFzcyhcXFwib3BlbnMtXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLmFsaWdubWVudCkpO1xcbiAgICAgICAgY2xlYXIgPSBfZm91bmRhdGlvbl91dGlsX2JveF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJCb3hcXFwiXS5JbU5vdFRvdWNoaW5nWW91KCRzdWIsIG51bGwsIHRydWUpO1xcblxcbiAgICAgICAgaWYgKCFjbGVhcikge1xcbiAgICAgICAgICAkcGFyZW50TGkucmVtb3ZlQ2xhc3MoXFxcIm9wZW5zLVxcXCIuY29uY2F0KHRoaXMub3B0aW9ucy5hbGlnbm1lbnQpKS5hZGRDbGFzcygnb3BlbnMtaW5uZXInKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgICRzdWIuY3NzKCd2aXNpYmlsaXR5JywgJycpO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKSB7XFxuICAgICAgICB0aGlzLl9hZGRCb2R5SGFuZGxlcigpO1xcbiAgICAgIH1cXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBuZXcgZHJvcGRvd24gcGFuZSBpcyB2aXNpYmxlLlxcbiAgICAgICAqIEBldmVudCBEcm9wZG93bm1lbnUjc2hvd1xcbiAgICAgICAqL1xcblxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignc2hvdy56Zi5kcm9wZG93bm1lbnUnLCBbJHN1Yl0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBIaWRlcyBhIHNpbmdsZSwgY3VycmVudGx5IG9wZW4gZHJvcGRvd24gcGFuZSwgaWYgcGFzc2VkIGEgcGFyYW1ldGVyLCBvdGhlcndpc2UsIGhpZGVzIGV2ZXJ5dGhpbmcuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW0gLSBlbGVtZW50IHdpdGggYSBzdWJtZW51IHRvIGhpZGVcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkeCAtIGluZGV4IG9mIHRoZSAkdGFicyBjb2xsZWN0aW9uIHRvIGhpZGVcXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9oaWRlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oaWRlKCRlbGVtLCBpZHgpIHtcXG4gICAgICB2YXIgJHRvQ2xvc2U7XFxuXFxuICAgICAgaWYgKCRlbGVtICYmICRlbGVtLmxlbmd0aCkge1xcbiAgICAgICAgJHRvQ2xvc2UgPSAkZWxlbTtcXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpZHggIT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAkdG9DbG9zZSA9IHRoaXMuJHRhYnMubm90KGZ1bmN0aW9uIChpLCBlbCkge1xcbiAgICAgICAgICByZXR1cm4gaSA9PT0gaWR4O1xcbiAgICAgICAgfSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgICR0b0Nsb3NlID0gdGhpcy4kZWxlbWVudDtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHNvbWV0aGluZ1RvQ2xvc2UgPSAkdG9DbG9zZS5oYXNDbGFzcygnaXMtYWN0aXZlJykgfHwgJHRvQ2xvc2UuZmluZCgnLmlzLWFjdGl2ZScpLmxlbmd0aCA+IDA7XFxuXFxuICAgICAgaWYgKHNvbWV0aGluZ1RvQ2xvc2UpIHtcXG4gICAgICAgICR0b0Nsb3NlLmZpbmQoJ2xpLmlzLWFjdGl2ZScpLmFkZCgkdG9DbG9zZSkuYXR0cih7XFxuICAgICAgICAgICdkYXRhLWlzLWNsaWNrJzogZmFsc2VcXG4gICAgICAgIH0pLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKTtcXG4gICAgICAgICR0b0Nsb3NlLmZpbmQoJ3VsLmpzLWRyb3Bkb3duLWFjdGl2ZScpLnJlbW92ZUNsYXNzKCdqcy1kcm9wZG93bi1hY3RpdmUnKTtcXG5cXG4gICAgICAgIGlmICh0aGlzLmNoYW5nZWQgfHwgJHRvQ2xvc2UuZmluZCgnb3BlbnMtaW5uZXInKS5sZW5ndGgpIHtcXG4gICAgICAgICAgdmFyIG9sZENsYXNzID0gdGhpcy5vcHRpb25zLmFsaWdubWVudCA9PT0gJ2xlZnQnID8gJ3JpZ2h0JyA6ICdsZWZ0JztcXG4gICAgICAgICAgJHRvQ2xvc2UuZmluZCgnbGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnKS5hZGQoJHRvQ2xvc2UpLnJlbW92ZUNsYXNzKFxcXCJvcGVucy1pbm5lciBvcGVucy1cXFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuYWxpZ25tZW50KSkuYWRkQ2xhc3MoXFxcIm9wZW5zLVxcXCIuY29uY2F0KG9sZENsYXNzKSk7XFxuICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBvcGVuIG1lbnVzIGFyZSBjbG9zZWQuXFxuICAgICAgICAgKiBAZXZlbnQgRHJvcGRvd25tZW51I2hpZGVcXG4gICAgICAgICAqL1xcblxcblxcbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdoaWRlLnpmLmRyb3Bkb3dubWVudScsIFskdG9DbG9zZV0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogRGVzdHJveXMgdGhlIHBsdWdpbi5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZGVzdHJveVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICB0aGlzLiRtZW51SXRlbXMub2ZmKCcuemYuZHJvcGRvd25tZW51JykucmVtb3ZlQXR0cignZGF0YS1pcy1jbGljaycpLnJlbW92ZUNsYXNzKCdpcy1yaWdodC1hcnJvdyBpcy1sZWZ0LWFycm93IGlzLWRvd24tYXJyb3cgb3BlbnMtcmlnaHQgb3BlbnMtbGVmdCBvcGVucy1pbm5lcicpO1xcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShkb2N1bWVudC5ib2R5KS5vZmYoJy56Zi5kcm9wZG93bm1lbnUnKTtcXG4gICAgICBfZm91bmRhdGlvbl91dGlsX25lc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiTmVzdFxcXCJdLkJ1cm4odGhpcy4kZWxlbWVudCwgJ2Ryb3Bkb3duJyk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBEcm9wZG93bk1lbnU7XFxufShfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJQbHVnaW5cXFwiXSk7XFxuLyoqXFxuICogRGVmYXVsdCBzZXR0aW5ncyBmb3IgcGx1Z2luXFxuICovXFxuXFxuXFxuRHJvcGRvd25NZW51LmRlZmF1bHRzID0ge1xcbiAgLyoqXFxuICAgKiBEaXNhbGxvd3MgaG92ZXIgZXZlbnRzIGZyb20gb3BlbmluZyBzdWJtZW51c1xcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBkaXNhYmxlSG92ZXI6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvdyBhIHN1Ym1lbnUgdG8gYXV0b21hdGljYWxseSBjbG9zZSBvbiBhIG1vdXNlbGVhdmUgZXZlbnQsIGlmIG5vdCBjbGlja2VkIG9wZW4uXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IHRydWVcXG4gICAqL1xcbiAgYXV0b2Nsb3NlOiB0cnVlLFxcblxcbiAgLyoqXFxuICAgKiBBbW91bnQgb2YgdGltZSB0byBkZWxheSBvcGVuaW5nIGEgc3VibWVudSBvbiBob3ZlciBldmVudC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCA1MFxcbiAgICovXFxuICBob3ZlckRlbGF5OiA1MCxcXG5cXG4gIC8qKlxcbiAgICogQWxsb3cgYSBzdWJtZW51IHRvIG9wZW4vcmVtYWluIG9wZW4gb24gcGFyZW50IGNsaWNrIGV2ZW50LiBBbGxvd3MgY3Vyc29yIHRvIG1vdmUgYXdheSBmcm9tIG1lbnUuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGNsaWNrT3BlbjogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIEFtb3VudCBvZiB0aW1lIHRvIGRlbGF5IGNsb3NpbmcgYSBzdWJtZW51IG9uIGEgbW91c2VsZWF2ZSBldmVudC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCA1MDBcXG4gICAqL1xcbiAgY2xvc2luZ1RpbWU6IDUwMCxcXG5cXG4gIC8qKlxcbiAgICogUG9zaXRpb24gb2YgdGhlIG1lbnUgcmVsYXRpdmUgdG8gd2hhdCBkaXJlY3Rpb24gdGhlIHN1Ym1lbnVzIHNob3VsZCBvcGVuLiBIYW5kbGVkIGJ5IEpTLiBDYW4gYmUgYCdhdXRvJ2AsIGAnbGVmdCdgIG9yIGAncmlnaHQnYC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnYXV0bydcXG4gICAqL1xcbiAgYWxpZ25tZW50OiAnYXV0bycsXFxuXFxuICAvKipcXG4gICAqIEFsbG93IGNsaWNrcyBvbiB0aGUgYm9keSB0byBjbG9zZSBhbnkgb3BlbiBzdWJtZW51cy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgdHJ1ZVxcbiAgICovXFxuICBjbG9zZU9uQ2xpY2s6IHRydWUsXFxuXFxuICAvKipcXG4gICAqIEFsbG93IGNsaWNrcyBvbiBsZWFmIGFuY2hvciBsaW5rcyB0byBjbG9zZSBhbnkgb3BlbiBzdWJtZW51cy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgdHJ1ZVxcbiAgICovXFxuICBjbG9zZU9uQ2xpY2tJbnNpZGU6IHRydWUsXFxuXFxuICAvKipcXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gdmVydGljYWwgb3JpZW50ZWQgbWVudXMsIEZvdW5kYXRpb24gZGVmYXVsdCBpcyBgdmVydGljYWxgLiBVcGRhdGUgdGhpcyBpZiB1c2luZyB5b3VyIG93biBjbGFzcy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAndmVydGljYWwnXFxuICAgKi9cXG4gIHZlcnRpY2FsQ2xhc3M6ICd2ZXJ0aWNhbCcsXFxuXFxuICAvKipcXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gcmlnaHQtc2lkZSBvcmllbnRlZCBtZW51cywgRm91bmRhdGlvbiBkZWZhdWx0IGlzIGBhbGlnbi1yaWdodGAuIFVwZGF0ZSB0aGlzIGlmIHVzaW5nIHlvdXIgb3duIGNsYXNzLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICdhbGlnbi1yaWdodCdcXG4gICAqL1xcbiAgcmlnaHRDbGFzczogJ2FsaWduLXJpZ2h0JyxcXG5cXG4gIC8qKlxcbiAgICogQm9vbGVhbiB0byBmb3JjZSBvdmVyaWRlIHRoZSBjbGlja2luZyBvZiBsaW5rcyB0byBwZXJmb3JtIGRlZmF1bHQgYWN0aW9uLCBvbiBzZWNvbmQgdG91Y2ggZXZlbnQgZm9yIG1vYmlsZS5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgdHJ1ZVxcbiAgICovXFxuICBmb3JjZUZvbGxvdzogdHJ1ZVxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi5kcm9wZG93bk1lbnUuanM/XCIpfSxcIi4vanMvZm91bmRhdGlvbi5lcXVhbGl6ZXIuanNcIjpmdW5jdGlvbihtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkVxdWFsaXplclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gRXF1YWxpemVyOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBqcXVlcnkgKi8gXFxcImpxdWVyeVxcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeSAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX2ltYWdlTG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC5pbWFnZUxvYWRlciAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwuaW1hZ2VMb2FkZXIuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUudXRpbHMgKi8gXFxcIi4vanMvZm91bmRhdGlvbi5jb3JlLnV0aWxzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfcGx1Z2luX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uY29yZS5wbHVnaW4gKi8gXFxcIi4vanMvZm91bmRhdGlvbi5jb3JlLnBsdWdpbi5qc1xcXCIpO1xcblxcblxcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXFxcImZ1bmN0aW9uXFxcIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cXG5cXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXFxcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFxcXCIpOyB9IHJldHVybiBzZWxmOyB9XFxuXFxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblxcXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cXG5cXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxcblxcblxcblxcblxcblxcblxcbi8qKlxcbiAqIEVxdWFsaXplciBtb2R1bGUuXFxuICogQG1vZHVsZSBmb3VuZGF0aW9uLmVxdWFsaXplclxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuaW1hZ2VMb2FkZXIgaWYgZXF1YWxpemVyIGNvbnRhaW5zIGltYWdlc1xcbiAqL1xcblxcbnZhciBFcXVhbGl6ZXIgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoX1BsdWdpbikge1xcbiAgX2luaGVyaXRzKEVxdWFsaXplciwgX1BsdWdpbik7XFxuXFxuICBmdW5jdGlvbiBFcXVhbGl6ZXIoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFcXVhbGl6ZXIpO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEVxdWFsaXplcikuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoRXF1YWxpemVyLCBbe1xcbiAgICBrZXk6IFxcXCJfc2V0dXBcXFwiLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBFcXVhbGl6ZXIuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAbmFtZSBFcXVhbGl6ZXJcXG4gICAgICogQGZpcmVzIEVxdWFsaXplciNpbml0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIHRyaWdnZXIgdG8uXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cXG4gICAgICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMub3B0aW9ucyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoe30sIEVxdWFsaXplci5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ0VxdWFsaXplcic7IC8vIGllOSBiYWNrIGNvbXBhdFxcblxcbiAgICAgIHRoaXMuX2luaXQoKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIEVxdWFsaXplciBwbHVnaW4gYW5kIGNhbGxzIGZ1bmN0aW9ucyB0byBnZXQgZXF1YWxpemVyIGZ1bmN0aW9uaW5nIG9uIGxvYWQuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfaW5pdFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcXG4gICAgICB2YXIgZXFJZCA9IHRoaXMuJGVsZW1lbnQuYXR0cignZGF0YS1lcXVhbGl6ZXInKSB8fCAnJztcXG4gICAgICB2YXIgJHdhdGNoZWQgPSB0aGlzLiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLWVxdWFsaXplci13YXRjaD1cXFxcXFxcIlxcXCIuY29uY2F0KGVxSWQsIFxcXCJcXFxcXFxcIl1cXFwiKSk7XFxuXFxuICAgICAgX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIk1lZGlhUXVlcnlcXFwiXS5faW5pdCgpO1xcblxcbiAgICAgIHRoaXMuJHdhdGNoZWQgPSAkd2F0Y2hlZC5sZW5ndGggPyAkd2F0Y2hlZCA6IHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtZXF1YWxpemVyLXdhdGNoXScpO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignZGF0YS1yZXNpemUnLCBlcUlkIHx8IE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcIkdldFlvRGlnaXRzXFxcIl0pKDYsICdlcScpKTtcXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2RhdGEtbXV0YXRlJywgZXFJZCB8fCBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJHZXRZb0RpZ2l0c1xcXCJdKSg2LCAnZXEnKSk7XFxuICAgICAgdGhpcy5oYXNOZXN0ZWQgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLWVxdWFsaXplcl0nKS5sZW5ndGggPiAwO1xcbiAgICAgIHRoaXMuaXNOZXN0ZWQgPSB0aGlzLiRlbGVtZW50LnBhcmVudHNVbnRpbChkb2N1bWVudC5ib2R5LCAnW2RhdGEtZXF1YWxpemVyXScpLmxlbmd0aCA+IDA7XFxuICAgICAgdGhpcy5pc09uID0gZmFsc2U7XFxuICAgICAgdGhpcy5fYmluZEhhbmRsZXIgPSB7XFxuICAgICAgICBvblJlc2l6ZU1lQm91bmQ6IHRoaXMuX29uUmVzaXplTWUuYmluZCh0aGlzKSxcXG4gICAgICAgIG9uUG9zdEVxdWFsaXplZEJvdW5kOiB0aGlzLl9vblBvc3RFcXVhbGl6ZWQuYmluZCh0aGlzKVxcbiAgICAgIH07XFxuICAgICAgdmFyIGltZ3MgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2ltZycpO1xcbiAgICAgIHZhciB0b29TbWFsbDtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVxdWFsaXplT24pIHtcXG4gICAgICAgIHRvb1NtYWxsID0gdGhpcy5fY2hlY2tNUSgpO1xcbiAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub24oJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIHRoaXMuX2NoZWNrTVEuYmluZCh0aGlzKSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuX2V2ZW50cygpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodHlwZW9mIHRvb1NtYWxsICE9PSAndW5kZWZpbmVkJyAmJiB0b29TbWFsbCA9PT0gZmFsc2UgfHwgdHlwZW9mIHRvb1NtYWxsID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgaWYgKGltZ3MubGVuZ3RoKSB7XFxuICAgICAgICAgIE9iamVjdChfZm91bmRhdGlvbl91dGlsX2ltYWdlTG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIm9uSW1hZ2VzTG9hZGVkXFxcIl0pKGltZ3MsIHRoaXMuX3JlZmxvdy5iaW5kKHRoaXMpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMuX3JlZmxvdygpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lcnMgaWYgdGhlIGJyZWFrcG9pbnQgaXMgdG9vIHNtYWxsLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3BhdXNlRXZlbnRzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXVzZUV2ZW50cygpIHtcXG4gICAgICB0aGlzLmlzT24gPSBmYWxzZTtcXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZih7XFxuICAgICAgICAnLnpmLmVxdWFsaXplcic6IHRoaXMuX2JpbmRIYW5kbGVyLm9uUG9zdEVxdWFsaXplZEJvdW5kLFxcbiAgICAgICAgJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInOiB0aGlzLl9iaW5kSGFuZGxlci5vblJlc2l6ZU1lQm91bmQsXFxuICAgICAgICAnbXV0YXRlbWUuemYudHJpZ2dlcic6IHRoaXMuX2JpbmRIYW5kbGVyLm9uUmVzaXplTWVCb3VuZFxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBmdW5jdGlvbiB0byBoYW5kbGUgJGVsZW1lbnRzIHJlc2l6ZW1lLnpmLnRyaWdnZXIsIHdpdGggYm91bmQgdGhpcyBvbiBfYmluZEhhbmRsZXIub25SZXNpemVNZUJvdW5kXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfb25SZXNpemVNZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25SZXNpemVNZShlKSB7XFxuICAgICAgdGhpcy5fcmVmbG93KCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIGZ1bmN0aW9uIHRvIGhhbmRsZSAkZWxlbWVudHMgcG9zdGVxdWFsaXplZC56Zi5lcXVhbGl6ZXIsIHdpdGggYm91bmQgdGhpcyBvbiBfYmluZEhhbmRsZXIub25Qb3N0RXF1YWxpemVkQm91bmRcXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9vblBvc3RFcXVhbGl6ZWRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uUG9zdEVxdWFsaXplZChlKSB7XFxuICAgICAgaWYgKGUudGFyZ2V0ICE9PSB0aGlzLiRlbGVtZW50WzBdKSB7XFxuICAgICAgICB0aGlzLl9yZWZsb3coKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgRXF1YWxpemVyLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2V2ZW50c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy5fcGF1c2VFdmVudHMoKTtcXG5cXG4gICAgICBpZiAodGhpcy5oYXNOZXN0ZWQpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ3Bvc3RlcXVhbGl6ZWQuemYuZXF1YWxpemVyJywgdGhpcy5fYmluZEhhbmRsZXIub25Qb3N0RXF1YWxpemVkQm91bmQpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCdyZXNpemVtZS56Zi50cmlnZ2VyJywgdGhpcy5fYmluZEhhbmRsZXIub25SZXNpemVNZUJvdW5kKTtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ211dGF0ZW1lLnpmLnRyaWdnZXInLCB0aGlzLl9iaW5kSGFuZGxlci5vblJlc2l6ZU1lQm91bmQpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLmlzT24gPSB0cnVlO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgdGhlIGN1cnJlbnQgYnJlYWtwb2ludCB0byB0aGUgbWluaW11bSByZXF1aXJlZCBzaXplLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2NoZWNrTVFcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrTVEoKSB7XFxuICAgICAgdmFyIHRvb1NtYWxsID0gIV9mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJNZWRpYVF1ZXJ5XFxcIl0uaXModGhpcy5vcHRpb25zLmVxdWFsaXplT24pO1xcblxcbiAgICAgIGlmICh0b29TbWFsbCkge1xcbiAgICAgICAgaWYgKHRoaXMuaXNPbikge1xcbiAgICAgICAgICB0aGlzLl9wYXVzZUV2ZW50cygpO1xcblxcbiAgICAgICAgICB0aGlzLiR3YXRjaGVkLmNzcygnaGVpZ2h0JywgJ2F1dG8nKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKCF0aGlzLmlzT24pIHtcXG4gICAgICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0b29TbWFsbDtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQSBub29wIHZlcnNpb24gZm9yIHRoZSBwbHVnaW5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9raWxsc3dpdGNoXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9raWxsc3dpdGNoKCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2FsbHMgbmVjZXNzYXJ5IGZ1bmN0aW9ucyB0byB1cGRhdGUgRXF1YWxpemVyIHVwb24gRE9NIGNoYW5nZVxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3JlZmxvd1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVmbG93KCkge1xcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmVxdWFsaXplT25TdGFjaykge1xcbiAgICAgICAgaWYgKHRoaXMuX2lzU3RhY2tlZCgpKSB7XFxuICAgICAgICAgIHRoaXMuJHdhdGNoZWQuY3NzKCdoZWlnaHQnLCAnYXV0bycpO1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXF1YWxpemVCeVJvdykge1xcbiAgICAgICAgdGhpcy5nZXRIZWlnaHRzQnlSb3codGhpcy5hcHBseUhlaWdodEJ5Um93LmJpbmQodGhpcykpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLmdldEhlaWdodHModGhpcy5hcHBseUhlaWdodC5iaW5kKHRoaXMpKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIE1hbnVhbGx5IGRldGVybWluZXMgaWYgdGhlIGZpcnN0IDIgZWxlbWVudHMgYXJlICpOT1QqIHN0YWNrZWQuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfaXNTdGFja2VkXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc1N0YWNrZWQoKSB7XFxuICAgICAgaWYgKCF0aGlzLiR3YXRjaGVkWzBdIHx8ICF0aGlzLiR3YXRjaGVkWzFdKSB7XFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXMuJHdhdGNoZWRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICE9PSB0aGlzLiR3YXRjaGVkWzFdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogRmluZHMgdGhlIG91dGVyIGhlaWdodHMgb2YgY2hpbGRyZW4gY29udGFpbmVkIHdpdGhpbiBhbiBFcXVhbGl6ZXIgcGFyZW50IGFuZCByZXR1cm5zIHRoZW0gaW4gYW4gYXJyYXlcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBBIG5vbi1vcHRpb25hbCBjYWxsYmFjayB0byByZXR1cm4gdGhlIGhlaWdodHMgYXJyYXkgdG8uXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gaGVpZ2h0cyAtIEFuIGFycmF5IG9mIGhlaWdodHMgb2YgY2hpbGRyZW4gd2l0aGluIEVxdWFsaXplciBjb250YWluZXJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImdldEhlaWdodHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGVpZ2h0cyhjYikge1xcbiAgICAgIHZhciBoZWlnaHRzID0gW107XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuJHdhdGNoZWQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICAgIHRoaXMuJHdhdGNoZWRbaV0uc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xcbiAgICAgICAgaGVpZ2h0cy5wdXNoKHRoaXMuJHdhdGNoZWRbaV0ub2Zmc2V0SGVpZ2h0KTtcXG4gICAgICB9XFxuXFxuICAgICAgY2IoaGVpZ2h0cyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEZpbmRzIHRoZSBvdXRlciBoZWlnaHRzIG9mIGNoaWxkcmVuIGNvbnRhaW5lZCB3aXRoaW4gYW4gRXF1YWxpemVyIHBhcmVudCBhbmQgcmV0dXJucyB0aGVtIGluIGFuIGFycmF5XFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gQSBub24tb3B0aW9uYWwgY2FsbGJhY2sgdG8gcmV0dXJuIHRoZSBoZWlnaHRzIGFycmF5IHRvLlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGdyb3VwcyAtIEFuIGFycmF5IG9mIGhlaWdodHMgb2YgY2hpbGRyZW4gd2l0aGluIEVxdWFsaXplciBjb250YWluZXIgZ3JvdXBlZCBieSByb3cgd2l0aCBlbGVtZW50LGhlaWdodCBhbmQgbWF4IGFzIGxhc3QgY2hpbGRcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImdldEhlaWdodHNCeVJvd1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIZWlnaHRzQnlSb3coY2IpIHtcXG4gICAgICB2YXIgbGFzdEVsVG9wT2Zmc2V0ID0gdGhpcy4kd2F0Y2hlZC5sZW5ndGggPyB0aGlzLiR3YXRjaGVkLmZpcnN0KCkub2Zmc2V0KCkudG9wIDogMCxcXG4gICAgICAgICAgZ3JvdXBzID0gW10sXFxuICAgICAgICAgIGdyb3VwID0gMDsgLy9ncm91cCBieSBSb3dcXG5cXG4gICAgICBncm91cHNbZ3JvdXBdID0gW107XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuJHdhdGNoZWQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICAgIHRoaXMuJHdhdGNoZWRbaV0uc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nOyAvL21heWJlIGNvdWxkIHVzZSB0aGlzLiR3YXRjaGVkW2ldLm9mZnNldFRvcFxcblxcbiAgICAgICAgdmFyIGVsT2Zmc2V0VG9wID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMuJHdhdGNoZWRbaV0pLm9mZnNldCgpLnRvcDtcXG5cXG4gICAgICAgIGlmIChlbE9mZnNldFRvcCAhPSBsYXN0RWxUb3BPZmZzZXQpIHtcXG4gICAgICAgICAgZ3JvdXArKztcXG4gICAgICAgICAgZ3JvdXBzW2dyb3VwXSA9IFtdO1xcbiAgICAgICAgICBsYXN0RWxUb3BPZmZzZXQgPSBlbE9mZnNldFRvcDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGdyb3Vwc1tncm91cF0ucHVzaChbdGhpcy4kd2F0Y2hlZFtpXSwgdGhpcy4kd2F0Y2hlZFtpXS5vZmZzZXRIZWlnaHRdKTtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yICh2YXIgaiA9IDAsIGxuID0gZ3JvdXBzLmxlbmd0aDsgaiA8IGxuOyBqKyspIHtcXG4gICAgICAgIHZhciBoZWlnaHRzID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGdyb3Vwc1tqXSkubWFwKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXNbMV07XFxuICAgICAgICB9KS5nZXQoKTtcXG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heC5hcHBseShudWxsLCBoZWlnaHRzKTtcXG4gICAgICAgIGdyb3Vwc1tqXS5wdXNoKG1heCk7XFxuICAgICAgfVxcblxcbiAgICAgIGNiKGdyb3Vwcyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENoYW5nZXMgdGhlIENTUyBoZWlnaHQgcHJvcGVydHkgb2YgZWFjaCBjaGlsZCBpbiBhbiBFcXVhbGl6ZXIgcGFyZW50IHRvIG1hdGNoIHRoZSB0YWxsZXN0XFxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGhlaWdodHMgLSBBbiBhcnJheSBvZiBoZWlnaHRzIG9mIGNoaWxkcmVuIHdpdGhpbiBFcXVhbGl6ZXIgY29udGFpbmVyXFxuICAgICAqIEBmaXJlcyBFcXVhbGl6ZXIjcHJlZXF1YWxpemVkXFxuICAgICAqIEBmaXJlcyBFcXVhbGl6ZXIjcG9zdGVxdWFsaXplZFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiYXBwbHlIZWlnaHRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlIZWlnaHQoaGVpZ2h0cykge1xcbiAgICAgIHZhciBtYXggPSBNYXRoLm1heC5hcHBseShudWxsLCBoZWlnaHRzKTtcXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyBiZWZvcmUgdGhlIGhlaWdodHMgYXJlIGFwcGxpZWRcXG4gICAgICAgKiBAZXZlbnQgRXF1YWxpemVyI3ByZWVxdWFsaXplZFxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncHJlZXF1YWxpemVkLnpmLmVxdWFsaXplcicpO1xcbiAgICAgIHRoaXMuJHdhdGNoZWQuY3NzKCdoZWlnaHQnLCBtYXgpO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGhlaWdodHMgaGF2ZSBiZWVuIGFwcGxpZWRcXG4gICAgICAgKiBAZXZlbnQgRXF1YWxpemVyI3Bvc3RlcXVhbGl6ZWRcXG4gICAgICAgKi9cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3Bvc3RlcXVhbGl6ZWQuemYuZXF1YWxpemVyJyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENoYW5nZXMgdGhlIENTUyBoZWlnaHQgcHJvcGVydHkgb2YgZWFjaCBjaGlsZCBpbiBhbiBFcXVhbGl6ZXIgcGFyZW50IHRvIG1hdGNoIHRoZSB0YWxsZXN0IGJ5IHJvd1xcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBncm91cHMgLSBBbiBhcnJheSBvZiBoZWlnaHRzIG9mIGNoaWxkcmVuIHdpdGhpbiBFcXVhbGl6ZXIgY29udGFpbmVyIGdyb3VwZWQgYnkgcm93IHdpdGggZWxlbWVudCxoZWlnaHQgYW5kIG1heCBhcyBsYXN0IGNoaWxkXFxuICAgICAqIEBmaXJlcyBFcXVhbGl6ZXIjcHJlZXF1YWxpemVkXFxuICAgICAqIEBmaXJlcyBFcXVhbGl6ZXIjcHJlZXF1YWxpemVkcm93XFxuICAgICAqIEBmaXJlcyBFcXVhbGl6ZXIjcG9zdGVxdWFsaXplZHJvd1xcbiAgICAgKiBAZmlyZXMgRXF1YWxpemVyI3Bvc3RlcXVhbGl6ZWRcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImFwcGx5SGVpZ2h0QnlSb3dcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlIZWlnaHRCeVJvdyhncm91cHMpIHtcXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyBiZWZvcmUgdGhlIGhlaWdodHMgYXJlIGFwcGxpZWRcXG4gICAgICAgKi9cXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3ByZWVxdWFsaXplZC56Zi5lcXVhbGl6ZXInKTtcXG5cXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAgICB2YXIgZ3JvdXBzSUxlbmd0aCA9IGdyb3Vwc1tpXS5sZW5ndGgsXFxuICAgICAgICAgICAgbWF4ID0gZ3JvdXBzW2ldW2dyb3Vwc0lMZW5ndGggLSAxXTtcXG5cXG4gICAgICAgIGlmIChncm91cHNJTGVuZ3RoIDw9IDIpIHtcXG4gICAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGdyb3Vwc1tpXVswXVswXSkuY3NzKHtcXG4gICAgICAgICAgICAnaGVpZ2h0JzogJ2F1dG8nXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICAqIEZpcmVzIGJlZm9yZSB0aGUgaGVpZ2h0cyBwZXIgcm93IGFyZSBhcHBsaWVkXFxuICAgICAgICAgICogQGV2ZW50IEVxdWFsaXplciNwcmVlcXVhbGl6ZWRyb3dcXG4gICAgICAgICAgKi9cXG5cXG5cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncHJlZXF1YWxpemVkcm93LnpmLmVxdWFsaXplcicpO1xcblxcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbkogPSBncm91cHNJTGVuZ3RoIC0gMTsgaiA8IGxlbko7IGorKykge1xcbiAgICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZ3JvdXBzW2ldW2pdWzBdKS5jc3Moe1xcbiAgICAgICAgICAgICdoZWlnaHQnOiBtYXhcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgICAvKipcXG4gICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBoZWlnaHRzIHBlciByb3cgaGF2ZSBiZWVuIGFwcGxpZWRcXG4gICAgICAgICAgKiBAZXZlbnQgRXF1YWxpemVyI3Bvc3RlcXVhbGl6ZWRyb3dcXG4gICAgICAgICAgKi9cXG5cXG5cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncG9zdGVxdWFsaXplZHJvdy56Zi5lcXVhbGl6ZXInKTtcXG4gICAgICB9XFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgaGVpZ2h0cyBoYXZlIGJlZW4gYXBwbGllZFxcbiAgICAgICAqL1xcblxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncG9zdGVxdWFsaXplZC56Zi5lcXVhbGl6ZXInKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgRXF1YWxpemVyLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9kZXN0cm95XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgIHRoaXMuX3BhdXNlRXZlbnRzKCk7XFxuXFxuICAgICAgdGhpcy4kd2F0Y2hlZC5jc3MoJ2hlaWdodCcsICdhdXRvJyk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBFcXVhbGl6ZXI7XFxufShfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJQbHVnaW5cXFwiXSk7XFxuLyoqXFxuICogRGVmYXVsdCBzZXR0aW5ncyBmb3IgcGx1Z2luXFxuICovXFxuXFxuXFxuRXF1YWxpemVyLmRlZmF1bHRzID0ge1xcbiAgLyoqXFxuICAgKiBFbmFibGUgaGVpZ2h0IGVxdWFsaXphdGlvbiB3aGVuIHN0YWNrZWQgb24gc21hbGxlciBzY3JlZW5zLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBlcXVhbGl6ZU9uU3RhY2s6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBFbmFibGUgaGVpZ2h0IGVxdWFsaXphdGlvbiByb3cgYnkgcm93LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBlcXVhbGl6ZUJ5Um93OiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogU3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbWluaW11bSBicmVha3BvaW50IHNpemUgdGhlIHBsdWdpbiBzaG91bGQgZXF1YWxpemUgaGVpZ2h0cyBvbi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnJ1xcbiAgICovXFxuICBlcXVhbGl6ZU9uOiAnJ1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi5lcXVhbGl6ZXIuanM/XCIpfSxcIi4vanMvZm91bmRhdGlvbi5pbnRlcmNoYW5nZS5qc1wiOmZ1bmN0aW9uKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiSW50ZXJjaGFuZ2VcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEludGVyY2hhbmdlOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBqcXVlcnkgKi8gXFxcImpxdWVyeVxcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeSAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUucGx1Z2luICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS5wbHVnaW4uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUudXRpbHMgKi8gXFxcIi4vanMvZm91bmRhdGlvbi5jb3JlLnV0aWxzLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxcblxcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXFxcIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxcblxcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XFxuXFxuXFxuXFxuXFxuXFxuLyoqXFxuICogSW50ZXJjaGFuZ2UgbW9kdWxlLlxcbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5pbnRlcmNoYW5nZVxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxcbiAqL1xcblxcbnZhciBJbnRlcmNoYW5nZSA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uIChfUGx1Z2luKSB7XFxuICBfaW5oZXJpdHMoSW50ZXJjaGFuZ2UsIF9QbHVnaW4pO1xcblxcbiAgZnVuY3Rpb24gSW50ZXJjaGFuZ2UoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnRlcmNoYW5nZSk7XFxuXFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoSW50ZXJjaGFuZ2UpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKEludGVyY2hhbmdlLCBbe1xcbiAgICBrZXk6IFxcXCJfc2V0dXBcXFwiLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBJbnRlcmNoYW5nZS5cXG4gICAgICogQGNsYXNzXFxuICAgICAqIEBuYW1lIEludGVyY2hhbmdlXFxuICAgICAqIEBmaXJlcyBJbnRlcmNoYW5nZSNpbml0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIHRyaWdnZXIgdG8uXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cXG4gICAgICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMub3B0aW9ucyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoe30sIEludGVyY2hhbmdlLmRlZmF1bHRzLCBvcHRpb25zKTtcXG4gICAgICB0aGlzLnJ1bGVzID0gW107XFxuICAgICAgdGhpcy5jdXJyZW50UGF0aCA9ICcnO1xcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ0ludGVyY2hhbmdlJzsgLy8gaWU5IGJhY2sgY29tcGF0XFxuXFxuICAgICAgdGhpcy5faW5pdCgpO1xcblxcbiAgICAgIHRoaXMuX2V2ZW50cygpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgSW50ZXJjaGFuZ2UgcGx1Z2luIGFuZCBjYWxscyBmdW5jdGlvbnMgdG8gZ2V0IGludGVyY2hhbmdlIGZ1bmN0aW9uaW5nIG9uIGxvYWQuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2luaXRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIk1lZGlhUXVlcnlcXFwiXS5faW5pdCgpO1xcblxcbiAgICAgIHZhciBpZCA9IHRoaXMuJGVsZW1lbnRbMF0uaWQgfHwgT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiR2V0WW9EaWdpdHNcXFwiXSkoNiwgJ2ludGVyY2hhbmdlJyk7XFxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcXG4gICAgICAgICdkYXRhLXJlc2l6ZSc6IGlkLFxcbiAgICAgICAgJ2lkJzogaWRcXG4gICAgICB9KTtcXG5cXG4gICAgICB0aGlzLl9hZGRCcmVha3BvaW50cygpO1xcblxcbiAgICAgIHRoaXMuX2dlbmVyYXRlUnVsZXMoKTtcXG5cXG4gICAgICB0aGlzLl9yZWZsb3coKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgZXZlbnRzIGZvciBJbnRlcmNoYW5nZS5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZXZlbnRzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInKS5vbigncmVzaXplbWUuemYudHJpZ2dlcicsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiBfdGhpczIuX3JlZmxvdygpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDYWxscyBuZWNlc3NhcnkgZnVuY3Rpb25zIHRvIHVwZGF0ZSBJbnRlcmNoYW5nZSB1cG9uIERPTSBjaGFuZ2VcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfcmVmbG93XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWZsb3coKSB7XFxuICAgICAgdmFyIG1hdGNoOyAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBydWxlLCBidXQgb25seSBzYXZlIHRoZSBsYXN0IG1hdGNoXFxuXFxuICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnJ1bGVzKSB7XFxuICAgICAgICBpZiAodGhpcy5ydWxlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xcbiAgICAgICAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXNbaV07XFxuXFxuICAgICAgICAgIGlmICh3aW5kb3cubWF0Y2hNZWRpYShydWxlLnF1ZXJ5KS5tYXRjaGVzKSB7XFxuICAgICAgICAgICAgbWF0Y2ggPSBydWxlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChtYXRjaCkge1xcbiAgICAgICAgdGhpcy5yZXBsYWNlKG1hdGNoLnBhdGgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogR2V0cyB0aGUgRm91bmRhdGlvbiBicmVha3BvaW50cyBhbmQgYWRkcyB0aGVtIHRvIHRoZSBJbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVMgb2JqZWN0LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9hZGRCcmVha3BvaW50c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkQnJlYWtwb2ludHMoKSB7XFxuICAgICAgZm9yICh2YXIgaSBpbiBfZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiTWVkaWFRdWVyeVxcXCJdLnF1ZXJpZXMpIHtcXG4gICAgICAgIGlmIChfZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiTWVkaWFRdWVyeVxcXCJdLnF1ZXJpZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgdmFyIHF1ZXJ5ID0gX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIk1lZGlhUXVlcnlcXFwiXS5xdWVyaWVzW2ldO1xcbiAgICAgICAgICBJbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVNbcXVlcnkubmFtZV0gPSBxdWVyeS52YWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyB0aGUgSW50ZXJjaGFuZ2UgZWxlbWVudCBmb3IgdGhlIHByb3ZpZGVkIG1lZGlhIHF1ZXJ5ICsgY29udGVudCBwYWlyaW5nc1xcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRoYXQgaXMgYW4gSW50ZXJjaGFuZ2UgaW5zdGFuY2VcXG4gICAgICogQHJldHVybnMge0FycmF5fSBzY2VuYXJpb3MgLSBBcnJheSBvZiBvYmplY3RzIHRoYXQgaGF2ZSAnbXEnIGFuZCAncGF0aCcga2V5cyB3aXRoIGNvcnJlc3BvbmRpbmcga2V5c1xcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2dlbmVyYXRlUnVsZXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dlbmVyYXRlUnVsZXMoZWxlbWVudCkge1xcbiAgICAgIHZhciBydWxlc0xpc3QgPSBbXTtcXG4gICAgICB2YXIgcnVsZXM7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydWxlcykge1xcbiAgICAgICAgcnVsZXMgPSB0aGlzLm9wdGlvbnMucnVsZXM7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJ1bGVzID0gdGhpcy4kZWxlbWVudC5kYXRhKCdpbnRlcmNoYW5nZScpO1xcbiAgICAgIH1cXG5cXG4gICAgICBydWxlcyA9IHR5cGVvZiBydWxlcyA9PT0gJ3N0cmluZycgPyBydWxlcy5tYXRjaCgvXFxcXFsuKj8sIC4qP1xcXFxdL2cpIDogcnVsZXM7XFxuXFxuICAgICAgZm9yICh2YXIgaSBpbiBydWxlcykge1xcbiAgICAgICAgaWYgKHJ1bGVzLmhhc093blByb3BlcnR5KGkpKSB7XFxuICAgICAgICAgIHZhciBydWxlID0gcnVsZXNbaV0uc2xpY2UoMSwgLTEpLnNwbGl0KCcsICcpO1xcbiAgICAgICAgICB2YXIgcGF0aCA9IHJ1bGUuc2xpY2UoMCwgLTEpLmpvaW4oJycpO1xcbiAgICAgICAgICB2YXIgcXVlcnkgPSBydWxlW3J1bGUubGVuZ3RoIC0gMV07XFxuXFxuICAgICAgICAgIGlmIChJbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVNbcXVlcnldKSB7XFxuICAgICAgICAgICAgcXVlcnkgPSBJbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVNbcXVlcnldO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJ1bGVzTGlzdC5wdXNoKHtcXG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxcbiAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzTGlzdDtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogVXBkYXRlIHRoZSBgc3JjYCBwcm9wZXJ0eSBvZiBhbiBpbWFnZSwgb3IgY2hhbmdlIHRoZSBIVE1MIG9mIGEgY29udGFpbmVyLCB0byB0aGUgc3BlY2lmaWVkIHBhdGguXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCAtIFBhdGggdG8gdGhlIGltYWdlIG9yIEhUTUwgcGFydGlhbC5cXG4gICAgICogQGZpcmVzIEludGVyY2hhbmdlI3JlcGxhY2VkXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJyZXBsYWNlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCkge1xcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoID09PSBwYXRoKSByZXR1cm47XFxuXFxuICAgICAgdmFyIF90aGlzID0gdGhpcyxcXG4gICAgICAgICAgdHJpZ2dlciA9ICdyZXBsYWNlZC56Zi5pbnRlcmNoYW5nZSc7IC8vIFJlcGxhY2luZyBpbWFnZXNcXG5cXG5cXG4gICAgICBpZiAodGhpcy4kZWxlbWVudFswXS5ub2RlTmFtZSA9PT0gJ0lNRycpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignc3JjJywgcGF0aCkub24oJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIF90aGlzLmN1cnJlbnRQYXRoID0gcGF0aDtcXG4gICAgICAgIH0pLnRyaWdnZXIodHJpZ2dlcik7XFxuICAgICAgfSAvLyBSZXBsYWNpbmcgYmFja2dyb3VuZCBpbWFnZXNcXG4gICAgICBlbHNlIGlmIChwYXRoLm1hdGNoKC9cXFxcLihnaWZ8anBnfGpwZWd8cG5nfHN2Z3x0aWZmKShbPyNdLiopPy9pKSkge1xcbiAgICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXFxcKC9nLCAnJTI4JykucmVwbGFjZSgvXFxcXCkvZywgJyUyOScpO1xcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LmNzcyh7XFxuICAgICAgICAgICAgJ2JhY2tncm91bmQtaW1hZ2UnOiAndXJsKCcgKyBwYXRoICsgJyknXFxuICAgICAgICAgIH0pLnRyaWdnZXIodHJpZ2dlcik7XFxuICAgICAgICB9IC8vIFJlcGxhY2luZyBIVE1MXFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZ2V0KHBhdGgsIGZ1bmN0aW9uIChyZXNwb25zZSkge1xcbiAgICAgICAgICAgICAgX3RoaXMuJGVsZW1lbnQuaHRtbChyZXNwb25zZSkudHJpZ2dlcih0cmlnZ2VyKTtcXG5cXG4gICAgICAgICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShyZXNwb25zZSkuZm91bmRhdGlvbigpO1xcbiAgICAgICAgICAgICAgX3RoaXMuY3VycmVudFBhdGggPSBwYXRoO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9XFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgd2hlbiBjb250ZW50IGluIGFuIEludGVyY2hhbmdlIGVsZW1lbnQgaXMgZG9uZSBiZWluZyBsb2FkZWQuXFxuICAgICAgICogQGV2ZW50IEludGVyY2hhbmdlI3JlcGxhY2VkXFxuICAgICAgICovXFxuICAgICAgLy8gdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdyZXBsYWNlZC56Zi5pbnRlcmNoYW5nZScpO1xcblxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBpbnRlcmNoYW5nZS5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZGVzdHJveVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZigncmVzaXplbWUuemYudHJpZ2dlcicpO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gSW50ZXJjaGFuZ2U7XFxufShfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJQbHVnaW5cXFwiXSk7XFxuLyoqXFxuICogRGVmYXVsdCBzZXR0aW5ncyBmb3IgcGx1Z2luXFxuICovXFxuXFxuXFxuSW50ZXJjaGFuZ2UuZGVmYXVsdHMgPSB7XFxuICAvKipcXG4gICAqIFJ1bGVzIHRvIGJlIGFwcGxpZWQgdG8gSW50ZXJjaGFuZ2UgZWxlbWVudHMuIFNldCB3aXRoIHRoZSBgZGF0YS1pbnRlcmNoYW5nZWAgYXJyYXkgbm90YXRpb24uXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7P2FycmF5fVxcbiAgICogQGRlZmF1bHQgbnVsbFxcbiAgICovXFxuICBydWxlczogbnVsbFxcbn07XFxuSW50ZXJjaGFuZ2UuU1BFQ0lBTF9RVUVSSUVTID0ge1xcbiAgJ2xhbmRzY2FwZSc6ICdzY3JlZW4gYW5kIChvcmllbnRhdGlvbjogbGFuZHNjYXBlKScsXFxuICAncG9ydHJhaXQnOiAnc2NyZWVuIGFuZCAob3JpZW50YXRpb246IHBvcnRyYWl0KScsXFxuICAncmV0aW5hJzogJ29ubHkgc2NyZWVuIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwgb25seSBzY3JlZW4gYW5kIChtaW4tLW1vei1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCBvbmx5IHNjcmVlbiBhbmQgKC1vLW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIvMSksIG9ubHkgc2NyZWVuIGFuZCAobWluLWRldmljZS1waXhlbC1yYXRpbzogMiksIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDE5MmRwaSksIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDJkcHB4KSdcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL2pzL2ZvdW5kYXRpb24uaW50ZXJjaGFuZ2UuanM/XCIpfSxcIi4vanMvZm91bmRhdGlvbi5tYWdlbGxhbi5qc1wiOmZ1bmN0aW9uKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiTWFnZWxsYW5cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIE1hZ2VsbGFuOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBqcXVlcnkgKi8gXFxcImpxdWVyeVxcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnV0aWxzICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS51dGlscy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUucGx1Z2luICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS5wbHVnaW4uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fc21vb3RoU2Nyb2xsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uc21vb3RoU2Nyb2xsICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uc21vb3RoU2Nyb2xsLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxcblxcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXFxcIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxcblxcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XFxuXFxuXFxuXFxuXFxuXFxuLyoqXFxuICogTWFnZWxsYW4gbW9kdWxlLlxcbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5tYWdlbGxhblxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnNtb290aFNjcm9sbFxcbiAqL1xcblxcbnZhciBNYWdlbGxhbiA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uIChfUGx1Z2luKSB7XFxuICBfaW5oZXJpdHMoTWFnZWxsYW4sIF9QbHVnaW4pO1xcblxcbiAgZnVuY3Rpb24gTWFnZWxsYW4oKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYWdlbGxhbik7XFxuXFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoTWFnZWxsYW4pLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKE1hZ2VsbGFuLCBbe1xcbiAgICBrZXk6IFxcXCJfc2V0dXBcXFwiLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBNYWdlbGxhbi5cXG4gICAgICogQGNsYXNzXFxuICAgICAqIEBuYW1lIE1hZ2VsbGFuXFxuICAgICAqIEBmaXJlcyBNYWdlbGxhbiNpbml0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIHRyaWdnZXIgdG8uXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cXG4gICAgICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMub3B0aW9ucyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoe30sIE1hZ2VsbGFuLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XFxuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnTWFnZWxsYW4nOyAvLyBpZTkgYmFjayBjb21wYXRcXG5cXG4gICAgICB0aGlzLl9pbml0KCk7XFxuXFxuICAgICAgdGhpcy5jYWxjUG9pbnRzKCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIHRoZSBNYWdlbGxhbiBwbHVnaW4gYW5kIGNhbGxzIGZ1bmN0aW9ucyB0byBnZXQgZXF1YWxpemVyIGZ1bmN0aW9uaW5nIG9uIGxvYWQuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfaW5pdFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcXG4gICAgICB2YXIgaWQgPSB0aGlzLiRlbGVtZW50WzBdLmlkIHx8IE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIkdldFlvRGlnaXRzXFxcIl0pKDYsICdtYWdlbGxhbicpO1xcblxcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy4kdGFyZ2V0cyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnW2RhdGEtbWFnZWxsYW4tdGFyZ2V0XScpO1xcbiAgICAgIHRoaXMuJGxpbmtzID0gdGhpcy4kZWxlbWVudC5maW5kKCdhJyk7XFxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcXG4gICAgICAgICdkYXRhLXJlc2l6ZSc6IGlkLFxcbiAgICAgICAgJ2RhdGEtc2Nyb2xsJzogaWQsXFxuICAgICAgICAnaWQnOiBpZFxcbiAgICAgIH0pO1xcbiAgICAgIHRoaXMuJGFjdGl2ZSA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgpO1xcbiAgICAgIHRoaXMuc2Nyb2xsUG9zID0gcGFyc2VJbnQod2luZG93LnBhZ2VZT2Zmc2V0LCAxMCk7XFxuXFxuICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENhbGN1bGF0ZXMgYW4gYXJyYXkgb2YgcGl4ZWwgdmFsdWVzIHRoYXQgYXJlIHRoZSBkZW1hcmNhdGlvbiBsaW5lcyBiZXR3ZWVuIGxvY2F0aW9ucyBvbiB0aGUgcGFnZS5cXG4gICAgICogQ2FuIGJlIGludm9rZWQgaWYgbmV3IGVsZW1lbnRzIGFyZSBhZGRlZCBvciB0aGUgc2l6ZSBvZiBhIGxvY2F0aW9uIGNoYW5nZXMuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiY2FsY1BvaW50c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjUG9pbnRzKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXFxuICAgICAgICAgIGJvZHkgPSBkb2N1bWVudC5ib2R5LFxcbiAgICAgICAgICBodG1sID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xcblxcbiAgICAgIHRoaXMucG9pbnRzID0gW107XFxuICAgICAgdGhpcy53aW5IZWlnaHQgPSBNYXRoLnJvdW5kKE1hdGgubWF4KHdpbmRvdy5pbm5lckhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQpKTtcXG4gICAgICB0aGlzLmRvY0hlaWdodCA9IE1hdGgucm91bmQoTWF0aC5tYXgoYm9keS5zY3JvbGxIZWlnaHQsIGJvZHkub2Zmc2V0SGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCwgaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwub2Zmc2V0SGVpZ2h0KSk7XFxuICAgICAgdGhpcy4kdGFyZ2V0cy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciAkdGFyID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLFxcbiAgICAgICAgICAgIHB0ID0gTWF0aC5yb3VuZCgkdGFyLm9mZnNldCgpLnRvcCAtIF90aGlzLm9wdGlvbnMudGhyZXNob2xkKTtcXG4gICAgICAgICR0YXIudGFyZ2V0UG9pbnQgPSBwdDtcXG5cXG4gICAgICAgIF90aGlzLnBvaW50cy5wdXNoKHB0KTtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgZXZlbnRzIGZvciBNYWdlbGxhbi5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9ldmVudHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxcbiAgICAgICAgICAkYm9keSA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnaHRtbCwgYm9keScpLFxcbiAgICAgICAgICBvcHRzID0ge1xcbiAgICAgICAgZHVyYXRpb246IF90aGlzLm9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sXFxuICAgICAgICBlYXNpbmc6IF90aGlzLm9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nXFxuICAgICAgfTtcXG5cXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS5vbmUoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5kZWVwTGlua2luZykge1xcbiAgICAgICAgICBpZiAobG9jYXRpb24uaGFzaCkge1xcbiAgICAgICAgICAgIF90aGlzLnNjcm9sbFRvTG9jKGxvY2F0aW9uLmhhc2gpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBfdGhpcy5jYWxjUG9pbnRzKCk7XFxuXFxuICAgICAgICBfdGhpcy5fdXBkYXRlQWN0aXZlKCk7XFxuICAgICAgfSk7XFxuICAgICAgX3RoaXMub25Mb2FkTGlzdGVuZXIgPSBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJvbkxvYWRcXFwiXSkoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdyksIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIF90aGlzLiRlbGVtZW50Lm9uKHtcXG4gICAgICAgICAgJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInOiBfdGhpcy5yZWZsb3cuYmluZChfdGhpcyksXFxuICAgICAgICAgICdzY3JvbGxtZS56Zi50cmlnZ2VyJzogX3RoaXMuX3VwZGF0ZUFjdGl2ZS5iaW5kKF90aGlzKVxcbiAgICAgICAgfSkub24oJ2NsaWNrLnpmLm1hZ2VsbGFuJywgJ2FbaHJlZl49XFxcIiNcXFwiXScsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgdmFyIGFycml2YWwgPSB0aGlzLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xcblxcbiAgICAgICAgICBfdGhpcy5zY3JvbGxUb0xvYyhhcnJpdmFsKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIHRoaXMuX2RlZXBMaW5rU2Nyb2xsID0gZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmRlZXBMaW5raW5nKSB7XFxuICAgICAgICAgIF90aGlzLnNjcm9sbFRvTG9jKHdpbmRvdy5sb2NhdGlvbi5oYXNoKTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcblxcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLm9uKCdoYXNoY2hhbmdlJywgdGhpcy5fZGVlcExpbmtTY3JvbGwpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBGdW5jdGlvbiB0byBzY3JvbGwgdG8gYSBnaXZlbiBsb2NhdGlvbiBvbiB0aGUgcGFnZS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxvYyAtIGEgcHJvcGVybHkgZm9ybWF0dGVkIGpRdWVyeSBpZCBzZWxlY3Rvci4gRXhhbXBsZTogJyNmb28nXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwic2Nyb2xsVG9Mb2NcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2Nyb2xsVG9Mb2MobG9jKSB7XFxuICAgICAgdGhpcy5faW5UcmFuc2l0aW9uID0gdHJ1ZTtcXG5cXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgIHZhciBvcHRpb25zID0ge1xcbiAgICAgICAgYW5pbWF0aW9uRWFzaW5nOiB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nLFxcbiAgICAgICAgYW5pbWF0aW9uRHVyYXRpb246IHRoaXMub3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixcXG4gICAgICAgIHRocmVzaG9sZDogdGhpcy5vcHRpb25zLnRocmVzaG9sZCxcXG4gICAgICAgIG9mZnNldDogdGhpcy5vcHRpb25zLm9mZnNldFxcbiAgICAgIH07XFxuICAgICAgX2ZvdW5kYXRpb25fc21vb3RoU2Nyb2xsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcIlNtb290aFNjcm9sbFxcXCJdLnNjcm9sbFRvTG9jKGxvYywgb3B0aW9ucywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgX3RoaXMuX2luVHJhbnNpdGlvbiA9IGZhbHNlO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDYWxscyBuZWNlc3NhcnkgZnVuY3Rpb25zIHRvIHVwZGF0ZSBNYWdlbGxhbiB1cG9uIERPTSBjaGFuZ2VcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJyZWZsb3dcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVmbG93KCkge1xcbiAgICAgIHRoaXMuY2FsY1BvaW50cygpO1xcblxcbiAgICAgIHRoaXMuX3VwZGF0ZUFjdGl2ZSgpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBVcGRhdGVzIHRoZSB2aXNpYmlsaXR5IG9mIGFuIGFjdGl2ZSBsb2NhdGlvbiBsaW5rLCBhbmQgdXBkYXRlcyB0aGUgdXJsIGhhc2ggZm9yIHRoZSBwYWdlLCBpZiBkZWVwTGlua2luZyBlbmFibGVkLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQGZpcmVzIE1hZ2VsbGFuI3VwZGF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3VwZGF0ZUFjdGl2ZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlQWN0aXZlKClcXG4gICAgLypldnQsIGVsZW0sIHNjcm9sbFBvcyovXFxuICAgIHtcXG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcXG5cXG4gICAgICBpZiAodGhpcy5faW5UcmFuc2l0aW9uKSByZXR1cm47XFxuICAgICAgdmFyIG5ld1Njcm9sbFBvcyA9IHBhcnNlSW50KHdpbmRvdy5wYWdlWU9mZnNldCwgMTApO1xcbiAgICAgIHZhciBpc1Njcm9sbGluZ1VwID0gdGhpcy5zY3JvbGxQb3MgPiBuZXdTY3JvbGxQb3M7XFxuICAgICAgdGhpcy5zY3JvbGxQb3MgPSBuZXdTY3JvbGxQb3M7XFxuICAgICAgdmFyIGFjdGl2ZUlkeDsgLy8gQmVmb3JlIHRoZSBmaXJzdCBwb2ludDogbm8gbGlua1xcblxcbiAgICAgIGlmIChuZXdTY3JvbGxQb3MgPCB0aGlzLnBvaW50c1swXSkge31cXG4gICAgICAvKiBkbyBub3RoaW5nICovXFxuICAgICAgLy8gQXQgdGhlIGJvdHRvbSBvZiB0aGUgcGFnZTogbGFzdCBsaW5rXFxuICAgICAgZWxzZSBpZiAobmV3U2Nyb2xsUG9zICsgdGhpcy53aW5IZWlnaHQgPT09IHRoaXMuZG9jSGVpZ2h0KSB7XFxuICAgICAgICAgIGFjdGl2ZUlkeCA9IHRoaXMucG9pbnRzLmxlbmd0aCAtIDE7XFxuICAgICAgICB9IC8vIE90aGVyd2hpc2UsIHVzZSB0aGUgbGFzdCB2aXNpYmxlIGxpbmtcXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIHZhciB2aXNpYmxlTGlua3MgPSB0aGlzLnBvaW50cy5maWx0ZXIoZnVuY3Rpb24gKHAsIGkpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBwIC0gX3RoaXMyLm9wdGlvbnMub2Zmc2V0IC0gKGlzU2Nyb2xsaW5nVXAgPyBfdGhpczIub3B0aW9ucy50aHJlc2hvbGQgOiAwKSA8PSBuZXdTY3JvbGxQb3M7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgYWN0aXZlSWR4ID0gdmlzaWJsZUxpbmtzLmxlbmd0aCA/IHZpc2libGVMaW5rcy5sZW5ndGggLSAxIDogMDtcXG4gICAgICAgICAgfSAvLyBHZXQgdGhlIG5ldyBhY3RpdmUgbGlua1xcblxcblxcbiAgICAgIHZhciAkb2xkQWN0aXZlID0gdGhpcy4kYWN0aXZlO1xcbiAgICAgIHZhciBhY3RpdmVIYXNoID0gJyc7XFxuXFxuICAgICAgaWYgKHR5cGVvZiBhY3RpdmVJZHggIT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICB0aGlzLiRhY3RpdmUgPSB0aGlzLiRsaW5rcy5maWx0ZXIoJ1tocmVmPVxcXCIjJyArIHRoaXMuJHRhcmdldHMuZXEoYWN0aXZlSWR4KS5kYXRhKCdtYWdlbGxhbi10YXJnZXQnKSArICdcXFwiXScpO1xcbiAgICAgICAgaWYgKHRoaXMuJGFjdGl2ZS5sZW5ndGgpIGFjdGl2ZUhhc2ggPSB0aGlzLiRhY3RpdmVbMF0uZ2V0QXR0cmlidXRlKCdocmVmJyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuJGFjdGl2ZSA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgaXNOZXdBY3RpdmUgPSAhKCF0aGlzLiRhY3RpdmUubGVuZ3RoICYmICEkb2xkQWN0aXZlLmxlbmd0aCkgJiYgIXRoaXMuJGFjdGl2ZS5pcygkb2xkQWN0aXZlKTtcXG4gICAgICB2YXIgaXNOZXdIYXNoID0gYWN0aXZlSGFzaCAhPT0gd2luZG93LmxvY2F0aW9uLmhhc2g7IC8vIFVwZGF0ZSB0aGUgYWN0aXZlIGxpbmsgZWxlbWVudFxcblxcbiAgICAgIGlmIChpc05ld0FjdGl2ZSkge1xcbiAgICAgICAgJG9sZEFjdGl2ZS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xcbiAgICAgICAgdGhpcy4kYWN0aXZlLmFkZENsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyk7XFxuICAgICAgfSAvLyBVcGRhdGUgdGhlIGhhc2ggKGl0IG1heSBoYXZlIGNoYW5nZWQgd2l0aCB0aGUgc2FtZSBhY3RpdmUgbGluaylcXG5cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5raW5nICYmIGlzTmV3SGFzaCkge1xcbiAgICAgICAgaWYgKHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSkge1xcbiAgICAgICAgICAvLyBTZXQgb3IgcmVtb3ZlIHRoZSBoYXNoIChzZWU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81Mjk4Njg0LzQzMTczODRcXG4gICAgICAgICAgdmFyIHVybCA9IGFjdGl2ZUhhc2ggPyBhY3RpdmVIYXNoIDogd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaDtcXG4gICAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKG51bGwsIG51bGwsIHVybCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IGFjdGl2ZUhhc2g7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpc05ld0FjdGl2ZSkge1xcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBGaXJlcyB3aGVuIG1hZ2VsbGFuIGlzIGZpbmlzaGVkIHVwZGF0aW5nIHRvIHRoZSBuZXcgYWN0aXZlIGVsZW1lbnQuXFxuICAgICAgICAgKiBAZXZlbnQgTWFnZWxsYW4jdXBkYXRlXFxuICAgICAgICAgKi9cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigndXBkYXRlLnpmLm1hZ2VsbGFuJywgW3RoaXMuJGFjdGl2ZV0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgTWFnZWxsYW4gYW5kIHJlc2V0cyB0aGUgdXJsIG9mIHRoZSB3aW5kb3cuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2Rlc3Ryb3lcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi50cmlnZ2VyIC56Zi5tYWdlbGxhbicpLmZpbmQoXFxcIi5cXFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpKS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVlcExpbmtpbmcpIHtcXG4gICAgICAgIHZhciBoYXNoID0gdGhpcy4kYWN0aXZlWzBdLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2gucmVwbGFjZShoYXNoLCAnJyk7XFxuICAgICAgfVxcblxcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLm9mZignaGFzaGNoYW5nZScsIHRoaXMuX2RlZXBMaW5rU2Nyb2xsKTtcXG4gICAgICBpZiAodGhpcy5vbkxvYWRMaXN0ZW5lcikganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub2ZmKHRoaXMub25Mb2FkTGlzdGVuZXIpO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gTWFnZWxsYW47XFxufShfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJQbHVnaW5cXFwiXSk7XFxuLyoqXFxuICogRGVmYXVsdCBzZXR0aW5ncyBmb3IgcGx1Z2luXFxuICovXFxuXFxuXFxuTWFnZWxsYW4uZGVmYXVsdHMgPSB7XFxuICAvKipcXG4gICAqIEFtb3VudCBvZiB0aW1lLCBpbiBtcywgdGhlIGFuaW1hdGVkIHNjcm9sbGluZyBzaG91bGQgdGFrZSBiZXR3ZWVuIGxvY2F0aW9ucy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCA1MDBcXG4gICAqL1xcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcXG5cXG4gIC8qKlxcbiAgICogQW5pbWF0aW9uIHN0eWxlIHRvIHVzZSB3aGVuIHNjcm9sbGluZyBiZXR3ZWVuIGxvY2F0aW9ucy4gQ2FuIGJlIGAnc3dpbmcnYCBvciBgJ2xpbmVhcidgLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICdsaW5lYXInXFxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2FwaS5qcXVlcnkuY29tL2FuaW1hdGV8SnF1ZXJ5IGFuaW1hdGV9XFxuICAgKi9cXG4gIGFuaW1hdGlvbkVhc2luZzogJ2xpbmVhcicsXFxuXFxuICAvKipcXG4gICAqIE51bWJlciBvZiBwaXhlbHMgdG8gdXNlIGFzIGEgbWFya2VyIGZvciBsb2NhdGlvbiBjaGFuZ2VzLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDUwXFxuICAgKi9cXG4gIHRocmVzaG9sZDogNTAsXFxuXFxuICAvKipcXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGFjdGl2ZSBsb2NhdGlvbnMgbGluayBvbiB0aGUgbWFnZWxsYW4gY29udGFpbmVyLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICdpcy1hY3RpdmUnXFxuICAgKi9cXG4gIGFjdGl2ZUNsYXNzOiAnaXMtYWN0aXZlJyxcXG5cXG4gIC8qKlxcbiAgICogQWxsb3dzIHRoZSBzY3JpcHQgdG8gbWFuaXB1bGF0ZSB0aGUgdXJsIG9mIHRoZSBjdXJyZW50IHBhZ2UsIGFuZCBpZiBzdXBwb3J0ZWQsIGFsdGVyIHRoZSBoaXN0b3J5LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBkZWVwTGlua2luZzogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIE51bWJlciBvZiBwaXhlbHMgdG8gb2Zmc2V0IHRoZSBzY3JvbGwgb2YgdGhlIHBhZ2Ugb24gaXRlbSBjbGljayBpZiB1c2luZyBhIHN0aWNreSBuYXYgYmFyLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDBcXG4gICAqL1xcbiAgb2Zmc2V0OiAwXFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9qcy9mb3VuZGF0aW9uLm1hZ2VsbGFuLmpzP1wiKX0sXCIuL2pzL2ZvdW5kYXRpb24ub2ZmY2FudmFzLmpzXCI6ZnVuY3Rpb24obW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJPZmZDYW52YXNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIE9mZkNhbnZhczsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganF1ZXJ5ICovIFxcXCJqcXVlcnlcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uY29yZS51dGlscyAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUudXRpbHMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmQgKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLmtleWJvYXJkLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeSAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUucGx1Z2luICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS5wbHVnaW4uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF90cmlnZ2Vyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnMgKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxcblxcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXFxcIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxcblxcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuLyoqXFxuICogT2ZmQ2FudmFzIG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24ub2ZmY2FudmFzXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcXG4gKi9cXG5cXG52YXIgT2ZmQ2FudmFzID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKF9QbHVnaW4pIHtcXG4gIF9pbmhlcml0cyhPZmZDYW52YXMsIF9QbHVnaW4pO1xcblxcbiAgZnVuY3Rpb24gT2ZmQ2FudmFzKCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT2ZmQ2FudmFzKTtcXG5cXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihPZmZDYW52YXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKE9mZkNhbnZhcywgW3tcXG4gICAga2V5OiBcXFwiX3NldHVwXFxcIixcXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYW4gb2ZmLWNhbnZhcyB3cmFwcGVyLlxcbiAgICAgKiBAY2xhc3NcXG4gICAgICogQG5hbWUgT2ZmQ2FudmFzXFxuICAgICAqIEBmaXJlcyBPZmZDYW52YXMjaW5pdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gaW5pdGlhbGl6ZS5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnT2ZmQ2FudmFzJzsgLy8gaWU5IGJhY2sgY29tcGF0XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XFxuICAgICAgdGhpcy5vcHRpb25zID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCh7fSwgT2ZmQ2FudmFzLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XFxuICAgICAgdGhpcy5jb250ZW50Q2xhc3NlcyA9IHtcXG4gICAgICAgIGJhc2U6IFtdLFxcbiAgICAgICAgcmV2ZWFsOiBbXVxcbiAgICAgIH07XFxuICAgICAgdGhpcy4kbGFzdFRyaWdnZXIgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoKTtcXG4gICAgICB0aGlzLiR0cmlnZ2VycyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgpO1xcbiAgICAgIHRoaXMucG9zaXRpb24gPSAnbGVmdCc7XFxuICAgICAgdGhpcy4kY29udGVudCA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgpO1xcbiAgICAgIHRoaXMubmVzdGVkID0gISF0aGlzLm9wdGlvbnMubmVzdGVkOyAvLyBEZWZpbmVzIHRoZSBDU1MgdHJhbnNpdGlvbi9wb3NpdGlvbiBjbGFzc2VzIG9mIHRoZSBvZmYtY2FudmFzIGNvbnRlbnQgY29udGFpbmVyLlxcblxcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShbJ3B1c2gnLCAnb3ZlcmxhcCddKS5lYWNoKGZ1bmN0aW9uIChpbmRleCwgdmFsKSB7XFxuICAgICAgICBfdGhpczIuY29udGVudENsYXNzZXMuYmFzZS5wdXNoKCdoYXMtdHJhbnNpdGlvbi0nICsgdmFsKTtcXG4gICAgICB9KTtcXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoWydsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nXSkuZWFjaChmdW5jdGlvbiAoaW5kZXgsIHZhbCkge1xcbiAgICAgICAgX3RoaXMyLmNvbnRlbnRDbGFzc2VzLmJhc2UucHVzaCgnaGFzLXBvc2l0aW9uLScgKyB2YWwpO1xcblxcbiAgICAgICAgX3RoaXMyLmNvbnRlbnRDbGFzc2VzLnJldmVhbC5wdXNoKCdoYXMtcmV2ZWFsLScgKyB2YWwpO1xcbiAgICAgIH0pOyAvLyBUcmlnZ2VycyBpbml0IGlzIGlkZW1wb3RlbnQsIGp1c3QgbmVlZCB0byBtYWtlIHN1cmUgaXQgaXMgaW5pdGlhbGl6ZWRcXG5cXG4gICAgICBfZm91bmRhdGlvbl91dGlsX3RyaWdnZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcIlRyaWdnZXJzXFxcIl0uaW5pdChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEpO1xcblxcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJNZWRpYVF1ZXJ5XFxcIl0uX2luaXQoKTtcXG5cXG4gICAgICB0aGlzLl9pbml0KCk7XFxuXFxuICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuXFxuICAgICAgX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJLZXlib2FyZFxcXCJdLnJlZ2lzdGVyKCdPZmZDYW52YXMnLCB7XFxuICAgICAgICAnRVNDQVBFJzogJ2Nsb3NlJ1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgb2ZmLWNhbnZhcyB3cmFwcGVyIGJ5IGFkZGluZyB0aGUgZXhpdCBvdmVybGF5IChpZiBuZWVkZWQpLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9pbml0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgIHZhciBpZCA9IHRoaXMuJGVsZW1lbnQuYXR0cignaWQnKTtcXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTsgLy8gRmluZCBvZmYtY2FudmFzIGNvbnRlbnQsIGVpdGhlciBieSBJRCAoaWYgc3BlY2lmaWVkKSwgYnkgc2libGluZ3Mgb3IgYnkgY2xvc2VzdCBzZWxlY3RvciAoZmFsbGJhY2spXFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50SWQpIHtcXG4gICAgICAgIHRoaXMuJGNvbnRlbnQgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoJyMnICsgdGhpcy5vcHRpb25zLmNvbnRlbnRJZCk7XFxuICAgICAgfSBlbHNlIGlmICh0aGlzLiRlbGVtZW50LnNpYmxpbmdzKCdbZGF0YS1vZmYtY2FudmFzLWNvbnRlbnRdJykubGVuZ3RoKSB7XFxuICAgICAgICB0aGlzLiRjb250ZW50ID0gdGhpcy4kZWxlbWVudC5zaWJsaW5ncygnW2RhdGEtb2ZmLWNhbnZhcy1jb250ZW50XScpLmZpcnN0KCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuJGNvbnRlbnQgPSB0aGlzLiRlbGVtZW50LmNsb3Nlc3QoJ1tkYXRhLW9mZi1jYW52YXMtY29udGVudF0nKS5maXJzdCgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5jb250ZW50SWQpIHtcXG4gICAgICAgIC8vIEFzc3VtZSB0aGF0IHRoZSBvZmYtY2FudmFzIGVsZW1lbnQgaXMgbmVzdGVkIGlmIGl0IGlzbid0IGEgc2libGluZyBvZiB0aGUgY29udGVudFxcbiAgICAgICAgdGhpcy5uZXN0ZWQgPSB0aGlzLiRlbGVtZW50LnNpYmxpbmdzKCdbZGF0YS1vZmYtY2FudmFzLWNvbnRlbnRdJykubGVuZ3RoID09PSAwO1xcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmNvbnRlbnRJZCAmJiB0aGlzLm9wdGlvbnMubmVzdGVkID09PSBudWxsKSB7XFxuICAgICAgICAvLyBXYXJuaW5nIGlmIHVzaW5nIGNvbnRlbnQgSUQgd2l0aG91dCBzZXR0aW5nIHRoZSBuZXN0ZWQgb3B0aW9uXFxuICAgICAgICAvLyBPbmNlIHRoZSBlbGVtZW50IGlzIG5lc3RlZCBpdCBpcyByZXF1aXJlZCB0byB3b3JrIHByb3Blcmx5IGluIHRoaXMgY2FzZVxcbiAgICAgICAgY29uc29sZS53YXJuKCdSZW1lbWJlciB0byB1c2UgdGhlIG5lc3RlZCBvcHRpb24gaWYgdXNpbmcgdGhlIGNvbnRlbnQgSUQgb3B0aW9uIScpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5uZXN0ZWQgPT09IHRydWUpIHtcXG4gICAgICAgIC8vIEZvcmNlIHRyYW5zaXRpb24gb3ZlcmxhcCBpZiBuZXN0ZWRcXG4gICAgICAgIHRoaXMub3B0aW9ucy50cmFuc2l0aW9uID0gJ292ZXJsYXAnOyAvLyBSZW1vdmUgYXBwcm9wcmlhdGUgY2xhc3NlcyBpZiBhbHJlYWR5IGFzc2lnbmVkIGluIG1hcmt1cFxcblxcbiAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcygnaXMtdHJhbnNpdGlvbi1wdXNoJyk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoXFxcImlzLXRyYW5zaXRpb24tXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLnRyYW5zaXRpb24sIFxcXCIgaXMtY2xvc2VkXFxcIikpOyAvLyBGaW5kIHRyaWdnZXJzIHRoYXQgYWZmZWN0IHRoaXMgZWxlbWVudCBhbmQgYWRkIGFyaWEtZXhwYW5kZWQgdG8gdGhlbVxcblxcbiAgICAgIHRoaXMuJHRyaWdnZXJzID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGRvY3VtZW50KS5maW5kKCdbZGF0YS1vcGVuPVxcXCInICsgaWQgKyAnXFxcIl0sIFtkYXRhLWNsb3NlPVxcXCInICsgaWQgKyAnXFxcIl0sIFtkYXRhLXRvZ2dsZT1cXFwiJyArIGlkICsgJ1xcXCJdJykuYXR0cignYXJpYS1leHBhbmRlZCcsICdmYWxzZScpLmF0dHIoJ2FyaWEtY29udHJvbHMnLCBpZCk7IC8vIEdldCBwb3NpdGlvbiBieSBjaGVja2luZyBmb3IgcmVsYXRlZCBDU1MgY2xhc3NcXG5cXG4gICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy4kZWxlbWVudC5pcygnLnBvc2l0aW9uLWxlZnQsIC5wb3NpdGlvbi10b3AsIC5wb3NpdGlvbi1yaWdodCwgLnBvc2l0aW9uLWJvdHRvbScpID8gdGhpcy4kZWxlbWVudC5hdHRyKCdjbGFzcycpLm1hdGNoKC9wb3NpdGlvblxcXFwtKGxlZnR8dG9wfHJpZ2h0fGJvdHRvbSkvKVsxXSA6IHRoaXMucG9zaXRpb247IC8vIEFkZCBhbiBvdmVybGF5IG92ZXIgdGhlIGNvbnRlbnQgaWYgbmVjZXNzYXJ5XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50T3ZlcmxheSA9PT0gdHJ1ZSkge1xcbiAgICAgICAgdmFyIG92ZXJsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcXG4gICAgICAgIHZhciBvdmVybGF5UG9zaXRpb24gPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcy4kZWxlbWVudCkuY3NzKFxcXCJwb3NpdGlvblxcXCIpID09PSAnZml4ZWQnID8gJ2lzLW92ZXJsYXktZml4ZWQnIDogJ2lzLW92ZXJsYXktYWJzb2x1dGUnO1xcbiAgICAgICAgb3ZlcmxheS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2pzLW9mZi1jYW52YXMtb3ZlcmxheSAnICsgb3ZlcmxheVBvc2l0aW9uKTtcXG4gICAgICAgIHRoaXMuJG92ZXJsYXkgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkob3ZlcmxheSk7XFxuXFxuICAgICAgICBpZiAob3ZlcmxheVBvc2l0aW9uID09PSAnaXMtb3ZlcmxheS1maXhlZCcpIHtcXG4gICAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMuJG92ZXJsYXkpLmluc2VydEFmdGVyKHRoaXMuJGVsZW1lbnQpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy4kY29udGVudC5hcHBlbmQodGhpcy4kb3ZlcmxheSk7XFxuICAgICAgICB9XFxuICAgICAgfSAvLyBHZXQgdGhlIHJldmVhbE9uIG9wdGlvbiBmcm9tIHRoZSBjbGFzcy5cXG5cXG5cXG4gICAgICB2YXIgcmV2ZWFsT25SZWdFeHAgPSBuZXcgUmVnRXhwKE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIlJlZ0V4cEVzY2FwZVxcXCJdKSh0aGlzLm9wdGlvbnMucmV2ZWFsQ2xhc3MpICsgJyhbXlxcXFxcXFxcc10rKScsICdnJyk7XFxuICAgICAgdmFyIHJldmVhbE9uQ2xhc3MgPSByZXZlYWxPblJlZ0V4cC5leGVjKHRoaXMuJGVsZW1lbnRbMF0uY2xhc3NOYW1lKTtcXG5cXG4gICAgICBpZiAocmV2ZWFsT25DbGFzcykge1xcbiAgICAgICAgdGhpcy5vcHRpb25zLmlzUmV2ZWFsZWQgPSB0cnVlO1xcbiAgICAgICAgdGhpcy5vcHRpb25zLnJldmVhbE9uID0gdGhpcy5vcHRpb25zLnJldmVhbE9uIHx8IHJldmVhbE9uQ2xhc3NbMV07XFxuICAgICAgfSAvLyBFbnN1cmUgdGhlIGByZXZlYWwtb24tKmAgY2xhc3MgaXMgc2V0LlxcblxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaXNSZXZlYWxlZCA9PT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMucmV2ZWFsT24pIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuZmlyc3QoKS5hZGRDbGFzcyhcXFwiXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLnJldmVhbENsYXNzKS5jb25jYXQodGhpcy5vcHRpb25zLnJldmVhbE9uKSk7XFxuXFxuICAgICAgICB0aGlzLl9zZXRNUUNoZWNrZXIoKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZSkge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5jc3MoJ3RyYW5zaXRpb24tZHVyYXRpb24nLCB0aGlzLm9wdGlvbnMudHJhbnNpdGlvblRpbWUpO1xcbiAgICAgIH0gLy8gSW5pdGFsbHkgcmVtb3ZlIGFsbCB0cmFuc2l0aW9uL3Bvc2l0aW9uIENTUyBjbGFzc2VzIGZyb20gb2ZmLWNhbnZhcyBjb250ZW50IGNvbnRhaW5lci5cXG5cXG5cXG4gICAgICB0aGlzLl9yZW1vdmVDb250ZW50Q2xhc3NlcygpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIHRvIHRoZSBvZmYtY2FudmFzIHdyYXBwZXIgYW5kIHRoZSBleGl0IG92ZXJsYXkuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2V2ZW50c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYudHJpZ2dlciAuemYub2ZmY2FudmFzJykub24oe1xcbiAgICAgICAgJ29wZW4uemYudHJpZ2dlcic6IHRoaXMub3Blbi5iaW5kKHRoaXMpLFxcbiAgICAgICAgJ2Nsb3NlLnpmLnRyaWdnZXInOiB0aGlzLmNsb3NlLmJpbmQodGhpcyksXFxuICAgICAgICAndG9nZ2xlLnpmLnRyaWdnZXInOiB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpLFxcbiAgICAgICAgJ2tleWRvd24uemYub2ZmY2FudmFzJzogdGhpcy5faGFuZGxlS2V5Ym9hcmQuYmluZCh0aGlzKVxcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrID09PSB0cnVlKSB7XFxuICAgICAgICB2YXIgJHRhcmdldCA9IHRoaXMub3B0aW9ucy5jb250ZW50T3ZlcmxheSA/IHRoaXMuJG92ZXJsYXkgOiB0aGlzLiRjb250ZW50O1xcbiAgICAgICAgJHRhcmdldC5vbih7XFxuICAgICAgICAgICdjbGljay56Zi5vZmZjYW52YXMnOiB0aGlzLmNsb3NlLmJpbmQodGhpcylcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQXBwbGllcyBldmVudCBsaXN0ZW5lciBmb3IgZWxlbWVudHMgdGhhdCB3aWxsIHJldmVhbCBhdCBjZXJ0YWluIGJyZWFrcG9pbnRzLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3NldE1RQ2hlY2tlclxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0TVFDaGVja2VyKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy5vbkxvYWRMaXN0ZW5lciA9IE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIm9uTG9hZFxcXCJdKShqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKF9mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJNZWRpYVF1ZXJ5XFxcIl0uYXRMZWFzdChfdGhpcy5vcHRpb25zLnJldmVhbE9uKSkge1xcbiAgICAgICAgICBfdGhpcy5yZXZlYWwodHJ1ZSk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub24oJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmIChfZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiTWVkaWFRdWVyeVxcXCJdLmF0TGVhc3QoX3RoaXMub3B0aW9ucy5yZXZlYWxPbikpIHtcXG4gICAgICAgICAgX3RoaXMucmV2ZWFsKHRydWUpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgX3RoaXMucmV2ZWFsKGZhbHNlKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogUmVtb3ZlcyB0aGUgQ1NTIHRyYW5zaXRpb24vcG9zaXRpb24gY2xhc3NlcyBvZiB0aGUgb2ZmLWNhbnZhcyBjb250ZW50IGNvbnRhaW5lci5cXG4gICAgICogUmVtb3ZpbmcgdGhlIGNsYXNzZXMgaXMgaW1wb3J0YW50IHdoZW4gYW5vdGhlciBvZmYtY2FudmFzIGdldHMgb3BlbmVkIHRoYXQgdXNlcyB0aGUgc2FtZSBjb250ZW50IGNvbnRhaW5lci5cXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBoYXNSZXZlYWwgLSB0cnVlIGlmIHJlbGF0ZWQgb2ZmLWNhbnZhcyBlbGVtZW50IGlzIHJldmVhbGVkLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3JlbW92ZUNvbnRlbnRDbGFzc2VzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVDb250ZW50Q2xhc3NlcyhoYXNSZXZlYWwpIHtcXG4gICAgICBpZiAodHlwZW9mIGhhc1JldmVhbCAhPT0gJ2Jvb2xlYW4nKSB7XFxuICAgICAgICB0aGlzLiRjb250ZW50LnJlbW92ZUNsYXNzKHRoaXMuY29udGVudENsYXNzZXMuYmFzZS5qb2luKCcgJykpO1xcbiAgICAgIH0gZWxzZSBpZiAoaGFzUmV2ZWFsID09PSBmYWxzZSkge1xcbiAgICAgICAgdGhpcy4kY29udGVudC5yZW1vdmVDbGFzcyhcXFwiaGFzLXJldmVhbC1cXFwiLmNvbmNhdCh0aGlzLnBvc2l0aW9uKSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBBZGRzIHRoZSBDU1MgdHJhbnNpdGlvbi9wb3NpdGlvbiBjbGFzc2VzIG9mIHRoZSBvZmYtY2FudmFzIGNvbnRlbnQgY29udGFpbmVyLCBiYXNlZCBvbiB0aGUgb3BlbmluZyBvZmYtY2FudmFzIGVsZW1lbnQuXFxuICAgICAqIEJlZm9yZWhhbmQgYW55IHRyYW5zaXRpb24vcG9zaXRpb24gY2xhc3MgZ2V0cyByZW1vdmVkLlxcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGhhc1JldmVhbCAtIHRydWUgaWYgcmVsYXRlZCBvZmYtY2FudmFzIGVsZW1lbnQgaXMgcmV2ZWFsZWQuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfYWRkQ29udGVudENsYXNzZXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZENvbnRlbnRDbGFzc2VzKGhhc1JldmVhbCkge1xcbiAgICAgIHRoaXMuX3JlbW92ZUNvbnRlbnRDbGFzc2VzKGhhc1JldmVhbCk7XFxuXFxuICAgICAgaWYgKHR5cGVvZiBoYXNSZXZlYWwgIT09ICdib29sZWFuJykge1xcbiAgICAgICAgdGhpcy4kY29udGVudC5hZGRDbGFzcyhcXFwiaGFzLXRyYW5zaXRpb24tXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLnRyYW5zaXRpb24sIFxcXCIgaGFzLXBvc2l0aW9uLVxcXCIpLmNvbmNhdCh0aGlzLnBvc2l0aW9uKSk7XFxuICAgICAgfSBlbHNlIGlmIChoYXNSZXZlYWwgPT09IHRydWUpIHtcXG4gICAgICAgIHRoaXMuJGNvbnRlbnQuYWRkQ2xhc3MoXFxcImhhcy1yZXZlYWwtXFxcIi5jb25jYXQodGhpcy5wb3NpdGlvbikpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSGFuZGxlcyB0aGUgcmV2ZWFsaW5nL2hpZGluZyB0aGUgb2ZmLWNhbnZhcyBhdCBicmVha3BvaW50cywgbm90IHRoZSBzYW1lIGFzIG9wZW4uXFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNSZXZlYWxlZCAtIHRydWUgaWYgZWxlbWVudCBzaG91bGQgYmUgcmV2ZWFsZWQuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicmV2ZWFsXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJldmVhbChpc1JldmVhbGVkKSB7XFxuICAgICAgaWYgKGlzUmV2ZWFsZWQpIHtcXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcXG4gICAgICAgIHRoaXMuaXNSZXZlYWxlZCA9IHRydWU7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtaGlkZGVuJywgJ2ZhbHNlJyk7XFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZignb3Blbi56Zi50cmlnZ2VyIHRvZ2dsZS56Zi50cmlnZ2VyJyk7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdpcy1jbG9zZWQnKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5pc1JldmVhbGVkID0gZmFsc2U7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdvcGVuLnpmLnRyaWdnZXIgdG9nZ2xlLnpmLnRyaWdnZXInKS5vbih7XFxuICAgICAgICAgICdvcGVuLnpmLnRyaWdnZXInOiB0aGlzLm9wZW4uYmluZCh0aGlzKSxcXG4gICAgICAgICAgJ3RvZ2dsZS56Zi50cmlnZ2VyJzogdGhpcy50b2dnbGUuYmluZCh0aGlzKVxcbiAgICAgICAgfSk7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKCdpcy1jbG9zZWQnKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fYWRkQ29udGVudENsYXNzZXMoaXNSZXZlYWxlZCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFN0b3BzIHNjcm9sbGluZyBvZiB0aGUgYm9keSB3aGVuIG9mZmNhbnZhcyBpcyBvcGVuIG9uIG1vYmlsZSBTYWZhcmkgYW5kIG90aGVyIHRyb3VibGVzb21lIGJyb3dzZXJzLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3N0b3BTY3JvbGxpbmdcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0b3BTY3JvbGxpbmcoZXZlbnQpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH0gLy8gVGFrZW4gYW5kIGFkYXB0ZWQgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE2ODg5NDQ3L3ByZXZlbnQtZnVsbC1wYWdlLXNjcm9sbGluZy1pb3NcXG4gICAgLy8gT25seSByZWFsbHkgd29ya3MgZm9yIHksIG5vdCBzdXJlIGhvdyB0byBleHRlbmQgdG8geCBvciBpZiB3ZSBuZWVkIHRvLlxcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfcmVjb3JkU2Nyb2xsYWJsZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVjb3JkU2Nyb2xsYWJsZShldmVudCkge1xcbiAgICAgIHZhciBlbGVtID0gdGhpczsgLy8gY2FsbGVkIGZyb20gZXZlbnQgaGFuZGxlciBjb250ZXh0IHdpdGggdGhpcyBhcyBlbGVtXFxuICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgaXMgc2Nyb2xsYWJsZSAoY29udGVudCBvdmVyZmxvd3MpLCB0aGVuLi4uXFxuXFxuICAgICAgaWYgKGVsZW0uc2Nyb2xsSGVpZ2h0ICE9PSBlbGVtLmNsaWVudEhlaWdodCkge1xcbiAgICAgICAgLy8gSWYgd2UncmUgYXQgdGhlIHRvcCwgc2Nyb2xsIGRvd24gb25lIHBpeGVsIHRvIGFsbG93IHNjcm9sbGluZyB1cFxcbiAgICAgICAgaWYgKGVsZW0uc2Nyb2xsVG9wID09PSAwKSB7XFxuICAgICAgICAgIGVsZW0uc2Nyb2xsVG9wID0gMTtcXG4gICAgICAgIH0gLy8gSWYgd2UncmUgYXQgdGhlIGJvdHRvbSwgc2Nyb2xsIHVwIG9uZSBwaXhlbCB0byBhbGxvdyBzY3JvbGxpbmcgZG93blxcblxcblxcbiAgICAgICAgaWYgKGVsZW0uc2Nyb2xsVG9wID09PSBlbGVtLnNjcm9sbEhlaWdodCAtIGVsZW0uY2xpZW50SGVpZ2h0KSB7XFxuICAgICAgICAgIGVsZW0uc2Nyb2xsVG9wID0gZWxlbS5zY3JvbGxIZWlnaHQgLSBlbGVtLmNsaWVudEhlaWdodCAtIDE7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGVsZW0uYWxsb3dVcCA9IGVsZW0uc2Nyb2xsVG9wID4gMDtcXG4gICAgICBlbGVtLmFsbG93RG93biA9IGVsZW0uc2Nyb2xsVG9wIDwgZWxlbS5zY3JvbGxIZWlnaHQgLSBlbGVtLmNsaWVudEhlaWdodDtcXG4gICAgICBlbGVtLmxhc3RZID0gZXZlbnQub3JpZ2luYWxFdmVudC5wYWdlWTtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfc3RvcFNjcm9sbFByb3BhZ2F0aW9uXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdG9wU2Nyb2xsUHJvcGFnYXRpb24oZXZlbnQpIHtcXG4gICAgICB2YXIgZWxlbSA9IHRoaXM7IC8vIGNhbGxlZCBmcm9tIGV2ZW50IGhhbmRsZXIgY29udGV4dCB3aXRoIHRoaXMgYXMgZWxlbVxcblxcbiAgICAgIHZhciB1cCA9IGV2ZW50LnBhZ2VZIDwgZWxlbS5sYXN0WTtcXG4gICAgICB2YXIgZG93biA9ICF1cDtcXG4gICAgICBlbGVtLmxhc3RZID0gZXZlbnQucGFnZVk7XFxuXFxuICAgICAgaWYgKHVwICYmIGVsZW0uYWxsb3dVcCB8fCBkb3duICYmIGVsZW0uYWxsb3dEb3duKSB7XFxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIE9wZW5zIHRoZSBvZmYtY2FudmFzIG1lbnUuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBFdmVudCBvYmplY3QgcGFzc2VkIGZyb20gbGlzdGVuZXIuXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSB0cmlnZ2VyIC0gZWxlbWVudCB0aGF0IHRyaWdnZXJlZCB0aGUgb2ZmLWNhbnZhcyB0byBvcGVuLlxcbiAgICAgKiBAZmlyZXMgT2ZmY2FudmFzI29wZW5lZFxcbiAgICAgKiBAdG9kbyBhbHNvIHRyaWdnZXIgJ29wZW4nIGV2ZW50P1xcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwib3BlblxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuKGV2ZW50LCB0cmlnZ2VyKSB7XFxuICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2lzLW9wZW4nKSB8fCB0aGlzLmlzUmV2ZWFsZWQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICBpZiAodHJpZ2dlcikge1xcbiAgICAgICAgdGhpcy4kbGFzdFRyaWdnZXIgPSB0cmlnZ2VyO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmZvcmNlVG8gPT09ICd0b3AnKSB7XFxuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XFxuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZm9yY2VUbyA9PT0gJ2JvdHRvbScpIHtcXG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhbnNpdGlvblRpbWUgJiYgdGhpcy5vcHRpb25zLnRyYW5zaXRpb24gIT09ICdvdmVybGFwJykge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5zaWJsaW5ncygnW2RhdGEtb2ZmLWNhbnZhcy1jb250ZW50XScpLmNzcygndHJhbnNpdGlvbi1kdXJhdGlvbicsIHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuc2libGluZ3MoJ1tkYXRhLW9mZi1jYW52YXMtY29udGVudF0nKS5jc3MoJ3RyYW5zaXRpb24tZHVyYXRpb24nLCAnJyk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoJ2lzLW9wZW4nKS5yZW1vdmVDbGFzcygnaXMtY2xvc2VkJyk7XFxuICAgICAgdGhpcy4kdHJpZ2dlcnMuYXR0cignYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XFxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xcbiAgICAgIHRoaXMuJGNvbnRlbnQuYWRkQ2xhc3MoJ2lzLW9wZW4tJyArIHRoaXMucG9zaXRpb24pOyAvLyBJZiBgY29udGVudFNjcm9sbGAgaXMgc2V0IHRvIGZhbHNlLCBhZGQgY2xhc3MgYW5kIGRpc2FibGUgc2Nyb2xsaW5nIG9uIHRvdWNoIGRldmljZXMuXFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50U2Nyb2xsID09PSBmYWxzZSkge1xcbiAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCdib2R5JykuYWRkQ2xhc3MoJ2lzLW9mZi1jYW52YXMtb3BlbicpLm9uKCd0b3VjaG1vdmUnLCB0aGlzLl9zdG9wU2Nyb2xsaW5nKTtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ3RvdWNoc3RhcnQnLCB0aGlzLl9yZWNvcmRTY3JvbGxhYmxlKTtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ3RvdWNobW92ZScsIHRoaXMuX3N0b3BTY3JvbGxQcm9wYWdhdGlvbik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGVudE92ZXJsYXkgPT09IHRydWUpIHtcXG4gICAgICAgIHRoaXMuJG92ZXJsYXkuYWRkQ2xhc3MoJ2lzLXZpc2libGUnKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmNvbnRlbnRPdmVybGF5ID09PSB0cnVlKSB7XFxuICAgICAgICB0aGlzLiRvdmVybGF5LmFkZENsYXNzKCdpcy1jbG9zYWJsZScpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9Gb2N1cyA9PT0gdHJ1ZSkge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbmUoT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwidHJhbnNpdGlvbmVuZFxcXCJdKSh0aGlzLiRlbGVtZW50KSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBpZiAoIV90aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpcy1vcGVuJykpIHtcXG4gICAgICAgICAgICByZXR1cm47IC8vIGV4aXQgaWYgcHJlbWF0dXJlbHkgY2xvc2VkXFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdmFyIGNhbnZhc0ZvY3VzID0gX3RoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtYXV0b2ZvY3VzXScpO1xcblxcbiAgICAgICAgICBpZiAoY2FudmFzRm9jdXMubGVuZ3RoKSB7XFxuICAgICAgICAgICAgY2FudmFzRm9jdXMuZXEoMCkuZm9jdXMoKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBfdGhpcy4kZWxlbWVudC5maW5kKCdhLCBidXR0b24nKS5lcSgwKS5mb2N1cygpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFwRm9jdXMgPT09IHRydWUpIHtcXG4gICAgICAgIHRoaXMuJGNvbnRlbnQuYXR0cigndGFiaW5kZXgnLCAnLTEnKTtcXG4gICAgICAgIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiS2V5Ym9hcmRcXFwiXS50cmFwRm9jdXModGhpcy4kZWxlbWVudCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2FkZENvbnRlbnRDbGFzc2VzKCk7XFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgb2ZmLWNhbnZhcyBtZW51IG9wZW5zLlxcbiAgICAgICAqIEBldmVudCBPZmZjYW52YXMjb3BlbmVkXFxuICAgICAgICovXFxuXFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdvcGVuZWQuemYub2ZmY2FudmFzJyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENsb3NlcyB0aGUgb2ZmLWNhbnZhcyBtZW51LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBvcHRpb25hbCBjYiB0byBmaXJlIGFmdGVyIGNsb3N1cmUuXFxuICAgICAqIEBmaXJlcyBPZmZjYW52YXMjY2xvc2VkXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJjbG9zZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZShjYikge1xcbiAgICAgIGlmICghdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaXMtb3BlbicpIHx8IHRoaXMuaXNSZXZlYWxlZCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2lzLW9wZW4nKTtcXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKVxcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG9mZi1jYW52YXMgbWVudSBvcGVucy5cXG4gICAgICAgKiBAZXZlbnQgT2ZmY2FudmFzI2Nsb3NlZFxcbiAgICAgICAqL1xcbiAgICAgIC50cmlnZ2VyKCdjbG9zZWQuemYub2ZmY2FudmFzJyk7XFxuICAgICAgdGhpcy4kY29udGVudC5yZW1vdmVDbGFzcygnaXMtb3Blbi1sZWZ0IGlzLW9wZW4tdG9wIGlzLW9wZW4tcmlnaHQgaXMtb3Blbi1ib3R0b20nKTsgLy8gSWYgYGNvbnRlbnRTY3JvbGxgIGlzIHNldCB0byBmYWxzZSwgcmVtb3ZlIGNsYXNzIGFuZCByZS1lbmFibGUgc2Nyb2xsaW5nIG9uIHRvdWNoIGRldmljZXMuXFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50U2Nyb2xsID09PSBmYWxzZSkge1xcbiAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCdib2R5JykucmVtb3ZlQ2xhc3MoJ2lzLW9mZi1jYW52YXMtb3BlbicpLm9mZigndG91Y2htb3ZlJywgdGhpcy5fc3RvcFNjcm9sbGluZyk7XFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZigndG91Y2hzdGFydCcsIHRoaXMuX3JlY29yZFNjcm9sbGFibGUpO1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ3RvdWNobW92ZScsIHRoaXMuX3N0b3BTY3JvbGxQcm9wYWdhdGlvbik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGVudE92ZXJsYXkgPT09IHRydWUpIHtcXG4gICAgICAgIHRoaXMuJG92ZXJsYXkucmVtb3ZlQ2xhc3MoJ2lzLXZpc2libGUnKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmNvbnRlbnRPdmVybGF5ID09PSB0cnVlKSB7XFxuICAgICAgICB0aGlzLiRvdmVybGF5LnJlbW92ZUNsYXNzKCdpcy1jbG9zYWJsZScpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLiR0cmlnZ2Vycy5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFwRm9jdXMgPT09IHRydWUpIHtcXG4gICAgICAgIHRoaXMuJGNvbnRlbnQucmVtb3ZlQXR0cigndGFiaW5kZXgnKTtcXG4gICAgICAgIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiS2V5Ym9hcmRcXFwiXS5yZWxlYXNlRm9jdXModGhpcy4kZWxlbWVudCk7XFxuICAgICAgfSAvLyBMaXN0ZW4gdG8gdHJhbnNpdGlvbkVuZCBhbmQgYWRkIGNsYXNzIHdoZW4gZG9uZS5cXG5cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50Lm9uZShPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJ0cmFuc2l0aW9uZW5kXFxcIl0pKHRoaXMuJGVsZW1lbnQpLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgX3RoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoJ2lzLWNsb3NlZCcpO1xcblxcbiAgICAgICAgX3RoaXMuX3JlbW92ZUNvbnRlbnRDbGFzc2VzKCk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFRvZ2dsZXMgdGhlIG9mZi1jYW52YXMgbWVudSBvcGVuIG9yIGNsb3NlZC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIEV2ZW50IG9iamVjdCBwYXNzZWQgZnJvbSBsaXN0ZW5lci5cXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IHRyaWdnZXIgLSBlbGVtZW50IHRoYXQgdHJpZ2dlcmVkIHRoZSBvZmYtY2FudmFzIHRvIG9wZW4uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ0b2dnbGVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlKGV2ZW50LCB0cmlnZ2VyKSB7XFxuICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2lzLW9wZW4nKSkge1xcbiAgICAgICAgdGhpcy5jbG9zZShldmVudCwgdHJpZ2dlcik7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMub3BlbihldmVudCwgdHJpZ2dlcik7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBIYW5kbGVzIGtleWJvYXJkIGlucHV0IHdoZW4gZGV0ZWN0ZWQuIFdoZW4gdGhlIGVzY2FwZSBrZXkgaXMgcHJlc3NlZCwgdGhlIG9mZi1jYW52YXMgbWVudSBjbG9zZXMsIGFuZCBmb2N1cyBpcyByZXN0b3JlZCB0byB0aGUgZWxlbWVudCB0aGF0IG9wZW5lZCB0aGUgbWVudS5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfaGFuZGxlS2V5Ym9hcmRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUtleWJvYXJkKGUpIHtcXG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcXG5cXG4gICAgICBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIktleWJvYXJkXFxcIl0uaGFuZGxlS2V5KGUsICdPZmZDYW52YXMnLCB7XFxuICAgICAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XFxuICAgICAgICAgIF90aGlzMy5jbG9zZSgpO1xcblxcbiAgICAgICAgICBfdGhpczMuJGxhc3RUcmlnZ2VyLmZvY3VzKCk7XFxuXFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uIGhhbmRsZWQoKSB7XFxuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XFxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogRGVzdHJveXMgdGhlIG9mZmNhbnZhcyBwbHVnaW4uXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2Rlc3Ryb3lcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgdGhpcy5jbG9zZSgpO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYudHJpZ2dlciAuemYub2ZmY2FudmFzJyk7XFxuICAgICAgdGhpcy4kb3ZlcmxheS5vZmYoJy56Zi5vZmZjYW52YXMnKTtcXG4gICAgICBpZiAodGhpcy5vbkxvYWRMaXN0ZW5lcikganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub2ZmKHRoaXMub25Mb2FkTGlzdGVuZXIpO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gT2ZmQ2FudmFzO1xcbn0oX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiUGx1Z2luXFxcIl0pO1xcblxcbk9mZkNhbnZhcy5kZWZhdWx0cyA9IHtcXG4gIC8qKlxcbiAgICogQWxsb3cgdGhlIHVzZXIgdG8gY2xpY2sgb3V0c2lkZSBvZiB0aGUgbWVudSB0byBjbG9zZSBpdC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgdHJ1ZVxcbiAgICovXFxuICBjbG9zZU9uQ2xpY2s6IHRydWUsXFxuXFxuICAvKipcXG4gICAqIEFkZHMgYW4gb3ZlcmxheSBvbiB0b3Agb2YgYFtkYXRhLW9mZi1jYW52YXMtY29udGVudF1gLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCB0cnVlXFxuICAgKi9cXG4gIGNvbnRlbnRPdmVybGF5OiB0cnVlLFxcblxcbiAgLyoqXFxuICAgKiBUYXJnZXQgYW4gb2ZmLWNhbnZhcyBjb250ZW50IGNvbnRhaW5lciBieSBJRCB0aGF0IG1heSBiZSBwbGFjZWQgYW55d2hlcmUuIElmIG51bGwgdGhlIGNsb3Nlc3QgY29udGVudCBjb250YWluZXIgd2lsbCBiZSB0YWtlbi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHs/c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgbnVsbFxcbiAgICovXFxuICBjb250ZW50SWQ6IG51bGwsXFxuXFxuICAvKipcXG4gICAqIERlZmluZSB0aGUgb2ZmLWNhbnZhcyBlbGVtZW50IGlzIG5lc3RlZCBpbiBhbiBvZmYtY2FudmFzIGNvbnRlbnQuIFRoaXMgaXMgcmVxdWlyZWQgd2hlbiB1c2luZyB0aGUgY29udGVudElkIG9wdGlvbiBmb3IgYSBuZXN0ZWQgZWxlbWVudC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgbnVsbFxcbiAgICovXFxuICBuZXN0ZWQ6IG51bGwsXFxuXFxuICAvKipcXG4gICAqIEVuYWJsZS9kaXNhYmxlIHNjcm9sbGluZyBvZiB0aGUgbWFpbiBjb250ZW50IHdoZW4gYW4gb2ZmIGNhbnZhcyBwYW5lbCBpcyBvcGVuLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCB0cnVlXFxuICAgKi9cXG4gIGNvbnRlbnRTY3JvbGw6IHRydWUsXFxuXFxuICAvKipcXG4gICAqIEFtb3VudCBvZiB0aW1lIGluIG1zIHRoZSBvcGVuIGFuZCBjbG9zZSB0cmFuc2l0aW9uIHJlcXVpcmVzLiBJZiBub25lIHNlbGVjdGVkLCBwdWxscyBmcm9tIGJvZHkgc3R5bGUuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgbnVsbFxcbiAgICovXFxuICB0cmFuc2l0aW9uVGltZTogbnVsbCxcXG5cXG4gIC8qKlxcbiAgICogVHlwZSBvZiB0cmFuc2l0aW9uIGZvciB0aGUgb2ZmY2FudmFzIG1lbnUuIE9wdGlvbnMgYXJlICdwdXNoJywgJ2RldGFjaGVkJyBvciAnc2xpZGUnLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0IHB1c2hcXG4gICAqL1xcbiAgdHJhbnNpdGlvbjogJ3B1c2gnLFxcblxcbiAgLyoqXFxuICAgKiBGb3JjZSB0aGUgcGFnZSB0byBzY3JvbGwgdG8gdG9wIG9yIGJvdHRvbSBvbiBvcGVuLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUgez9zdHJpbmd9XFxuICAgKiBAZGVmYXVsdCBudWxsXFxuICAgKi9cXG4gIGZvcmNlVG86IG51bGwsXFxuXFxuICAvKipcXG4gICAqIEFsbG93IHRoZSBvZmZjYW52YXMgdG8gcmVtYWluIG9wZW4gZm9yIGNlcnRhaW4gYnJlYWtwb2ludHMuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGlzUmV2ZWFsZWQ6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBCcmVha3BvaW50IGF0IHdoaWNoIHRvIHJldmVhbC4gSlMgd2lsbCB1c2UgYSBSZWdFeHAgdG8gdGFyZ2V0IHN0YW5kYXJkIGNsYXNzZXMsIGlmIGNoYW5naW5nIGNsYXNzbmFtZXMsIHBhc3MgeW91ciBjbGFzcyB3aXRoIHRoZSBgcmV2ZWFsQ2xhc3NgIG9wdGlvbi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHs/c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgbnVsbFxcbiAgICovXFxuICByZXZlYWxPbjogbnVsbCxcXG5cXG4gIC8qKlxcbiAgICogRm9yY2UgZm9jdXMgdG8gdGhlIG9mZmNhbnZhcyBvbiBvcGVuLiBJZiB0cnVlLCB3aWxsIGZvY3VzIHRoZSBvcGVuaW5nIHRyaWdnZXIgb24gY2xvc2UuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IHRydWVcXG4gICAqL1xcbiAgYXV0b0ZvY3VzOiB0cnVlLFxcblxcbiAgLyoqXFxuICAgKiBDbGFzcyB1c2VkIHRvIGZvcmNlIGFuIG9mZmNhbnZhcyB0byByZW1haW4gb3Blbi4gRm91bmRhdGlvbiBkZWZhdWx0cyBmb3IgdGhpcyBhcmUgYHJldmVhbC1mb3ItbGFyZ2VgICYgYHJldmVhbC1mb3ItbWVkaXVtYC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCByZXZlYWwtZm9yLVxcbiAgICogQHRvZG8gaW1wcm92ZSB0aGUgcmVnZXggdGVzdGluZyBmb3IgdGhpcy5cXG4gICAqL1xcbiAgcmV2ZWFsQ2xhc3M6ICdyZXZlYWwtZm9yLScsXFxuXFxuICAvKipcXG4gICAqIFRyaWdnZXJzIG9wdGlvbmFsIGZvY3VzIHRyYXBwaW5nIHdoZW4gb3BlbmluZyBhbiBvZmZjYW52YXMuIFNldHMgdGFiaW5kZXggb2YgW2RhdGEtb2ZmLWNhbnZhcy1jb250ZW50XSB0byAtMSBmb3IgYWNjZXNzaWJpbGl0eSBwdXJwb3Nlcy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgdHJhcEZvY3VzOiBmYWxzZVxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi5vZmZjYW52YXMuanM/XCIpfSxcIi4vanMvZm91bmRhdGlvbi5vcmJpdC5qc1wiOmZ1bmN0aW9uKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiT3JiaXRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIE9yYml0OyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBqcXVlcnkgKi8gXFxcImpxdWVyeVxcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi51dGlsLmtleWJvYXJkICovIFxcXCIuL2pzL2ZvdW5kYXRpb24udXRpbC5rZXlib2FyZC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX21vdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwubW90aW9uICovIFxcXCIuL2pzL2ZvdW5kYXRpb24udXRpbC5tb3Rpb24uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF90aW1lcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwudGltZXIgKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLnRpbWVyLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3V0aWxfaW1hZ2VMb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi51dGlsLmltYWdlTG9hZGVyICovIFxcXCIuL2pzL2ZvdW5kYXRpb24udXRpbC5pbWFnZUxvYWRlci5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uY29yZS51dGlscyAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUudXRpbHMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnBsdWdpbiAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUucGx1Z2luLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3V0aWxfdG91Y2hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi51dGlsLnRvdWNoICovIFxcXCIuL2pzL2ZvdW5kYXRpb24udXRpbC50b3VjaC5qc1xcXCIpO1xcblxcblxcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXFxcImZ1bmN0aW9uXFxcIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cXG5cXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXFxcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFxcXCIpOyB9IHJldHVybiBzZWxmOyB9XFxuXFxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblxcXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cXG5cXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbi8qKlxcbiAqIE9yYml0IG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24ub3JiaXRcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tb3Rpb25cXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRpbWVyXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5pbWFnZUxvYWRlclxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudG91Y2hcXG4gKi9cXG5cXG52YXIgT3JiaXQgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoX1BsdWdpbikge1xcbiAgX2luaGVyaXRzKE9yYml0LCBfUGx1Z2luKTtcXG5cXG4gIGZ1bmN0aW9uIE9yYml0KCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT3JiaXQpO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKE9yYml0KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhPcmJpdCwgW3tcXG4gICAga2V5OiBcXFwiX3NldHVwXFxcIixcXG5cXG4gICAgLyoqXFxuICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhbiBvcmJpdCBjYXJvdXNlbC5cXG4gICAgKiBAY2xhc3NcXG4gICAgKiBAbmFtZSBPcmJpdFxcbiAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYW4gT3JiaXQgQ2Fyb3VzZWwuXFxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxcbiAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZXh0ZW5kKHt9LCBPcmJpdC5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ09yYml0JzsgLy8gaWU5IGJhY2sgY29tcGF0XFxuXFxuICAgICAgX2ZvdW5kYXRpb25fdXRpbF90b3VjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1xcXCJUb3VjaFxcXCJdLmluaXQoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hKTsgLy8gVG91Y2ggaW5pdCBpcyBpZGVtcG90ZW50LCB3ZSBqdXN0IG5lZWQgdG8gbWFrZSBzdXJlIGl0J3MgaW5pdGlhbGllZC5cXG5cXG4gICAgICB0aGlzLl9pbml0KCk7XFxuXFxuICAgICAgX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJLZXlib2FyZFxcXCJdLnJlZ2lzdGVyKCdPcmJpdCcsIHtcXG4gICAgICAgICdsdHInOiB7XFxuICAgICAgICAgICdBUlJPV19SSUdIVCc6ICduZXh0JyxcXG4gICAgICAgICAgJ0FSUk9XX0xFRlQnOiAncHJldmlvdXMnXFxuICAgICAgICB9LFxcbiAgICAgICAgJ3J0bCc6IHtcXG4gICAgICAgICAgJ0FSUk9XX0xFRlQnOiAnbmV4dCcsXFxuICAgICAgICAgICdBUlJPV19SSUdIVCc6ICdwcmV2aW91cydcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgKiBJbml0aWFsaXplcyB0aGUgcGx1Z2luIGJ5IGNyZWF0aW5nIGpRdWVyeSBjb2xsZWN0aW9ucywgc2V0dGluZyBhdHRyaWJ1dGVzLCBhbmQgc3RhcnRpbmcgdGhlIGFuaW1hdGlvbi5cXG4gICAgKiBAZnVuY3Rpb25cXG4gICAgKiBAcHJpdmF0ZVxcbiAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfaW5pdFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcXG4gICAgICAvLyBAVE9ETzogY29uc2lkZXIgZGlzY3Vzc2lvbiBvbiBQUiAjOTI3OCBhYm91dCBET00gcG9sbHV0aW9uIGJ5IGNoYW5nZVNsaWRlXFxuICAgICAgdGhpcy5fcmVzZXQoKTtcXG5cXG4gICAgICB0aGlzLiR3cmFwcGVyID0gdGhpcy4kZWxlbWVudC5maW5kKFxcXCIuXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLmNvbnRhaW5lckNsYXNzKSk7XFxuICAgICAgdGhpcy4kc2xpZGVzID0gdGhpcy4kZWxlbWVudC5maW5kKFxcXCIuXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpKTtcXG4gICAgICB2YXIgJGltYWdlcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnaW1nJyksXFxuICAgICAgICAgIGluaXRBY3RpdmUgPSB0aGlzLiRzbGlkZXMuZmlsdGVyKCcuaXMtYWN0aXZlJyksXFxuICAgICAgICAgIGlkID0gdGhpcy4kZWxlbWVudFswXS5pZCB8fCBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJHZXRZb0RpZ2l0c1xcXCJdKSg2LCAnb3JiaXQnKTtcXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xcbiAgICAgICAgJ2RhdGEtcmVzaXplJzogaWQsXFxuICAgICAgICAnaWQnOiBpZFxcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmICghaW5pdEFjdGl2ZS5sZW5ndGgpIHtcXG4gICAgICAgIHRoaXMuJHNsaWRlcy5lcSgwKS5hZGRDbGFzcygnaXMtYWN0aXZlJyk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnVzZU1VSSkge1xcbiAgICAgICAgdGhpcy4kc2xpZGVzLmFkZENsYXNzKCduby1tb3Rpb251aScpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoJGltYWdlcy5sZW5ndGgpIHtcXG4gICAgICAgIE9iamVjdChfZm91bmRhdGlvbl91dGlsX2ltYWdlTG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcIm9uSW1hZ2VzTG9hZGVkXFxcIl0pKCRpbWFnZXMsIHRoaXMuX3ByZXBhcmVGb3JPcmJpdC5iaW5kKHRoaXMpKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5fcHJlcGFyZUZvck9yYml0KCk7IC8vaGVoZVxcblxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmJ1bGxldHMpIHtcXG4gICAgICAgIHRoaXMuX2xvYWRCdWxsZXRzKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2V2ZW50cygpO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1BsYXkgJiYgdGhpcy4kc2xpZGVzLmxlbmd0aCA+IDEpIHtcXG4gICAgICAgIHRoaXMuZ2VvU3luYygpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFjY2Vzc2libGUpIHtcXG4gICAgICAgIC8vIGFsbG93IHdyYXBwZXIgdG8gYmUgZm9jdXNhYmxlIHRvIGVuYWJsZSBhcnJvdyBuYXZpZ2F0aW9uXFxuICAgICAgICB0aGlzLiR3cmFwcGVyLmF0dHIoJ3RhYmluZGV4JywgMCk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAqIENyZWF0ZXMgYSBqUXVlcnkgY29sbGVjdGlvbiBvZiBidWxsZXRzLCBpZiB0aGV5IGFyZSBiZWluZyB1c2VkLlxcbiAgICAqIEBmdW5jdGlvblxcbiAgICAqIEBwcml2YXRlXFxuICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9sb2FkQnVsbGV0c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9hZEJ1bGxldHMoKSB7XFxuICAgICAgdGhpcy4kYnVsbGV0cyA9IHRoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIuY29uY2F0KHRoaXMub3B0aW9ucy5ib3hPZkJ1bGxldHMpKS5maW5kKCdidXR0b24nKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgKiBTZXRzIGEgYHRpbWVyYCBvYmplY3Qgb24gdGhlIG9yYml0LCBhbmQgc3RhcnRzIHRoZSBjb3VudGVyIGZvciB0aGUgbmV4dCBzbGlkZS5cXG4gICAgKiBAZnVuY3Rpb25cXG4gICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZ2VvU3luY1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZW9TeW5jKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy50aW1lciA9IG5ldyBfZm91bmRhdGlvbl91dGlsX3RpbWVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcIlRpbWVyXFxcIl0odGhpcy4kZWxlbWVudCwge1xcbiAgICAgICAgZHVyYXRpb246IHRoaXMub3B0aW9ucy50aW1lckRlbGF5LFxcbiAgICAgICAgaW5maW5pdGU6IGZhbHNlXFxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUodHJ1ZSk7XFxuICAgICAgfSk7XFxuICAgICAgdGhpcy50aW1lci5zdGFydCgpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAqIFNldHMgd3JhcHBlciBhbmQgc2xpZGUgaGVpZ2h0cyBmb3IgdGhlIG9yYml0LlxcbiAgICAqIEBmdW5jdGlvblxcbiAgICAqIEBwcml2YXRlXFxuICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9wcmVwYXJlRm9yT3JiaXRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ByZXBhcmVGb3JPcmJpdCgpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgIHRoaXMuX3NldFdyYXBwZXJIZWlnaHQoKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgKiBDYWx1bGF0ZXMgdGhlIGhlaWdodCBvZiBlYWNoIHNsaWRlIGluIHRoZSBjb2xsZWN0aW9uLCBhbmQgdXNlcyB0aGUgdGFsbGVzdCBvbmUgZm9yIHRoZSB3cmFwcGVyIGhlaWdodC5cXG4gICAgKiBAZnVuY3Rpb25cXG4gICAgKiBAcHJpdmF0ZVxcbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gYSBjYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIHdoZW4gY29tcGxldGUuXFxuICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9zZXRXcmFwcGVySGVpZ2h0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRXcmFwcGVySGVpZ2h0KGNiKSB7XFxuICAgICAgLy9yZXdyaXRlIHRoaXMgdG8gYGZvcmAgbG9vcFxcbiAgICAgIHZhciBtYXggPSAwLFxcbiAgICAgICAgICB0ZW1wLFxcbiAgICAgICAgICBjb3VudGVyID0gMCxcXG4gICAgICAgICAgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgIHRoaXMuJHNsaWRlcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHRlbXAgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcXG4gICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS5hdHRyKCdkYXRhLXNsaWRlJywgY291bnRlcik7IC8vIGhpZGUgYWxsIHNsaWRlcyBidXQgdGhlIGFjdGl2ZSBvbmVcXG5cXG4gICAgICAgIGlmICghL211aS9nLnRlc3QoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpWzBdLmNsYXNzTmFtZSkgJiYgX3RoaXMuJHNsaWRlcy5maWx0ZXIoJy5pcy1hY3RpdmUnKVswXSAhPT0gX3RoaXMuJHNsaWRlcy5lcShjb3VudGVyKVswXSkge1xcbiAgICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykuY3NzKHtcXG4gICAgICAgICAgICAnZGlzcGxheSc6ICdub25lJ1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIG1heCA9IHRlbXAgPiBtYXggPyB0ZW1wIDogbWF4O1xcbiAgICAgICAgY291bnRlcisrO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmIChjb3VudGVyID09PSB0aGlzLiRzbGlkZXMubGVuZ3RoKSB7XFxuICAgICAgICB0aGlzLiR3cmFwcGVyLmNzcyh7XFxuICAgICAgICAgICdoZWlnaHQnOiBtYXhcXG4gICAgICAgIH0pOyAvL29ubHkgY2hhbmdlIHRoZSB3cmFwcGVyIGhlaWdodCBwcm9wZXJ0eSBvbmNlLlxcblxcbiAgICAgICAgaWYgKGNiKSB7XFxuICAgICAgICAgIGNiKG1heCk7XFxuICAgICAgICB9IC8vZmlyZSBjYWxsYmFjayB3aXRoIG1heCBoZWlnaHQgZGltZW5zaW9uLlxcblxcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgKiBTZXRzIHRoZSBtYXgtaGVpZ2h0IG9mIGVhY2ggc2xpZGUuXFxuICAgICogQGZ1bmN0aW9uXFxuICAgICogQHByaXZhdGVcXG4gICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3NldFNsaWRlSGVpZ2h0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRTbGlkZUhlaWdodChoZWlnaHQpIHtcXG4gICAgICB0aGlzLiRzbGlkZXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykuY3NzKCdtYXgtaGVpZ2h0JywgaGVpZ2h0KTtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byBiYXNpY2FsbHkgZXZlcnl0aGluZyB3aXRoaW4gdGhlIGVsZW1lbnQuXFxuICAgICogQGZ1bmN0aW9uXFxuICAgICogQHByaXZhdGVcXG4gICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2V2ZW50c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7IC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxuICAgICAgLy8qKk5vdyB1c2luZyBjdXN0b20gZXZlbnQgLSB0aGFua3MgdG86KipcXG4gICAgICAvLyoqICAgICAgWW9oYWkgQXJhcmF0IG9mIFRvcm9udG8gICAgICAqKlxcbiAgICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxuICAgICAgLy9cXG5cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZignLnJlc2l6ZW1lLnpmLnRyaWdnZXInKS5vbih7XFxuICAgICAgICAncmVzaXplbWUuemYudHJpZ2dlcic6IHRoaXMuX3ByZXBhcmVGb3JPcmJpdC5iaW5kKHRoaXMpXFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKHRoaXMuJHNsaWRlcy5sZW5ndGggPiAxKSB7XFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN3aXBlKSB7XFxuICAgICAgICAgIHRoaXMuJHNsaWRlcy5vZmYoJ3N3aXBlbGVmdC56Zi5vcmJpdCBzd2lwZXJpZ2h0LnpmLm9yYml0Jykub24oJ3N3aXBlbGVmdC56Zi5vcmJpdCcsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcbiAgICAgICAgICAgIF90aGlzLmNoYW5nZVNsaWRlKHRydWUpO1xcbiAgICAgICAgICB9KS5vbignc3dpcGVyaWdodC56Zi5vcmJpdCcsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcbiAgICAgICAgICAgIF90aGlzLmNoYW5nZVNsaWRlKGZhbHNlKTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9IC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxuXFxuXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9QbGF5KSB7XFxuICAgICAgICAgIHRoaXMuJHNsaWRlcy5vbignY2xpY2suemYub3JiaXQnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgX3RoaXMuJGVsZW1lbnQuZGF0YSgnY2xpY2tlZE9uJywgX3RoaXMuJGVsZW1lbnQuZGF0YSgnY2xpY2tlZE9uJykgPyBmYWxzZSA6IHRydWUpO1xcblxcbiAgICAgICAgICAgIF90aGlzLnRpbWVyW190aGlzLiRlbGVtZW50LmRhdGEoJ2NsaWNrZWRPbicpID8gJ3BhdXNlJyA6ICdzdGFydCddKCk7XFxuICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBhdXNlT25Ib3Zlcikge1xcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ21vdXNlZW50ZXIuemYub3JiaXQnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICBfdGhpcy50aW1lci5wYXVzZSgpO1xcbiAgICAgICAgICAgIH0pLm9uKCdtb3VzZWxlYXZlLnpmLm9yYml0JywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgaWYgKCFfdGhpcy4kZWxlbWVudC5kYXRhKCdjbGlja2VkT24nKSkge1xcbiAgICAgICAgICAgICAgICBfdGhpcy50aW1lci5zdGFydCgpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5hdkJ1dHRvbnMpIHtcXG4gICAgICAgICAgdmFyICRjb250cm9scyA9IHRoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIuY29uY2F0KHRoaXMub3B0aW9ucy5uZXh0Q2xhc3MsIFxcXCIsIC5cXFwiKS5jb25jYXQodGhpcy5vcHRpb25zLnByZXZDbGFzcykpO1xcbiAgICAgICAgICAkY29udHJvbHMuYXR0cigndGFiaW5kZXgnLCAwKSAvL2Fsc28gbmVlZCB0byBoYW5kbGUgZW50ZXIvcmV0dXJuIGFuZCBzcGFjZWJhciBrZXkgcHJlc3Nlc1xcbiAgICAgICAgICAub24oJ2NsaWNrLnpmLm9yYml0IHRvdWNoZW5kLnpmLm9yYml0JywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuXFxuICAgICAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLmhhc0NsYXNzKF90aGlzLm9wdGlvbnMubmV4dENsYXNzKSk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5idWxsZXRzKSB7XFxuICAgICAgICAgIHRoaXMuJGJ1bGxldHMub24oJ2NsaWNrLnpmLm9yYml0IHRvdWNoZW5kLnpmLm9yYml0JywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGlmICgvaXMtYWN0aXZlL2cudGVzdCh0aGlzLmNsYXNzTmFtZSkpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgICB9IC8vaWYgdGhpcyBpcyBhY3RpdmUsIGtpY2sgb3V0IG9mIGZ1bmN0aW9uLlxcblxcblxcbiAgICAgICAgICAgIHZhciBpZHggPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykuZGF0YSgnc2xpZGUnKSxcXG4gICAgICAgICAgICAgICAgbHRyID0gaWR4ID4gX3RoaXMuJHNsaWRlcy5maWx0ZXIoJy5pcy1hY3RpdmUnKS5kYXRhKCdzbGlkZScpLFxcbiAgICAgICAgICAgICAgICAkc2xpZGUgPSBfdGhpcy4kc2xpZGVzLmVxKGlkeCk7XFxuXFxuICAgICAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUobHRyLCAkc2xpZGUsIGlkeCk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hY2Nlc3NpYmxlKSB7XFxuICAgICAgICAgIHRoaXMuJHdyYXBwZXIuYWRkKHRoaXMuJGJ1bGxldHMpLm9uKCdrZXlkb3duLnpmLm9yYml0JywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICAvLyBoYW5kbGUga2V5Ym9hcmQgZXZlbnQgd2l0aCBrZXlib2FyZCB1dGlsXFxuICAgICAgICAgICAgX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJLZXlib2FyZFxcXCJdLmhhbmRsZUtleShlLCAnT3JiaXQnLCB7XFxuICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xcbiAgICAgICAgICAgICAgICBfdGhpcy5jaGFuZ2VTbGlkZSh0cnVlKTtcXG4gICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICBwcmV2aW91czogZnVuY3Rpb24gcHJldmlvdXMoKSB7XFxuICAgICAgICAgICAgICAgIF90aGlzLmNoYW5nZVNsaWRlKGZhbHNlKTtcXG4gICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICBoYW5kbGVkOiBmdW5jdGlvbiBoYW5kbGVkKCkge1xcbiAgICAgICAgICAgICAgICAvLyBpZiBidWxsZXQgaXMgZm9jdXNlZCwgbWFrZSBzdXJlIGZvY3VzIG1vdmVzXFxuICAgICAgICAgICAgICAgIGlmIChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZS50YXJnZXQpLmlzKF90aGlzLiRidWxsZXRzKSkge1xcbiAgICAgICAgICAgICAgICAgIF90aGlzLiRidWxsZXRzLmZpbHRlcignLmlzLWFjdGl2ZScpLmZvY3VzKCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBSZXNldHMgT3JiaXQgc28gaXQgY2FuIGJlIHJlaW5pdGlhbGl6ZWRcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9yZXNldFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzZXQoKSB7XFxuICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhlcmUgYXJlIG5vIHNsaWRlcyAoZmlyc3QgcnVuKVxcbiAgICAgIGlmICh0eXBlb2YgdGhpcy4kc2xpZGVzID09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLiRzbGlkZXMubGVuZ3RoID4gMSkge1xcbiAgICAgICAgLy8gUmVtb3ZlIG9sZCBldmVudHNcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYub3JiaXQnKS5maW5kKCcqJykub2ZmKCcuemYub3JiaXQnKTsgLy8gUmVzdGFydCB0aW1lciBpZiBhdXRvUGxheSBpcyBlbmFibGVkXFxuXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9QbGF5KSB7XFxuICAgICAgICAgIHRoaXMudGltZXIucmVzdGFydCgpO1xcbiAgICAgICAgfSAvLyBSZXNldCBhbGwgc2xpZGRlc1xcblxcblxcbiAgICAgICAgdGhpcy4kc2xpZGVzLmVhY2goZnVuY3Rpb24gKGVsKSB7XFxuICAgICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShlbCkucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZSBpcy1hY3RpdmUgaXMtaW4nKS5yZW1vdmVBdHRyKCdhcmlhLWxpdmUnKS5oaWRlKCk7XFxuICAgICAgICB9KTsgLy8gU2hvdyB0aGUgZmlyc3Qgc2xpZGVcXG5cXG4gICAgICAgIHRoaXMuJHNsaWRlcy5maXJzdCgpLmFkZENsYXNzKCdpcy1hY3RpdmUnKS5zaG93KCk7IC8vIFRyaWdnZXJzIHdoZW4gdGhlIHNsaWRlIGhhcyBmaW5pc2hlZCBhbmltYXRpbmdcXG5cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignc2xpZGVjaGFuZ2UuemYub3JiaXQnLCBbdGhpcy4kc2xpZGVzLmZpcnN0KCldKTsgLy8gU2VsZWN0IGZpcnN0IGJ1bGxldCBpZiBidWxsZXRzIGFyZSBwcmVzZW50XFxuXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJ1bGxldHMpIHtcXG4gICAgICAgICAgdGhpcy5fdXBkYXRlQnVsbGV0cygwKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICogQ2hhbmdlcyB0aGUgY3VycmVudCBzbGlkZSB0byBhIG5ldyBvbmUuXFxuICAgICogQGZ1bmN0aW9uXFxuICAgICogQHBhcmFtIHtCb29sZWFufSBpc0xUUiAtIGlmIHRydWUgdGhlIHNsaWRlIG1vdmVzIGZyb20gcmlnaHQgdG8gbGVmdCwgaWYgZmFsc2UgdGhlIHNsaWRlIG1vdmVzIGZyb20gbGVmdCB0byByaWdodC5cXG4gICAgKiBAcGFyYW0ge2pRdWVyeX0gY2hvc2VuU2xpZGUgLSB0aGUgalF1ZXJ5IGVsZW1lbnQgb2YgdGhlIHNsaWRlIHRvIHNob3cgbmV4dCwgaWYgb25lIGlzIHNlbGVjdGVkLlxcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZHggLSB0aGUgaW5kZXggb2YgdGhlIG5ldyBzbGlkZSBpbiBpdHMgY29sbGVjdGlvbiwgaWYgb25lIGNob3Nlbi5cXG4gICAgKiBAZmlyZXMgT3JiaXQjc2xpZGVjaGFuZ2VcXG4gICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiY2hhbmdlU2xpZGVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hhbmdlU2xpZGUoaXNMVFIsIGNob3NlblNsaWRlLCBpZHgpIHtcXG4gICAgICBpZiAoIXRoaXMuJHNsaWRlcykge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH0gLy8gRG9uJ3QgZnJlYWsgb3V0IGlmIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgY2xlYW51cFxcblxcblxcbiAgICAgIHZhciAkY3VyU2xpZGUgPSB0aGlzLiRzbGlkZXMuZmlsdGVyKCcuaXMtYWN0aXZlJykuZXEoMCk7XFxuXFxuICAgICAgaWYgKC9tdWkvZy50ZXN0KCRjdXJTbGlkZVswXS5jbGFzc05hbWUpKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfSAvL2lmIHRoZSBzbGlkZSBpcyBjdXJyZW50bHkgYW5pbWF0aW5nLCBraWNrIG91dCBvZiB0aGUgZnVuY3Rpb25cXG5cXG5cXG4gICAgICB2YXIgJGZpcnN0U2xpZGUgPSB0aGlzLiRzbGlkZXMuZmlyc3QoKSxcXG4gICAgICAgICAgJGxhc3RTbGlkZSA9IHRoaXMuJHNsaWRlcy5sYXN0KCksXFxuICAgICAgICAgIGRpckluID0gaXNMVFIgPyAnUmlnaHQnIDogJ0xlZnQnLFxcbiAgICAgICAgICBkaXJPdXQgPSBpc0xUUiA/ICdMZWZ0JyA6ICdSaWdodCcsXFxuICAgICAgICAgIF90aGlzID0gdGhpcyxcXG4gICAgICAgICAgJG5ld1NsaWRlO1xcblxcbiAgICAgIGlmICghY2hvc2VuU2xpZGUpIHtcXG4gICAgICAgIC8vbW9zdCBvZiB0aGUgdGltZSwgdGhpcyB3aWxsIGJlIGF1dG8gcGxheWVkIG9yIGNsaWNrZWQgZnJvbSB0aGUgbmF2QnV0dG9ucy5cXG4gICAgICAgICRuZXdTbGlkZSA9IGlzTFRSID8gLy9pZiB3cmFwcGluZyBlbmFibGVkLCBjaGVjayB0byBzZWUgaWYgdGhlcmUgaXMgYSBgbmV4dGAgb3IgYHByZXZgIHNpYmxpbmcsIGlmIG5vdCwgc2VsZWN0IHRoZSBmaXJzdCBvciBsYXN0IHNsaWRlIHRvIGZpbGwgaW4uIGlmIHdyYXBwaW5nIG5vdCBlbmFibGVkLCBhdHRlbXB0IHRvIHNlbGVjdCBgbmV4dGAgb3IgYHByZXZgLCBpZiB0aGVyZSdzIG5vdGhpbmcgdGhlcmUsIHRoZSBmdW5jdGlvbiB3aWxsIGtpY2sgb3V0IG9uIG5leHQgc3RlcC4gQ1JBWlkgTkVTVEVEIFRFUk5BUklFUyEhISEhXFxuICAgICAgICB0aGlzLm9wdGlvbnMuaW5maW5pdGVXcmFwID8gJGN1clNsaWRlLm5leHQoXFxcIi5cXFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykpLmxlbmd0aCA/ICRjdXJTbGlkZS5uZXh0KFxcXCIuXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpKSA6ICRmaXJzdFNsaWRlIDogJGN1clNsaWRlLm5leHQoXFxcIi5cXFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykpIDogLy9waWNrIG5leHQgc2xpZGUgaWYgbW92aW5nIGxlZnQgdG8gcmlnaHRcXG4gICAgICAgIHRoaXMub3B0aW9ucy5pbmZpbml0ZVdyYXAgPyAkY3VyU2xpZGUucHJldihcXFwiLlxcXCIuY29uY2F0KHRoaXMub3B0aW9ucy5zbGlkZUNsYXNzKSkubGVuZ3RoID8gJGN1clNsaWRlLnByZXYoXFxcIi5cXFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykpIDogJGxhc3RTbGlkZSA6ICRjdXJTbGlkZS5wcmV2KFxcXCIuXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpKTsgLy9waWNrIHByZXYgc2xpZGUgaWYgbW92aW5nIHJpZ2h0IHRvIGxlZnRcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgJG5ld1NsaWRlID0gY2hvc2VuU2xpZGU7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICgkbmV3U2xpZGUubGVuZ3RoKSB7XFxuICAgICAgICAvKipcXG4gICAgICAgICogVHJpZ2dlcnMgYmVmb3JlIHRoZSBuZXh0IHNsaWRlIHN0YXJ0cyBhbmltYXRpbmcgaW4gYW5kIG9ubHkgaWYgYSBuZXh0IHNsaWRlIGhhcyBiZWVuIGZvdW5kLlxcbiAgICAgICAgKiBAZXZlbnQgT3JiaXQjYmVmb3Jlc2xpZGVjaGFuZ2VcXG4gICAgICAgICovXFxuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2JlZm9yZXNsaWRlY2hhbmdlLnpmLm9yYml0JywgWyRjdXJTbGlkZSwgJG5ld1NsaWRlXSk7XFxuXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJ1bGxldHMpIHtcXG4gICAgICAgICAgaWR4ID0gaWR4IHx8IHRoaXMuJHNsaWRlcy5pbmRleCgkbmV3U2xpZGUpOyAvL2dyYWIgaW5kZXggdG8gdXBkYXRlIGJ1bGxldHNcXG5cXG4gICAgICAgICAgdGhpcy5fdXBkYXRlQnVsbGV0cyhpZHgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51c2VNVUkgJiYgIXRoaXMuJGVsZW1lbnQuaXMoJzpoaWRkZW4nKSkge1xcbiAgICAgICAgICBfZm91bmRhdGlvbl91dGlsX21vdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJNb3Rpb25cXFwiXS5hbmltYXRlSW4oJG5ld1NsaWRlLmFkZENsYXNzKCdpcy1hY3RpdmUnKSwgdGhpcy5vcHRpb25zW1xcXCJhbmltSW5Gcm9tXFxcIi5jb25jYXQoZGlySW4pXSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICRuZXdTbGlkZS5jc3Moe1xcbiAgICAgICAgICAgICAgJ2Rpc3BsYXknOiAnYmxvY2snXFxuICAgICAgICAgICAgfSkuYXR0cignYXJpYS1saXZlJywgJ3BvbGl0ZScpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgX2ZvdW5kYXRpb25fdXRpbF9tb3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiTW90aW9uXFxcIl0uYW5pbWF0ZU91dCgkY3VyU2xpZGUucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpLCB0aGlzLm9wdGlvbnNbXFxcImFuaW1PdXRUb1xcXCIuY29uY2F0KGRpck91dCldLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgJGN1clNsaWRlLnJlbW92ZUF0dHIoJ2FyaWEtbGl2ZScpO1xcblxcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmF1dG9QbGF5ICYmICFfdGhpcy50aW1lci5pc1BhdXNlZCkge1xcbiAgICAgICAgICAgICAgX3RoaXMudGltZXIucmVzdGFydCgpO1xcbiAgICAgICAgICAgIH0gLy9kbyBzdHVmZj9cXG5cXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAkY3VyU2xpZGUucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZSBpcy1pbicpLnJlbW92ZUF0dHIoJ2FyaWEtbGl2ZScpLmhpZGUoKTtcXG4gICAgICAgICAgJG5ld1NsaWRlLmFkZENsYXNzKCdpcy1hY3RpdmUgaXMtaW4nKS5hdHRyKCdhcmlhLWxpdmUnLCAncG9saXRlJykuc2hvdygpO1xcblxcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9QbGF5ICYmICF0aGlzLnRpbWVyLmlzUGF1c2VkKSB7XFxuICAgICAgICAgICAgdGhpcy50aW1lci5yZXN0YXJ0KCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIC8qKlxcbiAgICAgICAgKiBUcmlnZ2VycyB3aGVuIHRoZSBzbGlkZSBoYXMgZmluaXNoZWQgYW5pbWF0aW5nIGluLlxcbiAgICAgICAgKiBAZXZlbnQgT3JiaXQjc2xpZGVjaGFuZ2VcXG4gICAgICAgICovXFxuXFxuXFxuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3NsaWRlY2hhbmdlLnpmLm9yYml0JywgWyRuZXdTbGlkZV0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgKiBVcGRhdGVzIHRoZSBhY3RpdmUgc3RhdGUgb2YgdGhlIGJ1bGxldHMsIGlmIGRpc3BsYXllZC5cXG4gICAgKiBAZnVuY3Rpb25cXG4gICAgKiBAcHJpdmF0ZVxcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZHggLSB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgc2xpZGUuXFxuICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl91cGRhdGVCdWxsZXRzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVCdWxsZXRzKGlkeCkge1xcbiAgICAgIHZhciAkb2xkQnVsbGV0ID0gdGhpcy4kZWxlbWVudC5maW5kKFxcXCIuXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLmJveE9mQnVsbGV0cykpLmZpbmQoJy5pcy1hY3RpdmUnKS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlJykuYmx1cigpLFxcbiAgICAgICAgICBzcGFuID0gJG9sZEJ1bGxldC5maW5kKCdzcGFuOmxhc3QnKS5kZXRhY2goKSxcXG4gICAgICAgICAgJG5ld0J1bGxldCA9IHRoaXMuJGJ1bGxldHMuZXEoaWR4KS5hZGRDbGFzcygnaXMtYWN0aXZlJykuYXBwZW5kKHNwYW4pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAqIERlc3Ryb3lzIHRoZSBjYXJvdXNlbCBhbmQgaGlkZXMgdGhlIGVsZW1lbnQuXFxuICAgICogQGZ1bmN0aW9uXFxuICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9kZXN0cm95XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYub3JiaXQnKS5maW5kKCcqJykub2ZmKCcuemYub3JiaXQnKS5lbmQoKS5oaWRlKCk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBPcmJpdDtcXG59KF9mb3VuZGF0aW9uX2NvcmVfcGx1Z2luX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXFxcIlBsdWdpblxcXCJdKTtcXG5cXG5PcmJpdC5kZWZhdWx0cyA9IHtcXG4gIC8qKlxcbiAgKiBUZWxscyB0aGUgSlMgdG8gbG9vayBmb3IgYW5kIGxvYWRCdWxsZXRzLlxcbiAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICogQGRlZmF1bHQgdHJ1ZVxcbiAgKi9cXG4gIGJ1bGxldHM6IHRydWUsXFxuXFxuICAvKipcXG4gICogVGVsbHMgdGhlIEpTIHRvIGFwcGx5IGV2ZW50IGxpc3RlbmVycyB0byBuYXYgYnV0dG9uc1xcbiAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICogQGRlZmF1bHQgdHJ1ZVxcbiAgKi9cXG4gIG5hdkJ1dHRvbnM6IHRydWUsXFxuXFxuICAvKipcXG4gICogbW90aW9uLXVpIGFuaW1hdGlvbiBjbGFzcyB0byBhcHBseVxcbiAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgKiBAZGVmYXVsdCAnc2xpZGUtaW4tcmlnaHQnXFxuICAqL1xcbiAgYW5pbUluRnJvbVJpZ2h0OiAnc2xpZGUtaW4tcmlnaHQnLFxcblxcbiAgLyoqXFxuICAqIG1vdGlvbi11aSBhbmltYXRpb24gY2xhc3MgdG8gYXBwbHlcXG4gICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICogQGRlZmF1bHQgJ3NsaWRlLW91dC1yaWdodCdcXG4gICovXFxuICBhbmltT3V0VG9SaWdodDogJ3NsaWRlLW91dC1yaWdodCcsXFxuXFxuICAvKipcXG4gICogbW90aW9uLXVpIGFuaW1hdGlvbiBjbGFzcyB0byBhcHBseVxcbiAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgKiBAZGVmYXVsdCAnc2xpZGUtaW4tbGVmdCdcXG4gICpcXG4gICovXFxuICBhbmltSW5Gcm9tTGVmdDogJ3NsaWRlLWluLWxlZnQnLFxcblxcbiAgLyoqXFxuICAqIG1vdGlvbi11aSBhbmltYXRpb24gY2xhc3MgdG8gYXBwbHlcXG4gICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICogQGRlZmF1bHQgJ3NsaWRlLW91dC1sZWZ0J1xcbiAgKi9cXG4gIGFuaW1PdXRUb0xlZnQ6ICdzbGlkZS1vdXQtbGVmdCcsXFxuXFxuICAvKipcXG4gICogQWxsb3dzIE9yYml0IHRvIGF1dG9tYXRpY2FsbHkgYW5pbWF0ZSBvbiBwYWdlIGxvYWQuXFxuICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgKiBAZGVmYXVsdCB0cnVlXFxuICAqL1xcbiAgYXV0b1BsYXk6IHRydWUsXFxuXFxuICAvKipcXG4gICogQW1vdW50IG9mIHRpbWUsIGluIG1zLCBiZXR3ZWVuIHNsaWRlIHRyYW5zaXRpb25zXFxuICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAqIEBkZWZhdWx0IDUwMDBcXG4gICovXFxuICB0aW1lckRlbGF5OiA1MDAwLFxcblxcbiAgLyoqXFxuICAqIEFsbG93cyBPcmJpdCB0byBpbmZpbml0ZWx5IGxvb3AgdGhyb3VnaCB0aGUgc2xpZGVzXFxuICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgKiBAZGVmYXVsdCB0cnVlXFxuICAqL1xcbiAgaW5maW5pdGVXcmFwOiB0cnVlLFxcblxcbiAgLyoqXFxuICAqIEFsbG93cyB0aGUgT3JiaXQgc2xpZGVzIHRvIGJpbmQgdG8gc3dpcGUgZXZlbnRzIGZvciBtb2JpbGUsIHJlcXVpcmVzIGFuIGFkZGl0aW9uYWwgdXRpbCBsaWJyYXJ5XFxuICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgKiBAZGVmYXVsdCB0cnVlXFxuICAqL1xcbiAgc3dpcGU6IHRydWUsXFxuXFxuICAvKipcXG4gICogQWxsb3dzIHRoZSB0aW1pbmcgZnVuY3Rpb24gdG8gcGF1c2UgYW5pbWF0aW9uIG9uIGhvdmVyLlxcbiAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICogQGRlZmF1bHQgdHJ1ZVxcbiAgKi9cXG4gIHBhdXNlT25Ib3ZlcjogdHJ1ZSxcXG5cXG4gIC8qKlxcbiAgKiBBbGxvd3MgT3JiaXQgdG8gYmluZCBrZXlib2FyZCBldmVudHMgdG8gdGhlIHNsaWRlciwgdG8gYW5pbWF0ZSBmcmFtZXMgd2l0aCBhcnJvdyBrZXlzXFxuICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgKiBAZGVmYXVsdCB0cnVlXFxuICAqL1xcbiAgYWNjZXNzaWJsZTogdHJ1ZSxcXG5cXG4gIC8qKlxcbiAgKiBDbGFzcyBhcHBsaWVkIHRvIHRoZSBjb250YWluZXIgb2YgT3JiaXRcXG4gICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICogQGRlZmF1bHQgJ29yYml0LWNvbnRhaW5lcidcXG4gICovXFxuICBjb250YWluZXJDbGFzczogJ29yYml0LWNvbnRhaW5lcicsXFxuXFxuICAvKipcXG4gICogQ2xhc3MgYXBwbGllZCB0byBpbmRpdmlkdWFsIHNsaWRlcy5cXG4gICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICogQGRlZmF1bHQgJ29yYml0LXNsaWRlJ1xcbiAgKi9cXG4gIHNsaWRlQ2xhc3M6ICdvcmJpdC1zbGlkZScsXFxuXFxuICAvKipcXG4gICogQ2xhc3MgYXBwbGllZCB0byB0aGUgYnVsbGV0IGNvbnRhaW5lci4gWW91J3JlIHdlbGNvbWUuXFxuICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAqIEBkZWZhdWx0ICdvcmJpdC1idWxsZXRzJ1xcbiAgKi9cXG4gIGJveE9mQnVsbGV0czogJ29yYml0LWJ1bGxldHMnLFxcblxcbiAgLyoqXFxuICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGBuZXh0YCBuYXZpZ2F0aW9uIGJ1dHRvbi5cXG4gICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICogQGRlZmF1bHQgJ29yYml0LW5leHQnXFxuICAqL1xcbiAgbmV4dENsYXNzOiAnb3JiaXQtbmV4dCcsXFxuXFxuICAvKipcXG4gICogQ2xhc3MgYXBwbGllZCB0byB0aGUgYHByZXZpb3VzYCBuYXZpZ2F0aW9uIGJ1dHRvbi5cXG4gICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICogQGRlZmF1bHQgJ29yYml0LXByZXZpb3VzJ1xcbiAgKi9cXG4gIHByZXZDbGFzczogJ29yYml0LXByZXZpb3VzJyxcXG5cXG4gIC8qKlxcbiAgKiBCb29sZWFuIHRvIGZsYWcgdGhlIGpzIHRvIHVzZSBtb3Rpb24gdWkgY2xhc3NlcyBvciBub3QuIERlZmF1bHQgdG8gdHJ1ZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXFxuICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgKiBAZGVmYXVsdCB0cnVlXFxuICAqL1xcbiAgdXNlTVVJOiB0cnVlXFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9qcy9mb3VuZGF0aW9uLm9yYml0LmpzP1wiKX0sXCIuL2pzL2ZvdW5kYXRpb24ucG9zaXRpb25hYmxlLmpzXCI6ZnVuY3Rpb24obW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbCgnX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJQb3NpdGlvbmFibGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBQb3NpdGlvbmFibGU7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX2JveF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwuYm94ICovIFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwuYm94LmpzXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUucGx1Z2luICovIFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUucGx1Z2luLmpzXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uY29yZS51dGlscyAqLyBcIi4vanMvZm91bmRhdGlvbi5jb3JlLnV0aWxzLmpzXCIpO1xcblxcblxcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XFxuXFxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuXFwndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuXFwndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxcblxcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxcblxcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XFxuXFxuXFxuXFxuXFxudmFyIFBPU0lUSU9OUyA9IFtcXCdsZWZ0XFwnLCBcXCdyaWdodFxcJywgXFwndG9wXFwnLCBcXCdib3R0b21cXCddO1xcbnZhciBWRVJUSUNBTF9BTElHTk1FTlRTID0gW1xcJ3RvcFxcJywgXFwnYm90dG9tXFwnLCBcXCdjZW50ZXJcXCddO1xcbnZhciBIT1JJWk9OVEFMX0FMSUdOTUVOVFMgPSBbXFwnbGVmdFxcJywgXFwncmlnaHRcXCcsIFxcJ2NlbnRlclxcJ107XFxudmFyIEFMSUdOTUVOVFMgPSB7XFxuICBcXCdsZWZ0XFwnOiBWRVJUSUNBTF9BTElHTk1FTlRTLFxcbiAgXFwncmlnaHRcXCc6IFZFUlRJQ0FMX0FMSUdOTUVOVFMsXFxuICBcXCd0b3BcXCc6IEhPUklaT05UQUxfQUxJR05NRU5UUyxcXG4gIFxcJ2JvdHRvbVxcJzogSE9SSVpPTlRBTF9BTElHTk1FTlRTXFxufTtcXG5cXG5mdW5jdGlvbiBuZXh0SXRlbShpdGVtLCBhcnJheSkge1xcbiAgdmFyIGN1cnJlbnRJZHggPSBhcnJheS5pbmRleE9mKGl0ZW0pO1xcblxcbiAgaWYgKGN1cnJlbnRJZHggPT09IGFycmF5Lmxlbmd0aCAtIDEpIHtcXG4gICAgcmV0dXJuIGFycmF5WzBdO1xcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIGFycmF5W2N1cnJlbnRJZHggKyAxXTtcXG4gIH1cXG59XFxuXFxudmFyIFBvc2l0aW9uYWJsZSA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uIChfUGx1Z2luKSB7XFxuICBfaW5oZXJpdHMoUG9zaXRpb25hYmxlLCBfUGx1Z2luKTtcXG5cXG4gIGZ1bmN0aW9uIFBvc2l0aW9uYWJsZSgpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvc2l0aW9uYWJsZSk7XFxuXFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoUG9zaXRpb25hYmxlKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhQb3NpdGlvbmFibGUsIFt7XFxuICAgIGtleTogXCJfaW5pdFwiLFxcblxcbiAgICAvKipcXG4gICAgICogQWJzdHJhY3QgY2xhc3MgZW5jYXBzdWxhdGluZyB0aGUgdGV0aGVyLWxpa2UgZXhwbGljaXQgcG9zaXRpb25pbmcgbG9naWNcXG4gICAgICogaW5jbHVkaW5nIHJlcG9zaXRpb25pbmcgYmFzZWQgb24gb3ZlcmxhcC5cXG4gICAgICogRXhwZWN0cyBjbGFzc2VzIHRvIGRlZmluZSBkZWZhdWx0cyBmb3Igdk9mZnNldCwgaE9mZnNldCwgcG9zaXRpb24sXFxuICAgICAqIGFsaWdubWVudCwgYWxsb3dPdmVybGFwLCBhbmQgYWxsb3dCb3R0b21PdmVybGFwLiBUaGV5IGNhbiBkbyB0aGlzIGJ5XFxuICAgICAqIGV4dGVuZGluZyB0aGUgZGVmYXVsdHMsIG9yIChmb3Igbm93IHJlY29tbWVuZGVkIGR1ZSB0byB0aGUgd2F5IGRvY3MgYXJlXFxuICAgICAqIGdlbmVyYXRlZCkgYnkgZXhwbGljaXRseSBkZWNsYXJpbmcgdGhlbS5cXG4gICAgICpcXG4gICAgICoqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgdGhpcy50cmllZFBvc2l0aW9ucyA9IHt9O1xcbiAgICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09IFxcJ2F1dG9cXCcgPyB0aGlzLl9nZXREZWZhdWx0UG9zaXRpb24oKSA6IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcXG4gICAgICB0aGlzLmFsaWdubWVudCA9IHRoaXMub3B0aW9ucy5hbGlnbm1lbnQgPT09IFxcJ2F1dG9cXCcgPyB0aGlzLl9nZXREZWZhdWx0QWxpZ25tZW50KCkgOiB0aGlzLm9wdGlvbnMuYWxpZ25tZW50O1xcbiAgICAgIHRoaXMub3JpZ2luYWxQb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XFxuICAgICAgdGhpcy5vcmlnaW5hbEFsaWdubWVudCA9IHRoaXMuYWxpZ25tZW50O1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXCJfZ2V0RGVmYXVsdFBvc2l0aW9uXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGVmYXVsdFBvc2l0aW9uKCkge1xcbiAgICAgIHJldHVybiBcXCdib3R0b21cXCc7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcIl9nZXREZWZhdWx0QWxpZ25tZW50XCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGVmYXVsdEFsaWdubWVudCgpIHtcXG4gICAgICBzd2l0Y2ggKHRoaXMucG9zaXRpb24pIHtcXG4gICAgICAgIGNhc2UgXFwnYm90dG9tXFwnOlxcbiAgICAgICAgY2FzZSBcXCd0b3BcXCc6XFxuICAgICAgICAgIHJldHVybiBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wicnRsXCJdKSgpID8gXFwncmlnaHRcXCcgOiBcXCdsZWZ0XFwnO1xcblxcbiAgICAgICAgY2FzZSBcXCdsZWZ0XFwnOlxcbiAgICAgICAgY2FzZSBcXCdyaWdodFxcJzpcXG4gICAgICAgICAgcmV0dXJuIFxcJ2JvdHRvbVxcJztcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEFkanVzdHMgdGhlIHBvc2l0aW9uYWJsZSBwb3NzaWJsZSBwb3NpdGlvbnMgYnkgaXRlcmF0aW5nIHRocm91Z2ggYWxpZ25tZW50c1xcbiAgICAgKiBhbmQgcG9zaXRpb25zLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXCJfcmVwb3NpdGlvblwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlcG9zaXRpb24oKSB7XFxuICAgICAgaWYgKHRoaXMuX2FsaWdubWVudHNFeGhhdXN0ZWQodGhpcy5wb3NpdGlvbikpIHtcXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBuZXh0SXRlbSh0aGlzLnBvc2l0aW9uLCBQT1NJVElPTlMpO1xcbiAgICAgICAgdGhpcy5hbGlnbm1lbnQgPSBBTElHTk1FTlRTW3RoaXMucG9zaXRpb25dWzBdO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLl9yZWFsaWduKCk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBBZGp1c3RzIHRoZSBkcm9wZG93biBwYW5lIHBvc3NpYmxlIHBvc2l0aW9ucyBieSBpdGVyYXRpbmcgdGhyb3VnaCBhbGlnbm1lbnRzXFxuICAgICAqIG9uIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXCJfcmVhbGlnblwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlYWxpZ24oKSB7XFxuICAgICAgdGhpcy5fYWRkVHJpZWRQb3NpdGlvbih0aGlzLnBvc2l0aW9uLCB0aGlzLmFsaWdubWVudCk7XFxuXFxuICAgICAgdGhpcy5hbGlnbm1lbnQgPSBuZXh0SXRlbSh0aGlzLmFsaWdubWVudCwgQUxJR05NRU5UU1t0aGlzLnBvc2l0aW9uXSk7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcIl9hZGRUcmllZFBvc2l0aW9uXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkVHJpZWRQb3NpdGlvbihwb3NpdGlvbiwgYWxpZ25tZW50KSB7XFxuICAgICAgdGhpcy50cmllZFBvc2l0aW9uc1twb3NpdGlvbl0gPSB0aGlzLnRyaWVkUG9zaXRpb25zW3Bvc2l0aW9uXSB8fCBbXTtcXG4gICAgICB0aGlzLnRyaWVkUG9zaXRpb25zW3Bvc2l0aW9uXS5wdXNoKGFsaWdubWVudCk7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcIl9wb3NpdGlvbnNFeGhhdXN0ZWRcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wb3NpdGlvbnNFeGhhdXN0ZWQoKSB7XFxuICAgICAgdmFyIGlzRXhoYXVzdGVkID0gdHJ1ZTtcXG5cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFBPU0lUSU9OUy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgaXNFeGhhdXN0ZWQgPSBpc0V4aGF1c3RlZCAmJiB0aGlzLl9hbGlnbm1lbnRzRXhoYXVzdGVkKFBPU0lUSU9OU1tpXSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBpc0V4aGF1c3RlZDtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFwiX2FsaWdubWVudHNFeGhhdXN0ZWRcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hbGlnbm1lbnRzRXhoYXVzdGVkKHBvc2l0aW9uKSB7XFxuICAgICAgcmV0dXJuIHRoaXMudHJpZWRQb3NpdGlvbnNbcG9zaXRpb25dICYmIHRoaXMudHJpZWRQb3NpdGlvbnNbcG9zaXRpb25dLmxlbmd0aCA9PSBBTElHTk1FTlRTW3Bvc2l0aW9uXS5sZW5ndGg7XFxuICAgIH0gLy8gV2hlbiB3ZVxcJ3JlIHRyeWluZyB0byBjZW50ZXIsIHdlIGRvblxcJ3Qgd2FudCB0byBhcHBseSBvZmZzZXQgdGhhdFxcJ3MgZ29pbmcgdG9cXG4gICAgLy8gdGFrZSB1cyBqdXN0IG9mZiBjZW50ZXIsIHNvIHdyYXAgYXJvdW5kIHRvIHJldHVybiAwIGZvciB0aGUgYXBwcm9wcmlhdGVcXG4gICAgLy8gb2Zmc2V0IGluIHRob3NlIGFsaWdubWVudHMuICBUT0RPOiBGaWd1cmUgb3V0IGlmIHdlIHdhbnQgdG8gbWFrZSB0aGlzXFxuICAgIC8vIGNvbmZpZ3VyYWJsZSBiZWhhdmlvci4uLiBpdCBmZWVscyBtb3JlIGludHVpdGl2ZSwgZXNwZWNpYWxseSBmb3IgdG9vbHRpcHMsIGJ1dFxcbiAgICAvLyBpdFxcJ3MgcG9zc2libGUgc29tZW9uZSBtaWdodCBhY3R1YWxseSB3YW50IHRvIHN0YXJ0IGZyb20gY2VudGVyIGFuZCB0aGVuIG51ZGdlXFxuICAgIC8vIHNsaWdodGx5IG9mZi5cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcIl9nZXRWT2Zmc2V0XCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Vk9mZnNldCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnZPZmZzZXQ7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcIl9nZXRIT2Zmc2V0XCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SE9mZnNldCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmhPZmZzZXQ7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcIl9zZXRQb3NpdGlvblwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFBvc2l0aW9uKCRhbmNob3IsICRlbGVtZW50LCAkcGFyZW50KSB7XFxuICAgICAgaWYgKCRhbmNob3IuYXR0cihcXCdhcmlhLWV4cGFuZGVkXFwnKSA9PT0gXFwnZmFsc2VcXCcpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyICRlbGVEaW1zID0gX2ZvdW5kYXRpb25fdXRpbF9ib3hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkJveFwiXS5HZXREaW1lbnNpb25zKCRlbGVtZW50KSxcXG4gICAgICAgICAgJGFuY2hvckRpbXMgPSBfZm91bmRhdGlvbl91dGlsX2JveF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiQm94XCJdLkdldERpbWVuc2lvbnMoJGFuY2hvcik7XFxuXFxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxsb3dPdmVybGFwKSB7XFxuICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIHBvc2l0aW9uICYgYWxpZ25tZW50IGJlZm9yZSBjaGVja2luZyBvdmVybGFwXFxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5vcmlnaW5hbFBvc2l0aW9uO1xcbiAgICAgICAgdGhpcy5hbGlnbm1lbnQgPSB0aGlzLm9yaWdpbmFsQWxpZ25tZW50O1xcbiAgICAgIH1cXG5cXG4gICAgICAkZWxlbWVudC5vZmZzZXQoX2ZvdW5kYXRpb25fdXRpbF9ib3hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkJveFwiXS5HZXRFeHBsaWNpdE9mZnNldHMoJGVsZW1lbnQsICRhbmNob3IsIHRoaXMucG9zaXRpb24sIHRoaXMuYWxpZ25tZW50LCB0aGlzLl9nZXRWT2Zmc2V0KCksIHRoaXMuX2dldEhPZmZzZXQoKSkpO1xcblxcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmFsbG93T3ZlcmxhcCkge1xcbiAgICAgICAgdmFyIG92ZXJsYXBzID0ge307XFxuICAgICAgICB2YXIgbWluT3ZlcmxhcCA9IDEwMDAwMDAwMDsgLy8gZGVmYXVsdCBjb29yZGluYXRlcyB0byBob3cgd2Ugc3RhcnQsIGluIGNhc2Ugd2UgY2FuXFwndCBmaWd1cmUgb3V0IGJldHRlclxcblxcbiAgICAgICAgdmFyIG1pbkNvb3JkaW5hdGVzID0ge1xcbiAgICAgICAgICBwb3NpdGlvbjogdGhpcy5wb3NpdGlvbixcXG4gICAgICAgICAgYWxpZ25tZW50OiB0aGlzLmFsaWdubWVudFxcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIHdoaWxlICghdGhpcy5fcG9zaXRpb25zRXhoYXVzdGVkKCkpIHtcXG4gICAgICAgICAgdmFyIG92ZXJsYXAgPSBfZm91bmRhdGlvbl91dGlsX2JveF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiQm94XCJdLk92ZXJsYXBBcmVhKCRlbGVtZW50LCAkcGFyZW50LCBmYWxzZSwgZmFsc2UsIHRoaXMub3B0aW9ucy5hbGxvd0JvdHRvbU92ZXJsYXApO1xcblxcbiAgICAgICAgICBpZiAob3ZlcmxhcCA9PT0gMCkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAob3ZlcmxhcCA8IG1pbk92ZXJsYXApIHtcXG4gICAgICAgICAgICBtaW5PdmVybGFwID0gb3ZlcmxhcDtcXG4gICAgICAgICAgICBtaW5Db29yZGluYXRlcyA9IHtcXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uLFxcbiAgICAgICAgICAgICAgYWxpZ25tZW50OiB0aGlzLmFsaWdubWVudFxcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGhpcy5fcmVwb3NpdGlvbigpO1xcblxcbiAgICAgICAgICAkZWxlbWVudC5vZmZzZXQoX2ZvdW5kYXRpb25fdXRpbF9ib3hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkJveFwiXS5HZXRFeHBsaWNpdE9mZnNldHMoJGVsZW1lbnQsICRhbmNob3IsIHRoaXMucG9zaXRpb24sIHRoaXMuYWxpZ25tZW50LCB0aGlzLl9nZXRWT2Zmc2V0KCksIHRoaXMuX2dldEhPZmZzZXQoKSkpO1xcbiAgICAgICAgfSAvLyBJZiB3ZSBnZXQgdGhyb3VnaCB0aGUgZW50aXJlIGxvb3AsIHRoZXJlIHdhcyBubyBub24tb3ZlcmxhcHBpbmdcXG4gICAgICAgIC8vIHBvc2l0aW9uIGF2YWlsYWJsZS4gUGljayB0aGUgdmVyc2lvbiB3aXRoIGxlYXN0IG92ZXJsYXAuXFxuXFxuXFxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gbWluQ29vcmRpbmF0ZXMucG9zaXRpb247XFxuICAgICAgICB0aGlzLmFsaWdubWVudCA9IG1pbkNvb3JkaW5hdGVzLmFsaWdubWVudDtcXG4gICAgICAgICRlbGVtZW50Lm9mZnNldChfZm91bmRhdGlvbl91dGlsX2JveF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiQm94XCJdLkdldEV4cGxpY2l0T2Zmc2V0cygkZWxlbWVudCwgJGFuY2hvciwgdGhpcy5wb3NpdGlvbiwgdGhpcy5hbGlnbm1lbnQsIHRoaXMuX2dldFZPZmZzZXQoKSwgdGhpcy5fZ2V0SE9mZnNldCgpKSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gUG9zaXRpb25hYmxlO1xcbn0oX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlBsdWdpblwiXSk7XFxuXFxuUG9zaXRpb25hYmxlLmRlZmF1bHRzID0ge1xcbiAgLyoqXFxuICAgKiBQb3NpdGlvbiBvZiBwb3NpdGlvbmFibGUgcmVsYXRpdmUgdG8gYW5jaG9yLiBDYW4gYmUgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBvciBhdXRvLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0IFxcJ2F1dG9cXCdcXG4gICAqL1xcbiAgcG9zaXRpb246IFxcJ2F1dG9cXCcsXFxuXFxuICAvKipcXG4gICAqIEFsaWdubWVudCBvZiBwb3NpdGlvbmFibGUgcmVsYXRpdmUgdG8gYW5jaG9yLiBDYW4gYmUgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBjZW50ZXIsIG9yIGF1dG8uXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgXFwnYXV0b1xcJ1xcbiAgICovXFxuICBhbGlnbm1lbnQ6IFxcJ2F1dG9cXCcsXFxuXFxuICAvKipcXG4gICAqIEFsbG93IG92ZXJsYXAgb2YgY29udGFpbmVyL3dpbmRvdy4gSWYgZmFsc2UsIGRyb3Bkb3duIHBvc2l0aW9uYWJsZSBmaXJzdFxcbiAgICogdHJ5IHRvIHBvc2l0aW9uIGFzIGRlZmluZWQgYnkgZGF0YS1wb3NpdGlvbiBhbmQgZGF0YS1hbGlnbm1lbnQsIGJ1dFxcbiAgICogcmVwb3NpdGlvbiBpZiBpdCB3b3VsZCBjYXVzZSBhbiBvdmVyZmxvdy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgYWxsb3dPdmVybGFwOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogQWxsb3cgb3ZlcmxhcCBvZiBvbmx5IHRoZSBib3R0b20gb2YgdGhlIGNvbnRhaW5lci4gVGhpcyBpcyB0aGUgbW9zdCBjb21tb25cXG4gICAqIGJlaGF2aW9yIGZvciBkcm9wZG93bnMsIGFsbG93aW5nIHRoZSBkcm9wZG93biB0byBleHRlbmQgdGhlIGJvdHRvbSBvZiB0aGVcXG4gICAqIHNjcmVlbiBidXQgbm90IG90aGVyd2lzZSBpbmZsdWVuY2Ugb3IgYnJlYWsgb3V0IG9mIHRoZSBjb250YWluZXIuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IHRydWVcXG4gICAqL1xcbiAgYWxsb3dCb3R0b21PdmVybGFwOiB0cnVlLFxcblxcbiAgLyoqXFxuICAgKiBOdW1iZXIgb2YgcGl4ZWxzIHRoZSBwb3NpdGlvbmFibGUgc2hvdWxkIGJlIHNlcGFyYXRlZCB2ZXJ0aWNhbGx5IGZyb20gYW5jaG9yXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgMFxcbiAgICovXFxuICB2T2Zmc2V0OiAwLFxcblxcbiAgLyoqXFxuICAgKiBOdW1iZXIgb2YgcGl4ZWxzIHRoZSBwb3NpdGlvbmFibGUgc2hvdWxkIGJlIHNlcGFyYXRlZCBob3Jpem9udGFsbHkgZnJvbSBhbmNob3JcXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAwXFxuICAgKi9cXG4gIGhPZmZzZXQ6IDBcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL2pzL2ZvdW5kYXRpb24ucG9zaXRpb25hYmxlLmpzPycpfSxcIi4vanMvZm91bmRhdGlvbi5yZXNwb25zaXZlQWNjb3JkaW9uVGFicy5qc1wiOmZ1bmN0aW9uKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiUmVzcG9uc2l2ZUFjY29yZGlvblRhYnNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBqcXVlcnkgKi8gXFxcImpxdWVyeVxcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeSAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uY29yZS51dGlscyAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUudXRpbHMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnBsdWdpbiAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUucGx1Z2luLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2FjY29yZGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmFjY29yZGlvbiAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmFjY29yZGlvbi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl90YWJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udGFicyAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnRhYnMuanNcXFwiKTtcXG5cXG5cXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxcblxcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XFxuXFxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXFxcIm9iamVjdFxcXCIgfHwgdHlwZW9mIGNhbGwgPT09IFxcXCJmdW5jdGlvblxcXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XFxuXFxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcXFwiKTsgfSByZXR1cm4gc2VsZjsgfVxcblxcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cXFwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XFxuXFxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cXG5cXG5cXG5cXG5cXG5cXG5cXG4gLy8gVGhlIHBsdWdpbiBtYXRjaGVzIHRoZSBwbHVnaW4gY2xhc3NlcyB3aXRoIHRoZXNlIHBsdWdpbiBpbnN0YW5jZXMuXFxuXFxudmFyIE1lbnVQbHVnaW5zID0ge1xcbiAgdGFiczoge1xcbiAgICBjc3NDbGFzczogJ3RhYnMnLFxcbiAgICBwbHVnaW46IF9mb3VuZGF0aW9uX3RhYnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwiVGFic1xcXCJdXFxuICB9LFxcbiAgYWNjb3JkaW9uOiB7XFxuICAgIGNzc0NsYXNzOiAnYWNjb3JkaW9uJyxcXG4gICAgcGx1Z2luOiBfZm91bmRhdGlvbl9hY2NvcmRpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiQWNjb3JkaW9uXFxcIl1cXG4gIH1cXG59O1xcbi8qKlxcbiAqIFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzIG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24ucmVzcG9uc2l2ZUFjY29yZGlvblRhYnNcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvblxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLmFjY29yZGlvblxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnRhYnNcXG4gKi9cXG5cXG52YXIgUmVzcG9uc2l2ZUFjY29yZGlvblRhYnMgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoX1BsdWdpbikge1xcbiAgX2luaGVyaXRzKFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzLCBfUGx1Z2luKTtcXG5cXG4gIGZ1bmN0aW9uIFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzKCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzcG9uc2l2ZUFjY29yZGlvblRhYnMpO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhSZXNwb25zaXZlQWNjb3JkaW9uVGFicywgW3tcXG4gICAga2V5OiBcXFwiX3NldHVwXFxcIixcXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSByZXNwb25zaXZlIGFjY29yZGlvbiB0YWJzLlxcbiAgICAgKiBAY2xhc3NcXG4gICAgICogQG5hbWUgUmVzcG9uc2l2ZUFjY29yZGlvblRhYnNcXG4gICAgICogQGZpcmVzIFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzI2luaXRcXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBSZXNwb25zaXZlIEFjY29yZGlvbiBUYWJzLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50ID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGVsZW1lbnQpO1xcbiAgICAgIHRoaXMub3B0aW9ucyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoe30sIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG4gICAgICB0aGlzLnJ1bGVzID0gdGhpcy4kZWxlbWVudC5kYXRhKCdyZXNwb25zaXZlLWFjY29yZGlvbi10YWJzJyk7XFxuICAgICAgdGhpcy5jdXJyZW50TXEgPSBudWxsO1xcbiAgICAgIHRoaXMuY3VycmVudFBsdWdpbiA9IG51bGw7XFxuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnUmVzcG9uc2l2ZUFjY29yZGlvblRhYnMnOyAvLyBpZTkgYmFjayBjb21wYXRcXG5cXG4gICAgICBpZiAoIXRoaXMuJGVsZW1lbnQuYXR0cignaWQnKSkge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcsIE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIkdldFlvRGlnaXRzXFxcIl0pKDYsICdyZXNwb25zaXZlYWNjb3JkaW9udGFicycpKTtcXG4gICAgICB9XFxuXFxuICAgICAgO1xcblxcbiAgICAgIHRoaXMuX2luaXQoKTtcXG5cXG4gICAgICB0aGlzLl9ldmVudHMoKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIE1lbnUgYnkgcGFyc2luZyB0aGUgY2xhc3NlcyBmcm9tIHRoZSAnZGF0YS1yZXNwb25zaXZlLWFjY29yZGlvbi10YWJzJyBhdHRyaWJ1dGUgb24gdGhlIGVsZW1lbnQuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2luaXRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIk1lZGlhUXVlcnlcXFwiXS5faW5pdCgpOyAvLyBUaGUgZmlyc3QgdGltZSBhbiBJbnRlcmNoYW5nZSBwbHVnaW4gaXMgaW5pdGlhbGl6ZWQsIHRoaXMucnVsZXMgaXMgY29udmVydGVkIGZyb20gYSBzdHJpbmcgb2YgXFxcImNsYXNzZXNcXFwiIHRvIGFuIG9iamVjdCBvZiBydWxlc1xcblxcblxcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5ydWxlcyA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgIHZhciBydWxlc1RyZWUgPSB7fTsgLy8gUGFyc2UgcnVsZXMgZnJvbSBcXFwiY2xhc3Nlc1xcXCIgcHVsbGVkIGZyb20gZGF0YSBhdHRyaWJ1dGVcXG5cXG4gICAgICAgIHZhciBydWxlcyA9IHRoaXMucnVsZXMuc3BsaXQoJyAnKTsgLy8gSXRlcmF0ZSB0aHJvdWdoIGV2ZXJ5IHJ1bGUgZm91bmRcXG5cXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgdmFyIHJ1bGUgPSBydWxlc1tpXS5zcGxpdCgnLScpO1xcbiAgICAgICAgICB2YXIgcnVsZVNpemUgPSBydWxlLmxlbmd0aCA+IDEgPyBydWxlWzBdIDogJ3NtYWxsJztcXG4gICAgICAgICAgdmFyIHJ1bGVQbHVnaW4gPSBydWxlLmxlbmd0aCA+IDEgPyBydWxlWzFdIDogcnVsZVswXTtcXG5cXG4gICAgICAgICAgaWYgKE1lbnVQbHVnaW5zW3J1bGVQbHVnaW5dICE9PSBudWxsKSB7XFxuICAgICAgICAgICAgcnVsZXNUcmVlW3J1bGVTaXplXSA9IE1lbnVQbHVnaW5zW3J1bGVQbHVnaW5dO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLnJ1bGVzID0gcnVsZXNUcmVlO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9nZXRBbGxPcHRpb25zKCk7XFxuXFxuICAgICAgaWYgKCFqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuaXNFbXB0eU9iamVjdCh0aGlzLnJ1bGVzKSkge1xcbiAgICAgICAgdGhpcy5fY2hlY2tNZWRpYVF1ZXJpZXMoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2dldEFsbE9wdGlvbnNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEFsbE9wdGlvbnMoKSB7XFxuICAgICAgLy9nZXQgYWxsIGRlZmF1bHRzIGFuZCBvcHRpb25zXFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICBfdGhpcy5hbGxPcHRpb25zID0ge307XFxuXFxuICAgICAgZm9yICh2YXIga2V5IGluIE1lbnVQbHVnaW5zKSB7XFxuICAgICAgICBpZiAoTWVudVBsdWdpbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xcbiAgICAgICAgICB2YXIgb2JqID0gTWVudVBsdWdpbnNba2V5XTtcXG5cXG4gICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICB2YXIgZHVtbXlQbHVnaW4gPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoJzx1bD48L3VsPicpO1xcbiAgICAgICAgICAgIHZhciB0bXBQbHVnaW4gPSBuZXcgb2JqLnBsdWdpbihkdW1teVBsdWdpbiwgX3RoaXMub3B0aW9ucyk7XFxuXFxuICAgICAgICAgICAgZm9yICh2YXIga2V5S2V5IGluIHRtcFBsdWdpbi5vcHRpb25zKSB7XFxuICAgICAgICAgICAgICBpZiAodG1wUGx1Z2luLm9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5S2V5KSAmJiBrZXlLZXkgIT09ICd6ZlBsdWdpbicpIHtcXG4gICAgICAgICAgICAgICAgdmFyIG9iak9iaiA9IHRtcFBsdWdpbi5vcHRpb25zW2tleUtleV07XFxuICAgICAgICAgICAgICAgIF90aGlzLmFsbE9wdGlvbnNba2V5S2V5XSA9IG9iak9iajtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdG1wUGx1Z2luLmRlc3Ryb3koKTtcXG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgdGhlIE1lbnUuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2V2ZW50c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xcbiAgICAgIHRoaXMuX2NoYW5nZWRaZk1lZGlhUXVlcnlIYW5kbGVyID0gdGhpcy5fY2hlY2tNZWRpYVF1ZXJpZXMuYmluZCh0aGlzKTtcXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS5vbignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgdGhpcy5fY2hhbmdlZFpmTWVkaWFRdWVyeUhhbmRsZXIpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgdGhlIGN1cnJlbnQgc2NyZWVuIHdpZHRoIGFnYWluc3QgYXZhaWxhYmxlIG1lZGlhIHF1ZXJpZXMuIElmIHRoZSBtZWRpYSBxdWVyeSBoYXMgY2hhbmdlZCwgYW5kIHRoZSBwbHVnaW4gbmVlZGVkIGhhcyBjaGFuZ2VkLCB0aGUgcGx1Z2lucyB3aWxsIHN3YXAgb3V0LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9jaGVja01lZGlhUXVlcmllc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tNZWRpYVF1ZXJpZXMoKSB7XFxuICAgICAgdmFyIG1hdGNoZWRNcSxcXG4gICAgICAgICAgX3RoaXMgPSB0aGlzOyAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBydWxlIGFuZCBmaW5kIHRoZSBsYXN0IG1hdGNoaW5nIHJ1bGVcXG5cXG5cXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZWFjaCh0aGlzLnJ1bGVzLCBmdW5jdGlvbiAoa2V5KSB7XFxuICAgICAgICBpZiAoX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIk1lZGlhUXVlcnlcXFwiXS5hdExlYXN0KGtleSkpIHtcXG4gICAgICAgICAgbWF0Y2hlZE1xID0ga2V5O1xcbiAgICAgICAgfVxcbiAgICAgIH0pOyAvLyBObyBtYXRjaD8gTm8gZGljZVxcblxcbiAgICAgIGlmICghbWF0Y2hlZE1xKSByZXR1cm47IC8vIFBsdWdpbiBhbHJlYWR5IGluaXRpYWxpemVkPyBXZSBnb29kXFxuXFxuICAgICAgaWYgKHRoaXMuY3VycmVudFBsdWdpbiBpbnN0YW5jZW9mIHRoaXMucnVsZXNbbWF0Y2hlZE1xXS5wbHVnaW4pIHJldHVybjsgLy8gUmVtb3ZlIGV4aXN0aW5nIHBsdWdpbi1zcGVjaWZpYyBDU1MgY2xhc3Nlc1xcblxcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5lYWNoKE1lbnVQbHVnaW5zLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xcbiAgICAgICAgX3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModmFsdWUuY3NzQ2xhc3MpO1xcbiAgICAgIH0pOyAvLyBBZGQgdGhlIENTUyBjbGFzcyBmb3IgdGhlIG5ldyBwbHVnaW5cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMucnVsZXNbbWF0Y2hlZE1xXS5jc3NDbGFzcyk7IC8vIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGUgbmV3IHBsdWdpblxcblxcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRQbHVnaW4pIHtcXG4gICAgICAgIC8vZG9uJ3Qga25vdyB3aHkgYnV0IG9uIG5lc3RlZCBlbGVtZW50cyBkYXRhIHpmUGx1Z2luIGdldCdzIGxvc3RcXG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50UGx1Z2luLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJykgJiYgdGhpcy5zdG9yZXpmRGF0YSkgdGhpcy5jdXJyZW50UGx1Z2luLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJywgdGhpcy5zdG9yZXpmRGF0YSk7XFxuICAgICAgICB0aGlzLmN1cnJlbnRQbHVnaW4uZGVzdHJveSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9oYW5kbGVNYXJrdXAodGhpcy5ydWxlc1ttYXRjaGVkTXFdLmNzc0NsYXNzKTtcXG5cXG4gICAgICB0aGlzLmN1cnJlbnRQbHVnaW4gPSBuZXcgdGhpcy5ydWxlc1ttYXRjaGVkTXFdLnBsdWdpbih0aGlzLiRlbGVtZW50LCB7fSk7XFxuICAgICAgdGhpcy5zdG9yZXpmRGF0YSA9IHRoaXMuY3VycmVudFBsdWdpbi4kZWxlbWVudC5kYXRhKCd6ZlBsdWdpbicpO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9oYW5kbGVNYXJrdXBcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZU1hcmt1cCh0b1NldCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXFxuICAgICAgICAgIGZyb21TdHJpbmcgPSAnYWNjb3JkaW9uJztcXG5cXG4gICAgICB2YXIgJHBhbmVscyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnW2RhdGEtdGFicy1jb250ZW50PScgKyB0aGlzLiRlbGVtZW50LmF0dHIoJ2lkJykgKyAnXScpO1xcbiAgICAgIGlmICgkcGFuZWxzLmxlbmd0aCkgZnJvbVN0cmluZyA9ICd0YWJzJztcXG5cXG4gICAgICBpZiAoZnJvbVN0cmluZyA9PT0gdG9TZXQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgO1xcbiAgICAgIHZhciB0YWJzVGl0bGUgPSBfdGhpcy5hbGxPcHRpb25zLmxpbmtDbGFzcyA/IF90aGlzLmFsbE9wdGlvbnMubGlua0NsYXNzIDogJ3RhYnMtdGl0bGUnO1xcbiAgICAgIHZhciB0YWJzUGFuZWwgPSBfdGhpcy5hbGxPcHRpb25zLnBhbmVsQ2xhc3MgPyBfdGhpcy5hbGxPcHRpb25zLnBhbmVsQ2xhc3MgOiAndGFicy1wYW5lbCc7XFxuICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVBdHRyKCdyb2xlJyk7XFxuICAgICAgdmFyICRsaUhlYWRzID0gdGhpcy4kZWxlbWVudC5jaGlsZHJlbignLicgKyB0YWJzVGl0bGUgKyAnLFtkYXRhLWFjY29yZGlvbi1pdGVtXScpLnJlbW92ZUNsYXNzKHRhYnNUaXRsZSkucmVtb3ZlQ2xhc3MoJ2FjY29yZGlvbi1pdGVtJykucmVtb3ZlQXR0cignZGF0YS1hY2NvcmRpb24taXRlbScpO1xcbiAgICAgIHZhciAkbGlIZWFkc0EgPSAkbGlIZWFkcy5jaGlsZHJlbignYScpLnJlbW92ZUNsYXNzKCdhY2NvcmRpb24tdGl0bGUnKTtcXG5cXG4gICAgICBpZiAoZnJvbVN0cmluZyA9PT0gJ3RhYnMnKSB7XFxuICAgICAgICAkcGFuZWxzID0gJHBhbmVscy5jaGlsZHJlbignLicgKyB0YWJzUGFuZWwpLnJlbW92ZUNsYXNzKHRhYnNQYW5lbCkucmVtb3ZlQXR0cigncm9sZScpLnJlbW92ZUF0dHIoJ2FyaWEtaGlkZGVuJykucmVtb3ZlQXR0cignYXJpYS1sYWJlbGxlZGJ5Jyk7XFxuICAgICAgICAkcGFuZWxzLmNoaWxkcmVuKCdhJykucmVtb3ZlQXR0cigncm9sZScpLnJlbW92ZUF0dHIoJ2FyaWEtY29udHJvbHMnKS5yZW1vdmVBdHRyKCdhcmlhLXNlbGVjdGVkJyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgICRwYW5lbHMgPSAkbGlIZWFkcy5jaGlsZHJlbignW2RhdGEtdGFiLWNvbnRlbnRdJykucmVtb3ZlQ2xhc3MoJ2FjY29yZGlvbi1jb250ZW50Jyk7XFxuICAgICAgfVxcblxcbiAgICAgIDtcXG4gICAgICAkcGFuZWxzLmNzcyh7XFxuICAgICAgICBkaXNwbGF5OiAnJyxcXG4gICAgICAgIHZpc2liaWxpdHk6ICcnXFxuICAgICAgfSk7XFxuICAgICAgJGxpSGVhZHMuY3NzKHtcXG4gICAgICAgIGRpc3BsYXk6ICcnLFxcbiAgICAgICAgdmlzaWJpbGl0eTogJydcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAodG9TZXQgPT09ICdhY2NvcmRpb24nKSB7XFxuICAgICAgICAkcGFuZWxzLmVhY2goZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcXG4gICAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHZhbHVlKS5hcHBlbmRUbygkbGlIZWFkcy5nZXQoa2V5KSkuYWRkQ2xhc3MoJ2FjY29yZGlvbi1jb250ZW50JykuYXR0cignZGF0YS10YWItY29udGVudCcsICcnKS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlJykuY3NzKHtcXG4gICAgICAgICAgICBoZWlnaHQ6ICcnXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoJ1tkYXRhLXRhYnMtY29udGVudD0nICsgX3RoaXMuJGVsZW1lbnQuYXR0cignaWQnKSArICddJykuYWZ0ZXIoJzxkaXYgaWQ9XFxcInRhYnMtcGxhY2Vob2xkZXItJyArIF90aGlzLiRlbGVtZW50LmF0dHIoJ2lkJykgKyAnXFxcIj48L2Rpdj4nKS5kZXRhY2goKTtcXG4gICAgICAgICAgJGxpSGVhZHMuYWRkQ2xhc3MoJ2FjY29yZGlvbi1pdGVtJykuYXR0cignZGF0YS1hY2NvcmRpb24taXRlbScsICcnKTtcXG4gICAgICAgICAgJGxpSGVhZHNBLmFkZENsYXNzKCdhY2NvcmRpb24tdGl0bGUnKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gZWxzZSBpZiAodG9TZXQgPT09ICd0YWJzJykge1xcbiAgICAgICAgdmFyICR0YWJzQ29udGVudCA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnW2RhdGEtdGFicy1jb250ZW50PScgKyBfdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpICsgJ10nKTtcXG4gICAgICAgIHZhciAkcGxhY2Vob2xkZXIgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoJyN0YWJzLXBsYWNlaG9sZGVyLScgKyBfdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpKTtcXG5cXG4gICAgICAgIGlmICgkcGxhY2Vob2xkZXIubGVuZ3RoKSB7XFxuICAgICAgICAgICR0YWJzQ29udGVudCA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnPGRpdiBjbGFzcz1cXFwidGFicy1jb250ZW50XFxcIj48L2Rpdj4nKS5pbnNlcnRBZnRlcigkcGxhY2Vob2xkZXIpLmF0dHIoJ2RhdGEtdGFicy1jb250ZW50JywgX3RoaXMuJGVsZW1lbnQuYXR0cignaWQnKSk7XFxuICAgICAgICAgICRwbGFjZWhvbGRlci5yZW1vdmUoKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICR0YWJzQ29udGVudCA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnPGRpdiBjbGFzcz1cXFwidGFicy1jb250ZW50XFxcIj48L2Rpdj4nKS5pbnNlcnRBZnRlcihfdGhpcy4kZWxlbWVudCkuYXR0cignZGF0YS10YWJzLWNvbnRlbnQnLCBfdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIDtcXG4gICAgICAgICRwYW5lbHMuZWFjaChmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xcbiAgICAgICAgICB2YXIgdGVtcFZhbHVlID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHZhbHVlKS5hcHBlbmRUbygkdGFic0NvbnRlbnQpLmFkZENsYXNzKHRhYnNQYW5lbCk7XFxuICAgICAgICAgIHZhciBoYXNoID0gJGxpSGVhZHNBLmdldChrZXkpLmhhc2guc2xpY2UoMSk7XFxuICAgICAgICAgIHZhciBpZCA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh2YWx1ZSkuYXR0cignaWQnKSB8fCBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJHZXRZb0RpZ2l0c1xcXCJdKSg2LCAnYWNjb3JkaW9uJyk7XFxuXFxuICAgICAgICAgIGlmIChoYXNoICE9PSBpZCkge1xcbiAgICAgICAgICAgIGlmIChoYXNoICE9PSAnJykge1xcbiAgICAgICAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHZhbHVlKS5hdHRyKCdpZCcsIGhhc2gpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICBoYXNoID0gaWQ7XFxuICAgICAgICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodmFsdWUpLmF0dHIoJ2lkJywgaGFzaCk7XFxuICAgICAgICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoJGxpSGVhZHNBLmdldChrZXkpKS5hdHRyKCdocmVmJywganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCRsaUhlYWRzQS5nZXQoa2V5KSkuYXR0cignaHJlZicpLnJlcGxhY2UoJyMnLCAnJykgKyAnIycgKyBoYXNoKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIDtcXG4gICAgICAgICAgdmFyIGlzQWN0aXZlID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCRsaUhlYWRzLmdldChrZXkpKS5oYXNDbGFzcygnaXMtYWN0aXZlJyk7XFxuXFxuICAgICAgICAgIGlmIChpc0FjdGl2ZSkge1xcbiAgICAgICAgICAgIHRlbXBWYWx1ZS5hZGRDbGFzcygnaXMtYWN0aXZlJyk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgO1xcbiAgICAgICAgfSk7XFxuICAgICAgICAkbGlIZWFkcy5hZGRDbGFzcyh0YWJzVGl0bGUpO1xcbiAgICAgIH1cXG5cXG4gICAgICA7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIERlc3Ryb3lzIHRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBwbHVnaW4gb24gdGhpcyBlbGVtZW50LCBhcyB3ZWxsIGFzIHRoZSB3aW5kb3cgcmVzaXplIGhhbmRsZXIgdGhhdCBzd2l0Y2hlcyB0aGUgcGx1Z2lucyBvdXQuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2Rlc3Ryb3lcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgaWYgKHRoaXMuY3VycmVudFBsdWdpbikgdGhpcy5jdXJyZW50UGx1Z2luLmRlc3Ryb3koKTtcXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS5vZmYoJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIHRoaXMuX2NoYW5nZWRaZk1lZGlhUXVlcnlIYW5kbGVyKTtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzO1xcbn0oX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiUGx1Z2luXFxcIl0pO1xcblxcblJlc3BvbnNpdmVBY2NvcmRpb25UYWJzLmRlZmF1bHRzID0ge307XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi5yZXNwb25zaXZlQWNjb3JkaW9uVGFicy5qcz9cIil9LFwiLi9qcy9mb3VuZGF0aW9uLnJlc3BvbnNpdmVNZW51LmpzXCI6ZnVuY3Rpb24obW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbCgnX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJSZXNwb25zaXZlTWVudVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFJlc3BvbnNpdmVNZW51OyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBqcXVlcnkgKi8gXCJqcXVlcnlcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5ICovIFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeS5qc1wiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUudXRpbHMgKi8gXCIuL2pzL2ZvdW5kYXRpb24uY29yZS51dGlscy5qc1wiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnBsdWdpbiAqLyBcIi4vanMvZm91bmRhdGlvbi5jb3JlLnBsdWdpbi5qc1wiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fZHJvcGRvd25NZW51X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uZHJvcGRvd25NZW51ICovIFwiLi9qcy9mb3VuZGF0aW9uLmRyb3Bkb3duTWVudS5qc1wiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fZHJpbGxkb3duX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uZHJpbGxkb3duICovIFwiLi9qcy9mb3VuZGF0aW9uLmRyaWxsZG93bi5qc1wiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fYWNjb3JkaW9uTWVudV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmFjY29yZGlvbk1lbnUgKi8gXCIuL2pzL2ZvdW5kYXRpb24uYWNjb3JkaW9uTWVudS5qc1wiKTtcXG5cXG5cXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxcblxcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XFxuXFxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxcblxcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzblxcJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzblxcJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cXG5cXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxcblxcblxcblxcblxcblxcblxcblxcblxcbnZhciBNZW51UGx1Z2lucyA9IHtcXG4gIGRyb3Bkb3duOiB7XFxuICAgIGNzc0NsYXNzOiBcXCdkcm9wZG93blxcJyxcXG4gICAgcGx1Z2luOiBfZm91bmRhdGlvbl9kcm9wZG93bk1lbnVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIkRyb3Bkb3duTWVudVwiXVxcbiAgfSxcXG4gIGRyaWxsZG93bjoge1xcbiAgICBjc3NDbGFzczogXFwnZHJpbGxkb3duXFwnLFxcbiAgICBwbHVnaW46IF9mb3VuZGF0aW9uX2RyaWxsZG93bl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiRHJpbGxkb3duXCJdXFxuICB9LFxcbiAgYWNjb3JkaW9uOiB7XFxuICAgIGNzc0NsYXNzOiBcXCdhY2NvcmRpb24tbWVudVxcJyxcXG4gICAgcGx1Z2luOiBfZm91bmRhdGlvbl9hY2NvcmRpb25NZW51X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJBY2NvcmRpb25NZW51XCJdXFxuICB9XFxufTsgLy8gaW1wb3J0IFwiZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzLmpzXCI7XFxuXFxuLyoqXFxuICogUmVzcG9uc2l2ZU1lbnUgbW9kdWxlLlxcbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5yZXNwb25zaXZlTWVudVxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnlcXG4gKi9cXG5cXG52YXIgUmVzcG9uc2l2ZU1lbnUgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoX1BsdWdpbikge1xcbiAgX2luaGVyaXRzKFJlc3BvbnNpdmVNZW51LCBfUGx1Z2luKTtcXG5cXG4gIGZ1bmN0aW9uIFJlc3BvbnNpdmVNZW51KCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzcG9uc2l2ZU1lbnUpO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFJlc3BvbnNpdmVNZW51KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhSZXNwb25zaXZlTWVudSwgW3tcXG4gICAga2V5OiBcIl9zZXR1cFwiLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIHJlc3BvbnNpdmUgbWVudS5cXG4gICAgICogQGNsYXNzXFxuICAgICAqIEBuYW1lIFJlc3BvbnNpdmVNZW51XFxuICAgICAqIEBmaXJlcyBSZXNwb25zaXZlTWVudSNpbml0XFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYSBkcm9wZG93biBtZW51LlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50ID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGVsZW1lbnQpO1xcbiAgICAgIHRoaXMucnVsZXMgPSB0aGlzLiRlbGVtZW50LmRhdGEoXFwncmVzcG9uc2l2ZS1tZW51XFwnKTtcXG4gICAgICB0aGlzLmN1cnJlbnRNcSA9IG51bGw7XFxuICAgICAgdGhpcy5jdXJyZW50UGx1Z2luID0gbnVsbDtcXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9IFxcJ1Jlc3BvbnNpdmVNZW51XFwnOyAvLyBpZTkgYmFjayBjb21wYXRcXG5cXG4gICAgICB0aGlzLl9pbml0KCk7XFxuXFxuICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIHRoZSBNZW51IGJ5IHBhcnNpbmcgdGhlIGNsYXNzZXMgZnJvbSB0aGUgXFwnZGF0YS1SZXNwb25zaXZlTWVudVxcJyBhdHRyaWJ1dGUgb24gdGhlIGVsZW1lbnQuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcIl9pbml0XCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcXG4gICAgICBfZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIk1lZGlhUXVlcnlcIl0uX2luaXQoKTsgLy8gVGhlIGZpcnN0IHRpbWUgYW4gSW50ZXJjaGFuZ2UgcGx1Z2luIGlzIGluaXRpYWxpemVkLCB0aGlzLnJ1bGVzIGlzIGNvbnZlcnRlZCBmcm9tIGEgc3RyaW5nIG9mIFwiY2xhc3Nlc1wiIHRvIGFuIG9iamVjdCBvZiBydWxlc1xcblxcblxcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5ydWxlcyA9PT0gXFwnc3RyaW5nXFwnKSB7XFxuICAgICAgICB2YXIgcnVsZXNUcmVlID0ge307IC8vIFBhcnNlIHJ1bGVzIGZyb20gXCJjbGFzc2VzXCIgcHVsbGVkIGZyb20gZGF0YSBhdHRyaWJ1dGVcXG5cXG4gICAgICAgIHZhciBydWxlcyA9IHRoaXMucnVsZXMuc3BsaXQoXFwnIFxcJyk7IC8vIEl0ZXJhdGUgdGhyb3VnaCBldmVyeSBydWxlIGZvdW5kXFxuXFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIHZhciBydWxlID0gcnVsZXNbaV0uc3BsaXQoXFwnLVxcJyk7XFxuICAgICAgICAgIHZhciBydWxlU2l6ZSA9IHJ1bGUubGVuZ3RoID4gMSA/IHJ1bGVbMF0gOiBcXCdzbWFsbFxcJztcXG4gICAgICAgICAgdmFyIHJ1bGVQbHVnaW4gPSBydWxlLmxlbmd0aCA+IDEgPyBydWxlWzFdIDogcnVsZVswXTtcXG5cXG4gICAgICAgICAgaWYgKE1lbnVQbHVnaW5zW3J1bGVQbHVnaW5dICE9PSBudWxsKSB7XFxuICAgICAgICAgICAgcnVsZXNUcmVlW3J1bGVTaXplXSA9IE1lbnVQbHVnaW5zW3J1bGVQbHVnaW5dO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLnJ1bGVzID0gcnVsZXNUcmVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5pc0VtcHR5T2JqZWN0KHRoaXMucnVsZXMpKSB7XFxuICAgICAgICB0aGlzLl9jaGVja01lZGlhUXVlcmllcygpO1xcbiAgICAgIH0gLy8gQWRkIGRhdGEtbXV0YXRlIHNpbmNlIGNoaWxkcmVuIG1heSBuZWVkIGl0LlxcblxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cihcXCdkYXRhLW11dGF0ZVxcJywgdGhpcy4kZWxlbWVudC5hdHRyKFxcJ2RhdGEtbXV0YXRlXFwnKSB8fCBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiR2V0WW9EaWdpdHNcIl0pKDYsIFxcJ3Jlc3BvbnNpdmUtbWVudVxcJykpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplcyBldmVudHMgZm9yIHRoZSBNZW51LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXCJfZXZlbnRzXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub24oXFwnY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5XFwnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBfdGhpcy5fY2hlY2tNZWRpYVF1ZXJpZXMoKTtcXG4gICAgICB9KTsgLy8gJCh3aW5kb3cpLm9uKFxcJ3Jlc2l6ZS56Zi5SZXNwb25zaXZlTWVudVxcJywgZnVuY3Rpb24oKSB7XFxuICAgICAgLy8gICBfdGhpcy5fY2hlY2tNZWRpYVF1ZXJpZXMoKTtcXG4gICAgICAvLyB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2hlY2tzIHRoZSBjdXJyZW50IHNjcmVlbiB3aWR0aCBhZ2FpbnN0IGF2YWlsYWJsZSBtZWRpYSBxdWVyaWVzLiBJZiB0aGUgbWVkaWEgcXVlcnkgaGFzIGNoYW5nZWQsIGFuZCB0aGUgcGx1Z2luIG5lZWRlZCBoYXMgY2hhbmdlZCwgdGhlIHBsdWdpbnMgd2lsbCBzd2FwIG91dC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFwiX2NoZWNrTWVkaWFRdWVyaWVzXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tNZWRpYVF1ZXJpZXMoKSB7XFxuICAgICAgdmFyIG1hdGNoZWRNcSxcXG4gICAgICAgICAgX3RoaXMgPSB0aGlzOyAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBydWxlIGFuZCBmaW5kIHRoZSBsYXN0IG1hdGNoaW5nIHJ1bGVcXG5cXG5cXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZWFjaCh0aGlzLnJ1bGVzLCBmdW5jdGlvbiAoa2V5KSB7XFxuICAgICAgICBpZiAoX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJNZWRpYVF1ZXJ5XCJdLmF0TGVhc3Qoa2V5KSkge1xcbiAgICAgICAgICBtYXRjaGVkTXEgPSBrZXk7XFxuICAgICAgICB9XFxuICAgICAgfSk7IC8vIE5vIG1hdGNoPyBObyBkaWNlXFxuXFxuICAgICAgaWYgKCFtYXRjaGVkTXEpIHJldHVybjsgLy8gUGx1Z2luIGFscmVhZHkgaW5pdGlhbGl6ZWQ/IFdlIGdvb2RcXG5cXG4gICAgICBpZiAodGhpcy5jdXJyZW50UGx1Z2luIGluc3RhbmNlb2YgdGhpcy5ydWxlc1ttYXRjaGVkTXFdLnBsdWdpbikgcmV0dXJuOyAvLyBSZW1vdmUgZXhpc3RpbmcgcGx1Z2luLXNwZWNpZmljIENTUyBjbGFzc2VzXFxuXFxuICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmVhY2goTWVudVBsdWdpbnMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XFxuICAgICAgICBfdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh2YWx1ZS5jc3NDbGFzcyk7XFxuICAgICAgfSk7IC8vIEFkZCB0aGUgQ1NTIGNsYXNzIGZvciB0aGUgbmV3IHBsdWdpblxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5ydWxlc1ttYXRjaGVkTXFdLmNzc0NsYXNzKTsgLy8gQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoZSBuZXcgcGx1Z2luXFxuXFxuICAgICAgaWYgKHRoaXMuY3VycmVudFBsdWdpbikgdGhpcy5jdXJyZW50UGx1Z2luLmRlc3Ryb3koKTtcXG4gICAgICB0aGlzLmN1cnJlbnRQbHVnaW4gPSBuZXcgdGhpcy5ydWxlc1ttYXRjaGVkTXFdLnBsdWdpbih0aGlzLiRlbGVtZW50LCB7fSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIERlc3Ryb3lzIHRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBwbHVnaW4gb24gdGhpcyBlbGVtZW50LCBhcyB3ZWxsIGFzIHRoZSB3aW5kb3cgcmVzaXplIGhhbmRsZXIgdGhhdCBzd2l0Y2hlcyB0aGUgcGx1Z2lucyBvdXQuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcIl9kZXN0cm95XCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICB0aGlzLmN1cnJlbnRQbHVnaW4uZGVzdHJveSgpO1xcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLm9mZihcXCcuemYuUmVzcG9uc2l2ZU1lbnVcXCcpO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gUmVzcG9uc2l2ZU1lbnU7XFxufShfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiUGx1Z2luXCJdKTtcXG5cXG5SZXNwb25zaXZlTWVudS5kZWZhdWx0cyA9IHt9O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL2pzL2ZvdW5kYXRpb24ucmVzcG9uc2l2ZU1lbnUuanM/Jyl9LFwiLi9qcy9mb3VuZGF0aW9uLnJlc3BvbnNpdmVUb2dnbGUuanNcIjpmdW5jdGlvbihtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKCdfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlJlc3BvbnNpdmVUb2dnbGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBSZXNwb25zaXZlVG9nZ2xlOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBqcXVlcnkgKi8gXCJqcXVlcnlcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5ICovIFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeS5qc1wiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF9tb3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi51dGlsLm1vdGlvbiAqLyBcIi4vanMvZm91bmRhdGlvbi51dGlsLm1vdGlvbi5qc1wiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnBsdWdpbiAqLyBcIi4vanMvZm91bmRhdGlvbi5jb3JlLnBsdWdpbi5qc1wiKTtcXG5cXG5cXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxcblxcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XFxuXFxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxcblxcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzblxcJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzblxcJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cXG5cXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxcblxcblxcblxcblxcblxcbi8qKlxcbiAqIFJlc3BvbnNpdmVUb2dnbGUgbW9kdWxlLlxcbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5yZXNwb25zaXZlVG9nZ2xlXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5XFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tb3Rpb25cXG4gKi9cXG5cXG52YXIgUmVzcG9uc2l2ZVRvZ2dsZSA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uIChfUGx1Z2luKSB7XFxuICBfaW5oZXJpdHMoUmVzcG9uc2l2ZVRvZ2dsZSwgX1BsdWdpbik7XFxuXFxuICBmdW5jdGlvbiBSZXNwb25zaXZlVG9nZ2xlKCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzcG9uc2l2ZVRvZ2dsZSk7XFxuXFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoUmVzcG9uc2l2ZVRvZ2dsZSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoUmVzcG9uc2l2ZVRvZ2dsZSwgW3tcXG4gICAga2V5OiBcIl9zZXR1cFwiLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBUYWIgQmFyLlxcbiAgICAgKiBAY2xhc3NcXG4gICAgICogQG5hbWUgUmVzcG9uc2l2ZVRvZ2dsZVxcbiAgICAgKiBAZmlyZXMgUmVzcG9uc2l2ZVRvZ2dsZSNpbml0XFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhdHRhY2ggdGFiIGJhciBmdW5jdGlvbmFsaXR5IHRvLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50ID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGVsZW1lbnQpO1xcbiAgICAgIHRoaXMub3B0aW9ucyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoe30sIFJlc3BvbnNpdmVUb2dnbGUuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9IFxcJ1Jlc3BvbnNpdmVUb2dnbGVcXCc7IC8vIGllOSBiYWNrIGNvbXBhdFxcblxcbiAgICAgIHRoaXMuX2luaXQoKTtcXG5cXG4gICAgICB0aGlzLl9ldmVudHMoKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHRhYiBiYXIgYnkgZmluZGluZyB0aGUgdGFyZ2V0IGVsZW1lbnQsIHRvZ2dsaW5nIGVsZW1lbnQsIGFuZCBydW5uaW5nIHVwZGF0ZSgpLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXCJfaW5pdFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJNZWRpYVF1ZXJ5XCJdLl9pbml0KCk7XFxuXFxuICAgICAgdmFyIHRhcmdldElEID0gdGhpcy4kZWxlbWVudC5kYXRhKFxcJ3Jlc3BvbnNpdmUtdG9nZ2xlXFwnKTtcXG5cXG4gICAgICBpZiAoIXRhcmdldElEKSB7XFxuICAgICAgICBjb25zb2xlLmVycm9yKFxcJ1lvdXIgdGFiIGJhciBuZWVkcyBhbiBJRCBvZiBhIE1lbnUgYXMgdGhlIHZhbHVlIG9mIGRhdGEtdGFiLWJhci5cXCcpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLiR0YXJnZXRNZW51ID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKFwiI1wiLmNvbmNhdCh0YXJnZXRJRCkpO1xcbiAgICAgIHRoaXMuJHRvZ2dsZXIgPSB0aGlzLiRlbGVtZW50LmZpbmQoXFwnW2RhdGEtdG9nZ2xlXVxcJykuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciB0YXJnZXQgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykuZGF0YShcXCd0b2dnbGVcXCcpO1xcbiAgICAgICAgcmV0dXJuIHRhcmdldCA9PT0gdGFyZ2V0SUQgfHwgdGFyZ2V0ID09PSBcIlwiO1xcbiAgICAgIH0pO1xcbiAgICAgIHRoaXMub3B0aW9ucyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgdGhpcy4kdGFyZ2V0TWVudS5kYXRhKCkpOyAvLyBJZiB0aGV5IHdlcmUgc2V0LCBwYXJzZSB0aGUgYW5pbWF0aW9uIGNsYXNzZXNcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGUpIHtcXG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMub3B0aW9ucy5hbmltYXRlLnNwbGl0KFxcJyBcXCcpO1xcbiAgICAgICAgdGhpcy5hbmltYXRpb25JbiA9IGlucHV0WzBdO1xcbiAgICAgICAgdGhpcy5hbmltYXRpb25PdXQgPSBpbnB1dFsxXSB8fCBudWxsO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl91cGRhdGUoKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQWRkcyBuZWNlc3NhcnkgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSB0YWIgYmFyIHRvIHdvcmsuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcIl9ldmVudHNcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLl91cGRhdGVNcUhhbmRsZXIgPSB0aGlzLl91cGRhdGUuYmluZCh0aGlzKTtcXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS5vbihcXCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnlcXCcsIHRoaXMuX3VwZGF0ZU1xSGFuZGxlcik7XFxuICAgICAgdGhpcy4kdG9nZ2xlci5vbihcXCdjbGljay56Zi5yZXNwb25zaXZlVG9nZ2xlXFwnLCB0aGlzLnRvZ2dsZU1lbnUuYmluZCh0aGlzKSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyB0aGUgY3VycmVudCBtZWRpYSBxdWVyeSB0byBkZXRlcm1pbmUgaWYgdGhlIHRhYiBiYXIgc2hvdWxkIGJlIHZpc2libGUgb3IgaGlkZGVuLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXCJfdXBkYXRlXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKCkge1xcbiAgICAgIC8vIE1vYmlsZVxcbiAgICAgIGlmICghX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJNZWRpYVF1ZXJ5XCJdLmF0TGVhc3QodGhpcy5vcHRpb25zLmhpZGVGb3IpKSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LnNob3coKTtcXG4gICAgICAgIHRoaXMuJHRhcmdldE1lbnUuaGlkZSgpO1xcbiAgICAgIH0gLy8gRGVza3RvcFxcbiAgICAgIGVsc2Uge1xcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LmhpZGUoKTtcXG4gICAgICAgICAgdGhpcy4kdGFyZ2V0TWVudS5zaG93KCk7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFRvZ2dsZXMgdGhlIGVsZW1lbnQgYXR0YWNoZWQgdG8gdGhlIHRhYiBiYXIuIFRoZSB0b2dnbGUgb25seSBoYXBwZW5zIGlmIHRoZSBzY3JlZW4gaXMgc21hbGwgZW5vdWdoIHRvIGFsbG93IGl0LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQGZpcmVzIFJlc3BvbnNpdmVUb2dnbGUjdG9nZ2xlZFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcInRvZ2dsZU1lbnVcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZU1lbnUoKSB7XFxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICAgICAgaWYgKCFfZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIk1lZGlhUXVlcnlcIl0uYXRMZWFzdCh0aGlzLm9wdGlvbnMuaGlkZUZvcikpIHtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgZWxlbWVudCBhdHRhY2hlZCB0byB0aGUgdGFiIGJhciB0b2dnbGVzLlxcbiAgICAgICAgICogQGV2ZW50IFJlc3BvbnNpdmVUb2dnbGUjdG9nZ2xlZFxcbiAgICAgICAgICovXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGUpIHtcXG4gICAgICAgICAgaWYgKHRoaXMuJHRhcmdldE1lbnUuaXMoXFwnOmhpZGRlblxcJykpIHtcXG4gICAgICAgICAgICBfZm91bmRhdGlvbl91dGlsX21vdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiTW90aW9uXCJdLmFuaW1hdGVJbih0aGlzLiR0YXJnZXRNZW51LCB0aGlzLmFuaW1hdGlvbkluLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICBfdGhpczIuJGVsZW1lbnQudHJpZ2dlcihcXCd0b2dnbGVkLnpmLnJlc3BvbnNpdmVUb2dnbGVcXCcpO1xcblxcbiAgICAgICAgICAgICAgX3RoaXMyLiR0YXJnZXRNZW51LmZpbmQoXFwnW2RhdGEtbXV0YXRlXVxcJykudHJpZ2dlckhhbmRsZXIoXFwnbXV0YXRlbWUuemYudHJpZ2dlclxcJyk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgX2ZvdW5kYXRpb25fdXRpbF9tb3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIk1vdGlvblwiXS5hbmltYXRlT3V0KHRoaXMuJHRhcmdldE1lbnUsIHRoaXMuYW5pbWF0aW9uT3V0LCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICBfdGhpczIuJGVsZW1lbnQudHJpZ2dlcihcXCd0b2dnbGVkLnpmLnJlc3BvbnNpdmVUb2dnbGVcXCcpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB0aGlzLiR0YXJnZXRNZW51LnRvZ2dsZSgwKTtcXG4gICAgICAgICAgdGhpcy4kdGFyZ2V0TWVudS5maW5kKFxcJ1tkYXRhLW11dGF0ZV1cXCcpLnRyaWdnZXIoXFwnbXV0YXRlbWUuemYudHJpZ2dlclxcJyk7XFxuICAgICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXCd0b2dnbGVkLnpmLnJlc3BvbnNpdmVUb2dnbGVcXCcpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFwiX2Rlc3Ryb3lcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKFxcJy56Zi5yZXNwb25zaXZlVG9nZ2xlXFwnKTtcXG4gICAgICB0aGlzLiR0b2dnbGVyLm9mZihcXCcuemYucmVzcG9uc2l2ZVRvZ2dsZVxcJyk7XFxuICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub2ZmKFxcJ2NoYW5nZWQuemYubWVkaWFxdWVyeVxcJywgdGhpcy5fdXBkYXRlTXFIYW5kbGVyKTtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIFJlc3BvbnNpdmVUb2dnbGU7XFxufShfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiUGx1Z2luXCJdKTtcXG5cXG5SZXNwb25zaXZlVG9nZ2xlLmRlZmF1bHRzID0ge1xcbiAgLyoqXFxuICAgKiBUaGUgYnJlYWtwb2ludCBhZnRlciB3aGljaCB0aGUgbWVudSBpcyBhbHdheXMgc2hvd24sIGFuZCB0aGUgdGFiIGJhciBpcyBoaWRkZW4uXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgXFwnbWVkaXVtXFwnXFxuICAgKi9cXG4gIGhpZGVGb3I6IFxcJ21lZGl1bVxcJyxcXG5cXG4gIC8qKlxcbiAgICogVG8gZGVjaWRlIGlmIHRoZSB0b2dnbGUgc2hvdWxkIGJlIGFuaW1hdGVkIG9yIG5vdC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgYW5pbWF0ZTogZmFsc2VcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL2pzL2ZvdW5kYXRpb24ucmVzcG9uc2l2ZVRvZ2dsZS5qcz8nKX0sXCIuL2pzL2ZvdW5kYXRpb24ucmV2ZWFsLmpzXCI6ZnVuY3Rpb24obW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJSZXZlYWxcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFJldmVhbDsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganF1ZXJ5ICovIFxcXCJqcXVlcnlcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uY29yZS51dGlscyAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUudXRpbHMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmQgKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLmtleWJvYXJkLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeSAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX21vdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwubW90aW9uICovIFxcXCIuL2pzL2ZvdW5kYXRpb24udXRpbC5tb3Rpb24uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnBsdWdpbiAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUucGx1Z2luLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3V0aWxfdHJpZ2dlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzICovIFxcXCIuL2pzL2ZvdW5kYXRpb24udXRpbC50cmlnZ2Vycy5qc1xcXCIpO1xcblxcblxcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXFxcImZ1bmN0aW9uXFxcIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cXG5cXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXFxcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFxcXCIpOyB9IHJldHVybiBzZWxmOyB9XFxuXFxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblxcXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cXG5cXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxcblxcblxcblxcblxcblxcblxcblxcblxcbi8qKlxcbiAqIFJldmVhbCBtb2R1bGUuXFxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnJldmVhbFxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5XFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tb3Rpb24gaWYgdXNpbmcgYW5pbWF0aW9uc1xcbiAqL1xcblxcbnZhciBSZXZlYWwgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoX1BsdWdpbikge1xcbiAgX2luaGVyaXRzKFJldmVhbCwgX1BsdWdpbik7XFxuXFxuICBmdW5jdGlvbiBSZXZlYWwoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZXZlYWwpO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFJldmVhbCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoUmV2ZWFsLCBbe1xcbiAgICBrZXk6IFxcXCJfc2V0dXBcXFwiLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXZlYWwuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAbmFtZSBSZXZlYWxcXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIHVzZSBmb3IgdGhlIG1vZGFsLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbmFsIHBhcmFtZXRlcnMuXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZXh0ZW5kKHt9LCBSZXZlYWwuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdSZXZlYWwnOyAvLyBpZTkgYmFjayBjb21wYXRcXG5cXG4gICAgICB0aGlzLl9pbml0KCk7IC8vIFRyaWdnZXJzIGluaXQgaXMgaWRlbXBvdGVudCwganVzdCBuZWVkIHRvIG1ha2Ugc3VyZSBpdCBpcyBpbml0aWFsaXplZFxcblxcblxcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfdHJpZ2dlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcXFwiVHJpZ2dlcnNcXFwiXS5pbml0KGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYSk7XFxuICAgICAgX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJLZXlib2FyZFxcXCJdLnJlZ2lzdGVyKCdSZXZlYWwnLCB7XFxuICAgICAgICAnRVNDQVBFJzogJ2Nsb3NlJ1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgbW9kYWwgYnkgYWRkaW5nIHRoZSBvdmVybGF5IGFuZCBjbG9zZSBidXR0b25zLCAoaWYgc2VsZWN0ZWQpLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2luaXRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICAgICAgX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcIk1lZGlhUXVlcnlcXFwiXS5faW5pdCgpO1xcblxcbiAgICAgIHRoaXMuaWQgPSB0aGlzLiRlbGVtZW50LmF0dHIoJ2lkJyk7XFxuICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xcbiAgICAgIHRoaXMuY2FjaGVkID0ge1xcbiAgICAgICAgbXE6IF9mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJNZWRpYVF1ZXJ5XFxcIl0uY3VycmVudFxcbiAgICAgIH07XFxuICAgICAgdGhpcy4kYW5jaG9yID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKFxcXCJbZGF0YS1vcGVuPVxcXFxcXFwiXFxcIi5jb25jYXQodGhpcy5pZCwgXFxcIlxcXFxcXFwiXVxcXCIpKS5sZW5ndGggPyBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoXFxcIltkYXRhLW9wZW49XFxcXFxcXCJcXFwiLmNvbmNhdCh0aGlzLmlkLCBcXFwiXFxcXFxcXCJdXFxcIikpIDoganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKFxcXCJbZGF0YS10b2dnbGU9XFxcXFxcXCJcXFwiLmNvbmNhdCh0aGlzLmlkLCBcXFwiXFxcXFxcXCJdXFxcIikpO1xcbiAgICAgIHRoaXMuJGFuY2hvci5hdHRyKHtcXG4gICAgICAgICdhcmlhLWNvbnRyb2xzJzogdGhpcy5pZCxcXG4gICAgICAgICdhcmlhLWhhc3BvcHVwJzogdHJ1ZSxcXG4gICAgICAgICd0YWJpbmRleCc6IDBcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmZ1bGxTY3JlZW4gfHwgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZnVsbCcpKSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnMuZnVsbFNjcmVlbiA9IHRydWU7XFxuICAgICAgICB0aGlzLm9wdGlvbnMub3ZlcmxheSA9IGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJsYXkgJiYgIXRoaXMuJG92ZXJsYXkpIHtcXG4gICAgICAgIHRoaXMuJG92ZXJsYXkgPSB0aGlzLl9tYWtlT3ZlcmxheSh0aGlzLmlkKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcXG4gICAgICAgICdyb2xlJzogJ2RpYWxvZycsXFxuICAgICAgICAnYXJpYS1oaWRkZW4nOiB0cnVlLFxcbiAgICAgICAgJ2RhdGEteWV0aS1ib3gnOiB0aGlzLmlkLFxcbiAgICAgICAgJ2RhdGEtcmVzaXplJzogdGhpcy5pZFxcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmICh0aGlzLiRvdmVybGF5KSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmRldGFjaCgpLmFwcGVuZFRvKHRoaXMuJG92ZXJsYXkpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmRldGFjaCgpLmFwcGVuZFRvKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzLm9wdGlvbnMuYXBwZW5kVG8pKTtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoJ3dpdGhvdXQtb3ZlcmxheScpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9ldmVudHMoKTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5rICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoID09PSBcXFwiI1xcXCIuY29uY2F0KHRoaXMuaWQpKSB7XFxuICAgICAgICB0aGlzLm9uTG9hZExpc3RlbmVyID0gT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwib25Mb2FkXFxcIl0pKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHJldHVybiBfdGhpczIub3BlbigpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGFuIG92ZXJsYXkgZGl2IHRvIGRpc3BsYXkgYmVoaW5kIHRoZSBtb2RhbC5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9tYWtlT3ZlcmxheVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZU92ZXJsYXkoKSB7XFxuICAgICAgdmFyIGFkZGl0aW9uYWxPdmVybGF5Q2xhc3NlcyA9ICcnO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWRkaXRpb25hbE92ZXJsYXlDbGFzc2VzKSB7XFxuICAgICAgICBhZGRpdGlvbmFsT3ZlcmxheUNsYXNzZXMgPSAnICcgKyB0aGlzLm9wdGlvbnMuYWRkaXRpb25hbE92ZXJsYXlDbGFzc2VzO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCdyZXZlYWwtb3ZlcmxheScgKyBhZGRpdGlvbmFsT3ZlcmxheUNsYXNzZXMpLmFwcGVuZFRvKHRoaXMub3B0aW9ucy5hcHBlbmRUbyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFVwZGF0ZXMgcG9zaXRpb24gb2YgbW9kYWxcXG4gICAgICogVE9ETzogIEZpZ3VyZSBvdXQgaWYgd2UgYWN0dWFsbHkgbmVlZCB0byBjYWNoZSB0aGVzZSB2YWx1ZXMgb3IgaWYgaXQgZG9lc24ndCBtYXR0ZXJcXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl91cGRhdGVQb3NpdGlvblxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlUG9zaXRpb24oKSB7XFxuICAgICAgdmFyIHdpZHRoID0gdGhpcy4kZWxlbWVudC5vdXRlcldpZHRoKCk7XFxuICAgICAgdmFyIG91dGVyV2lkdGggPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS53aWR0aCgpO1xcbiAgICAgIHZhciBoZWlnaHQgPSB0aGlzLiRlbGVtZW50Lm91dGVySGVpZ2h0KCk7XFxuICAgICAgdmFyIG91dGVySGVpZ2h0ID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykuaGVpZ2h0KCk7XFxuICAgICAgdmFyIGxlZnQsXFxuICAgICAgICAgIHRvcCA9IG51bGw7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oT2Zmc2V0ID09PSAnYXV0bycpIHtcXG4gICAgICAgIGxlZnQgPSBwYXJzZUludCgob3V0ZXJXaWR0aCAtIHdpZHRoKSAvIDIsIDEwKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbGVmdCA9IHBhcnNlSW50KHRoaXMub3B0aW9ucy5oT2Zmc2V0LCAxMCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudk9mZnNldCA9PT0gJ2F1dG8nKSB7XFxuICAgICAgICBpZiAoaGVpZ2h0ID4gb3V0ZXJIZWlnaHQpIHtcXG4gICAgICAgICAgdG9wID0gcGFyc2VJbnQoTWF0aC5taW4oMTAwLCBvdXRlckhlaWdodCAvIDEwKSwgMTApO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdG9wID0gcGFyc2VJbnQoKG91dGVySGVpZ2h0IC0gaGVpZ2h0KSAvIDQsIDEwKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy52T2Zmc2V0ICE9PSBudWxsKSB7XFxuICAgICAgICB0b3AgPSBwYXJzZUludCh0aGlzLm9wdGlvbnMudk9mZnNldCwgMTApO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodG9wICE9PSBudWxsKSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmNzcyh7XFxuICAgICAgICAgIHRvcDogdG9wICsgJ3B4J1xcbiAgICAgICAgfSk7XFxuICAgICAgfSAvLyBvbmx5IHdvcnJ5IGFib3V0IGxlZnQgaWYgd2UgZG9uJ3QgaGF2ZSBhbiBvdmVybGF5IG9yIHdlIGhhdmUgYSBob3Jpem9udGFsIG9mZnNldCxcXG4gICAgICAvLyBvdGhlcndpc2Ugd2UncmUgcGVyZmVjdGx5IGluIHRoZSBtaWRkbGVcXG5cXG5cXG4gICAgICBpZiAoIXRoaXMuJG92ZXJsYXkgfHwgdGhpcy5vcHRpb25zLmhPZmZzZXQgIT09ICdhdXRvJykge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5jc3Moe1xcbiAgICAgICAgICBsZWZ0OiBsZWZ0ICsgJ3B4J1xcbiAgICAgICAgfSk7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmNzcyh7XFxuICAgICAgICAgIG1hcmdpbjogJzBweCdcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQWRkcyBldmVudCBoYW5kbGVycyBmb3IgdGhlIG1vZGFsLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2V2ZW50c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xcblxcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5vbih7XFxuICAgICAgICAnb3Blbi56Zi50cmlnZ2VyJzogdGhpcy5vcGVuLmJpbmQodGhpcyksXFxuICAgICAgICAnY2xvc2UuemYudHJpZ2dlcic6IGZ1bmN0aW9uIGNsb3NlWmZUcmlnZ2VyKGV2ZW50LCAkZWxlbWVudCkge1xcbiAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBfdGhpcy4kZWxlbWVudFswXSB8fCBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZXZlbnQudGFyZ2V0KS5wYXJlbnRzKCdbZGF0YS1jbG9zYWJsZV0nKVswXSA9PT0gJGVsZW1lbnQpIHtcXG4gICAgICAgICAgICAvLyBvbmx5IGNsb3NlIHJldmVhbCB3aGVuIGl0J3MgZXhwbGljaXRseSBjYWxsZWRcXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLmNsb3NlLmFwcGx5KF90aGlzMyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICAndG9nZ2xlLnpmLnRyaWdnZXInOiB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpLFxcbiAgICAgICAgJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInOiBmdW5jdGlvbiByZXNpemVtZVpmVHJpZ2dlcigpIHtcXG4gICAgICAgICAgX3RoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgJiYgdGhpcy5vcHRpb25zLm92ZXJsYXkpIHtcXG4gICAgICAgIHRoaXMuJG92ZXJsYXkub2ZmKCcuemYucmV2ZWFsJykub24oJ2NsaWNrLnpmLnJldmVhbCcsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIGlmIChlLnRhcmdldCA9PT0gX3RoaXMuJGVsZW1lbnRbMF0gfHwganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNvbnRhaW5zKF90aGlzLiRlbGVtZW50WzBdLCBlLnRhcmdldCkgfHwgIWpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jb250YWlucyhkb2N1bWVudCwgZS50YXJnZXQpKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIF90aGlzLmNsb3NlKCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluaykge1xcbiAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub24oXFxcImhhc2hjaGFuZ2UuemYucmV2ZWFsOlxcXCIuY29uY2F0KHRoaXMuaWQpLCB0aGlzLl9oYW5kbGVTdGF0ZS5iaW5kKHRoaXMpKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEhhbmRsZXMgbW9kYWwgbWV0aG9kcyBvbiBiYWNrL2ZvcndhcmQgYnV0dG9uIGNsaWNrcyBvciBhbnkgb3RoZXIgZXZlbnQgdGhhdCB0cmlnZ2VycyBoYXNoY2hhbmdlLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2hhbmRsZVN0YXRlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVTdGF0ZShlKSB7XFxuICAgICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5oYXNoID09PSAnIycgKyB0aGlzLmlkICYmICF0aGlzLmlzQWN0aXZlKSB7XFxuICAgICAgICB0aGlzLm9wZW4oKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgKiBEaXNhYmxlcyB0aGUgc2Nyb2xsIHdoZW4gUmV2ZWFsIGlzIHNob3duIHRvIHByZXZlbnQgdGhlIGJhY2tncm91bmQgZnJvbSBzaGlmdGluZ1xcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxUb3AgLSBTY3JvbGwgdG8gdmlzdWFsbHkgYXBwbHksIHdpbmRvdyBjdXJyZW50IHNjcm9sbCBieSBkZWZhdWx0XFxuICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9kaXNhYmxlU2Nyb2xsXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kaXNhYmxlU2Nyb2xsKHNjcm9sbFRvcCkge1xcbiAgICAgIHNjcm9sbFRvcCA9IHNjcm9sbFRvcCB8fCBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS5zY3JvbGxUb3AoKTtcXG5cXG4gICAgICBpZiAoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGRvY3VtZW50KS5oZWlnaHQoKSA+IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLmhlaWdodCgpKSB7XFxuICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoXFxcImh0bWxcXFwiKS5jc3MoXFxcInRvcFxcXCIsIC1zY3JvbGxUb3ApO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgKiBSZWVuYWJsZXMgdGhlIHNjcm9sbCB3aGVuIFJldmVhbCBjbG9zZXNcXG4gICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsVG9wIC0gU2Nyb2xsIHRvIHJlc3RvcmUsIGh0bWwgXFxcInRvcFxcXCIgcHJvcGVydHkgYnkgZGVmYXVsdCAoYXMgc2V0IGJ5IGBfZGlzYWJsZVNjcm9sbGApXFxuICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9lbmFibGVTY3JvbGxcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VuYWJsZVNjcm9sbChzY3JvbGxUb3ApIHtcXG4gICAgICBzY3JvbGxUb3AgPSBzY3JvbGxUb3AgfHwgcGFyc2VJbnQoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKFxcXCJodG1sXFxcIikuY3NzKFxcXCJ0b3BcXFwiKSk7XFxuXFxuICAgICAgaWYgKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShkb2N1bWVudCkuaGVpZ2h0KCkgPiBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS5oZWlnaHQoKSkge1xcbiAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKFxcXCJodG1sXFxcIikuY3NzKFxcXCJ0b3BcXFwiLCBcXFwiXFxcIik7XFxuICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS5zY3JvbGxUb3AoLXNjcm9sbFRvcCk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBPcGVucyB0aGUgbW9kYWwgY29udHJvbGxlZCBieSBgdGhpcy4kYW5jaG9yYCwgYW5kIGNsb3NlcyBhbGwgb3RoZXJzIGJ5IGRlZmF1bHQuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAZmlyZXMgUmV2ZWFsI2Nsb3NlbWVcXG4gICAgICogQGZpcmVzIFJldmVhbCNvcGVuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJvcGVuXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW4oKSB7XFxuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XFxuXFxuICAgICAgLy8gZWl0aGVyIHVwZGF0ZSBvciByZXBsYWNlIGJyb3dzZXIgaGlzdG9yeVxcbiAgICAgIHZhciBoYXNoID0gXFxcIiNcXFwiLmNvbmNhdCh0aGlzLmlkKTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5rICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoICE9PSBoYXNoKSB7XFxuICAgICAgICBpZiAod2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKSB7XFxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBkYXRlSGlzdG9yeSkge1xcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSh7fSwgJycsIGhhc2gpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7fSwgJycsIGhhc2gpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IGhhc2g7XFxuICAgICAgICB9XFxuICAgICAgfSAvLyBSZW1lbWJlciBhbmNob3IgdGhhdCBvcGVuZWQgaXQgdG8gc2V0IGZvY3VzIGJhY2sgbGF0ZXIsIGhhdmUgZ2VuZXJhbCBhbmNob3JzIGFzIGZhbGxiYWNrXFxuXFxuXFxuICAgICAgdGhpcy4kYWN0aXZlQW5jaG9yID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmlzKHRoaXMuJGFuY2hvcikgPyBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgOiB0aGlzLiRhbmNob3I7XFxuICAgICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7IC8vIE1ha2UgZWxlbWVudHMgaW52aXNpYmxlLCBidXQgcmVtb3ZlIGRpc3BsYXk6IG5vbmUgc28gd2UgY2FuIGdldCBzaXplIGFuZCBwb3NpdGlvbmluZ1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQuY3NzKHtcXG4gICAgICAgICd2aXNpYmlsaXR5JzogJ2hpZGRlbidcXG4gICAgICB9KS5zaG93KCkuc2Nyb2xsVG9wKDApO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcmxheSkge1xcbiAgICAgICAgdGhpcy4kb3ZlcmxheS5jc3Moe1xcbiAgICAgICAgICAndmlzaWJpbGl0eSc6ICdoaWRkZW4nXFxuICAgICAgICB9KS5zaG93KCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5oaWRlKCkuY3NzKHtcXG4gICAgICAgICd2aXNpYmlsaXR5JzogJydcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAodGhpcy4kb3ZlcmxheSkge1xcbiAgICAgICAgdGhpcy4kb3ZlcmxheS5jc3Moe1xcbiAgICAgICAgICAndmlzaWJpbGl0eSc6ICcnXFxuICAgICAgICB9KS5oaWRlKCk7XFxuXFxuICAgICAgICBpZiAodGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZmFzdCcpKSB7XFxuICAgICAgICAgIHRoaXMuJG92ZXJsYXkuYWRkQ2xhc3MoJ2Zhc3QnKTtcXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy4kZWxlbWVudC5oYXNDbGFzcygnc2xvdycpKSB7XFxuICAgICAgICAgIHRoaXMuJG92ZXJsYXkuYWRkQ2xhc3MoJ3Nsb3cnKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubXVsdGlwbGVPcGVuZWQpIHtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBtb2RhbCBvcGVucy5cXG4gICAgICAgICAqIENsb3NlcyBhbnkgb3RoZXIgbW9kYWxzIHRoYXQgYXJlIGN1cnJlbnRseSBvcGVuXFxuICAgICAgICAgKiBAZXZlbnQgUmV2ZWFsI2Nsb3NlbWVcXG4gICAgICAgICAqL1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjbG9zZW1lLnpmLnJldmVhbCcsIHRoaXMuaWQpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9kaXNhYmxlU2Nyb2xsKCk7XFxuXFxuICAgICAgdmFyIF90aGlzID0gdGhpczsgLy8gTW90aW9uIFVJIG1ldGhvZCBvZiByZXZlYWxcXG5cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGlvbkluKSB7XFxuICAgICAgICB2YXIgYWZ0ZXJBbmltYXRpb24gPSBmdW5jdGlvbiBhZnRlckFuaW1hdGlvbigpIHtcXG4gICAgICAgICAgX3RoaXMuJGVsZW1lbnQuYXR0cih7XFxuICAgICAgICAgICAgJ2FyaWEtaGlkZGVuJzogZmFsc2UsXFxuICAgICAgICAgICAgJ3RhYmluZGV4JzogLTFcXG4gICAgICAgICAgfSkuZm9jdXMoKTtcXG5cXG4gICAgICAgICAgX3RoaXMuX2FkZEdsb2JhbENsYXNzZXMoKTtcXG5cXG4gICAgICAgICAgX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJLZXlib2FyZFxcXCJdLnRyYXBGb2N1cyhfdGhpcy4kZWxlbWVudCk7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vdmVybGF5KSB7XFxuICAgICAgICAgIF9mb3VuZGF0aW9uX3V0aWxfbW90aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcIk1vdGlvblxcXCJdLmFuaW1hdGVJbih0aGlzLiRvdmVybGF5LCAnZmFkZS1pbicpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgX2ZvdW5kYXRpb25fdXRpbF9tb3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiTW90aW9uXFxcIl0uYW5pbWF0ZUluKHRoaXMuJGVsZW1lbnQsIHRoaXMub3B0aW9ucy5hbmltYXRpb25JbiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBpZiAoX3RoaXM0LiRlbGVtZW50KSB7XFxuICAgICAgICAgICAgLy8gcHJvdGVjdCBhZ2FpbnN0IG9iamVjdCBoYXZpbmcgYmVlbiByZW1vdmVkXFxuICAgICAgICAgICAgX3RoaXM0LmZvY3VzYWJsZUVsZW1lbnRzID0gX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJLZXlib2FyZFxcXCJdLmZpbmRGb2N1c2FibGUoX3RoaXM0LiRlbGVtZW50KTtcXG4gICAgICAgICAgICBhZnRlckFuaW1hdGlvbigpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9IC8vIGpRdWVyeSBtZXRob2Qgb2YgcmV2ZWFsXFxuICAgICAgZWxzZSB7XFxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcmxheSkge1xcbiAgICAgICAgICAgIHRoaXMuJG92ZXJsYXkuc2hvdygwKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LnNob3codGhpcy5vcHRpb25zLnNob3dEZWxheSk7XFxuICAgICAgICB9IC8vIGhhbmRsZSBhY2Nlc3NpYmlsaXR5XFxuXFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcXG4gICAgICAgICdhcmlhLWhpZGRlbic6IGZhbHNlLFxcbiAgICAgICAgJ3RhYmluZGV4JzogLTFcXG4gICAgICB9KS5mb2N1cygpO1xcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiS2V5Ym9hcmRcXFwiXS50cmFwRm9jdXModGhpcy4kZWxlbWVudCk7XFxuXFxuICAgICAgdGhpcy5fYWRkR2xvYmFsQ2xhc3NlcygpO1xcblxcbiAgICAgIHRoaXMuX2FkZEdsb2JhbExpc3RlbmVycygpO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG1vZGFsIGhhcyBzdWNjZXNzZnVsbHkgb3BlbmVkLlxcbiAgICAgICAqIEBldmVudCBSZXZlYWwjb3BlblxcbiAgICAgICAqL1xcblxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignb3Blbi56Zi5yZXZlYWwnKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQWRkcyBjbGFzc2VzIGFuZCBsaXN0ZW5lcnMgb24gZG9jdW1lbnQgcmVxdWlyZWQgYnkgb3BlbiBtb2RhbHMuXFxuICAgICAqXFxuICAgICAqIFRoZSBmb2xsb3dpbmcgY2xhc3NlcyBhcmUgYWRkZWQgYW5kIHVwZGF0ZWQ6XFxuICAgICAqIC0gYC5pcy1yZXZlYWwtb3BlbmAgLSBQcmV2ZW50cyB0aGUgc2Nyb2xsIG9uIGRvY3VtZW50XFxuICAgICAqIC0gYC56Zi1oYXMtc2Nyb2xsYCAgLSBEaXNwbGF5cyBhIGRpc2FibGVkIHNjcm9sbGJhciBvbiBkb2N1bWVudCBpZiByZXF1aXJlZCBsaWtlIGlmIHRoZVxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsIHdhcyBub3QgZGlzYWJsZWQuIFRoaXMgcHJldmVudCBhIFxcXCJzaGlmdFxcXCIgb2YgdGhlIHBhZ2UgY29udGVudCBkdWVcXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgIHRoZSBzY3JvbGxiYXIgZGlzYXBwZWFyaW5nIHdoZW4gdGhlIG1vZGFsIG9wZW5zLlxcbiAgICAgKlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2FkZEdsb2JhbENsYXNzZXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEdsb2JhbENsYXNzZXMoKSB7XFxuICAgICAgdmFyIHVwZGF0ZVNjcm9sbGJhckNsYXNzID0gZnVuY3Rpb24gdXBkYXRlU2Nyb2xsYmFyQ2xhc3MoKSB7XFxuICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoJ2h0bWwnKS50b2dnbGVDbGFzcygnemYtaGFzLXNjcm9sbCcsICEhKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShkb2N1bWVudCkuaGVpZ2h0KCkgPiBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS5oZWlnaHQoKSkpO1xcbiAgICAgIH07XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5vbigncmVzaXplbWUuemYudHJpZ2dlci5yZXZlYWxTY3JvbGxiYXJMaXN0ZW5lcicsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiB1cGRhdGVTY3JvbGxiYXJDbGFzcygpO1xcbiAgICAgIH0pO1xcbiAgICAgIHVwZGF0ZVNjcm9sbGJhckNsYXNzKCk7XFxuICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCdodG1sJykuYWRkQ2xhc3MoJ2lzLXJldmVhbC1vcGVuJyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFJlbW92ZXMgY2xhc3NlcyBhbmQgbGlzdGVuZXJzIG9uIGRvY3VtZW50IHRoYXQgd2VyZSByZXF1aXJlZCBieSBvcGVuIG1vZGFscy5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9yZW1vdmVHbG9iYWxDbGFzc2VzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVHbG9iYWxDbGFzc2VzKCkge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdyZXNpemVtZS56Zi50cmlnZ2VyLnJldmVhbFNjcm9sbGJhckxpc3RlbmVyJyk7XFxuICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCdodG1sJykucmVtb3ZlQ2xhc3MoJ2lzLXJldmVhbC1vcGVuJyk7XFxuICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCdodG1sJykucmVtb3ZlQ2xhc3MoJ3pmLWhhcy1zY3JvbGwnKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQWRkcyBleHRyYSBldmVudCBoYW5kbGVycyBmb3IgdGhlIGJvZHkgYW5kIHdpbmRvdyBpZiBuZWNlc3NhcnkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfYWRkR2xvYmFsTGlzdGVuZXJzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRHbG9iYWxMaXN0ZW5lcnMoKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICBpZiAoIXRoaXMuJGVsZW1lbnQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9IC8vIElmIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgY2xlYW51cCwgZG9uJ3QgZnJlYWsgb3V0XFxuXFxuXFxuICAgICAgdGhpcy5mb2N1c2FibGVFbGVtZW50cyA9IF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiS2V5Ym9hcmRcXFwiXS5maW5kRm9jdXNhYmxlKHRoaXMuJGVsZW1lbnQpO1xcblxcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLm92ZXJsYXkgJiYgdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayAmJiAhdGhpcy5vcHRpb25zLmZ1bGxTY3JlZW4pIHtcXG4gICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnYm9keScpLm9uKCdjbGljay56Zi5yZXZlYWwnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICBpZiAoZS50YXJnZXQgPT09IF90aGlzLiRlbGVtZW50WzBdIHx8IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jb250YWlucyhfdGhpcy4kZWxlbWVudFswXSwgZS50YXJnZXQpIHx8ICFqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY29udGFpbnMoZG9jdW1lbnQsIGUudGFyZ2V0KSkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkVzYykge1xcbiAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub24oJ2tleWRvd24uemYucmV2ZWFsJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJLZXlib2FyZFxcXCJdLmhhbmRsZUtleShlLCAnUmV2ZWFsJywge1xcbiAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcXG4gICAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmNsb3NlT25Fc2MpIHtcXG4gICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDbG9zZXMgdGhlIG1vZGFsLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQGZpcmVzIFJldmVhbCNjbG9zZWRcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImNsb3NlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xcbiAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSB8fCAhdGhpcy4kZWxlbWVudC5pcygnOnZpc2libGUnKSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzOyAvLyBNb3Rpb24gVUkgbWV0aG9kIG9mIGhpZGluZ1xcblxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYW5pbWF0aW9uT3V0KSB7XFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJsYXkpIHtcXG4gICAgICAgICAgX2ZvdW5kYXRpb25fdXRpbF9tb3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiTW90aW9uXFxcIl0uYW5pbWF0ZU91dCh0aGlzLiRvdmVybGF5LCAnZmFkZS1vdXQnKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIF9mb3VuZGF0aW9uX3V0aWxfbW90aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcIk1vdGlvblxcXCJdLmFuaW1hdGVPdXQodGhpcy4kZWxlbWVudCwgdGhpcy5vcHRpb25zLmFuaW1hdGlvbk91dCwgZmluaXNoVXApO1xcbiAgICAgIH0gLy8galF1ZXJ5IG1ldGhvZCBvZiBoaWRpbmdcXG4gICAgICBlbHNlIHtcXG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5oaWRlKHRoaXMub3B0aW9ucy5oaWRlRGVsYXkpO1xcblxcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJsYXkpIHtcXG4gICAgICAgICAgICB0aGlzLiRvdmVybGF5LmhpZGUoMCwgZmluaXNoVXApO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGZpbmlzaFVwKCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gLy8gQ29uZGl0aW9uYWxzIHRvIHJlbW92ZSBleHRyYSBldmVudCBsaXN0ZW5lcnMgYWRkZWQgb24gb3BlblxcblxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkVzYykge1xcbiAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub2ZmKCdrZXlkb3duLnpmLnJldmVhbCcpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5vdmVybGF5ICYmIHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spIHtcXG4gICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnYm9keScpLm9mZignY2xpY2suemYucmV2ZWFsJyk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdrZXlkb3duLnpmLnJldmVhbCcpO1xcblxcbiAgICAgIGZ1bmN0aW9uIGZpbmlzaFVwKCkge1xcbiAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHRvcCBiZWZvcmUgdGhlIG1vZGFsIGlzIGNsb3NlZCBhbmQgcmVzdG9yZSB0aGUgc2Nyb2xsIGFmdGVyLlxcbiAgICAgICAgLy8gVE9ETzogdXNlIGNvbXBvbmVudCBwcm9wZXJ0aWVzIGluc3RlYWQgb2YgSFRNTCBwcm9wZXJ0aWVzXFxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3p1cmIvZm91bmRhdGlvbi1zaXRlcy9wdWxsLzEwNzg2XFxuICAgICAgICB2YXIgc2Nyb2xsVG9wID0gcGFyc2VJbnQoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKFxcXCJodG1sXFxcIikuY3NzKFxcXCJ0b3BcXFwiKSk7XFxuXFxuICAgICAgICBpZiAoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCcucmV2ZWFsOnZpc2libGUnKS5sZW5ndGggPT09IDApIHtcXG4gICAgICAgICAgX3RoaXMuX3JlbW92ZUdsb2JhbENsYXNzZXMoKTsgLy8gYWxzbyByZW1vdmUgLmlzLXJldmVhbC1vcGVuIGZyb20gdGhlIGh0bWwgZWxlbWVudCB3aGVuIHRoZXJlIGlzIG5vIG9wZW5lZCByZXZlYWxcXG5cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiS2V5Ym9hcmRcXFwiXS5yZWxlYXNlRm9jdXMoX3RoaXMuJGVsZW1lbnQpO1xcblxcbiAgICAgICAgX3RoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1oaWRkZW4nLCB0cnVlKTtcXG5cXG4gICAgICAgIF90aGlzLl9lbmFibGVTY3JvbGwoc2Nyb2xsVG9wKTtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBtb2RhbCBpcyBkb25lIGNsb3NpbmcuXFxuICAgICAgICAqIEBldmVudCBSZXZlYWwjY2xvc2VkXFxuICAgICAgICAqL1xcblxcblxcbiAgICAgICAgX3RoaXMuJGVsZW1lbnQudHJpZ2dlcignY2xvc2VkLnpmLnJldmVhbCcpO1xcbiAgICAgIH1cXG4gICAgICAvKipcXG4gICAgICAqIFJlc2V0cyB0aGUgbW9kYWwgY29udGVudFxcbiAgICAgICogVGhpcyBwcmV2ZW50cyBhIHJ1bm5pbmcgdmlkZW8gdG8ga2VlcCBnb2luZyBpbiB0aGUgYmFja2dyb3VuZFxcbiAgICAgICovXFxuXFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXNldE9uQ2xvc2UpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuaHRtbCh0aGlzLiRlbGVtZW50Lmh0bWwoKSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTsgLy8gSWYgZGVlcExpbmsgYW5kIHdlIGRpZCBub3Qgc3dpdGNoZWQgdG8gYW4gb3RoZXIgbW9kYWwuLi5cXG5cXG4gICAgICBpZiAoX3RoaXMub3B0aW9ucy5kZWVwTGluayAmJiB3aW5kb3cubG9jYXRpb24uaGFzaCA9PT0gXFxcIiNcXFwiLmNvbmNhdCh0aGlzLmlkKSkge1xcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBoaXN0b3J5IGhhc2hcXG4gICAgICAgIGlmICh3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUpIHtcXG4gICAgICAgICAgdmFyIHVybFdpdGhvdXRIYXNoID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaDtcXG5cXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGRhdGVIaXN0b3J5KSB7XFxuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHt9LCAnJywgdXJsV2l0aG91dEhhc2gpOyAvLyByZW1vdmUgdGhlIGhhc2hcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoJycsIGRvY3VtZW50LnRpdGxlLCB1cmxXaXRob3V0SGFzaCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gJyc7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuJGFjdGl2ZUFuY2hvci5mb2N1cygpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBUb2dnbGVzIHRoZSBvcGVuL2Nsb3NlZCBzdGF0ZSBvZiBhIG1vZGFsLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInRvZ2dsZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGUoKSB7XFxuICAgICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5vcGVuKCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9kZXN0cm95XFxcIixcXG5cXG4gICAgLyoqXFxuICAgICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIGEgbW9kYWwuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcmxheSkge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hcHBlbmRUbyhqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcy5vcHRpb25zLmFwcGVuZFRvKSk7IC8vIG1vdmUgJGVsZW1lbnQgb3V0c2lkZSBvZiAkb3ZlcmxheSB0byBwcmV2ZW50IGVycm9yIHVucmVnaXN0ZXJQbHVnaW4oKVxcblxcbiAgICAgICAgdGhpcy4kb3ZlcmxheS5oaWRlKCkub2ZmKCkucmVtb3ZlKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQuaGlkZSgpLm9mZigpO1xcbiAgICAgIHRoaXMuJGFuY2hvci5vZmYoJy56ZicpO1xcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLm9mZihcXFwiLnpmLnJldmVhbDpcXFwiLmNvbmNhdCh0aGlzLmlkKSk7XFxuICAgICAgaWYgKHRoaXMub25Mb2FkTGlzdGVuZXIpIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLm9mZih0aGlzLm9uTG9hZExpc3RlbmVyKTtcXG5cXG4gICAgICBpZiAoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCcucmV2ZWFsOnZpc2libGUnKS5sZW5ndGggPT09IDApIHtcXG4gICAgICAgIHRoaXMuX3JlbW92ZUdsb2JhbENsYXNzZXMoKTsgLy8gYWxzbyByZW1vdmUgLmlzLXJldmVhbC1vcGVuIGZyb20gdGhlIGh0bWwgZWxlbWVudCB3aGVuIHRoZXJlIGlzIG5vIG9wZW5lZCByZXZlYWxcXG5cXG4gICAgICB9XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBSZXZlYWw7XFxufShfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJQbHVnaW5cXFwiXSk7XFxuXFxuUmV2ZWFsLmRlZmF1bHRzID0ge1xcbiAgLyoqXFxuICAgKiBNb3Rpb24tVUkgY2xhc3MgdG8gdXNlIGZvciBhbmltYXRlZCBlbGVtZW50cy4gSWYgbm9uZSB1c2VkLCBkZWZhdWx0cyB0byBzaW1wbGUgc2hvdy9oaWRlLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICcnXFxuICAgKi9cXG4gIGFuaW1hdGlvbkluOiAnJyxcXG5cXG4gIC8qKlxcbiAgICogTW90aW9uLVVJIGNsYXNzIHRvIHVzZSBmb3IgYW5pbWF0ZWQgZWxlbWVudHMuIElmIG5vbmUgdXNlZCwgZGVmYXVsdHMgdG8gc2ltcGxlIHNob3cvaGlkZS5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnJ1xcbiAgICovXFxuICBhbmltYXRpb25PdXQ6ICcnLFxcblxcbiAgLyoqXFxuICAgKiBUaW1lLCBpbiBtcywgdG8gZGVsYXkgdGhlIG9wZW5pbmcgb2YgYSBtb2RhbCBhZnRlciBhIGNsaWNrIGlmIG5vIGFuaW1hdGlvbiB1c2VkLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDBcXG4gICAqL1xcbiAgc2hvd0RlbGF5OiAwLFxcblxcbiAgLyoqXFxuICAgKiBUaW1lLCBpbiBtcywgdG8gZGVsYXkgdGhlIGNsb3Npbmcgb2YgYSBtb2RhbCBhZnRlciBhIGNsaWNrIGlmIG5vIGFuaW1hdGlvbiB1c2VkLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDBcXG4gICAqL1xcbiAgaGlkZURlbGF5OiAwLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvd3MgYSBjbGljayBvbiB0aGUgYm9keS9vdmVybGF5IHRvIGNsb3NlIHRoZSBtb2RhbC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgdHJ1ZVxcbiAgICovXFxuICBjbG9zZU9uQ2xpY2s6IHRydWUsXFxuXFxuICAvKipcXG4gICAqIEFsbG93cyB0aGUgbW9kYWwgdG8gY2xvc2UgaWYgdGhlIHVzZXIgcHJlc3NlcyB0aGUgYEVTQ0FQRWAga2V5LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCB0cnVlXFxuICAgKi9cXG4gIGNsb3NlT25Fc2M6IHRydWUsXFxuXFxuICAvKipcXG4gICAqIElmIHRydWUsIGFsbG93cyBtdWx0aXBsZSBtb2RhbHMgdG8gYmUgZGlzcGxheWVkIGF0IG9uY2UuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIG11bHRpcGxlT3BlbmVkOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogRGlzdGFuY2UsIGluIHBpeGVscywgdGhlIG1vZGFsIHNob3VsZCBwdXNoIGRvd24gZnJvbSB0aGUgdG9wIG9mIHRoZSBzY3JlZW4uXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfHN0cmluZ31cXG4gICAqIEBkZWZhdWx0IGF1dG9cXG4gICAqL1xcbiAgdk9mZnNldDogJ2F1dG8nLFxcblxcbiAgLyoqXFxuICAgKiBEaXN0YW5jZSwgaW4gcGl4ZWxzLCB0aGUgbW9kYWwgc2hvdWxkIHB1c2ggaW4gZnJvbSB0aGUgc2lkZSBvZiB0aGUgc2NyZWVuLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcnxzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCBhdXRvXFxuICAgKi9cXG4gIGhPZmZzZXQ6ICdhdXRvJyxcXG5cXG4gIC8qKlxcbiAgICogQWxsb3dzIHRoZSBtb2RhbCB0byBiZSBmdWxsc2NyZWVuLCBjb21wbGV0ZWx5IGJsb2NraW5nIG91dCB0aGUgcmVzdCBvZiB0aGUgdmlldy4gSlMgY2hlY2tzIGZvciB0aGlzIGFzIHdlbGwuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGZ1bGxTY3JlZW46IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvd3MgdGhlIG1vZGFsIHRvIGdlbmVyYXRlIGFuIG92ZXJsYXkgZGl2LCB3aGljaCB3aWxsIGNvdmVyIHRoZSB2aWV3IHdoZW4gbW9kYWwgb3BlbnMuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IHRydWVcXG4gICAqL1xcbiAgb3ZlcmxheTogdHJ1ZSxcXG5cXG4gIC8qKlxcbiAgICogQWxsb3dzIHRoZSBtb2RhbCB0byByZW1vdmUgYW5kIHJlaW5qZWN0IG1hcmt1cCBvbiBjbG9zZS4gU2hvdWxkIGJlIHRydWUgaWYgdXNpbmcgdmlkZW8gZWxlbWVudHMgdy9vIHVzaW5nIHByb3ZpZGVyJ3MgYXBpLCBvdGhlcndpc2UsIHZpZGVvcyB3aWxsIGNvbnRpbnVlIHRvIHBsYXkgaW4gdGhlIGJhY2tncm91bmQuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIHJlc2V0T25DbG9zZTogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIExpbmsgdGhlIGxvY2F0aW9uIGhhc2ggdG8gdGhlIG1vZGFsLlxcbiAgICogU2V0IHRoZSBsb2NhdGlvbiBoYXNoIHdoZW4gdGhlIG1vZGFsIGlzIG9wZW5lZC9jbG9zZWQsIGFuZCBvcGVuL2Nsb3NlIHRoZSBtb2RhbCB3aGVuIHRoZSBsb2NhdGlvbiBjaGFuZ2VzLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBkZWVwTGluazogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIElmIGBkZWVwTGlua2AgaXMgZW5hYmxlZCwgdXBkYXRlIHRoZSBicm93c2VyIGhpc3Rvcnkgd2l0aCB0aGUgb3BlbiBtb2RhbFxcbiAgICogQG9wdGlvblxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgdXBkYXRlSGlzdG9yeTogZmFsc2UsXFxuXFxuICAvKipcXG4gICogQWxsb3dzIHRoZSBtb2RhbCB0byBhcHBlbmQgdG8gY3VzdG9tIGRpdi5cXG4gICogQG9wdGlvblxcbiAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgKiBAZGVmYXVsdCBcXFwiYm9keVxcXCJcXG4gICovXFxuICBhcHBlbmRUbzogXFxcImJvZHlcXFwiLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvd3MgYWRkaW5nIGFkZGl0aW9uYWwgY2xhc3MgbmFtZXMgdG8gdGhlIHJldmVhbCBvdmVybGF5LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICcnXFxuICAgKi9cXG4gIGFkZGl0aW9uYWxPdmVybGF5Q2xhc3NlczogJydcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL2pzL2ZvdW5kYXRpb24ucmV2ZWFsLmpzP1wiKX0sXCIuL2pzL2ZvdW5kYXRpb24uc2xpZGVyLmpzXCI6ZnVuY3Rpb24obW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJTbGlkZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFNsaWRlcjsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganF1ZXJ5ICovIFxcXCJqcXVlcnlcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC5rZXlib2FyZCAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF9tb3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi51dGlsLm1vdGlvbiAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwubW90aW9uLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnV0aWxzICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS51dGlscy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUucGx1Z2luICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS5wbHVnaW4uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF90b3VjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwudG91Y2ggKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLnRvdWNoLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3V0aWxfdHJpZ2dlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzICovIFxcXCIuL2pzL2ZvdW5kYXRpb24udXRpbC50cmlnZ2Vycy5qc1xcXCIpO1xcblxcblxcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXFxcImZ1bmN0aW9uXFxcIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cXG5cXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXFxcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFxcXCIpOyB9IHJldHVybiBzZWxmOyB9XFxuXFxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblxcXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cXG5cXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxcblxcblxcblxcblxcblxcblxcblxcblxcbi8qKlxcbiAqIFNsaWRlciBtb2R1bGUuXFxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnNsaWRlclxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubW90aW9uXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRvdWNoXFxuICovXFxuXFxudmFyIFNsaWRlciA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uIChfUGx1Z2luKSB7XFxuICBfaW5oZXJpdHMoU2xpZGVyLCBfUGx1Z2luKTtcXG5cXG4gIGZ1bmN0aW9uIFNsaWRlcigpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNsaWRlcik7XFxuXFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoU2xpZGVyKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhTbGlkZXIsIFt7XFxuICAgIGtleTogXFxcIl9zZXR1cFxcXCIsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgc2xpZGVyIGNvbnRyb2wuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAbmFtZSBTbGlkZXJcXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBhIHNsaWRlciBjb250cm9sLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZXh0ZW5kKHt9LCBTbGlkZXIuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdTbGlkZXInOyAvLyBpZTkgYmFjayBjb21wYXRcXG4gICAgICAvLyBUb3VjaCBhbmQgVHJpZ2dlcnMgaW5pdHMgYXJlIGlkZW1wb3RlbnQsIHdlIGp1c3QgbmVlZCB0byBtYWtlIHN1cmUgaXQncyBpbml0aWFsaWVkLlxcblxcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfdG91Y2hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwiVG91Y2hcXFwiXS5pbml0KGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYSk7XFxuICAgICAgX2ZvdW5kYXRpb25fdXRpbF90cmlnZ2Vyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1xcXCJUcmlnZ2Vyc1xcXCJdLmluaXQoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hKTtcXG5cXG4gICAgICB0aGlzLl9pbml0KCk7XFxuXFxuICAgICAgX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJLZXlib2FyZFxcXCJdLnJlZ2lzdGVyKCdTbGlkZXInLCB7XFxuICAgICAgICAnbHRyJzoge1xcbiAgICAgICAgICAnQVJST1dfUklHSFQnOiAnaW5jcmVhc2UnLFxcbiAgICAgICAgICAnQVJST1dfVVAnOiAnaW5jcmVhc2UnLFxcbiAgICAgICAgICAnQVJST1dfRE9XTic6ICdkZWNyZWFzZScsXFxuICAgICAgICAgICdBUlJPV19MRUZUJzogJ2RlY3JlYXNlJyxcXG4gICAgICAgICAgJ1NISUZUX0FSUk9XX1JJR0hUJzogJ2luY3JlYXNlX2Zhc3QnLFxcbiAgICAgICAgICAnU0hJRlRfQVJST1dfVVAnOiAnaW5jcmVhc2VfZmFzdCcsXFxuICAgICAgICAgICdTSElGVF9BUlJPV19ET1dOJzogJ2RlY3JlYXNlX2Zhc3QnLFxcbiAgICAgICAgICAnU0hJRlRfQVJST1dfTEVGVCc6ICdkZWNyZWFzZV9mYXN0JyxcXG4gICAgICAgICAgJ0hPTUUnOiAnbWluJyxcXG4gICAgICAgICAgJ0VORCc6ICdtYXgnXFxuICAgICAgICB9LFxcbiAgICAgICAgJ3J0bCc6IHtcXG4gICAgICAgICAgJ0FSUk9XX0xFRlQnOiAnaW5jcmVhc2UnLFxcbiAgICAgICAgICAnQVJST1dfUklHSFQnOiAnZGVjcmVhc2UnLFxcbiAgICAgICAgICAnU0hJRlRfQVJST1dfTEVGVCc6ICdpbmNyZWFzZV9mYXN0JyxcXG4gICAgICAgICAgJ1NISUZUX0FSUk9XX1JJR0hUJzogJ2RlY3JlYXNlX2Zhc3QnXFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEluaXRpbGl6ZXMgdGhlIHBsdWdpbiBieSByZWFkaW5nL3NldHRpbmcgYXR0cmlidXRlcywgY3JlYXRpbmcgY29sbGVjdGlvbnMgYW5kIHNldHRpbmcgdGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIGhhbmRsZShzKS5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfaW5pdFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcXG4gICAgICB0aGlzLmlucHV0cyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnaW5wdXQnKTtcXG4gICAgICB0aGlzLmhhbmRsZXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXNsaWRlci1oYW5kbGVdJyk7XFxuICAgICAgdGhpcy4kaGFuZGxlID0gdGhpcy5oYW5kbGVzLmVxKDApO1xcbiAgICAgIHRoaXMuJGlucHV0ID0gdGhpcy5pbnB1dHMubGVuZ3RoID8gdGhpcy5pbnB1dHMuZXEoMCkgOiBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoXFxcIiNcXFwiLmNvbmNhdCh0aGlzLiRoYW5kbGUuYXR0cignYXJpYS1jb250cm9scycpKSk7XFxuICAgICAgdGhpcy4kZmlsbCA9IHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtc2xpZGVyLWZpbGxdJykuY3NzKHRoaXMub3B0aW9ucy52ZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJywgMCk7XFxuXFxuICAgICAgdmFyIGlzRGJsID0gZmFsc2UsXFxuICAgICAgICAgIF90aGlzID0gdGhpcztcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRpc2FibGVkIHx8IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3ModGhpcy5vcHRpb25zLmRpc2FibGVkQ2xhc3MpKSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgPSB0cnVlO1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuZGlzYWJsZWRDbGFzcyk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghdGhpcy5pbnB1dHMubGVuZ3RoKSB7XFxuICAgICAgICB0aGlzLmlucHV0cyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgpLmFkZCh0aGlzLiRpbnB1dCk7XFxuICAgICAgICB0aGlzLm9wdGlvbnMuYmluZGluZyA9IHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX3NldEluaXRBdHRyKDApO1xcblxcbiAgICAgIGlmICh0aGlzLmhhbmRsZXNbMV0pIHtcXG4gICAgICAgIHRoaXMub3B0aW9ucy5kb3VibGVTaWRlZCA9IHRydWU7XFxuICAgICAgICB0aGlzLiRoYW5kbGUyID0gdGhpcy5oYW5kbGVzLmVxKDEpO1xcbiAgICAgICAgdGhpcy4kaW5wdXQyID0gdGhpcy5pbnB1dHMubGVuZ3RoID4gMSA/IHRoaXMuaW5wdXRzLmVxKDEpIDoganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKFxcXCIjXFxcIi5jb25jYXQodGhpcy4kaGFuZGxlMi5hdHRyKCdhcmlhLWNvbnRyb2xzJykpKTtcXG5cXG4gICAgICAgIGlmICghdGhpcy5pbnB1dHNbMV0pIHtcXG4gICAgICAgICAgdGhpcy5pbnB1dHMgPSB0aGlzLmlucHV0cy5hZGQodGhpcy4kaW5wdXQyKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlzRGJsID0gdHJ1ZTsgLy8gdGhpcy4kaGFuZGxlLnRyaWdnZXJIYW5kbGVyKCdjbGljay56Zi5zbGlkZXInKTtcXG5cXG4gICAgICAgIHRoaXMuX3NldEluaXRBdHRyKDEpO1xcbiAgICAgIH0gLy8gU2V0IGhhbmRsZSBwb3NpdGlvbnNcXG5cXG5cXG4gICAgICB0aGlzLnNldEhhbmRsZXMoKTtcXG5cXG4gICAgICB0aGlzLl9ldmVudHMoKTtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJzZXRIYW5kbGVzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEhhbmRsZXMoKSB7XFxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICAgICAgaWYgKHRoaXMuaGFuZGxlc1sxXSkge1xcbiAgICAgICAgdGhpcy5fc2V0SGFuZGxlUG9zKHRoaXMuJGhhbmRsZSwgdGhpcy5pbnB1dHMuZXEoMCkudmFsKCksIHRydWUsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgX3RoaXMyLl9zZXRIYW5kbGVQb3MoX3RoaXMyLiRoYW5kbGUyLCBfdGhpczIuaW5wdXRzLmVxKDEpLnZhbCgpLCB0cnVlKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLl9zZXRIYW5kbGVQb3ModGhpcy4kaGFuZGxlLCB0aGlzLmlucHV0cy5lcSgwKS52YWwoKSwgdHJ1ZSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9yZWZsb3dcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZmxvdygpIHtcXG4gICAgICB0aGlzLnNldEhhbmRsZXMoKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgKiBAZnVuY3Rpb25cXG4gICAgKiBAcHJpdmF0ZVxcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIGZsb2F0aW5nIHBvaW50ICh0aGUgdmFsdWUpIHRvIGJlIHRyYW5zZm9ybWVkIHVzaW5nIHRvIGEgcmVsYXRpdmUgcG9zaXRpb24gb24gdGhlIHNsaWRlciAodGhlIGludmVyc2Ugb2YgX3ZhbHVlKVxcbiAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfcGN0T2ZCYXJcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BjdE9mQmFyKHZhbHVlKSB7XFxuICAgICAgdmFyIHBjdE9mQmFyID0gcGVyY2VudCh2YWx1ZSAtIHRoaXMub3B0aW9ucy5zdGFydCwgdGhpcy5vcHRpb25zLmVuZCAtIHRoaXMub3B0aW9ucy5zdGFydCk7XFxuXFxuICAgICAgc3dpdGNoICh0aGlzLm9wdGlvbnMucG9zaXRpb25WYWx1ZUZ1bmN0aW9uKSB7XFxuICAgICAgICBjYXNlIFxcXCJwb3dcXFwiOlxcbiAgICAgICAgICBwY3RPZkJhciA9IHRoaXMuX2xvZ1RyYW5zZm9ybShwY3RPZkJhcik7XFxuICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgY2FzZSBcXFwibG9nXFxcIjpcXG4gICAgICAgICAgcGN0T2ZCYXIgPSB0aGlzLl9wb3dUcmFuc2Zvcm0ocGN0T2ZCYXIpO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHBjdE9mQmFyLnRvRml4ZWQoMik7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICogQGZ1bmN0aW9uXFxuICAgICogQHByaXZhdGVcXG4gICAgKiBAcGFyYW0ge051bWJlcn0gcGN0T2ZCYXIgLSBmbG9hdGluZyBwb2ludCwgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBzbGlkZXIgKHR5cGljYWxseSBiZXR3ZWVuIDAtMSkgdG8gYmUgdHJhbnNmb3JtZWQgdG8gYSB2YWx1ZVxcbiAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfdmFsdWVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ZhbHVlKHBjdE9mQmFyKSB7XFxuICAgICAgc3dpdGNoICh0aGlzLm9wdGlvbnMucG9zaXRpb25WYWx1ZUZ1bmN0aW9uKSB7XFxuICAgICAgICBjYXNlIFxcXCJwb3dcXFwiOlxcbiAgICAgICAgICBwY3RPZkJhciA9IHRoaXMuX3Bvd1RyYW5zZm9ybShwY3RPZkJhcik7XFxuICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgY2FzZSBcXFwibG9nXFxcIjpcXG4gICAgICAgICAgcGN0T2ZCYXIgPSB0aGlzLl9sb2dUcmFuc2Zvcm0ocGN0T2ZCYXIpO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHZhbHVlID0gKHRoaXMub3B0aW9ucy5lbmQgLSB0aGlzLm9wdGlvbnMuc3RhcnQpICogcGN0T2ZCYXIgKyBwYXJzZUZsb2F0KHRoaXMub3B0aW9ucy5zdGFydCk7XFxuICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAqIEBmdW5jdGlvblxcbiAgICAqIEBwcml2YXRlXFxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gZmxvYXRpbmcgcG9pbnQgKHR5cGljYWxseSBiZXR3ZWVuIDAtMSkgdG8gYmUgdHJhbnNmb3JtZWQgdXNpbmcgdGhlIGxvZyBmdW5jdGlvblxcbiAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfbG9nVHJhbnNmb3JtXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2dUcmFuc2Zvcm0odmFsdWUpIHtcXG4gICAgICByZXR1cm4gYmFzZUxvZyh0aGlzLm9wdGlvbnMubm9uTGluZWFyQmFzZSwgdmFsdWUgKiAodGhpcy5vcHRpb25zLm5vbkxpbmVhckJhc2UgLSAxKSArIDEpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAqIEBmdW5jdGlvblxcbiAgICAqIEBwcml2YXRlXFxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gZmxvYXRpbmcgcG9pbnQgKHR5cGljYWxseSBiZXR3ZWVuIDAtMSkgdG8gYmUgdHJhbnNmb3JtZWQgdXNpbmcgdGhlIHBvd2VyIGZ1bmN0aW9uXFxuICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9wb3dUcmFuc2Zvcm1cXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Bvd1RyYW5zZm9ybSh2YWx1ZSkge1xcbiAgICAgIHJldHVybiAoTWF0aC5wb3codGhpcy5vcHRpb25zLm5vbkxpbmVhckJhc2UsIHZhbHVlKSAtIDEpIC8gKHRoaXMub3B0aW9ucy5ub25MaW5lYXJCYXNlIC0gMSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBzZWxlY3RlZCBoYW5kbGUgYW5kIGZpbGwgYmFyLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICRobmRsIC0gdGhlIHNlbGVjdGVkIGhhbmRsZSB0byBtb3ZlLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbG9jYXRpb24gLSBmbG9hdGluZyBwb2ludCBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kIHZhbHVlcyBvZiB0aGUgc2xpZGVyIGJhci5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBjYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIG9uIGNvbXBsZXRpb24uXFxuICAgICAqIEBmaXJlcyBTbGlkZXIjbW92ZWRcXG4gICAgICogQGZpcmVzIFNsaWRlciNjaGFuZ2VkXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfc2V0SGFuZGxlUG9zXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRIYW5kbGVQb3MoJGhuZGwsIGxvY2F0aW9uLCBub0ludmVydCwgY2IpIHtcXG4gICAgICAvLyBkb24ndCBtb3ZlIGlmIHRoZSBzbGlkZXIgaGFzIGJlZW4gZGlzYWJsZWQgc2luY2UgaXRzIGluaXRpYWxpemF0aW9uXFxuICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3ModGhpcy5vcHRpb25zLmRpc2FibGVkQ2xhc3MpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfSAvL21pZ2h0IG5lZWQgdG8gYWx0ZXIgdGhhdCBzbGlnaHRseSBmb3IgYmFycyB0aGF0IHdpbGwgaGF2ZSBvZGQgbnVtYmVyIHNlbGVjdGlvbnMuXFxuXFxuXFxuICAgICAgbG9jYXRpb24gPSBwYXJzZUZsb2F0KGxvY2F0aW9uKTsgLy9vbiBpbnB1dCBjaGFuZ2UgZXZlbnRzLCBjb252ZXJ0IHN0cmluZyB0byBudW1iZXIuLi5ncnVtYmxlLlxcbiAgICAgIC8vIHByZXZlbnQgc2xpZGVyIGZyb20gcnVubmluZyBvdXQgb2YgYm91bmRzLCBpZiB2YWx1ZSBleGNlZWRzIHRoZSBsaW1pdHMgc2V0IHRocm91Z2ggb3B0aW9ucywgb3ZlcnJpZGUgdGhlIHZhbHVlIHRvIG1pbi9tYXhcXG5cXG4gICAgICBpZiAobG9jYXRpb24gPCB0aGlzLm9wdGlvbnMuc3RhcnQpIHtcXG4gICAgICAgIGxvY2F0aW9uID0gdGhpcy5vcHRpb25zLnN0YXJ0O1xcbiAgICAgIH0gZWxzZSBpZiAobG9jYXRpb24gPiB0aGlzLm9wdGlvbnMuZW5kKSB7XFxuICAgICAgICBsb2NhdGlvbiA9IHRoaXMub3B0aW9ucy5lbmQ7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBpc0RibCA9IHRoaXMub3B0aW9ucy5kb3VibGVTaWRlZDsgLy90aGlzIGlzIGZvciBzaW5nbGUtaGFuZGxlZCB2ZXJ0aWNhbCBzbGlkZXJzLCBpdCBhZGp1c3RzIHRoZSB2YWx1ZSB0byBhY2NvdW50IGZvciB0aGUgc2xpZGVyIGJlaW5nIFxcXCJ1cHNpZGUtZG93blxcXCJcXG4gICAgICAvL2ZvciBjbGljayBhbmQgZHJhZyBldmVudHMsIGl0J3Mgd2VpcmQgZHVlIHRvIHRoZSBzY2FsZSgtMSwgMSkgY3NzIHByb3BlcnR5XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy52ZXJ0aWNhbCAmJiAhbm9JbnZlcnQpIHtcXG4gICAgICAgIGxvY2F0aW9uID0gdGhpcy5vcHRpb25zLmVuZCAtIGxvY2F0aW9uO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaXNEYmwpIHtcXG4gICAgICAgIC8vdGhpcyBibG9jayBpcyB0byBwcmV2ZW50IDIgaGFuZGxlcyBmcm9tIGNyb3NzaW5nIGVhY2hvdGhlci4gQ291bGQvc2hvdWxkIGJlIGltcHJvdmVkLlxcbiAgICAgICAgaWYgKHRoaXMuaGFuZGxlcy5pbmRleCgkaG5kbCkgPT09IDApIHtcXG4gICAgICAgICAgdmFyIGgyVmFsID0gcGFyc2VGbG9hdCh0aGlzLiRoYW5kbGUyLmF0dHIoJ2FyaWEtdmFsdWVub3cnKSk7XFxuICAgICAgICAgIGxvY2F0aW9uID0gbG9jYXRpb24gPj0gaDJWYWwgPyBoMlZhbCAtIHRoaXMub3B0aW9ucy5zdGVwIDogbG9jYXRpb247XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB2YXIgaDFWYWwgPSBwYXJzZUZsb2F0KHRoaXMuJGhhbmRsZS5hdHRyKCdhcmlhLXZhbHVlbm93JykpO1xcbiAgICAgICAgICBsb2NhdGlvbiA9IGxvY2F0aW9uIDw9IGgxVmFsID8gaDFWYWwgKyB0aGlzLm9wdGlvbnMuc3RlcCA6IGxvY2F0aW9uO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxcbiAgICAgICAgICB2ZXJ0ID0gdGhpcy5vcHRpb25zLnZlcnRpY2FsLFxcbiAgICAgICAgICBoT3JXID0gdmVydCA/ICdoZWlnaHQnIDogJ3dpZHRoJyxcXG4gICAgICAgICAgbE9yVCA9IHZlcnQgPyAndG9wJyA6ICdsZWZ0JyxcXG4gICAgICAgICAgaGFuZGxlRGltID0gJGhuZGxbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbaE9yV10sXFxuICAgICAgICAgIGVsZW1EaW0gPSB0aGlzLiRlbGVtZW50WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2hPclddLFxcbiAgICAgICAgICAvL3BlcmNlbnRhZ2Ugb2YgYmFyIG1pbi9tYXggdmFsdWUgYmFzZWQgb24gY2xpY2sgb3IgZHJhZyBwb2ludFxcbiAgICAgIHBjdE9mQmFyID0gdGhpcy5fcGN0T2ZCYXIobG9jYXRpb24pLFxcbiAgICAgICAgICAvL251bWJlciBvZiBhY3R1YWwgcGl4ZWxzIHRvIHNoaWZ0IHRoZSBoYW5kbGUsIGJhc2VkIG9uIHRoZSBwZXJjZW50YWdlIG9idGFpbmVkIGFib3ZlXFxuICAgICAgcHhUb01vdmUgPSAoZWxlbURpbSAtIGhhbmRsZURpbSkgKiBwY3RPZkJhcixcXG4gICAgICAgICAgLy9wZXJjZW50YWdlIG9mIGJhciB0byBzaGlmdCB0aGUgaGFuZGxlXFxuICAgICAgbW92ZW1lbnQgPSAocGVyY2VudChweFRvTW92ZSwgZWxlbURpbSkgKiAxMDApLnRvRml4ZWQodGhpcy5vcHRpb25zLmRlY2ltYWwpOyAvL2ZpeGluZyB0aGUgZGVjaW1hbCB2YWx1ZSBmb3IgdGhlIGxvY2F0aW9uIG51bWJlciwgaXMgcGFzc2VkIHRvIG90aGVyIG1ldGhvZHMgYXMgYSBmaXhlZCBmbG9hdGluZy1wb2ludCB2YWx1ZVxcblxcblxcbiAgICAgIGxvY2F0aW9uID0gcGFyc2VGbG9hdChsb2NhdGlvbi50b0ZpeGVkKHRoaXMub3B0aW9ucy5kZWNpbWFsKSk7IC8vIGRlY2xhcmUgZW1wdHkgb2JqZWN0IGZvciBjc3MgYWRqdXN0bWVudHMsIG9ubHkgdXNlZCB3aXRoIDIgaGFuZGxlZC1zbGlkZXJzXFxuXFxuICAgICAgdmFyIGNzcyA9IHt9O1xcblxcbiAgICAgIHRoaXMuX3NldFZhbHVlcygkaG5kbCwgbG9jYXRpb24pOyAvLyBUT0RPIHVwZGF0ZSB0byBjYWxjdWxhdGUgYmFzZWQgb24gdmFsdWVzIHNldCB0byByZXNwZWN0aXZlIGlucHV0cz8/XFxuXFxuXFxuICAgICAgaWYgKGlzRGJsKSB7XFxuICAgICAgICB2YXIgaXNMZWZ0SG5kbCA9IHRoaXMuaGFuZGxlcy5pbmRleCgkaG5kbCkgPT09IDAsXFxuICAgICAgICAgICAgLy9lbXB0eSB2YXJpYWJsZSwgd2lsbCBiZSB1c2VkIGZvciBtaW4taGVpZ2h0L3dpZHRoIGZvciBmaWxsIGJhclxcbiAgICAgICAgZGltLFxcbiAgICAgICAgICAgIC8vcGVyY2VudGFnZSB3L2ggb2YgdGhlIGhhbmRsZSBjb21wYXJlZCB0byB0aGUgc2xpZGVyIGJhclxcbiAgICAgICAgaGFuZGxlUGN0ID0gfn4ocGVyY2VudChoYW5kbGVEaW0sIGVsZW1EaW0pICogMTAwKTsgLy9pZiBsZWZ0IGhhbmRsZSwgdGhlIG1hdGggaXMgc2xpZ2h0bHkgZGlmZmVyZW50IHRoYW4gaWYgaXQncyB0aGUgcmlnaHQgaGFuZGxlLCBhbmQgdGhlIGxlZnQvdG9wIHByb3BlcnR5IG5lZWRzIHRvIGJlIGNoYW5nZWQgZm9yIHRoZSBmaWxsIGJhclxcblxcbiAgICAgICAgaWYgKGlzTGVmdEhuZGwpIHtcXG4gICAgICAgICAgLy9sZWZ0IG9yIHRvcCBwZXJjZW50YWdlIHZhbHVlIHRvIGFwcGx5IHRvIHRoZSBmaWxsIGJhci5cXG4gICAgICAgICAgY3NzW2xPclRdID0gXFxcIlxcXCIuY29uY2F0KG1vdmVtZW50LCBcXFwiJVxcXCIpOyAvL2NhbGN1bGF0ZSB0aGUgbmV3IG1pbi1oZWlnaHQvd2lkdGggZm9yIHRoZSBmaWxsIGJhci5cXG5cXG4gICAgICAgICAgZGltID0gcGFyc2VGbG9hdCh0aGlzLiRoYW5kbGUyWzBdLnN0eWxlW2xPclRdKSAtIG1vdmVtZW50ICsgaGFuZGxlUGN0OyAvL3RoaXMgY2FsbGJhY2sgaXMgbmVjZXNzYXJ5IHRvIHByZXZlbnQgZXJyb3JzIGFuZCBhbGxvdyB0aGUgcHJvcGVyIHBsYWNlbWVudCBhbmQgaW5pdGlhbGl6YXRpb24gb2YgYSAyLWhhbmRsZWQgc2xpZGVyXFxuICAgICAgICAgIC8vcGx1cywgaXQgbWVhbnMgd2UgZG9uJ3QgY2FyZSBpZiAnZGltJyBpc05hTiBvbiBpbml0LCBpdCB3b24ndCBiZSBpbiB0aGUgZnV0dXJlLlxcblxcbiAgICAgICAgICBpZiAoY2IgJiYgdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgICAgY2IoKTtcXG4gICAgICAgICAgfSAvL3RoaXMgaXMgb25seSBuZWVkZWQgZm9yIHRoZSBpbml0aWFsaXphdGlvbiBvZiAyIGhhbmRsZWQgc2xpZGVyc1xcblxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgLy9qdXN0IGNhY2hpbmcgdGhlIHZhbHVlIG9mIHRoZSBsZWZ0L2JvdHRvbSBoYW5kbGUncyBsZWZ0L3RvcCBwcm9wZXJ0eVxcbiAgICAgICAgICB2YXIgaGFuZGxlUG9zID0gcGFyc2VGbG9hdCh0aGlzLiRoYW5kbGVbMF0uc3R5bGVbbE9yVF0pOyAvL2NhbGN1bGF0ZSB0aGUgbmV3IG1pbi1oZWlnaHQvd2lkdGggZm9yIHRoZSBmaWxsIGJhci4gVXNlIGlzTmFOIHRvIHByZXZlbnQgZmFsc2UgcG9zaXRpdmVzIGZvciBudW1iZXJzIDw9IDBcXG4gICAgICAgICAgLy9iYXNlZCBvbiB0aGUgcGVyY2VudGFnZSBvZiBtb3ZlbWVudCBvZiB0aGUgaGFuZGxlIGJlaW5nIG1hbmlwdWxhdGVkLCBsZXNzIHRoZSBvcHBvc2luZyBoYW5kbGUncyBsZWZ0L3RvcCBwb3NpdGlvbiwgcGx1cyB0aGUgcGVyY2VudGFnZSB3L2ggb2YgdGhlIGhhbmRsZSBpdHNlbGZcXG5cXG4gICAgICAgICAgZGltID0gbW92ZW1lbnQgLSAoaXNOYU4oaGFuZGxlUG9zKSA/ICh0aGlzLm9wdGlvbnMuaW5pdGlhbFN0YXJ0IC0gdGhpcy5vcHRpb25zLnN0YXJ0KSAvICgodGhpcy5vcHRpb25zLmVuZCAtIHRoaXMub3B0aW9ucy5zdGFydCkgLyAxMDApIDogaGFuZGxlUG9zKSArIGhhbmRsZVBjdDtcXG4gICAgICAgIH0gLy8gYXNzaWduIHRoZSBtaW4taGVpZ2h0L3dpZHRoIHRvIG91ciBjc3Mgb2JqZWN0XFxuXFxuXFxuICAgICAgICBjc3NbXFxcIm1pbi1cXFwiLmNvbmNhdChoT3JXKV0gPSBcXFwiXFxcIi5jb25jYXQoZGltLCBcXFwiJVxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50Lm9uZSgnZmluaXNoZWQuemYuYW5pbWF0ZScsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgaGFuZGxlIGlzIGRvbmUgbW92aW5nLlxcbiAgICAgICAgICogQGV2ZW50IFNsaWRlciNtb3ZlZFxcbiAgICAgICAgICovXFxuICAgICAgICBfdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdtb3ZlZC56Zi5zbGlkZXInLCBbJGhuZGxdKTtcXG4gICAgICB9KTsgLy9iZWNhdXNlIHdlIGRvbid0IGtub3cgZXhhY3RseSBob3cgdGhlIGhhbmRsZSB3aWxsIGJlIG1vdmVkLCBjaGVjayB0aGUgYW1vdW50IG9mIHRpbWUgaXQgc2hvdWxkIHRha2UgdG8gbW92ZS5cXG5cXG4gICAgICB2YXIgbW92ZVRpbWUgPSB0aGlzLiRlbGVtZW50LmRhdGEoJ2RyYWdnaW5nJykgPyAxMDAwIC8gNjAgOiB0aGlzLm9wdGlvbnMubW92ZVRpbWU7XFxuICAgICAgT2JqZWN0KF9mb3VuZGF0aW9uX3V0aWxfbW90aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIk1vdmVcXFwiXSkobW92ZVRpbWUsICRobmRsLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAvLyBhZGp1c3RpbmcgdGhlIGxlZnQvdG9wIHByb3BlcnR5IG9mIHRoZSBoYW5kbGUsIGJhc2VkIG9uIHRoZSBwZXJjZW50YWdlIGNhbGN1bGF0ZWQgYWJvdmVcXG4gICAgICAgIC8vIGlmIG1vdmVtZW50IGlzTmFOLCB0aGF0IGlzIGJlY2F1c2UgdGhlIHNsaWRlciBpcyBoaWRkZW4gYW5kIHdlIGNhbm5vdCBkZXRlcm1pbmUgaGFuZGxlIHdpZHRoLFxcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIG5leHQgYmVzdCBndWVzcy5cXG4gICAgICAgIGlmIChpc05hTihtb3ZlbWVudCkpIHtcXG4gICAgICAgICAgJGhuZGwuY3NzKGxPclQsIFxcXCJcXFwiLmNvbmNhdChwY3RPZkJhciAqIDEwMCwgXFxcIiVcXFwiKSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAkaG5kbC5jc3MobE9yVCwgXFxcIlxcXCIuY29uY2F0KG1vdmVtZW50LCBcXFwiJVxcXCIpKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghX3RoaXMub3B0aW9ucy5kb3VibGVTaWRlZCkge1xcbiAgICAgICAgICAvL2lmIHNpbmdsZS1oYW5kbGVkLCBhIHNpbXBsZSBtZXRob2QgdG8gZXhwYW5kIHRoZSBmaWxsIGJhclxcbiAgICAgICAgICBfdGhpcy4kZmlsbC5jc3MoaE9yVywgXFxcIlxcXCIuY29uY2F0KHBjdE9mQmFyICogMTAwLCBcXFwiJVxcXCIpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vb3RoZXJ3aXNlLCB1c2UgdGhlIGNzcyBvYmplY3Qgd2UgY3JlYXRlZCBhYm92ZVxcbiAgICAgICAgICBfdGhpcy4kZmlsbC5jc3MoY3NzKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSB2YWx1ZSBoYXMgbm90IGJlZW4gY2hhbmdlIGZvciBhIGdpdmVuIHRpbWUuXFxuICAgICAgICogQGV2ZW50IFNsaWRlciNjaGFuZ2VkXFxuICAgICAgICovXFxuXFxuICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXQpO1xcbiAgICAgIF90aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIF90aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2NoYW5nZWQuemYuc2xpZGVyJywgWyRobmRsXSk7XFxuICAgICAgfSwgX3RoaXMub3B0aW9ucy5jaGFuZ2VkRGVsYXkpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBTZXRzIHRoZSBpbml0aWFsIGF0dHJpYnV0ZSBmb3IgdGhlIHNsaWRlciBlbGVtZW50LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkeCAtIGluZGV4IG9mIHRoZSBjdXJyZW50IGhhbmRsZS9pbnB1dCB0byB1c2UuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfc2V0SW5pdEF0dHJcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEluaXRBdHRyKGlkeCkge1xcbiAgICAgIHZhciBpbml0VmFsID0gaWR4ID09PSAwID8gdGhpcy5vcHRpb25zLmluaXRpYWxTdGFydCA6IHRoaXMub3B0aW9ucy5pbml0aWFsRW5kO1xcbiAgICAgIHZhciBpZCA9IHRoaXMuaW5wdXRzLmVxKGlkeCkuYXR0cignaWQnKSB8fCBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJHZXRZb0RpZ2l0c1xcXCJdKSg2LCAnc2xpZGVyJyk7XFxuICAgICAgdGhpcy5pbnB1dHMuZXEoaWR4KS5hdHRyKHtcXG4gICAgICAgICdpZCc6IGlkLFxcbiAgICAgICAgJ21heCc6IHRoaXMub3B0aW9ucy5lbmQsXFxuICAgICAgICAnbWluJzogdGhpcy5vcHRpb25zLnN0YXJ0LFxcbiAgICAgICAgJ3N0ZXAnOiB0aGlzLm9wdGlvbnMuc3RlcFxcbiAgICAgIH0pO1xcbiAgICAgIHRoaXMuaW5wdXRzLmVxKGlkeCkudmFsKGluaXRWYWwpO1xcbiAgICAgIHRoaXMuaGFuZGxlcy5lcShpZHgpLmF0dHIoe1xcbiAgICAgICAgJ3JvbGUnOiAnc2xpZGVyJyxcXG4gICAgICAgICdhcmlhLWNvbnRyb2xzJzogaWQsXFxuICAgICAgICAnYXJpYS12YWx1ZW1heCc6IHRoaXMub3B0aW9ucy5lbmQsXFxuICAgICAgICAnYXJpYS12YWx1ZW1pbic6IHRoaXMub3B0aW9ucy5zdGFydCxcXG4gICAgICAgICdhcmlhLXZhbHVlbm93JzogaW5pdFZhbCxcXG4gICAgICAgICdhcmlhLW9yaWVudGF0aW9uJzogdGhpcy5vcHRpb25zLnZlcnRpY2FsID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJyxcXG4gICAgICAgICd0YWJpbmRleCc6IDBcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogU2V0cyB0aGUgaW5wdXQgYW5kIGBhcmlhLXZhbHVlbm93YCB2YWx1ZXMgZm9yIHRoZSBzbGlkZXIgZWxlbWVudC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkaGFuZGxlIC0gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBoYW5kbGUuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWwgLSBmbG9hdGluZyBwb2ludCBvZiB0aGUgbmV3IHZhbHVlLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3NldFZhbHVlc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0VmFsdWVzKCRoYW5kbGUsIHZhbCkge1xcbiAgICAgIHZhciBpZHggPSB0aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQgPyB0aGlzLmhhbmRsZXMuaW5kZXgoJGhhbmRsZSkgOiAwO1xcbiAgICAgIHRoaXMuaW5wdXRzLmVxKGlkeCkudmFsKHZhbCk7XFxuICAgICAgJGhhbmRsZS5hdHRyKCdhcmlhLXZhbHVlbm93JywgdmFsKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSGFuZGxlcyBldmVudHMgb24gdGhlIHNsaWRlciBlbGVtZW50LlxcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBuZXcgbG9jYXRpb24gb2YgdGhlIGN1cnJlbnQgaGFuZGxlLlxcbiAgICAgKiBJZiB0aGVyZSBhcmUgdHdvIGhhbmRsZXMgYW5kIHRoZSBiYXIgd2FzIGNsaWNrZWQsIGl0IGRldGVybWluZXMgd2hpY2ggaGFuZGxlIHRvIG1vdmUuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZSAtIHRoZSBgZXZlbnRgIG9iamVjdCBwYXNzZWQgZnJvbSB0aGUgbGlzdGVuZXIuXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkaGFuZGxlIC0gdGhlIGN1cnJlbnQgaGFuZGxlIHRvIGNhbGN1bGF0ZSBmb3IsIGlmIHNlbGVjdGVkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsIC0gZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGZvciB0aGUgbmV3IHZhbHVlIG9mIHRoZSBzbGlkZXIuXFxuICAgICAqIFRPRE8gY2xlYW4gdGhpcyB1cCwgdGhlcmUncyBhIGxvdCBvZiByZXBlYXRlZCBjb2RlIGJldHdlZW4gdGhpcyBhbmQgdGhlIF9zZXRIYW5kbGVQb3MgZm4uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfaGFuZGxlRXZlbnRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUV2ZW50KGUsICRoYW5kbGUsIHZhbCkge1xcbiAgICAgIHZhciB2YWx1ZSwgaGFzVmFsO1xcblxcbiAgICAgIGlmICghdmFsKSB7XFxuICAgICAgICAvL2NsaWNrIG9yIGRyYWcgZXZlbnRzXFxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuXFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzLFxcbiAgICAgICAgICAgIHZlcnRpY2FsID0gdGhpcy5vcHRpb25zLnZlcnRpY2FsLFxcbiAgICAgICAgICAgIHBhcmFtID0gdmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCcsXFxuICAgICAgICAgICAgZGlyZWN0aW9uID0gdmVydGljYWwgPyAndG9wJyA6ICdsZWZ0JyxcXG4gICAgICAgICAgICBldmVudE9mZnNldCA9IHZlcnRpY2FsID8gZS5wYWdlWSA6IGUucGFnZVgsXFxuICAgICAgICAgICAgaGFsZk9mSGFuZGxlID0gdGhpcy4kaGFuZGxlWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW3BhcmFtXSAvIDIsXFxuICAgICAgICAgICAgYmFyRGltID0gdGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtwYXJhbV0sXFxuICAgICAgICAgICAgd2luZG93U2Nyb2xsID0gdmVydGljYWwgPyBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS5zY3JvbGxUb3AoKSA6IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLnNjcm9sbExlZnQoKTtcXG5cXG4gICAgICAgIHZhciBlbGVtT2Zmc2V0ID0gdGhpcy4kZWxlbWVudC5vZmZzZXQoKVtkaXJlY3Rpb25dOyAvLyB0b3VjaCBldmVudHMgZW11bGF0ZWQgYnkgdGhlIHRvdWNoIHV0aWwgZ2l2ZSBwb3NpdGlvbiByZWxhdGl2ZSB0byBzY3JlZW4sIGFkZCB3aW5kb3cuc2Nyb2xsIHRvIGV2ZW50IGNvb3JkaW5hdGVzLi4uXFxuICAgICAgICAvLyBiZXN0IHdheSB0byBndWVzcyB0aGlzIGlzIHNpbXVsYXRlZCBpcyBpZiBjbGllbnRZID09IHBhZ2VZXFxuXFxuICAgICAgICBpZiAoZS5jbGllbnRZID09PSBlLnBhZ2VZKSB7XFxuICAgICAgICAgIGV2ZW50T2Zmc2V0ID0gZXZlbnRPZmZzZXQgKyB3aW5kb3dTY3JvbGw7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgZXZlbnRGcm9tQmFyID0gZXZlbnRPZmZzZXQgLSBlbGVtT2Zmc2V0O1xcbiAgICAgICAgdmFyIGJhclhZO1xcblxcbiAgICAgICAgaWYgKGV2ZW50RnJvbUJhciA8IDApIHtcXG4gICAgICAgICAgYmFyWFkgPSAwO1xcbiAgICAgICAgfSBlbHNlIGlmIChldmVudEZyb21CYXIgPiBiYXJEaW0pIHtcXG4gICAgICAgICAgYmFyWFkgPSBiYXJEaW07XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBiYXJYWSA9IGV2ZW50RnJvbUJhcjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBvZmZzZXRQY3QgPSBwZXJjZW50KGJhclhZLCBiYXJEaW0pO1xcbiAgICAgICAgdmFsdWUgPSB0aGlzLl92YWx1ZShvZmZzZXRQY3QpOyAvLyB0dXJuIGV2ZXJ5dGhpbmcgYXJvdW5kIGZvciBSVEwsIHlheSBtYXRoIVxcblxcbiAgICAgICAgaWYgKE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcInJ0bFxcXCJdKSgpICYmICF0aGlzLm9wdGlvbnMudmVydGljYWwpIHtcXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLm9wdGlvbnMuZW5kIC0gdmFsdWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YWx1ZSA9IF90aGlzLl9hZGp1c3RWYWx1ZShudWxsLCB2YWx1ZSk7IC8vYm9vbGVhbiBmbGFnIGZvciB0aGUgc2V0SGFuZGxlUG9zIGZuLCBzcGVjaWZpY2FsbHkgZm9yIHZlcnRpY2FsIHNsaWRlcnNcXG5cXG4gICAgICAgIGhhc1ZhbCA9IGZhbHNlO1xcblxcbiAgICAgICAgaWYgKCEkaGFuZGxlKSB7XFxuICAgICAgICAgIC8vZmlndXJlIG91dCB3aGljaCBoYW5kbGUgaXQgaXMsIHBhc3MgaXQgdG8gdGhlIG5leHQgZnVuY3Rpb24uXFxuICAgICAgICAgIHZhciBmaXJzdEhuZGxQb3MgPSBhYnNQb3NpdGlvbih0aGlzLiRoYW5kbGUsIGRpcmVjdGlvbiwgYmFyWFksIHBhcmFtKSxcXG4gICAgICAgICAgICAgIHNlY25kSG5kbFBvcyA9IGFic1Bvc2l0aW9uKHRoaXMuJGhhbmRsZTIsIGRpcmVjdGlvbiwgYmFyWFksIHBhcmFtKTtcXG4gICAgICAgICAgJGhhbmRsZSA9IGZpcnN0SG5kbFBvcyA8PSBzZWNuZEhuZGxQb3MgPyB0aGlzLiRoYW5kbGUgOiB0aGlzLiRoYW5kbGUyO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICAvL2NoYW5nZSBldmVudCBvbiBpbnB1dFxcbiAgICAgICAgdmFsdWUgPSB0aGlzLl9hZGp1c3RWYWx1ZShudWxsLCB2YWwpO1xcbiAgICAgICAgaGFzVmFsID0gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fc2V0SGFuZGxlUG9zKCRoYW5kbGUsIHZhbHVlLCBoYXNWYWwpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBBZGp1c3RlcyB2YWx1ZSBmb3IgaGFuZGxlIGluIHJlZ2FyZCB0byBzdGVwIHZhbHVlLiByZXR1cm5zIGFkanVzdGVkIHZhbHVlXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGhhbmRsZSAtIHRoZSBzZWxlY3RlZCBoYW5kbGUuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIHZhbHVlIHRvIGFkanVzdC4gdXNlZCBpZiAkaGFuZGxlIGlzIGZhbHN5XFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfYWRqdXN0VmFsdWVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkanVzdFZhbHVlKCRoYW5kbGUsIHZhbHVlKSB7XFxuICAgICAgdmFyIHZhbCxcXG4gICAgICAgICAgc3RlcCA9IHRoaXMub3B0aW9ucy5zdGVwLFxcbiAgICAgICAgICBkaXYgPSBwYXJzZUZsb2F0KHN0ZXAgLyAyKSxcXG4gICAgICAgICAgbGVmdCxcXG4gICAgICAgICAgcHJldl92YWwsXFxuICAgICAgICAgIG5leHRfdmFsO1xcblxcbiAgICAgIGlmICghISRoYW5kbGUpIHtcXG4gICAgICAgIHZhbCA9IHBhcnNlRmxvYXQoJGhhbmRsZS5hdHRyKCdhcmlhLXZhbHVlbm93JykpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YWwgPSB2YWx1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHZhbCA+PSAwKSB7XFxuICAgICAgICBsZWZ0ID0gdmFsICUgc3RlcDtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbGVmdCA9IHN0ZXAgKyB2YWwgJSBzdGVwO1xcbiAgICAgIH1cXG5cXG4gICAgICBwcmV2X3ZhbCA9IHZhbCAtIGxlZnQ7XFxuICAgICAgbmV4dF92YWwgPSBwcmV2X3ZhbCArIHN0ZXA7XFxuXFxuICAgICAgaWYgKGxlZnQgPT09IDApIHtcXG4gICAgICAgIHJldHVybiB2YWw7XFxuICAgICAgfVxcblxcbiAgICAgIHZhbCA9IHZhbCA+PSBwcmV2X3ZhbCArIGRpdiA/IG5leHRfdmFsIDogcHJldl92YWw7XFxuICAgICAgcmV0dXJuIHZhbDtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHNsaWRlciBlbGVtZW50cy5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZXZlbnRzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgdGhpcy5fZXZlbnRzRm9ySGFuZGxlKHRoaXMuJGhhbmRsZSk7XFxuXFxuICAgICAgaWYgKHRoaXMuaGFuZGxlc1sxXSkge1xcbiAgICAgICAgdGhpcy5fZXZlbnRzRm9ySGFuZGxlKHRoaXMuJGhhbmRsZTIpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQWRkcyBldmVudCBsaXN0ZW5lcnMgYSBwYXJ0aWN1bGFyIGhhbmRsZVxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICRoYW5kbGUgLSB0aGUgY3VycmVudCBoYW5kbGUgdG8gYXBwbHkgbGlzdGVuZXJzIHRvLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2V2ZW50c0ZvckhhbmRsZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzRm9ySGFuZGxlKCRoYW5kbGUpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxcbiAgICAgICAgICBjdXJIYW5kbGUsXFxuICAgICAgICAgIHRpbWVyO1xcblxcbiAgICAgIHZhciBoYW5kbGVDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZUV2ZW50KGUpIHtcXG4gICAgICAgIHZhciBpZHggPSBfdGhpcy5pbnB1dHMuaW5kZXgoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpKTtcXG5cXG4gICAgICAgIF90aGlzLl9oYW5kbGVFdmVudChlLCBfdGhpcy5oYW5kbGVzLmVxKGlkeCksIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS52YWwoKSk7XFxuICAgICAgfTsgLy8gSUUgb25seSB0cmlnZ2VycyB0aGUgY2hhbmdlIGV2ZW50IHdoZW4gdGhlIGlucHV0IGxvc2VzIGZvY3VzIHdoaWNoIHN0cmljdGx5IGZvbGxvd3MgdGhlIEhUTUwgc3BlY2lmaWNhdGlvblxcbiAgICAgIC8vIGxpc3RlbiBmb3IgdGhlIGVudGVyIGtleSBhbmQgdHJpZ2dlciBhIGNoYW5nZVxcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5wdXQuaHRtbCNjb21tb24taW5wdXQtZWxlbWVudC1ldmVudHNcXG5cXG5cXG4gICAgICB0aGlzLmlucHV0cy5vZmYoJ2tleXVwLnpmLnNsaWRlcicpLm9uKCdrZXl1cC56Zi5zbGlkZXInLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAxMykgaGFuZGxlQ2hhbmdlRXZlbnQuY2FsbCh0aGlzLCBlKTtcXG4gICAgICB9KTtcXG4gICAgICB0aGlzLmlucHV0cy5vZmYoJ2NoYW5nZS56Zi5zbGlkZXInKS5vbignY2hhbmdlLnpmLnNsaWRlcicsIGhhbmRsZUNoYW5nZUV2ZW50KTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNsaWNrU2VsZWN0KSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZignY2xpY2suemYuc2xpZGVyJykub24oJ2NsaWNrLnpmLnNsaWRlcicsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIGlmIChfdGhpcy4kZWxlbWVudC5kYXRhKCdkcmFnZ2luZycpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmICghanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGUudGFyZ2V0KS5pcygnW2RhdGEtc2xpZGVyLWhhbmRsZV0nKSkge1xcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkKSB7XFxuICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlRXZlbnQoZSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIF90aGlzLl9oYW5kbGVFdmVudChlLCBfdGhpcy4kaGFuZGxlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRyYWdnYWJsZSkge1xcbiAgICAgICAgdGhpcy5oYW5kbGVzLmFkZFRvdWNoKCk7XFxuICAgICAgICB2YXIgJGJvZHkgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoJ2JvZHknKTtcXG4gICAgICAgICRoYW5kbGUub2ZmKCdtb3VzZWRvd24uemYuc2xpZGVyJykub24oJ21vdXNlZG93bi56Zi5zbGlkZXInLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAkaGFuZGxlLmFkZENsYXNzKCdpcy1kcmFnZ2luZycpO1xcblxcbiAgICAgICAgICBfdGhpcy4kZmlsbC5hZGRDbGFzcygnaXMtZHJhZ2dpbmcnKTsgLy9cXG5cXG5cXG4gICAgICAgICAgX3RoaXMuJGVsZW1lbnQuZGF0YSgnZHJhZ2dpbmcnLCB0cnVlKTtcXG5cXG4gICAgICAgICAgY3VySGFuZGxlID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGUuY3VycmVudFRhcmdldCk7XFxuICAgICAgICAgICRib2R5Lm9uKCdtb3VzZW1vdmUuemYuc2xpZGVyJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuXFxuICAgICAgICAgICAgX3RoaXMuX2hhbmRsZUV2ZW50KGUsIGN1ckhhbmRsZSk7XFxuICAgICAgICAgIH0pLm9uKCdtb3VzZXVwLnpmLnNsaWRlcicsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgICAgX3RoaXMuX2hhbmRsZUV2ZW50KGUsIGN1ckhhbmRsZSk7XFxuXFxuICAgICAgICAgICAgJGhhbmRsZS5yZW1vdmVDbGFzcygnaXMtZHJhZ2dpbmcnKTtcXG5cXG4gICAgICAgICAgICBfdGhpcy4kZmlsbC5yZW1vdmVDbGFzcygnaXMtZHJhZ2dpbmcnKTtcXG5cXG4gICAgICAgICAgICBfdGhpcy4kZWxlbWVudC5kYXRhKCdkcmFnZ2luZycsIGZhbHNlKTtcXG5cXG4gICAgICAgICAgICAkYm9keS5vZmYoJ21vdXNlbW92ZS56Zi5zbGlkZXIgbW91c2V1cC56Zi5zbGlkZXInKTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9KSAvLyBwcmV2ZW50IGV2ZW50cyB0cmlnZ2VyZWQgYnkgdG91Y2hcXG4gICAgICAgIC5vbignc2VsZWN0c3RhcnQuemYuc2xpZGVyIHRvdWNobW92ZS56Zi5zbGlkZXInLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgJGhhbmRsZS5vZmYoJ2tleWRvd24uemYuc2xpZGVyJykub24oJ2tleWRvd24uemYuc2xpZGVyJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIHZhciBfJGhhbmRsZSA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKSxcXG4gICAgICAgICAgICBpZHggPSBfdGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkID8gX3RoaXMuaGFuZGxlcy5pbmRleChfJGhhbmRsZSkgOiAwLFxcbiAgICAgICAgICAgIG9sZFZhbHVlID0gcGFyc2VGbG9hdChfdGhpcy5pbnB1dHMuZXEoaWR4KS52YWwoKSksXFxuICAgICAgICAgICAgbmV3VmFsdWU7IC8vIGhhbmRsZSBrZXlib2FyZCBldmVudCB3aXRoIGtleWJvYXJkIHV0aWxcXG5cXG5cXG4gICAgICAgIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiS2V5Ym9hcmRcXFwiXS5oYW5kbGVLZXkoZSwgJ1NsaWRlcicsIHtcXG4gICAgICAgICAgZGVjcmVhc2U6IGZ1bmN0aW9uIGRlY3JlYXNlKCkge1xcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gb2xkVmFsdWUgLSBfdGhpcy5vcHRpb25zLnN0ZXA7XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIGluY3JlYXNlOiBmdW5jdGlvbiBpbmNyZWFzZSgpIHtcXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IG9sZFZhbHVlICsgX3RoaXMub3B0aW9ucy5zdGVwO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBkZWNyZWFzZV9mYXN0OiBmdW5jdGlvbiBkZWNyZWFzZV9mYXN0KCkge1xcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gb2xkVmFsdWUgLSBfdGhpcy5vcHRpb25zLnN0ZXAgKiAxMDtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgaW5jcmVhc2VfZmFzdDogZnVuY3Rpb24gaW5jcmVhc2VfZmFzdCgpIHtcXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IG9sZFZhbHVlICsgX3RoaXMub3B0aW9ucy5zdGVwICogMTA7XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIG1pbjogZnVuY3Rpb24gbWluKCkge1xcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gX3RoaXMub3B0aW9ucy5zdGFydDtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgbWF4OiBmdW5jdGlvbiBtYXgoKSB7XFxuICAgICAgICAgICAgbmV3VmFsdWUgPSBfdGhpcy5vcHRpb25zLmVuZDtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24gaGFuZGxlZCgpIHtcXG4gICAgICAgICAgICAvLyBvbmx5IHNldCBoYW5kbGUgcG9zIHdoZW4gZXZlbnQgd2FzIGhhbmRsZWQgc3BlY2lhbGx5XFxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcbiAgICAgICAgICAgIF90aGlzLl9zZXRIYW5kbGVQb3MoXyRoYW5kbGUsIG5ld1ZhbHVlLCB0cnVlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgICAvKmlmIChuZXdWYWx1ZSkgeyAvLyBpZiBwcmVzc2VkIGtleSBoYXMgc3BlY2lhbCBmdW5jdGlvbiwgdXBkYXRlIHZhbHVlXFxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgX3RoaXMuX3NldEhhbmRsZVBvcyhfJGhhbmRsZSwgbmV3VmFsdWUpO1xcbiAgICAgICAgfSovXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIERlc3Ryb3lzIHRoZSBzbGlkZXIgcGx1Z2luLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2Rlc3Ryb3lcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgdGhpcy5oYW5kbGVzLm9mZignLnpmLnNsaWRlcicpO1xcbiAgICAgIHRoaXMuaW5wdXRzLm9mZignLnpmLnNsaWRlcicpO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYuc2xpZGVyJyk7XFxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBTbGlkZXI7XFxufShfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJQbHVnaW5cXFwiXSk7XFxuXFxuU2xpZGVyLmRlZmF1bHRzID0ge1xcbiAgLyoqXFxuICAgKiBNaW5pbXVtIHZhbHVlIGZvciB0aGUgc2xpZGVyIHNjYWxlLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDBcXG4gICAqL1xcbiAgc3RhcnQ6IDAsXFxuXFxuICAvKipcXG4gICAqIE1heGltdW0gdmFsdWUgZm9yIHRoZSBzbGlkZXIgc2NhbGUuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgMTAwXFxuICAgKi9cXG4gIGVuZDogMTAwLFxcblxcbiAgLyoqXFxuICAgKiBNaW5pbXVtIHZhbHVlIGNoYW5nZSBwZXIgY2hhbmdlIGV2ZW50LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDFcXG4gICAqL1xcbiAgc3RlcDogMSxcXG5cXG4gIC8qKlxcbiAgICogVmFsdWUgYXQgd2hpY2ggdGhlIGhhbmRsZS9pbnB1dCAqKGxlZnQgaGFuZGxlL2ZpcnN0IGlucHV0KSogc2hvdWxkIGJlIHNldCB0byBvbiBpbml0aWFsaXphdGlvbi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAwXFxuICAgKi9cXG4gIGluaXRpYWxTdGFydDogMCxcXG5cXG4gIC8qKlxcbiAgICogVmFsdWUgYXQgd2hpY2ggdGhlIHJpZ2h0IGhhbmRsZS9zZWNvbmQgaW5wdXQgc2hvdWxkIGJlIHNldCB0byBvbiBpbml0aWFsaXphdGlvbi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAxMDBcXG4gICAqL1xcbiAgaW5pdGlhbEVuZDogMTAwLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvd3MgdGhlIGlucHV0IHRvIGJlIGxvY2F0ZWQgb3V0c2lkZSB0aGUgY29udGFpbmVyIGFuZCB2aXNpYmxlLiBTZXQgdG8gYnkgdGhlIEpTXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGJpbmRpbmc6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvd3MgdGhlIHVzZXIgdG8gY2xpY2svdGFwIG9uIHRoZSBzbGlkZXIgYmFyIHRvIHNlbGVjdCBhIHZhbHVlLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCB0cnVlXFxuICAgKi9cXG4gIGNsaWNrU2VsZWN0OiB0cnVlLFxcblxcbiAgLyoqXFxuICAgKiBTZXQgdG8gdHJ1ZSBhbmQgdXNlIHRoZSBgdmVydGljYWxgIGNsYXNzIHRvIGNoYW5nZSBhbGlnbm1lbnQgdG8gdmVydGljYWwuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIHZlcnRpY2FsOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogQWxsb3dzIHRoZSB1c2VyIHRvIGRyYWcgdGhlIHNsaWRlciBoYW5kbGUocykgdG8gc2VsZWN0IGEgdmFsdWUuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IHRydWVcXG4gICAqL1xcbiAgZHJhZ2dhYmxlOiB0cnVlLFxcblxcbiAgLyoqXFxuICAgKiBEaXNhYmxlcyB0aGUgc2xpZGVyIGFuZCBwcmV2ZW50cyBldmVudCBsaXN0ZW5lcnMgZnJvbSBiZWluZyBhcHBsaWVkLiBEb3VibGUgY2hlY2tlZCBieSBKUyB3aXRoIGBkaXNhYmxlZENsYXNzYC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgZGlzYWJsZWQ6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvd3MgdGhlIHVzZSBvZiB0d28gaGFuZGxlcy4gRG91YmxlIGNoZWNrZWQgYnkgdGhlIEpTLiBDaGFuZ2VzIHNvbWUgbG9naWMgaGFuZGxpbmcuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGRvdWJsZVNpZGVkOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogUG90ZW50aWFsIGZ1dHVyZSBmZWF0dXJlLlxcbiAgICovXFxuICAvLyBzdGVwczogMTAwLFxcblxcbiAgLyoqXFxuICAgKiBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhlIHBsdWdpbiBzaG91bGQgZ28gdG8gZm9yIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAyXFxuICAgKi9cXG4gIGRlY2ltYWw6IDIsXFxuXFxuICAvKipcXG4gICAqIFRpbWUgZGVsYXkgZm9yIGRyYWdnZWQgZWxlbWVudHMuXFxuICAgKi9cXG4gIC8vIGRyYWdEZWxheTogMCxcXG5cXG4gIC8qKlxcbiAgICogVGltZSwgaW4gbXMsIHRvIGFuaW1hdGUgdGhlIG1vdmVtZW50IG9mIGEgc2xpZGVyIGhhbmRsZSBpZiB1c2VyIGNsaWNrcy90YXBzIG9uIHRoZSBiYXIuIE5lZWRzIHRvIGJlIG1hbnVhbGx5IHNldCBpZiB1cGRhdGluZyB0aGUgdHJhbnNpdGlvbiB0aW1lIGluIHRoZSBTYXNzIHNldHRpbmdzLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDIwMFxcbiAgICovXFxuICBtb3ZlVGltZTogMjAwLFxcbiAgLy91cGRhdGUgdGhpcyBpZiBjaGFuZ2luZyB0aGUgdHJhbnNpdGlvbiB0aW1lIGluIHRoZSBzYXNzXFxuXFxuICAvKipcXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gZGlzYWJsZWQgc2xpZGVycy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnZGlzYWJsZWQnXFxuICAgKi9cXG4gIGRpc2FibGVkQ2xhc3M6ICdkaXNhYmxlZCcsXFxuXFxuICAvKipcXG4gICAqIFdpbGwgaW52ZXJ0IHRoZSBkZWZhdWx0IGxheW91dCBmb3IgYSB2ZXJ0aWNhbDxzcGFuIGRhdGEtdG9vbHRpcCB0aXRsZT1cXFwid2hvIHdvdWxkIGRvIHRoaXM/Pz9cXFwiPiA8L3NwYW4+c2xpZGVyLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBpbnZlcnRWZXJ0aWNhbDogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIE1pbGxpc2Vjb25kcyBiZWZvcmUgdGhlIGBjaGFuZ2VkLnpmLXNsaWRlcmAgZXZlbnQgaXMgdHJpZ2dlcmVkIGFmdGVyIHZhbHVlIGNoYW5nZS5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCA1MDBcXG4gICAqL1xcbiAgY2hhbmdlZERlbGF5OiA1MDAsXFxuXFxuICAvKipcXG4gICogQmFzZXZhbHVlIGZvciBub24tbGluZWFyIHNsaWRlcnNcXG4gICogQG9wdGlvblxcbiAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgKiBAZGVmYXVsdCA1XFxuICAqL1xcbiAgbm9uTGluZWFyQmFzZTogNSxcXG5cXG4gIC8qKlxcbiAgKiBCYXNldmFsdWUgZm9yIG5vbi1saW5lYXIgc2xpZGVycywgcG9zc2libGUgdmFsdWVzIGFyZTogYCdsaW5lYXInYCwgYCdwb3cnYCAmIGAnbG9nJ2AuIFBvdyBhbmQgTG9nIHVzZSB0aGUgbm9uTGluZWFyQmFzZSBzZXR0aW5nLlxcbiAgKiBAb3B0aW9uXFxuICAqIEB0eXBlIHtzdHJpbmd9XFxuICAqIEBkZWZhdWx0ICdsaW5lYXInXFxuICAqL1xcbiAgcG9zaXRpb25WYWx1ZUZ1bmN0aW9uOiAnbGluZWFyJ1xcbn07XFxuXFxuZnVuY3Rpb24gcGVyY2VudChmcmFjLCBudW0pIHtcXG4gIHJldHVybiBmcmFjIC8gbnVtO1xcbn1cXG5cXG5mdW5jdGlvbiBhYnNQb3NpdGlvbigkaGFuZGxlLCBkaXIsIGNsaWNrUG9zLCBwYXJhbSkge1xcbiAgcmV0dXJuIE1hdGguYWJzKCRoYW5kbGUucG9zaXRpb24oKVtkaXJdICsgJGhhbmRsZVtwYXJhbV0oKSAvIDIgLSBjbGlja1Bvcyk7XFxufVxcblxcbmZ1bmN0aW9uIGJhc2VMb2coYmFzZSwgdmFsdWUpIHtcXG4gIHJldHVybiBNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLmxvZyhiYXNlKTtcXG59XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi5zbGlkZXIuanM/XCIpfSxcIi4vanMvZm91bmRhdGlvbi5zbW9vdGhTY3JvbGwuanNcIjpmdW5jdGlvbihtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKCdfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlNtb290aFNjcm9sbFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFNtb290aFNjcm9sbDsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganF1ZXJ5ICovIFwianF1ZXJ5XCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnV0aWxzICovIFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUudXRpbHMuanNcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfcGx1Z2luX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uY29yZS5wbHVnaW4gKi8gXCIuL2pzL2ZvdW5kYXRpb24uY29yZS5wbHVnaW4uanNcIik7XFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cXG5cXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc25cXCd0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc25cXCd0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XFxuXFxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XFxuXFxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBTbW9vdGhTY3JvbGwgbW9kdWxlLlxcbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5zbW9vdGgtc2Nyb2xsXFxuICovXFxuXFxudmFyIFNtb290aFNjcm9sbCA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uIChfUGx1Z2luKSB7XFxuICBfaW5oZXJpdHMoU21vb3RoU2Nyb2xsLCBfUGx1Z2luKTtcXG5cXG4gIGZ1bmN0aW9uIFNtb290aFNjcm9sbCgpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNtb290aFNjcm9sbCk7XFxuXFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoU21vb3RoU2Nyb2xsKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhTbW9vdGhTY3JvbGwsIFt7XFxuICAgIGtleTogXCJfc2V0dXBcIixcXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgU21vb3RoU2Nyb2xsLlxcbiAgICAgKiBAY2xhc3NcXG4gICAgICogQG5hbWUgU21vb3RoU2Nyb2xsXFxuICAgICAqIEBmaXJlcyBTbW9vdGhTY3JvbGwjaW5pdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYWRkIHRoZSB0cmlnZ2VyIHRvLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZXh0ZW5kKHt9LCBTbW9vdGhTY3JvbGwuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9IFxcJ1Ntb290aFNjcm9sbFxcJzsgLy8gaWU5IGJhY2sgY29tcGF0XFxuXFxuICAgICAgdGhpcy5faW5pdCgpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplIHRoZSBTbW9vdGhTY3JvbGwgcGx1Z2luXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFwiX2luaXRcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgIHZhciBpZCA9IHRoaXMuJGVsZW1lbnRbMF0uaWQgfHwgT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkdldFlvRGlnaXRzXCJdKSg2LCBcXCdzbW9vdGgtc2Nyb2xsXFwnKTtcXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xcbiAgICAgICAgaWQ6IGlkXFxuICAgICAgfSk7XFxuXFxuICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgU21vb3RoU2Nyb2xsLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcIl9ldmVudHNcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudC5vbihcXCdjbGljay56Zi5zbW9vdGhTY3JvbGxcXCcsIHRoaXMuX2hhbmRsZUxpbmtDbGljayk7XFxuICAgICAgdGhpcy4kZWxlbWVudC5vbihcXCdjbGljay56Zi5zbW9vdGhTY3JvbGxcXCcsIFxcJ2FbaHJlZl49XCIjXCJdXFwnLCB0aGlzLl9oYW5kbGVMaW5rQ2xpY2spO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBIYW5kbGUgdGhlIGdpdmVuIGV2ZW50IHRvIHNtb290aGx5IHNjcm9sbCB0byB0aGUgYW5jaG9yIHBvaW50ZWQgYnkgdGhlIGV2ZW50IHRhcmdldC5cXG4gICAgICogQHBhcmFtIHsqfSBlIC0gZXZlbnRcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFwiX2hhbmRsZUxpbmtDbGlja1wiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUxpbmtDbGljayhlKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICAvLyBGb2xsb3cgdGhlIGxpbmsgaWYgaXQgZG9lcyBub3QgcG9pbnQgdG8gYW4gYW5jaG9yLlxcbiAgICAgIGlmICghanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGUuY3VycmVudFRhcmdldCkuaXMoXFwnYVtocmVmXj1cIiNcIl1cXCcpKSByZXR1cm47XFxuICAgICAgdmFyIGFycml2YWwgPSBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKFxcJ2hyZWZcXCcpO1xcbiAgICAgIHRoaXMuX2luVHJhbnNpdGlvbiA9IHRydWU7XFxuICAgICAgU21vb3RoU2Nyb2xsLnNjcm9sbFRvTG9jKGFycml2YWwsIHRoaXMub3B0aW9ucywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgX3RoaXMuX2luVHJhbnNpdGlvbiA9IGZhbHNlO1xcbiAgICAgIH0pO1xcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFwiX2Rlc3Ryb3lcIixcXG5cXG4gICAgLyoqXFxuICAgICAqIERlc3Ryb3lzIHRoZSBTbW9vdGhTY3JvbGwgaW5zdGFuY2UuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKFxcJ2NsaWNrLnpmLnNtb290aFNjcm9sbFxcJywgdGhpcy5faGFuZGxlTGlua0NsaWNrKTtcXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZihcXCdjbGljay56Zi5zbW9vdGhTY3JvbGxcXCcsIFxcJ2FbaHJlZl49XCIjXCJdXFwnLCB0aGlzLl9oYW5kbGVMaW5rQ2xpY2spO1xcbiAgICB9XFxuICB9XSwgW3tcXG4gICAga2V5OiBcInNjcm9sbFRvTG9jXCIsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBGdW5jdGlvbiB0byBzY3JvbGwgdG8gYSBnaXZlbiBsb2NhdGlvbiBvbiB0aGUgcGFnZS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxvYyAtIEEgcHJvcGVybHkgZm9ybWF0dGVkIGpRdWVyeSBpZCBzZWxlY3Rvci4gRXhhbXBsZTogXFwnI2Zvb1xcJ1xcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIHVzZS5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXFxuICAgICAqIEBzdGF0aWNcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2Nyb2xsVG9Mb2MobG9jKSB7XFxuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFNtb290aFNjcm9sbC5kZWZhdWx0cztcXG4gICAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcXG4gICAgICB2YXIgJGxvYyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShsb2MpOyAvLyBEbyBub3RoaW5nIGlmIHRhcmdldCBkb2VzIG5vdCBleGlzdCB0byBwcmV2ZW50IGVycm9yc1xcblxcbiAgICAgIGlmICghJGxvYy5sZW5ndGgpIHJldHVybiBmYWxzZTtcXG4gICAgICB2YXIgc2Nyb2xsUG9zID0gTWF0aC5yb3VuZCgkbG9jLm9mZnNldCgpLnRvcCAtIG9wdGlvbnMudGhyZXNob2xkIC8gMiAtIG9wdGlvbnMub2Zmc2V0KTtcXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoXFwnaHRtbCwgYm9keVxcJykuc3RvcCh0cnVlKS5hbmltYXRlKHtcXG4gICAgICAgIHNjcm9sbFRvcDogc2Nyb2xsUG9zXFxuICAgICAgfSwgb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbiwgb3B0aW9ucy5hbmltYXRpb25FYXNpbmcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFxcJ2Z1bmN0aW9uXFwnKSB7XFxuICAgICAgICAgIGNhbGxiYWNrKCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBTbW9vdGhTY3JvbGw7XFxufShfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiUGx1Z2luXCJdKTtcXG4vKipcXG4gKiBEZWZhdWx0IHNldHRpbmdzIGZvciBwbHVnaW4uXFxuICovXFxuXFxuXFxuU21vb3RoU2Nyb2xsLmRlZmF1bHRzID0ge1xcbiAgLyoqXFxuICAgKiBBbW91bnQgb2YgdGltZSwgaW4gbXMsIHRoZSBhbmltYXRlZCBzY3JvbGxpbmcgc2hvdWxkIHRha2UgYmV0d2VlbiBsb2NhdGlvbnMuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgNTAwXFxuICAgKi9cXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXFxuXFxuICAvKipcXG4gICAqIEFuaW1hdGlvbiBzdHlsZSB0byB1c2Ugd2hlbiBzY3JvbGxpbmcgYmV0d2VlbiBsb2NhdGlvbnMuIENhbiBiZSBgXFwnc3dpbmdcXCdgIG9yIGBcXCdsaW5lYXJcXCdgLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0IFxcJ2xpbmVhclxcJ1xcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9hbmltYXRlfEpxdWVyeSBhbmltYXRlfVxcbiAgICovXFxuICBhbmltYXRpb25FYXNpbmc6IFxcJ2xpbmVhclxcJyxcXG5cXG4gIC8qKlxcbiAgICogTnVtYmVyIG9mIHBpeGVscyB0byB1c2UgYXMgYSBtYXJrZXIgZm9yIGxvY2F0aW9uIGNoYW5nZXMuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgNTBcXG4gICAqL1xcbiAgdGhyZXNob2xkOiA1MCxcXG5cXG4gIC8qKlxcbiAgICogTnVtYmVyIG9mIHBpeGVscyB0byBvZmZzZXQgdGhlIHNjcm9sbCBvZiB0aGUgcGFnZSBvbiBpdGVtIGNsaWNrIGlmIHVzaW5nIGEgc3RpY2t5IG5hdiBiYXIuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgMFxcbiAgICovXFxuICBvZmZzZXQ6IDBcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL2pzL2ZvdW5kYXRpb24uc21vb3RoU2Nyb2xsLmpzPycpfSxcIi4vanMvZm91bmRhdGlvbi5zdGlja3kuanNcIjpmdW5jdGlvbihtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlN0aWNreVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU3RpY2t5OyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBqcXVlcnkgKi8gXFxcImpxdWVyeVxcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnV0aWxzICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS51dGlscy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnkgKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnkuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnBsdWdpbiAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUucGx1Z2luLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3V0aWxfdHJpZ2dlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzICovIFxcXCIuL2pzL2ZvdW5kYXRpb24udXRpbC50cmlnZ2Vycy5qc1xcXCIpO1xcblxcblxcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXFxcImZ1bmN0aW9uXFxcIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cXG5cXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXFxcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFxcXCIpOyB9IHJldHVybiBzZWxmOyB9XFxuXFxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblxcXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cXG5cXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxcblxcblxcblxcblxcblxcblxcbi8qKlxcbiAqIFN0aWNreSBtb2R1bGUuXFxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnN0aWNreVxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnlcXG4gKi9cXG5cXG52YXIgU3RpY2t5ID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKF9QbHVnaW4pIHtcXG4gIF9pbmhlcml0cyhTdGlja3ksIF9QbHVnaW4pO1xcblxcbiAgZnVuY3Rpb24gU3RpY2t5KCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RpY2t5KTtcXG5cXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihTdGlja3kpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKFN0aWNreSwgW3tcXG4gICAga2V5OiBcXFwiX3NldHVwXFxcIixcXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBzdGlja3kgdGhpbmcuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAbmFtZSBTdGlja3lcXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2Ugc3RpY2t5LlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgb2JqZWN0IHBhc3NlZCB3aGVuIGNyZWF0aW5nIHRoZSBlbGVtZW50IHByb2dyYW1tYXRpY2FsbHkuXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZXh0ZW5kKHt9LCBTdGlja3kuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdTdGlja3knOyAvLyBpZTkgYmFjayBjb21wYXRcXG4gICAgICAvLyBUcmlnZ2VycyBpbml0IGlzIGlkZW1wb3RlbnQsIGp1c3QgbmVlZCB0byBtYWtlIHN1cmUgaXQgaXMgaW5pdGlhbGl6ZWRcXG5cXG4gICAgICBfZm91bmRhdGlvbl91dGlsX3RyaWdnZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcIlRyaWdnZXJzXFxcIl0uaW5pdChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEpO1xcblxcbiAgICAgIHRoaXMuX2luaXQoKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHN0aWNreSBlbGVtZW50IGJ5IGFkZGluZyBjbGFzc2VzLCBnZXR0aW5nL3NldHRpbmcgZGltZW5zaW9ucywgYnJlYWtwb2ludHMgYW5kIGF0dHJpYnV0ZXNcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfaW5pdFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcXG4gICAgICBfZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiTWVkaWFRdWVyeVxcXCJdLl9pbml0KCk7XFxuXFxuICAgICAgdmFyICRwYXJlbnQgPSB0aGlzLiRlbGVtZW50LnBhcmVudCgnW2RhdGEtc3RpY2t5LWNvbnRhaW5lcl0nKSxcXG4gICAgICAgICAgaWQgPSB0aGlzLiRlbGVtZW50WzBdLmlkIHx8IE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIkdldFlvRGlnaXRzXFxcIl0pKDYsICdzdGlja3knKSxcXG4gICAgICAgICAgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgIGlmICgkcGFyZW50Lmxlbmd0aCkge1xcbiAgICAgICAgdGhpcy4kY29udGFpbmVyID0gJHBhcmVudDtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy53YXNXcmFwcGVkID0gdHJ1ZTtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQud3JhcCh0aGlzLm9wdGlvbnMuY29udGFpbmVyKTtcXG4gICAgICAgIHRoaXMuJGNvbnRhaW5lciA9IHRoaXMuJGVsZW1lbnQucGFyZW50KCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuJGNvbnRhaW5lci5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuY29udGFpbmVyQ2xhc3MpO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnN0aWNreUNsYXNzKS5hdHRyKHtcXG4gICAgICAgICdkYXRhLXJlc2l6ZSc6IGlkLFxcbiAgICAgICAgJ2RhdGEtbXV0YXRlJzogaWRcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFuY2hvciAhPT0gJycpIHtcXG4gICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnIycgKyBfdGhpcy5vcHRpb25zLmFuY2hvcikuYXR0cih7XFxuICAgICAgICAgICdkYXRhLW11dGF0ZSc6IGlkXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5zY3JvbGxDb3VudCA9IHRoaXMub3B0aW9ucy5jaGVja0V2ZXJ5O1xcbiAgICAgIHRoaXMuaXNTdHVjayA9IGZhbHNlO1xcbiAgICAgIHRoaXMub25Mb2FkTGlzdGVuZXIgPSBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJvbkxvYWRcXFwiXSkoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdyksIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIC8vV2UgY2FsY3VsYXRlIHRoZSBjb250YWluZXIgaGVpZ2h0IHRvIGhhdmUgY29ycmVjdCB2YWx1ZXMgZm9yIGFuY2hvciBwb2ludHMgb2Zmc2V0IGNhbGN1bGF0aW9uLlxcbiAgICAgICAgX3RoaXMuY29udGFpbmVySGVpZ2h0ID0gX3RoaXMuJGVsZW1lbnQuY3NzKFxcXCJkaXNwbGF5XFxcIikgPT0gXFxcIm5vbmVcXFwiID8gMCA6IF90aGlzLiRlbGVtZW50WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcXG5cXG4gICAgICAgIF90aGlzLiRjb250YWluZXIuY3NzKCdoZWlnaHQnLCBfdGhpcy5jb250YWluZXJIZWlnaHQpO1xcblxcbiAgICAgICAgX3RoaXMuZWxlbUhlaWdodCA9IF90aGlzLmNvbnRhaW5lckhlaWdodDtcXG5cXG4gICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmFuY2hvciAhPT0gJycpIHtcXG4gICAgICAgICAgX3RoaXMuJGFuY2hvciA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnIycgKyBfdGhpcy5vcHRpb25zLmFuY2hvcik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBfdGhpcy5fcGFyc2VQb2ludHMoKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIF90aGlzLl9zZXRTaXplcyhmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHZhciBzY3JvbGwgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XFxuXFxuICAgICAgICAgIF90aGlzLl9jYWxjKGZhbHNlLCBzY3JvbGwpOyAvL1Vuc3RpY2sgdGhlIGVsZW1lbnQgd2lsbCBlbnN1cmUgdGhhdCBwcm9wZXIgY2xhc3NlcyBhcmUgc2V0LlxcblxcblxcbiAgICAgICAgICBpZiAoIV90aGlzLmlzU3R1Y2spIHtcXG4gICAgICAgICAgICBfdGhpcy5fcmVtb3ZlU3RpY2t5KHNjcm9sbCA+PSBfdGhpcy50b3BQb2ludCA/IGZhbHNlIDogdHJ1ZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgX3RoaXMuX2V2ZW50cyhpZC5zcGxpdCgnLScpLnJldmVyc2UoKS5qb2luKCctJykpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJZiB1c2luZyBtdWx0aXBsZSBlbGVtZW50cyBhcyBhbmNob3JzLCBjYWxjdWxhdGVzIHRoZSB0b3AgYW5kIGJvdHRvbSBwaXhlbCB2YWx1ZXMgdGhlIHN0aWNreSB0aGluZyBzaG91bGQgc3RpY2sgYW5kIHVuc3RpY2sgb24uXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3BhcnNlUG9pbnRzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJzZVBvaW50cygpIHtcXG4gICAgICB2YXIgdG9wID0gdGhpcy5vcHRpb25zLnRvcEFuY2hvciA9PSBcXFwiXFxcIiA/IDEgOiB0aGlzLm9wdGlvbnMudG9wQW5jaG9yLFxcbiAgICAgICAgICBidG0gPSB0aGlzLm9wdGlvbnMuYnRtQW5jaG9yID09IFxcXCJcXFwiID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCA6IHRoaXMub3B0aW9ucy5idG1BbmNob3IsXFxuICAgICAgICAgIHB0cyA9IFt0b3AsIGJ0bV0sXFxuICAgICAgICAgIGJyZWFrcyA9IHt9O1xcblxcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwdHMubGVuZ3RoOyBpIDwgbGVuICYmIHB0c1tpXTsgaSsrKSB7XFxuICAgICAgICB2YXIgcHQ7XFxuXFxuICAgICAgICBpZiAodHlwZW9mIHB0c1tpXSA9PT0gJ251bWJlcicpIHtcXG4gICAgICAgICAgcHQgPSBwdHNbaV07XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB2YXIgcGxhY2UgPSBwdHNbaV0uc3BsaXQoJzonKSxcXG4gICAgICAgICAgICAgIGFuY2hvciA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShcXFwiI1xcXCIuY29uY2F0KHBsYWNlWzBdKSk7XFxuICAgICAgICAgIHB0ID0gYW5jaG9yLm9mZnNldCgpLnRvcDtcXG5cXG4gICAgICAgICAgaWYgKHBsYWNlWzFdICYmIHBsYWNlWzFdLnRvTG93ZXJDYXNlKCkgPT09ICdib3R0b20nKSB7XFxuICAgICAgICAgICAgcHQgKz0gYW5jaG9yWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgYnJlYWtzW2ldID0gcHQ7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMucG9pbnRzID0gYnJlYWtzO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQWRkcyBldmVudCBoYW5kbGVycyBmb3IgdGhlIHNjcm9sbGluZyBlbGVtZW50LlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBwc2V1ZG8tcmFuZG9tIGlkIGZvciB1bmlxdWUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2V2ZW50c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKGlkKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcyxcXG4gICAgICAgICAgc2Nyb2xsTGlzdGVuZXIgPSB0aGlzLnNjcm9sbExpc3RlbmVyID0gXFxcInNjcm9sbC56Zi5cXFwiLmNvbmNhdChpZCk7XFxuXFxuICAgICAgaWYgKHRoaXMuaXNPbikge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5jYW5TdGljaykge1xcbiAgICAgICAgdGhpcy5pc09uID0gdHJ1ZTtcXG4gICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLm9mZihzY3JvbGxMaXN0ZW5lcikub24oc2Nyb2xsTGlzdGVuZXIsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIGlmIChfdGhpcy5zY3JvbGxDb3VudCA9PT0gMCkge1xcbiAgICAgICAgICAgIF90aGlzLnNjcm9sbENvdW50ID0gX3RoaXMub3B0aW9ucy5jaGVja0V2ZXJ5O1xcblxcbiAgICAgICAgICAgIF90aGlzLl9zZXRTaXplcyhmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICBfdGhpcy5fY2FsYyhmYWxzZSwgd2luZG93LnBhZ2VZT2Zmc2V0KTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBfdGhpcy5zY3JvbGxDb3VudC0tO1xcblxcbiAgICAgICAgICAgIF90aGlzLl9jYWxjKGZhbHNlLCB3aW5kb3cucGFnZVlPZmZzZXQpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInKS5vbigncmVzaXplbWUuemYudHJpZ2dlcicsIGZ1bmN0aW9uIChlLCBlbCkge1xcbiAgICAgICAgX3RoaXMuX2V2ZW50c0hhbmRsZXIoaWQpO1xcbiAgICAgIH0pO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQub24oJ211dGF0ZW1lLnpmLnRyaWdnZXInLCBmdW5jdGlvbiAoZSwgZWwpIHtcXG4gICAgICAgIF90aGlzLl9ldmVudHNIYW5kbGVyKGlkKTtcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAodGhpcy4kYW5jaG9yKSB7XFxuICAgICAgICB0aGlzLiRhbmNob3Iub24oJ211dGF0ZW1lLnpmLnRyaWdnZXInLCBmdW5jdGlvbiAoZSwgZWwpIHtcXG4gICAgICAgICAgX3RoaXMuX2V2ZW50c0hhbmRsZXIoaWQpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBIYW5kbGVyIGZvciBldmVudHMuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIHBzZXVkby1yYW5kb20gaWQgZm9yIHVuaXF1ZSBzY3JvbGwgZXZlbnQgbGlzdGVuZXIuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZXZlbnRzSGFuZGxlclxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzSGFuZGxlcihpZCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXFxuICAgICAgICAgIHNjcm9sbExpc3RlbmVyID0gdGhpcy5zY3JvbGxMaXN0ZW5lciA9IFxcXCJzY3JvbGwuemYuXFxcIi5jb25jYXQoaWQpO1xcblxcbiAgICAgIF90aGlzLl9zZXRTaXplcyhmdW5jdGlvbiAoKSB7XFxuICAgICAgICBfdGhpcy5fY2FsYyhmYWxzZSk7XFxuXFxuICAgICAgICBpZiAoX3RoaXMuY2FuU3RpY2spIHtcXG4gICAgICAgICAgaWYgKCFfdGhpcy5pc09uKSB7XFxuICAgICAgICAgICAgX3RoaXMuX2V2ZW50cyhpZCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSBpZiAoX3RoaXMuaXNPbikge1xcbiAgICAgICAgICBfdGhpcy5fcGF1c2VMaXN0ZW5lcnMoc2Nyb2xsTGlzdGVuZXIpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBSZW1vdmVzIGV2ZW50IGhhbmRsZXJzIGZvciBzY3JvbGwgYW5kIGNoYW5nZSBldmVudHMgb24gYW5jaG9yLlxcbiAgICAgKiBAZmlyZXMgU3RpY2t5I3BhdXNlXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzY3JvbGxMaXN0ZW5lciAtIHVuaXF1ZSwgbmFtZXNwYWNlZCBzY3JvbGwgbGlzdGVuZXIgYXR0YWNoZWQgdG8gYHdpbmRvd2BcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9wYXVzZUxpc3RlbmVyc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGF1c2VMaXN0ZW5lcnMoc2Nyb2xsTGlzdGVuZXIpIHtcXG4gICAgICB0aGlzLmlzT24gPSBmYWxzZTtcXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS5vZmYoc2Nyb2xsTGlzdGVuZXIpO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHBsdWdpbiBpcyBwYXVzZWQgZHVlIHRvIHJlc2l6ZSBldmVudCBzaHJpbmtpbmcgdGhlIHZpZXcuXFxuICAgICAgICogQGV2ZW50IFN0aWNreSNwYXVzZVxcbiAgICAgICAqIEBwcml2YXRlXFxuICAgICAgICovXFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdwYXVzZS56Zi5zdGlja3knKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2FsbGVkIG9uIGV2ZXJ5IGBzY3JvbGxgIGV2ZW50IGFuZCBvbiBgX2luaXRgXFxuICAgICAqIGZpcmVzIGZ1bmN0aW9ucyBiYXNlZCBvbiBib29sZWFucyBhbmQgY2FjaGVkIHZhbHVlc1xcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNoZWNrU2l6ZXMgLSB0cnVlIGlmIHBsdWdpbiBzaG91bGQgcmVjYWxjdWxhdGUgc2l6ZXMgYW5kIGJyZWFrcG9pbnRzLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Nyb2xsIC0gY3VycmVudCBzY3JvbGwgcG9zaXRpb24gcGFzc2VkIGZyb20gc2Nyb2xsIGV2ZW50IGNiIGZ1bmN0aW9uLiBJZiBub3QgcGFzc2VkLCBkZWZhdWx0cyB0byBgd2luZG93LnBhZ2VZT2Zmc2V0YC5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9jYWxjXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjKGNoZWNrU2l6ZXMsIHNjcm9sbCkge1xcbiAgICAgIGlmIChjaGVja1NpemVzKSB7XFxuICAgICAgICB0aGlzLl9zZXRTaXplcygpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXRoaXMuY2FuU3RpY2spIHtcXG4gICAgICAgIGlmICh0aGlzLmlzU3R1Y2spIHtcXG4gICAgICAgICAgdGhpcy5fcmVtb3ZlU3RpY2t5KHRydWUpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXNjcm9sbCkge1xcbiAgICAgICAgc2Nyb2xsID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoc2Nyb2xsID49IHRoaXMudG9wUG9pbnQpIHtcXG4gICAgICAgIGlmIChzY3JvbGwgPD0gdGhpcy5ib3R0b21Qb2ludCkge1xcbiAgICAgICAgICBpZiAoIXRoaXMuaXNTdHVjaykge1xcbiAgICAgICAgICAgIHRoaXMuX3NldFN0aWNreSgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBpZiAodGhpcy5pc1N0dWNrKSB7XFxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlU3RpY2t5KGZhbHNlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAodGhpcy5pc1N0dWNrKSB7XFxuICAgICAgICAgIHRoaXMuX3JlbW92ZVN0aWNreSh0cnVlKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENhdXNlcyB0aGUgJGVsZW1lbnQgdG8gYmVjb21lIHN0dWNrLlxcbiAgICAgKiBBZGRzIGBwb3NpdGlvbjogZml4ZWQ7YCwgYW5kIGhlbHBlciBjbGFzc2VzLlxcbiAgICAgKiBAZmlyZXMgU3RpY2t5I3N0dWNrdG9cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfc2V0U3RpY2t5XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRTdGlja3koKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcyxcXG4gICAgICAgICAgc3RpY2tUbyA9IHRoaXMub3B0aW9ucy5zdGlja1RvLFxcbiAgICAgICAgICBtcmduID0gc3RpY2tUbyA9PT0gJ3RvcCcgPyAnbWFyZ2luVG9wJyA6ICdtYXJnaW5Cb3R0b20nLFxcbiAgICAgICAgICBub3RTdHVja1RvID0gc3RpY2tUbyA9PT0gJ3RvcCcgPyAnYm90dG9tJyA6ICd0b3AnLFxcbiAgICAgICAgICBjc3MgPSB7fTtcXG5cXG4gICAgICBjc3NbbXJnbl0gPSBcXFwiXFxcIi5jb25jYXQodGhpcy5vcHRpb25zW21yZ25dLCBcXFwiZW1cXFwiKTtcXG4gICAgICBjc3Nbc3RpY2tUb10gPSAwO1xcbiAgICAgIGNzc1tub3RTdHVja1RvXSA9ICdhdXRvJztcXG4gICAgICB0aGlzLmlzU3R1Y2sgPSB0cnVlO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcImlzLWFuY2hvcmVkIGlzLWF0LVxcXCIuY29uY2F0KG5vdFN0dWNrVG8pKS5hZGRDbGFzcyhcXFwiaXMtc3R1Y2sgaXMtYXQtXFxcIi5jb25jYXQoc3RpY2tUbykpLmNzcyhjc3MpXFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgJGVsZW1lbnQgaGFzIGJlY29tZSBgcG9zaXRpb246IGZpeGVkO2BcXG4gICAgICAgKiBOYW1lc3BhY2VkIHRvIGB0b3BgIG9yIGBib3R0b21gLCBlLmcuIGBzdGlja3kuemYuc3R1Y2t0bzp0b3BgXFxuICAgICAgICogQGV2ZW50IFN0aWNreSNzdHVja3RvXFxuICAgICAgICovXFxuICAgICAgLnRyaWdnZXIoXFxcInN0aWNreS56Zi5zdHVja3RvOlxcXCIuY29uY2F0KHN0aWNrVG8pKTtcXG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKFxcXCJ0cmFuc2l0aW9uZW5kIHdlYmtpdFRyYW5zaXRpb25FbmQgb1RyYW5zaXRpb25FbmQgb3RyYW5zaXRpb25lbmQgTVNUcmFuc2l0aW9uRW5kXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgX3RoaXMuX3NldFNpemVzKCk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENhdXNlcyB0aGUgJGVsZW1lbnQgdG8gYmVjb21lIHVuc3R1Y2suXFxuICAgICAqIFJlbW92ZXMgYHBvc2l0aW9uOiBmaXhlZDtgLCBhbmQgaGVscGVyIGNsYXNzZXMuXFxuICAgICAqIEFkZHMgb3RoZXIgaGVscGVyIGNsYXNzZXMuXFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNUb3AgLSB0ZWxscyB0aGUgZnVuY3Rpb24gaWYgdGhlICRlbGVtZW50IHNob3VsZCBhbmNob3IgdG8gdGhlIHRvcCBvciBib3R0b20gb2YgaXRzICRhbmNob3IgZWxlbWVudC5cXG4gICAgICogQGZpcmVzIFN0aWNreSN1bnN0dWNrZnJvbVxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3JlbW92ZVN0aWNreVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlU3RpY2t5KGlzVG9wKSB7XFxuICAgICAgdmFyIHN0aWNrVG8gPSB0aGlzLm9wdGlvbnMuc3RpY2tUbyxcXG4gICAgICAgICAgc3RpY2tUb1RvcCA9IHN0aWNrVG8gPT09ICd0b3AnLFxcbiAgICAgICAgICBjc3MgPSB7fSxcXG4gICAgICAgICAgYW5jaG9yUHQgPSAodGhpcy5wb2ludHMgPyB0aGlzLnBvaW50c1sxXSAtIHRoaXMucG9pbnRzWzBdIDogdGhpcy5hbmNob3JIZWlnaHQpIC0gdGhpcy5lbGVtSGVpZ2h0LFxcbiAgICAgICAgICBtcmduID0gc3RpY2tUb1RvcCA/ICdtYXJnaW5Ub3AnIDogJ21hcmdpbkJvdHRvbScsXFxuICAgICAgICAgIG5vdFN0dWNrVG8gPSBzdGlja1RvVG9wID8gJ2JvdHRvbScgOiAndG9wJyxcXG4gICAgICAgICAgdG9wT3JCb3R0b20gPSBpc1RvcCA/ICd0b3AnIDogJ2JvdHRvbSc7XFxuICAgICAgY3NzW21yZ25dID0gMDtcXG4gICAgICBjc3NbJ2JvdHRvbSddID0gJ2F1dG8nO1xcblxcbiAgICAgIGlmIChpc1RvcCkge1xcbiAgICAgICAgY3NzWyd0b3AnXSA9IDA7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGNzc1sndG9wJ10gPSBhbmNob3JQdDtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5pc1N0dWNrID0gZmFsc2U7XFxuICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwiaXMtc3R1Y2sgaXMtYXQtXFxcIi5jb25jYXQoc3RpY2tUbykpLmFkZENsYXNzKFxcXCJpcy1hbmNob3JlZCBpcy1hdC1cXFwiLmNvbmNhdCh0b3BPckJvdHRvbSkpLmNzcyhjc3MpXFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgJGVsZW1lbnQgaGFzIGJlY29tZSBhbmNob3JlZC5cXG4gICAgICAgKiBOYW1lc3BhY2VkIHRvIGB0b3BgIG9yIGBib3R0b21gLCBlLmcuIGBzdGlja3kuemYudW5zdHVja2Zyb206Ym90dG9tYFxcbiAgICAgICAqIEBldmVudCBTdGlja3kjdW5zdHVja2Zyb21cXG4gICAgICAgKi9cXG4gICAgICAudHJpZ2dlcihcXFwic3RpY2t5LnpmLnVuc3R1Y2tmcm9tOlxcXCIuY29uY2F0KHRvcE9yQm90dG9tKSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFNldHMgdGhlICRlbGVtZW50IGFuZCAkY29udGFpbmVyIHNpemVzIGZvciBwbHVnaW4uXFxuICAgICAqIENhbGxzIGBfc2V0QnJlYWtQb2ludHNgLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgb24gY29tcGxldGlvbiBvZiBgX3NldEJyZWFrUG9pbnRzYC5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9zZXRTaXplc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0U2l6ZXMoY2IpIHtcXG4gICAgICB0aGlzLmNhblN0aWNrID0gX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIk1lZGlhUXVlcnlcXFwiXS5pcyh0aGlzLm9wdGlvbnMuc3RpY2t5T24pO1xcblxcbiAgICAgIGlmICghdGhpcy5jYW5TdGljaykge1xcbiAgICAgICAgaWYgKGNiICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICBjYigpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxcbiAgICAgICAgICBuZXdFbGVtV2lkdGggPSB0aGlzLiRjb250YWluZXJbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgsXFxuICAgICAgICAgIGNvbXAgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRjb250YWluZXJbMF0pLFxcbiAgICAgICAgICBwZG5nbCA9IHBhcnNlSW50KGNvbXBbJ3BhZGRpbmctbGVmdCddLCAxMCksXFxuICAgICAgICAgIHBkbmdyID0gcGFyc2VJbnQoY29tcFsncGFkZGluZy1yaWdodCddLCAxMCk7XFxuXFxuICAgICAgaWYgKHRoaXMuJGFuY2hvciAmJiB0aGlzLiRhbmNob3IubGVuZ3RoKSB7XFxuICAgICAgICB0aGlzLmFuY2hvckhlaWdodCA9IHRoaXMuJGFuY2hvclswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuX3BhcnNlUG9pbnRzKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQuY3NzKHtcXG4gICAgICAgICdtYXgtd2lkdGgnOiBcXFwiXFxcIi5jb25jYXQobmV3RWxlbVdpZHRoIC0gcGRuZ2wgLSBwZG5nciwgXFxcInB4XFxcIilcXG4gICAgICB9KTtcXG4gICAgICB2YXIgbmV3Q29udGFpbmVySGVpZ2h0ID0gdGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgfHwgdGhpcy5jb250YWluZXJIZWlnaHQ7XFxuXFxuICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuY3NzKFxcXCJkaXNwbGF5XFxcIikgPT0gXFxcIm5vbmVcXFwiKSB7XFxuICAgICAgICBuZXdDb250YWluZXJIZWlnaHQgPSAwO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLmNvbnRhaW5lckhlaWdodCA9IG5ld0NvbnRhaW5lckhlaWdodDtcXG4gICAgICB0aGlzLiRjb250YWluZXIuY3NzKHtcXG4gICAgICAgIGhlaWdodDogbmV3Q29udGFpbmVySGVpZ2h0XFxuICAgICAgfSk7XFxuICAgICAgdGhpcy5lbGVtSGVpZ2h0ID0gbmV3Q29udGFpbmVySGVpZ2h0O1xcblxcbiAgICAgIGlmICghdGhpcy5pc1N0dWNrKSB7XFxuICAgICAgICBpZiAodGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaXMtYXQtYm90dG9tJykpIHtcXG4gICAgICAgICAgdmFyIGFuY2hvclB0ID0gKHRoaXMucG9pbnRzID8gdGhpcy5wb2ludHNbMV0gLSB0aGlzLiRjb250YWluZXIub2Zmc2V0KCkudG9wIDogdGhpcy5hbmNob3JIZWlnaHQpIC0gdGhpcy5lbGVtSGVpZ2h0O1xcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LmNzcygndG9wJywgYW5jaG9yUHQpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9zZXRCcmVha1BvaW50cyhuZXdDb250YWluZXJIZWlnaHQsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmIChjYiAmJiB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgY2IoKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogU2V0cyB0aGUgdXBwZXIgYW5kIGxvd2VyIGJyZWFrcG9pbnRzIGZvciB0aGUgZWxlbWVudCB0byBiZWNvbWUgc3RpY2t5L3Vuc3RpY2t5LlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZWxlbUhlaWdodCAtIHB4IHZhbHVlIGZvciBzdGlja3kuJGVsZW1lbnQgaGVpZ2h0LCBjYWxjdWxhdGVkIGJ5IGBfc2V0U2l6ZXNgLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBjb21wbGV0aW9uLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3NldEJyZWFrUG9pbnRzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRCcmVha1BvaW50cyhlbGVtSGVpZ2h0LCBjYikge1xcbiAgICAgIGlmICghdGhpcy5jYW5TdGljaykge1xcbiAgICAgICAgaWYgKGNiICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICBjYigpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgbVRvcCA9IGVtQ2FsYyh0aGlzLm9wdGlvbnMubWFyZ2luVG9wKSxcXG4gICAgICAgICAgbUJ0bSA9IGVtQ2FsYyh0aGlzLm9wdGlvbnMubWFyZ2luQm90dG9tKSxcXG4gICAgICAgICAgdG9wUG9pbnQgPSB0aGlzLnBvaW50cyA/IHRoaXMucG9pbnRzWzBdIDogdGhpcy4kYW5jaG9yLm9mZnNldCgpLnRvcCxcXG4gICAgICAgICAgYm90dG9tUG9pbnQgPSB0aGlzLnBvaW50cyA/IHRoaXMucG9pbnRzWzFdIDogdG9wUG9pbnQgKyB0aGlzLmFuY2hvckhlaWdodCxcXG4gICAgICAgICAgLy8gdG9wUG9pbnQgPSB0aGlzLiRhbmNob3Iub2Zmc2V0KCkudG9wIHx8IHRoaXMucG9pbnRzWzBdLFxcbiAgICAgIC8vIGJvdHRvbVBvaW50ID0gdG9wUG9pbnQgKyB0aGlzLmFuY2hvckhlaWdodCB8fCB0aGlzLnBvaW50c1sxXSxcXG4gICAgICB3aW5IZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGlja1RvID09PSAndG9wJykge1xcbiAgICAgICAgdG9wUG9pbnQgLT0gbVRvcDtcXG4gICAgICAgIGJvdHRvbVBvaW50IC09IGVsZW1IZWlnaHQgKyBtVG9wO1xcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnN0aWNrVG8gPT09ICdib3R0b20nKSB7XFxuICAgICAgICB0b3BQb2ludCAtPSB3aW5IZWlnaHQgLSAoZWxlbUhlaWdodCArIG1CdG0pO1xcbiAgICAgICAgYm90dG9tUG9pbnQgLT0gd2luSGVpZ2h0IC0gbUJ0bTtcXG4gICAgICB9IGVsc2Ugey8vdGhpcyB3b3VsZCBiZSB0aGUgc3RpY2tUbzogYm90aCBvcHRpb24uLi4gdHJpY2t5XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMudG9wUG9pbnQgPSB0b3BQb2ludDtcXG4gICAgICB0aGlzLmJvdHRvbVBvaW50ID0gYm90dG9tUG9pbnQ7XFxuXFxuICAgICAgaWYgKGNiICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgY2IoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIERlc3Ryb3lzIHRoZSBjdXJyZW50IHN0aWNreSBlbGVtZW50LlxcbiAgICAgKiBSZXNldHMgdGhlIGVsZW1lbnQgdG8gdGhlIHRvcCBwb3NpdGlvbiBmaXJzdC5cXG4gICAgICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lcnMsIEpTLWFkZGVkIGNzcyBwcm9wZXJ0aWVzIGFuZCBjbGFzc2VzLCBhbmQgdW53cmFwcyB0aGUgJGVsZW1lbnQgaWYgdGhlIEpTIGFkZGVkIHRoZSAkY29udGFpbmVyLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9kZXN0cm95XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgIHRoaXMuX3JlbW92ZVN0aWNreSh0cnVlKTtcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJcXFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuc3RpY2t5Q2xhc3MsIFxcXCIgaXMtYW5jaG9yZWQgaXMtYXQtdG9wXFxcIikpLmNzcyh7XFxuICAgICAgICBoZWlnaHQ6ICcnLFxcbiAgICAgICAgdG9wOiAnJyxcXG4gICAgICAgIGJvdHRvbTogJycsXFxuICAgICAgICAnbWF4LXdpZHRoJzogJydcXG4gICAgICB9KS5vZmYoJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInKS5vZmYoJ211dGF0ZW1lLnpmLnRyaWdnZXInKTtcXG5cXG4gICAgICBpZiAodGhpcy4kYW5jaG9yICYmIHRoaXMuJGFuY2hvci5sZW5ndGgpIHtcXG4gICAgICAgIHRoaXMuJGFuY2hvci5vZmYoJ2NoYW5nZS56Zi5zdGlja3knKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuc2Nyb2xsTGlzdGVuZXIpIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLm9mZih0aGlzLnNjcm9sbExpc3RlbmVyKTtcXG4gICAgICBpZiAodGhpcy5vbkxvYWRMaXN0ZW5lcikganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub2ZmKHRoaXMub25Mb2FkTGlzdGVuZXIpO1xcblxcbiAgICAgIGlmICh0aGlzLndhc1dyYXBwZWQpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudW53cmFwKCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuY29udGFpbmVyQ2xhc3MpLmNzcyh7XFxuICAgICAgICAgIGhlaWdodDogJydcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIFN0aWNreTtcXG59KF9mb3VuZGF0aW9uX2NvcmVfcGx1Z2luX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcIlBsdWdpblxcXCJdKTtcXG5cXG5TdGlja3kuZGVmYXVsdHMgPSB7XFxuICAvKipcXG4gICAqIEN1c3RvbWl6YWJsZSBjb250YWluZXIgdGVtcGxhdGUuIEFkZCB5b3VyIG93biBjbGFzc2VzIGZvciBzdHlsaW5nIGFuZCBzaXppbmcuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJyZsdDtkaXYgZGF0YS1zdGlja3ktY29udGFpbmVyJmd0OyZsdDsvZGl2Jmd0OydcXG4gICAqL1xcbiAgY29udGFpbmVyOiAnPGRpdiBkYXRhLXN0aWNreS1jb250YWluZXI+PC9kaXY+JyxcXG5cXG4gIC8qKlxcbiAgICogTG9jYXRpb24gaW4gdGhlIHZpZXcgdGhlIGVsZW1lbnQgc3RpY2tzIHRvLiBDYW4gYmUgYCd0b3AnYCBvciBgJ2JvdHRvbSdgLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICd0b3AnXFxuICAgKi9cXG4gIHN0aWNrVG86ICd0b3AnLFxcblxcbiAgLyoqXFxuICAgKiBJZiBhbmNob3JlZCB0byBhIHNpbmdsZSBlbGVtZW50LCB0aGUgaWQgb2YgdGhhdCBlbGVtZW50LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICcnXFxuICAgKi9cXG4gIGFuY2hvcjogJycsXFxuXFxuICAvKipcXG4gICAqIElmIHVzaW5nIG1vcmUgdGhhbiBvbmUgZWxlbWVudCBhcyBhbmNob3IgcG9pbnRzLCB0aGUgaWQgb2YgdGhlIHRvcCBhbmNob3IuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJydcXG4gICAqL1xcbiAgdG9wQW5jaG9yOiAnJyxcXG5cXG4gIC8qKlxcbiAgICogSWYgdXNpbmcgbW9yZSB0aGFuIG9uZSBlbGVtZW50IGFzIGFuY2hvciBwb2ludHMsIHRoZSBpZCBvZiB0aGUgYm90dG9tIGFuY2hvci5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnJ1xcbiAgICovXFxuICBidG1BbmNob3I6ICcnLFxcblxcbiAgLyoqXFxuICAgKiBNYXJnaW4sIGluIGBlbWAncyB0byBhcHBseSB0byB0aGUgdG9wIG9mIHRoZSBlbGVtZW50IHdoZW4gaXQgYmVjb21lcyBzdGlja3kuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgMVxcbiAgICovXFxuICBtYXJnaW5Ub3A6IDEsXFxuXFxuICAvKipcXG4gICAqIE1hcmdpbiwgaW4gYGVtYCdzIHRvIGFwcGx5IHRvIHRoZSBib3R0b20gb2YgdGhlIGVsZW1lbnQgd2hlbiBpdCBiZWNvbWVzIHN0aWNreS5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAxXFxuICAgKi9cXG4gIG1hcmdpbkJvdHRvbTogMSxcXG5cXG4gIC8qKlxcbiAgICogQnJlYWtwb2ludCBzdHJpbmcgdGhhdCBpcyB0aGUgbWluaW11bSBzY3JlZW4gc2l6ZSBhbiBlbGVtZW50IHNob3VsZCBiZWNvbWUgc3RpY2t5LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICdtZWRpdW0nXFxuICAgKi9cXG4gIHN0aWNreU9uOiAnbWVkaXVtJyxcXG5cXG4gIC8qKlxcbiAgICogQ2xhc3MgYXBwbGllZCB0byBzdGlja3kgZWxlbWVudCwgYW5kIHJlbW92ZWQgb24gZGVzdHJ1Y3Rpb24uIEZvdW5kYXRpb24gZGVmYXVsdHMgdG8gYHN0aWNreWAuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ3N0aWNreSdcXG4gICAqL1xcbiAgc3RpY2t5Q2xhc3M6ICdzdGlja3knLFxcblxcbiAgLyoqXFxuICAgKiBDbGFzcyBhcHBsaWVkIHRvIHN0aWNreSBjb250YWluZXIuIEZvdW5kYXRpb24gZGVmYXVsdHMgdG8gYHN0aWNreS1jb250YWluZXJgLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICdzdGlja3ktY29udGFpbmVyJ1xcbiAgICovXFxuICBjb250YWluZXJDbGFzczogJ3N0aWNreS1jb250YWluZXInLFxcblxcbiAgLyoqXFxuICAgKiBOdW1iZXIgb2Ygc2Nyb2xsIGV2ZW50cyBiZXR3ZWVuIHRoZSBwbHVnaW4ncyByZWNhbGN1bGF0aW5nIHN0aWNreSBwb2ludHMuIFNldHRpbmcgaXQgdG8gYDBgIHdpbGwgY2F1c2UgaXQgdG8gcmVjYWxjIGV2ZXJ5IHNjcm9sbCBldmVudCwgc2V0dGluZyBpdCB0byBgLTFgIHdpbGwgcHJldmVudCByZWNhbGMgb24gc2Nyb2xsLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IC0xXFxuICAgKi9cXG4gIGNoZWNrRXZlcnk6IC0xXFxufTtcXG4vKipcXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIGVtIHZhbHVlc1xcbiAqIEBwYXJhbSBOdW1iZXIge2VtfSAtIG51bWJlciBvZiBlbSdzIHRvIGNhbGN1bGF0ZSBpbnRvIHBpeGVsc1xcbiAqL1xcblxcbmZ1bmN0aW9uIGVtQ2FsYyhlbSkge1xcbiAgcmV0dXJuIHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHksIG51bGwpLmZvbnRTaXplLCAxMCkgKiBlbTtcXG59XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi5zdGlja3kuanM/XCIpfSxcIi4vanMvZm91bmRhdGlvbi50YWJzLmpzXCI6ZnVuY3Rpb24obW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJUYWJzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUYWJzOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBqcXVlcnkgKi8gXFxcImpxdWVyeVxcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnV0aWxzICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS51dGlscy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC5rZXlib2FyZCAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF9pbWFnZUxvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwuaW1hZ2VMb2FkZXIgKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLmltYWdlTG9hZGVyLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfcGx1Z2luX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uY29yZS5wbHVnaW4gKi8gXFxcIi4vanMvZm91bmRhdGlvbi5jb3JlLnBsdWdpbi5qc1xcXCIpO1xcblxcblxcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXFxcImZ1bmN0aW9uXFxcIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cXG5cXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXFxcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFxcXCIpOyB9IHJldHVybiBzZWxmOyB9XFxuXFxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblxcXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cXG5cXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxcblxcblxcblxcblxcblxcblxcbi8qKlxcbiAqIFRhYnMgbW9kdWxlLlxcbiAqIEBtb2R1bGUgZm91bmRhdGlvbi50YWJzXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuaW1hZ2VMb2FkZXIgaWYgdGFicyBjb250YWluIGltYWdlc1xcbiAqL1xcblxcbnZhciBUYWJzID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKF9QbHVnaW4pIHtcXG4gIF9pbmhlcml0cyhUYWJzLCBfUGx1Z2luKTtcXG5cXG4gIGZ1bmN0aW9uIFRhYnMoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUYWJzKTtcXG5cXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihUYWJzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhUYWJzLCBbe1xcbiAgICBrZXk6IFxcXCJfc2V0dXBcXFwiLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0YWJzLlxcbiAgICAgKiBAY2xhc3NcXG4gICAgICogQG5hbWUgVGFic1xcbiAgICAgKiBAZmlyZXMgVGFicyNpbml0XFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gdGFicy5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XFxuICAgICAgdGhpcy5vcHRpb25zID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCh7fSwgVGFicy5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1RhYnMnOyAvLyBpZTkgYmFjayBjb21wYXRcXG5cXG4gICAgICB0aGlzLl9pbml0KCk7XFxuXFxuICAgICAgX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJLZXlib2FyZFxcXCJdLnJlZ2lzdGVyKCdUYWJzJywge1xcbiAgICAgICAgJ0VOVEVSJzogJ29wZW4nLFxcbiAgICAgICAgJ1NQQUNFJzogJ29wZW4nLFxcbiAgICAgICAgJ0FSUk9XX1JJR0hUJzogJ25leHQnLFxcbiAgICAgICAgJ0FSUk9XX1VQJzogJ3ByZXZpb3VzJyxcXG4gICAgICAgICdBUlJPV19ET1dOJzogJ25leHQnLFxcbiAgICAgICAgJ0FSUk9XX0xFRlQnOiAncHJldmlvdXMnIC8vICdUQUInOiAnbmV4dCcsXFxuICAgICAgICAvLyAnU0hJRlRfVEFCJzogJ3ByZXZpb3VzJ1xcblxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgdGFicyBieSBzaG93aW5nIGFuZCBmb2N1c2luZyAoaWYgYXV0b0ZvY3VzPXRydWUpIHRoZSBwcmVzZXQgYWN0aXZlIHRhYi5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9pbml0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xcblxcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy5faXNJbml0aWFsaXppbmcgPSB0cnVlO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cih7XFxuICAgICAgICAncm9sZSc6ICd0YWJsaXN0J1xcbiAgICAgIH0pO1xcbiAgICAgIHRoaXMuJHRhYlRpdGxlcyA9IHRoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIuY29uY2F0KHRoaXMub3B0aW9ucy5saW5rQ2xhc3MpKTtcXG4gICAgICB0aGlzLiR0YWJDb250ZW50ID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKFxcXCJbZGF0YS10YWJzLWNvbnRlbnQ9XFxcXFxcXCJcXFwiLmNvbmNhdCh0aGlzLiRlbGVtZW50WzBdLmlkLCBcXFwiXFxcXFxcXCJdXFxcIikpO1xcbiAgICAgIHRoaXMuJHRhYlRpdGxlcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciAkZWxlbSA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKSxcXG4gICAgICAgICAgICAkbGluayA9ICRlbGVtLmZpbmQoJ2EnKSxcXG4gICAgICAgICAgICBpc0FjdGl2ZSA9ICRlbGVtLmhhc0NsYXNzKFxcXCJcXFwiLmNvbmNhdChfdGhpcy5vcHRpb25zLmxpbmtBY3RpdmVDbGFzcykpLFxcbiAgICAgICAgICAgIGhhc2ggPSAkbGluay5hdHRyKCdkYXRhLXRhYnMtdGFyZ2V0JykgfHwgJGxpbmtbMF0uaGFzaC5zbGljZSgxKSxcXG4gICAgICAgICAgICBsaW5rSWQgPSAkbGlua1swXS5pZCA/ICRsaW5rWzBdLmlkIDogXFxcIlxcXCIuY29uY2F0KGhhc2gsIFxcXCItbGFiZWxcXFwiKSxcXG4gICAgICAgICAgICAkdGFiQ29udGVudCA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShcXFwiI1xcXCIuY29uY2F0KGhhc2gpKTtcXG4gICAgICAgICRlbGVtLmF0dHIoe1xcbiAgICAgICAgICAncm9sZSc6ICdwcmVzZW50YXRpb24nXFxuICAgICAgICB9KTtcXG4gICAgICAgICRsaW5rLmF0dHIoe1xcbiAgICAgICAgICAncm9sZSc6ICd0YWInLFxcbiAgICAgICAgICAnYXJpYS1jb250cm9scyc6IGhhc2gsXFxuICAgICAgICAgICdhcmlhLXNlbGVjdGVkJzogaXNBY3RpdmUsXFxuICAgICAgICAgICdpZCc6IGxpbmtJZCxcXG4gICAgICAgICAgJ3RhYmluZGV4JzogaXNBY3RpdmUgPyAnMCcgOiAnLTEnXFxuICAgICAgICB9KTtcXG4gICAgICAgICR0YWJDb250ZW50LmF0dHIoe1xcbiAgICAgICAgICAncm9sZSc6ICd0YWJwYW5lbCcsXFxuICAgICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiBsaW5rSWRcXG4gICAgICAgIH0pOyAvLyBTYXZlIHVwIHRoZSBpbml0aWFsIGhhc2ggdG8gcmV0dXJuIHRvIGl0IGxhdGVyIHdoZW4gZ29pbmcgYmFjayBpbiBoaXN0b3J5XFxuXFxuICAgICAgICBpZiAoaXNBY3RpdmUpIHtcXG4gICAgICAgICAgX3RoaXMuX2luaXRpYWxBbmNob3IgPSBcXFwiI1xcXCIuY29uY2F0KGhhc2gpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCFpc0FjdGl2ZSkge1xcbiAgICAgICAgICAkdGFiQ29udGVudC5hdHRyKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoaXNBY3RpdmUgJiYgX3RoaXMub3B0aW9ucy5hdXRvRm9jdXMpIHtcXG4gICAgICAgICAgX3RoaXMub25Mb2FkTGlzdGVuZXIgPSBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJvbkxvYWRcXFwiXSkoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdyksIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoJ2h0bWwsIGJvZHknKS5hbmltYXRlKHtcXG4gICAgICAgICAgICAgIHNjcm9sbFRvcDogJGVsZW0ub2Zmc2V0KCkudG9wXFxuICAgICAgICAgICAgfSwgX3RoaXMub3B0aW9ucy5kZWVwTGlua1NtdWRnZURlbGF5LCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAkbGluay5mb2N1cygpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLm1hdGNoSGVpZ2h0KSB7XFxuICAgICAgICB2YXIgJGltYWdlcyA9IHRoaXMuJHRhYkNvbnRlbnQuZmluZCgnaW1nJyk7XFxuXFxuICAgICAgICBpZiAoJGltYWdlcy5sZW5ndGgpIHtcXG4gICAgICAgICAgT2JqZWN0KF9mb3VuZGF0aW9uX3V0aWxfaW1hZ2VMb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwib25JbWFnZXNMb2FkZWRcXFwiXSkoJGltYWdlcywgdGhpcy5fc2V0SGVpZ2h0LmJpbmQodGhpcykpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy5fc2V0SGVpZ2h0KCk7XFxuICAgICAgICB9XFxuICAgICAgfSAvLyBDdXJyZW50IGNvbnRleHQtYm91bmQgZnVuY3Rpb24gdG8gb3BlbiB0YWJzIG9uIHBhZ2UgbG9hZCBvciBoaXN0b3J5IGhhc2hjaGFuZ2VcXG5cXG5cXG4gICAgICB0aGlzLl9jaGVja0RlZXBMaW5rID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGFuY2hvciA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xcblxcbiAgICAgICAgaWYgKCFhbmNob3IubGVuZ3RoKSB7XFxuICAgICAgICAgIC8vIElmIHdlIGFyZSBzdGlsbCBpbml0aWFsaXppbmcgYW5kIHRoZXJlIGlzIG5vIGFuY2hvciwgdGhlbiB0aGVyZSBpcyBub3RoaW5nIHRvIGRvXFxuICAgICAgICAgIGlmIChfdGhpczIuX2lzSW5pdGlhbGl6aW5nKSByZXR1cm47IC8vIE90aGVyd2lzZSwgbW92ZSB0byB0aGUgaW5pdGlhbCBhbmNob3JcXG5cXG4gICAgICAgICAgaWYgKF90aGlzMi5faW5pdGlhbEFuY2hvcikgYW5jaG9yID0gX3RoaXMyLl9pbml0aWFsQW5jaG9yO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyICRhbmNob3IgPSBhbmNob3IgJiYganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGFuY2hvcik7XFxuXFxuICAgICAgICB2YXIgJGxpbmsgPSBhbmNob3IgJiYgX3RoaXMyLiRlbGVtZW50LmZpbmQoJ1tocmVmJD1cXFwiJyArIGFuY2hvciArICdcXFwiXScpOyAvLyBXaGV0aGVyIHRoZSBhbmNob3IgZWxlbWVudCB0aGF0IGhhcyBiZWVuIGZvdW5kIGlzIHBhcnQgb2YgdGhpcyBlbGVtZW50XFxuXFxuXFxuICAgICAgICB2YXIgaXNPd25BbmNob3IgPSAhISgkYW5jaG9yLmxlbmd0aCAmJiAkbGluay5sZW5ndGgpOyAvLyBJZiB0aGVyZSBpcyBhbiBhbmNob3IgZm9yIHRoZSBoYXNoLCBzZWxlY3QgaXRcXG5cXG4gICAgICAgIGlmICgkYW5jaG9yICYmICRhbmNob3IubGVuZ3RoICYmICRsaW5rICYmICRsaW5rLmxlbmd0aCkge1xcbiAgICAgICAgICBfdGhpczIuc2VsZWN0VGFiKCRhbmNob3IsIHRydWUpO1xcbiAgICAgICAgfSAvLyBPdGhlcndpc2UsIGNvbGxhcHNlIGV2ZXJ5dGhpbmdcXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIF90aGlzMi5fY29sbGFwc2UoKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGlzT3duQW5jaG9yKSB7XFxuICAgICAgICAgIC8vIFJvbGwgdXAgYSBsaXR0bGUgdG8gc2hvdyB0aGUgdGl0bGVzXFxuICAgICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5kZWVwTGlua1NtdWRnZSkge1xcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBfdGhpczIuJGVsZW1lbnQub2Zmc2V0KCk7XFxuXFxuICAgICAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCdodG1sLCBib2R5JykuYW5pbWF0ZSh7XFxuICAgICAgICAgICAgICBzY3JvbGxUb3A6IG9mZnNldC50b3BcXG4gICAgICAgICAgICB9LCBfdGhpczIub3B0aW9ucy5kZWVwTGlua1NtdWRnZURlbGF5KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICAvKipcXG4gICAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgcGx1Z2luIGhhcyBkZWVwbGlua2VkIGF0IHBhZ2Vsb2FkXFxuICAgICAgICAgICAqIEBldmVudCBUYWJzI2RlZXBsaW5rXFxuICAgICAgICAgICAqL1xcblxcblxcbiAgICAgICAgICBfdGhpczIuJGVsZW1lbnQudHJpZ2dlcignZGVlcGxpbmsuemYudGFicycsIFskbGluaywgJGFuY2hvcl0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07IC8vdXNlIGJyb3dzZXIgdG8gb3BlbiBhIHRhYiwgaWYgaXQgZXhpc3RzIGluIHRoaXMgdGFic2V0XFxuXFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluaykge1xcbiAgICAgICAgdGhpcy5fY2hlY2tEZWVwTGluaygpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9ldmVudHMoKTtcXG5cXG4gICAgICB0aGlzLl9pc0luaXRpYWxpemluZyA9IGZhbHNlO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciBpdGVtcyB3aXRoaW4gdGhlIHRhYnMuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZXZlbnRzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgdGhpcy5fYWRkS2V5SGFuZGxlcigpO1xcblxcbiAgICAgIHRoaXMuX2FkZENsaWNrSGFuZGxlcigpO1xcblxcbiAgICAgIHRoaXMuX3NldEhlaWdodE1xSGFuZGxlciA9IG51bGw7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXRjaEhlaWdodCkge1xcbiAgICAgICAgdGhpcy5fc2V0SGVpZ2h0TXFIYW5kbGVyID0gdGhpcy5fc2V0SGVpZ2h0LmJpbmQodGhpcyk7XFxuICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS5vbignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgdGhpcy5fc2V0SGVpZ2h0TXFIYW5kbGVyKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluaykge1xcbiAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub24oJ2hhc2hjaGFuZ2UnLCB0aGlzLl9jaGVja0RlZXBMaW5rKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEFkZHMgY2xpY2sgaGFuZGxlcnMgZm9yIGl0ZW1zIHdpdGhpbiB0aGUgdGFicy5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9hZGRDbGlja0hhbmRsZXJcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZENsaWNrSGFuZGxlcigpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdjbGljay56Zi50YWJzJykub24oJ2NsaWNrLnpmLnRhYnMnLCBcXFwiLlxcXCIuY29uY2F0KHRoaXMub3B0aW9ucy5saW5rQ2xhc3MpLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXG4gICAgICAgIF90aGlzLl9oYW5kbGVUYWJDaGFuZ2UoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpKTtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQWRkcyBrZXlib2FyZCBldmVudCBoYW5kbGVycyBmb3IgaXRlbXMgd2l0aGluIHRoZSB0YWJzLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2FkZEtleUhhbmRsZXJcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEtleUhhbmRsZXIoKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLiR0YWJUaXRsZXMub2ZmKCdrZXlkb3duLnpmLnRhYnMnKS5vbigna2V5ZG93bi56Zi50YWJzJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIGlmIChlLndoaWNoID09PSA5KSByZXR1cm47XFxuICAgICAgICB2YXIgJGVsZW1lbnQgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcyksXFxuICAgICAgICAgICAgJGVsZW1lbnRzID0gJGVsZW1lbnQucGFyZW50KCd1bCcpLmNoaWxkcmVuKCdsaScpLFxcbiAgICAgICAgICAgICRwcmV2RWxlbWVudCxcXG4gICAgICAgICAgICAkbmV4dEVsZW1lbnQ7XFxuICAgICAgICAkZWxlbWVudHMuZWFjaChmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgICBpZiAoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLmlzKCRlbGVtZW50KSkge1xcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLndyYXBPbktleXMpIHtcXG4gICAgICAgICAgICAgICRwcmV2RWxlbWVudCA9IGkgPT09IDAgPyAkZWxlbWVudHMubGFzdCgpIDogJGVsZW1lbnRzLmVxKGkgLSAxKTtcXG4gICAgICAgICAgICAgICRuZXh0RWxlbWVudCA9IGkgPT09ICRlbGVtZW50cy5sZW5ndGggLSAxID8gJGVsZW1lbnRzLmZpcnN0KCkgOiAkZWxlbWVudHMuZXEoaSArIDEpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAkcHJldkVsZW1lbnQgPSAkZWxlbWVudHMuZXEoTWF0aC5tYXgoMCwgaSAtIDEpKTtcXG4gICAgICAgICAgICAgICRuZXh0RWxlbWVudCA9ICRlbGVtZW50cy5lcShNYXRoLm1pbihpICsgMSwgJGVsZW1lbnRzLmxlbmd0aCAtIDEpKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTsgLy8gaGFuZGxlIGtleWJvYXJkIGV2ZW50IHdpdGgga2V5Ym9hcmQgdXRpbFxcblxcbiAgICAgICAgX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJLZXlib2FyZFxcXCJdLmhhbmRsZUtleShlLCAnVGFicycsIHtcXG4gICAgICAgICAgb3BlbjogZnVuY3Rpb24gb3BlbigpIHtcXG4gICAgICAgICAgICAkZWxlbWVudC5maW5kKCdbcm9sZT1cXFwidGFiXFxcIl0nKS5mb2N1cygpO1xcblxcbiAgICAgICAgICAgIF90aGlzLl9oYW5kbGVUYWJDaGFuZ2UoJGVsZW1lbnQpO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBwcmV2aW91czogZnVuY3Rpb24gcHJldmlvdXMoKSB7XFxuICAgICAgICAgICAgJHByZXZFbGVtZW50LmZpbmQoJ1tyb2xlPVxcXCJ0YWJcXFwiXScpLmZvY3VzKCk7XFxuXFxuICAgICAgICAgICAgX3RoaXMuX2hhbmRsZVRhYkNoYW5nZSgkcHJldkVsZW1lbnQpO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xcbiAgICAgICAgICAgICRuZXh0RWxlbWVudC5maW5kKCdbcm9sZT1cXFwidGFiXFxcIl0nKS5mb2N1cygpO1xcblxcbiAgICAgICAgICAgIF90aGlzLl9oYW5kbGVUYWJDaGFuZ2UoJG5leHRFbGVtZW50KTtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24gaGFuZGxlZCgpIHtcXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIE9wZW5zIHRoZSB0YWIgYCR0YXJnZXRDb250ZW50YCBkZWZpbmVkIGJ5IGAkdGFyZ2V0YC4gQ29sbGFwc2VzIGFjdGl2ZSB0YWIuXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gVGFiIHRvIG9wZW4uXFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGlzdG9yeUhhbmRsZWQgLSBicm93c2VyIGhhcyBhbHJlYWR5IGhhbmRsZWQgYSBoaXN0b3J5IHVwZGF0ZVxcbiAgICAgKiBAZmlyZXMgVGFicyNjaGFuZ2VcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfaGFuZGxlVGFiQ2hhbmdlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVUYWJDaGFuZ2UoJHRhcmdldCwgaGlzdG9yeUhhbmRsZWQpIHtcXG4gICAgICAvLyBXaXRoIGBhY3RpdmVDb2xsYXBzZWAsIGlmIHRoZSB0YXJnZXQgaXMgdGhlIGFjdGl2ZSBUYWIsIGNvbGxhcHNlIGl0LlxcbiAgICAgIGlmICgkdGFyZ2V0Lmhhc0NsYXNzKFxcXCJcXFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMubGlua0FjdGl2ZUNsYXNzKSkpIHtcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWN0aXZlQ29sbGFwc2UpIHtcXG4gICAgICAgICAgdGhpcy5fY29sbGFwc2UoKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyICRvbGRUYWIgPSB0aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5cXFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMubGlua0NsYXNzLCBcXFwiLlxcXCIpLmNvbmNhdCh0aGlzLm9wdGlvbnMubGlua0FjdGl2ZUNsYXNzKSksXFxuICAgICAgICAgICR0YWJMaW5rID0gJHRhcmdldC5maW5kKCdbcm9sZT1cXFwidGFiXFxcIl0nKSxcXG4gICAgICAgICAgdGFyZ2V0ID0gJHRhYkxpbmsuYXR0cignZGF0YS10YWJzLXRhcmdldCcpLFxcbiAgICAgICAgICBhbmNob3IgPSB0YXJnZXQgJiYgdGFyZ2V0Lmxlbmd0aCA/IFxcXCIjXFxcIi5jb25jYXQodGFyZ2V0KSA6ICR0YWJMaW5rWzBdLmhhc2gsXFxuICAgICAgICAgICR0YXJnZXRDb250ZW50ID0gdGhpcy4kdGFiQ29udGVudC5maW5kKGFuY2hvcik7IC8vY2xvc2Ugb2xkIHRhYlxcblxcbiAgICAgIHRoaXMuX2NvbGxhcHNlVGFiKCRvbGRUYWIpOyAvL29wZW4gbmV3IHRhYlxcblxcblxcbiAgICAgIHRoaXMuX29wZW5UYWIoJHRhcmdldCk7IC8vZWl0aGVyIHJlcGxhY2Ugb3IgdXBkYXRlIGJyb3dzZXIgaGlzdG9yeVxcblxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVlcExpbmsgJiYgIWhpc3RvcnlIYW5kbGVkKSB7XFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVwZGF0ZUhpc3RvcnkpIHtcXG4gICAgICAgICAgaGlzdG9yeS5wdXNoU3RhdGUoe30sICcnLCBhbmNob3IpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sICcnLCBhbmNob3IpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBwbHVnaW4gaGFzIHN1Y2Nlc3NmdWxseSBjaGFuZ2VkIHRhYnMuXFxuICAgICAgICogQGV2ZW50IFRhYnMjY2hhbmdlXFxuICAgICAgICovXFxuXFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjaGFuZ2UuemYudGFicycsIFskdGFyZ2V0LCAkdGFyZ2V0Q29udGVudF0pOyAvL2ZpcmUgdG8gY2hpbGRyZW4gYSBtdXRhdGlvbiBldmVudFxcblxcbiAgICAgICR0YXJnZXRDb250ZW50LmZpbmQoXFxcIltkYXRhLW11dGF0ZV1cXFwiKS50cmlnZ2VyKFxcXCJtdXRhdGVtZS56Zi50cmlnZ2VyXFxcIik7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIE9wZW5zIHRoZSB0YWIgYCR0YXJnZXRDb250ZW50YCBkZWZpbmVkIGJ5IGAkdGFyZ2V0YC5cXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSBUYWIgdG8gb3Blbi5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfb3BlblRhYlxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb3BlblRhYigkdGFyZ2V0KSB7XFxuICAgICAgdmFyICR0YWJMaW5rID0gJHRhcmdldC5maW5kKCdbcm9sZT1cXFwidGFiXFxcIl0nKSxcXG4gICAgICAgICAgaGFzaCA9ICR0YWJMaW5rLmF0dHIoJ2RhdGEtdGFicy10YXJnZXQnKSB8fCAkdGFiTGlua1swXS5oYXNoLnNsaWNlKDEpLFxcbiAgICAgICAgICAkdGFyZ2V0Q29udGVudCA9IHRoaXMuJHRhYkNvbnRlbnQuZmluZChcXFwiI1xcXCIuY29uY2F0KGhhc2gpKTtcXG4gICAgICAkdGFyZ2V0LmFkZENsYXNzKFxcXCJcXFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMubGlua0FjdGl2ZUNsYXNzKSk7XFxuICAgICAgJHRhYkxpbmsuYXR0cih7XFxuICAgICAgICAnYXJpYS1zZWxlY3RlZCc6ICd0cnVlJyxcXG4gICAgICAgICd0YWJpbmRleCc6ICcwJ1xcbiAgICAgIH0pO1xcbiAgICAgICR0YXJnZXRDb250ZW50LmFkZENsYXNzKFxcXCJcXFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMucGFuZWxBY3RpdmVDbGFzcykpLnJlbW92ZUF0dHIoJ2FyaWEtaGlkZGVuJyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENvbGxhcHNlcyBgJHRhcmdldENvbnRlbnRgIGRlZmluZWQgYnkgYCR0YXJnZXRgLlxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIFRhYiB0byBjb2xsYXBzZS5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfY29sbGFwc2VUYWJcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbGxhcHNlVGFiKCR0YXJnZXQpIHtcXG4gICAgICB2YXIgJHRhcmdldF9hbmNob3IgPSAkdGFyZ2V0LnJlbW92ZUNsYXNzKFxcXCJcXFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMubGlua0FjdGl2ZUNsYXNzKSkuZmluZCgnW3JvbGU9XFxcInRhYlxcXCJdJykuYXR0cih7XFxuICAgICAgICAnYXJpYS1zZWxlY3RlZCc6ICdmYWxzZScsXFxuICAgICAgICAndGFiaW5kZXgnOiAtMVxcbiAgICAgIH0pO1xcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShcXFwiI1xcXCIuY29uY2F0KCR0YXJnZXRfYW5jaG9yLmF0dHIoJ2FyaWEtY29udHJvbHMnKSkpLnJlbW92ZUNsYXNzKFxcXCJcXFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMucGFuZWxBY3RpdmVDbGFzcykpLmF0dHIoe1xcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogJ3RydWUnXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENvbGxhcHNlcyB0aGUgYWN0aXZlIFRhYi5cXG4gICAgICogQGZpcmVzIFRhYnMjY29sbGFwc2VcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfY29sbGFwc2VcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbGxhcHNlKCkge1xcbiAgICAgIHZhciAkYWN0aXZlVGFiID0gdGhpcy4kZWxlbWVudC5maW5kKFxcXCIuXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLmxpbmtDbGFzcywgXFxcIi5cXFwiKS5jb25jYXQodGhpcy5vcHRpb25zLmxpbmtBY3RpdmVDbGFzcykpO1xcblxcbiAgICAgIGlmICgkYWN0aXZlVGFiLmxlbmd0aCkge1xcbiAgICAgICAgdGhpcy5fY29sbGFwc2VUYWIoJGFjdGl2ZVRhYik7XFxuICAgICAgICAvKipcXG4gICAgICAgICogRmlyZXMgd2hlbiB0aGUgcGx1Z2luIGhhcyBzdWNjZXNzZnVsbHkgY29sbGFwc2VkIHRhYnMuXFxuICAgICAgICAqIEBldmVudCBUYWJzI2NvbGxhcHNlXFxuICAgICAgICAqL1xcblxcblxcbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjb2xsYXBzZS56Zi50YWJzJywgWyRhY3RpdmVUYWJdKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFB1YmxpYyBtZXRob2QgZm9yIHNlbGVjdGluZyBhIGNvbnRlbnQgcGFuZSB0byBkaXNwbGF5LlxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeSB8IFN0cmluZ30gZWxlbSAtIGpRdWVyeSBvYmplY3Qgb3Igc3RyaW5nIG9mIHRoZSBpZCBvZiB0aGUgcGFuZSB0byBkaXNwbGF5LlxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhpc3RvcnlIYW5kbGVkIC0gYnJvd3NlciBoYXMgYWxyZWFkeSBoYW5kbGVkIGEgaGlzdG9yeSB1cGRhdGVcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJzZWxlY3RUYWJcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0VGFiKGVsZW0sIGhpc3RvcnlIYW5kbGVkKSB7XFxuICAgICAgdmFyIGlkU3RyO1xcblxcbiAgICAgIGlmIChfdHlwZW9mKGVsZW0pID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgaWRTdHIgPSBlbGVtWzBdLmlkO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZFN0ciA9IGVsZW07XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpZFN0ci5pbmRleE9mKCcjJykgPCAwKSB7XFxuICAgICAgICBpZFN0ciA9IFxcXCIjXFxcIi5jb25jYXQoaWRTdHIpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgJHRhcmdldCA9IHRoaXMuJHRhYlRpdGxlcy5oYXMoXFxcIltocmVmJD1cXFxcXFxcIlxcXCIuY29uY2F0KGlkU3RyLCBcXFwiXFxcXFxcXCJdXFxcIikpO1xcblxcbiAgICAgIHRoaXMuX2hhbmRsZVRhYkNoYW5nZSgkdGFyZ2V0LCBoaXN0b3J5SGFuZGxlZCk7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3NldEhlaWdodFxcXCIsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBTZXRzIHRoZSBoZWlnaHQgb2YgZWFjaCBwYW5lbCB0byB0aGUgaGVpZ2h0IG9mIHRoZSB0YWxsZXN0IHBhbmVsLlxcbiAgICAgKiBJZiBlbmFibGVkIGluIG9wdGlvbnMsIGdldHMgY2FsbGVkIG9uIG1lZGlhIHF1ZXJ5IGNoYW5nZS5cXG4gICAgICogSWYgbG9hZGluZyBjb250ZW50IHZpYSBleHRlcm5hbCBzb3VyY2UsIGNhbiBiZSBjYWxsZWQgZGlyZWN0bHkgb3Igd2l0aCBfcmVmbG93LlxcbiAgICAgKiBJZiBlbmFibGVkIHdpdGggYGRhdGEtbWF0Y2gtaGVpZ2h0PVxcXCJ0cnVlXFxcImAsIHRhYnMgc2V0cyB0byBlcXVhbCBoZWlnaHRcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEhlaWdodCgpIHtcXG4gICAgICB2YXIgbWF4ID0gMCxcXG4gICAgICAgICAgX3RoaXMgPSB0aGlzOyAvLyBMb2NrIGRvd24gdGhlIGB0aGlzYCB2YWx1ZSBmb3IgdGhlIHJvb3QgdGFicyBvYmplY3RcXG5cXG5cXG4gICAgICB0aGlzLiR0YWJDb250ZW50LmZpbmQoXFxcIi5cXFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMucGFuZWxDbGFzcykpLmNzcygnaGVpZ2h0JywgJycpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIHBhbmVsID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLFxcbiAgICAgICAgICAgIGlzQWN0aXZlID0gcGFuZWwuaGFzQ2xhc3MoXFxcIlxcXCIuY29uY2F0KF90aGlzLm9wdGlvbnMucGFuZWxBY3RpdmVDbGFzcykpOyAvLyBnZXQgdGhlIG9wdGlvbnMgZnJvbSB0aGUgcGFyZW50IGluc3RlYWQgb2YgdHJ5aW5nIHRvIGdldCB0aGVtIGZyb20gdGhlIGNoaWxkXFxuXFxuICAgICAgICBpZiAoIWlzQWN0aXZlKSB7XFxuICAgICAgICAgIHBhbmVsLmNzcyh7XFxuICAgICAgICAgICAgJ3Zpc2liaWxpdHknOiAnaGlkZGVuJyxcXG4gICAgICAgICAgICAnZGlzcGxheSc6ICdibG9jaydcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgdGVtcCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xcblxcbiAgICAgICAgaWYgKCFpc0FjdGl2ZSkge1xcbiAgICAgICAgICBwYW5lbC5jc3Moe1xcbiAgICAgICAgICAgICd2aXNpYmlsaXR5JzogJycsXFxuICAgICAgICAgICAgJ2Rpc3BsYXknOiAnJ1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIG1heCA9IHRlbXAgPiBtYXggPyB0ZW1wIDogbWF4O1xcbiAgICAgIH0pLmNzcygnaGVpZ2h0JywgXFxcIlxcXCIuY29uY2F0KG1heCwgXFxcInB4XFxcIikpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiB0YWJzLlxcbiAgICAgKiBAZmlyZXMgVGFicyNkZXN0cm95ZWRcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9kZXN0cm95XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIuY29uY2F0KHRoaXMub3B0aW9ucy5saW5rQ2xhc3MpKS5vZmYoJy56Zi50YWJzJykuaGlkZSgpLmVuZCgpLmZpbmQoXFxcIi5cXFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMucGFuZWxDbGFzcykpLmhpZGUoKTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLm1hdGNoSGVpZ2h0KSB7XFxuICAgICAgICBpZiAodGhpcy5fc2V0SGVpZ2h0TXFIYW5kbGVyICE9IG51bGwpIHtcXG4gICAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub2ZmKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCB0aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXIpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5rKSB7XFxuICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS5vZmYoJ2hhc2hjaGFuZ2UnLCB0aGlzLl9jaGVja0RlZXBMaW5rKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub25Mb2FkTGlzdGVuZXIpIHtcXG4gICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLm9mZih0aGlzLm9uTG9hZExpc3RlbmVyKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBUYWJzO1xcbn0oX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiUGx1Z2luXFxcIl0pO1xcblxcblRhYnMuZGVmYXVsdHMgPSB7XFxuICAvKipcXG4gICAqIExpbmsgdGhlIGxvY2F0aW9uIGhhc2ggdG8gdGhlIGFjdGl2ZSBwYW5lLlxcbiAgICogU2V0IHRoZSBsb2NhdGlvbiBoYXNoIHdoZW4gdGhlIGFjdGl2ZSBwYW5lIGNoYW5nZXMsIGFuZCBvcGVuIHRoZSBjb3JyZXNwb25kaW5nIHBhbmUgd2hlbiB0aGUgbG9jYXRpb24gY2hhbmdlcy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgZGVlcExpbms6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBJZiBgZGVlcExpbmtgIGlzIGVuYWJsZWQsIGFkanVzdCB0aGUgZGVlcCBsaW5rIHNjcm9sbCB0byBtYWtlIHN1cmUgdGhlIHRvcCBvZiB0aGUgdGFiIHBhbmVsIGlzIHZpc2libGVcXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgZGVlcExpbmtTbXVkZ2U6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBJZiBgZGVlcExpbmtTbXVkZ2VgIGlzIGVuYWJsZWQsIGFuaW1hdGlvbiB0aW1lIChtcykgZm9yIHRoZSBkZWVwIGxpbmsgYWRqdXN0bWVudFxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDMwMFxcbiAgICovXFxuICBkZWVwTGlua1NtdWRnZURlbGF5OiAzMDAsXFxuXFxuICAvKipcXG4gICAqIElmIGBkZWVwTGlua2AgaXMgZW5hYmxlZCwgdXBkYXRlIHRoZSBicm93c2VyIGhpc3Rvcnkgd2l0aCB0aGUgb3BlbiB0YWJcXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgdXBkYXRlSGlzdG9yeTogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIEFsbG93cyB0aGUgd2luZG93IHRvIHNjcm9sbCB0byBjb250ZW50IG9mIGFjdGl2ZSBwYW5lIG9uIGxvYWQuXFxuICAgKiBOb3QgcmVjb21tZW5kZWQgaWYgbW9yZSB0aGFuIG9uZSB0YWIgcGFuZWwgcGVyIHBhZ2UuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGF1dG9Gb2N1czogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIEFsbG93cyBrZXlib2FyZCBpbnB1dCB0byAnd3JhcCcgYXJvdW5kIHRoZSB0YWIgbGlua3MuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IHRydWVcXG4gICAqL1xcbiAgd3JhcE9uS2V5czogdHJ1ZSxcXG5cXG4gIC8qKlxcbiAgICogQWxsb3dzIHRoZSB0YWIgY29udGVudCBwYW5lcyB0byBtYXRjaCBoZWlnaHRzIGlmIHNldCB0byB0cnVlLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBtYXRjaEhlaWdodDogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIEFsbG93cyBhY3RpdmUgdGFicyB0byBjb2xsYXBzZSB3aGVuIGNsaWNrZWQuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGFjdGl2ZUNvbGxhcHNlOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogQ2xhc3MgYXBwbGllZCB0byBgbGlgJ3MgaW4gdGFiIGxpbmsgbGlzdC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAndGFicy10aXRsZSdcXG4gICAqL1xcbiAgbGlua0NsYXNzOiAndGFicy10aXRsZScsXFxuXFxuICAvKipcXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGFjdGl2ZSBgbGlgIGluIHRhYiBsaW5rIGxpc3QuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ2lzLWFjdGl2ZSdcXG4gICAqL1xcbiAgbGlua0FjdGl2ZUNsYXNzOiAnaXMtYWN0aXZlJyxcXG5cXG4gIC8qKlxcbiAgICogQ2xhc3MgYXBwbGllZCB0byB0aGUgY29udGVudCBjb250YWluZXJzLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICd0YWJzLXBhbmVsJ1xcbiAgICovXFxuICBwYW5lbENsYXNzOiAndGFicy1wYW5lbCcsXFxuXFxuICAvKipcXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGFjdGl2ZSBjb250ZW50IGNvbnRhaW5lci5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnaXMtYWN0aXZlJ1xcbiAgICovXFxuICBwYW5lbEFjdGl2ZUNsYXNzOiAnaXMtYWN0aXZlJ1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi50YWJzLmpzP1wiKX0sXCIuL2pzL2ZvdW5kYXRpb24udG9nZ2xlci5qc1wiOmZ1bmN0aW9uKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoJ19fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVG9nZ2xlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRvZ2dsZXI7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGpxdWVyeSAqLyBcImpxdWVyeVwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX21vdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwubW90aW9uICovIFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwubW90aW9uLmpzXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUucGx1Z2luICovIFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUucGx1Z2luLmpzXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uY29yZS51dGlscyAqLyBcIi4vanMvZm91bmRhdGlvbi5jb3JlLnV0aWxzLmpzXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX3RyaWdnZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC50cmlnZ2VycyAqLyBcIi4vanMvZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzLmpzXCIpO1xcblxcblxcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XFxuXFxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuXFwndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuXFwndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxcblxcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxcblxcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XFxuXFxuXFxuXFxuXFxuXFxuXFxuLyoqXFxuICogVG9nZ2xlciBtb2R1bGUuXFxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnRvZ2dsZXJcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvblxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcXG4gKi9cXG5cXG52YXIgVG9nZ2xlciA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uIChfUGx1Z2luKSB7XFxuICBfaW5oZXJpdHMoVG9nZ2xlciwgX1BsdWdpbik7XFxuXFxuICBmdW5jdGlvbiBUb2dnbGVyKCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9nZ2xlcik7XFxuXFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoVG9nZ2xlcikuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoVG9nZ2xlciwgW3tcXG4gICAga2V5OiBcIl9zZXR1cFwiLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBUb2dnbGVyLlxcbiAgICAgKiBAY2xhc3NcXG4gICAgICogQG5hbWUgVG9nZ2xlclxcbiAgICAgKiBAZmlyZXMgVG9nZ2xlciNpbml0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIHRyaWdnZXIgdG8uXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cXG4gICAgICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMub3B0aW9ucyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoe30sIFRvZ2dsZXIuZGVmYXVsdHMsIGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9IFxcJ1xcJztcXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9IFxcJ1RvZ2dsZXJcXCc7IC8vIGllOSBiYWNrIGNvbXBhdFxcbiAgICAgIC8vIFRyaWdnZXJzIGluaXQgaXMgaWRlbXBvdGVudCwganVzdCBuZWVkIHRvIG1ha2Ugc3VyZSBpdCBpcyBpbml0aWFsaXplZFxcblxcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfdHJpZ2dlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIlRyaWdnZXJzXCJdLmluaXQoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hKTtcXG5cXG4gICAgICB0aGlzLl9pbml0KCk7XFxuXFxuICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIHRoZSBUb2dnbGVyIHBsdWdpbiBieSBwYXJzaW5nIHRoZSB0b2dnbGUgY2xhc3MgZnJvbSBkYXRhLXRvZ2dsZXIsIG9yIGFuaW1hdGlvbiBjbGFzc2VzIGZyb20gZGF0YS1hbmltYXRlLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXCJfaW5pdFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgdmFyIGlucHV0OyAvLyBQYXJzZSBhbmltYXRpb24gY2xhc3NlcyBpZiB0aGV5IHdlcmUgc2V0XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRlKSB7XFxuICAgICAgICBpbnB1dCA9IHRoaXMub3B0aW9ucy5hbmltYXRlLnNwbGl0KFxcJyBcXCcpO1xcbiAgICAgICAgdGhpcy5hbmltYXRpb25JbiA9IGlucHV0WzBdO1xcbiAgICAgICAgdGhpcy5hbmltYXRpb25PdXQgPSBpbnB1dFsxXSB8fCBudWxsO1xcbiAgICAgIH0gLy8gT3RoZXJ3aXNlLCBwYXJzZSB0b2dnbGUgY2xhc3NcXG4gICAgICBlbHNlIHtcXG4gICAgICAgICAgaW5wdXQgPSB0aGlzLiRlbGVtZW50LmRhdGEoXFwndG9nZ2xlclxcJyk7IC8vIEFsbG93IGZvciBhIC4gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgc3RyaW5nXFxuXFxuICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gaW5wdXRbMF0gPT09IFxcJy5cXCcgPyBpbnB1dC5zbGljZSgxKSA6IGlucHV0O1xcbiAgICAgICAgfSAvLyBBZGQgQVJJQSBhdHRyaWJ1dGVzIHRvIHRyaWdnZXJzOlxcblxcblxcbiAgICAgIHZhciBpZCA9IHRoaXMuJGVsZW1lbnRbMF0uaWQsXFxuICAgICAgICAgICR0cmlnZ2VycyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShcIltkYXRhLW9wZW5+PVxcXFxcIlwiLmNvbmNhdChpZCwgXCJcXFxcXCJdLCBbZGF0YS1jbG9zZX49XFxcXFwiXCIpLmNvbmNhdChpZCwgXCJcXFxcXCJdLCBbZGF0YS10b2dnbGV+PVxcXFxcIlwiKS5jb25jYXQoaWQsIFwiXFxcXFwiXVwiKSk7IC8vIC0gYXJpYS1leHBhbmRlZDogYWNjb3JkaW5nIHRvIHRoZSBlbGVtZW50IHZpc2liaWxpdHkuXFxuXFxuICAgICAgJHRyaWdnZXJzLmF0dHIoXFwnYXJpYS1leHBhbmRlZFxcJywgIXRoaXMuJGVsZW1lbnQuaXMoXFwnOmhpZGRlblxcJykpOyAvLyAtIGFyaWEtY29udHJvbHM6IGFkZGluZyB0aGUgZWxlbWVudCBpZCB0byBpdCBpZiBub3QgYWxyZWFkeSBpbiBpdC5cXG5cXG4gICAgICAkdHJpZ2dlcnMuZWFjaChmdW5jdGlvbiAoaW5kZXgsIHRyaWdnZXIpIHtcXG4gICAgICAgIHZhciAkdHJpZ2dlciA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0cmlnZ2VyKTtcXG4gICAgICAgIHZhciBjb250cm9scyA9ICR0cmlnZ2VyLmF0dHIoXFwnYXJpYS1jb250cm9sc1xcJykgfHwgXFwnXFwnO1xcbiAgICAgICAgdmFyIGNvbnRhaW5zSWQgPSBuZXcgUmVnRXhwKFwiXFxcXFxcXFxiXCIuY29uY2F0KE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJSZWdFeHBFc2NhcGVcIl0pKGlkKSwgXCJcXFxcXFxcXGJcIikpLnRlc3QoY29udHJvbHMpO1xcbiAgICAgICAgaWYgKCFjb250YWluc0lkKSAkdHJpZ2dlci5hdHRyKFxcJ2FyaWEtY29udHJvbHNcXCcsIGNvbnRyb2xzID8gXCJcIi5jb25jYXQoY29udHJvbHMsIFwiIFwiKS5jb25jYXQoaWQpIDogaWQpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplcyBldmVudHMgZm9yIHRoZSB0b2dnbGUgdHJpZ2dlci5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFwiX2V2ZW50c1wiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZihcXCd0b2dnbGUuemYudHJpZ2dlclxcJykub24oXFwndG9nZ2xlLnpmLnRyaWdnZXJcXCcsIHRoaXMudG9nZ2xlLmJpbmQodGhpcykpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBUb2dnbGVzIHRoZSB0YXJnZXQgY2xhc3Mgb24gdGhlIHRhcmdldCBlbGVtZW50LiBBbiBldmVudCBpcyBmaXJlZCBmcm9tIHRoZSBvcmlnaW5hbCB0cmlnZ2VyIGRlcGVuZGluZyBvbiBpZiB0aGUgcmVzdWx0YW50IHN0YXRlIHdhcyBcIm9uXCIgb3IgXCJvZmZcIi5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBmaXJlcyBUb2dnbGVyI29uXFxuICAgICAqIEBmaXJlcyBUb2dnbGVyI29mZlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcInRvZ2dsZVwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlKCkge1xcbiAgICAgIHRoaXNbdGhpcy5vcHRpb25zLmFuaW1hdGUgPyBcXCdfdG9nZ2xlQW5pbWF0ZVxcJyA6IFxcJ190b2dnbGVDbGFzc1xcJ10oKTtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFwiX3RvZ2dsZUNsYXNzXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdG9nZ2xlQ2xhc3MoKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyh0aGlzLmNsYXNzTmFtZSk7XFxuICAgICAgdmFyIGlzT24gPSB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMuY2xhc3NOYW1lKTtcXG5cXG4gICAgICBpZiAoaXNPbikge1xcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBGaXJlcyBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaGFzIHRoZSBjbGFzcyBhZnRlciBhIHRvZ2dsZS5cXG4gICAgICAgICAqIEBldmVudCBUb2dnbGVyI29uXFxuICAgICAgICAgKi9cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXCdvbi56Zi50b2dnbGVyXFwnKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBGaXJlcyBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgZG9lcyBub3QgaGF2ZSB0aGUgY2xhc3MgYWZ0ZXIgYSB0b2dnbGUuXFxuICAgICAgICAgKiBAZXZlbnQgVG9nZ2xlciNvZmZcXG4gICAgICAgICAqL1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcJ29mZi56Zi50b2dnbGVyXFwnKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fdXBkYXRlQVJJQShpc09uKTtcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LmZpbmQoXFwnW2RhdGEtbXV0YXRlXVxcJykudHJpZ2dlcihcXCdtdXRhdGVtZS56Zi50cmlnZ2VyXFwnKTtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFwiX3RvZ2dsZUFuaW1hdGVcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90b2dnbGVBbmltYXRlKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuaXMoXFwnOmhpZGRlblxcJykpIHtcXG4gICAgICAgIF9mb3VuZGF0aW9uX3V0aWxfbW90aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJNb3Rpb25cIl0uYW5pbWF0ZUluKHRoaXMuJGVsZW1lbnQsIHRoaXMuYW5pbWF0aW9uSW4sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgX3RoaXMuX3VwZGF0ZUFSSUEodHJ1ZSk7XFxuXFxuICAgICAgICAgIHRoaXMudHJpZ2dlcihcXCdvbi56Zi50b2dnbGVyXFwnKTtcXG4gICAgICAgICAgdGhpcy5maW5kKFxcJ1tkYXRhLW11dGF0ZV1cXCcpLnRyaWdnZXIoXFwnbXV0YXRlbWUuemYudHJpZ2dlclxcJyk7XFxuICAgICAgICB9KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgX2ZvdW5kYXRpb25fdXRpbF9tb3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIk1vdGlvblwiXS5hbmltYXRlT3V0KHRoaXMuJGVsZW1lbnQsIHRoaXMuYW5pbWF0aW9uT3V0LCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIF90aGlzLl91cGRhdGVBUklBKGZhbHNlKTtcXG5cXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKFxcJ29mZi56Zi50b2dnbGVyXFwnKTtcXG4gICAgICAgICAgdGhpcy5maW5kKFxcJ1tkYXRhLW11dGF0ZV1cXCcpLnRyaWdnZXIoXFwnbXV0YXRlbWUuemYudHJpZ2dlclxcJyk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcIl91cGRhdGVBUklBXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlQVJJQShpc09uKSB7XFxuICAgICAgdmFyIGlkID0gdGhpcy4kZWxlbWVudFswXS5pZDtcXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoXCJbZGF0YS1vcGVuPVxcXFxcIlwiLmNvbmNhdChpZCwgXCJcXFxcXCJdLCBbZGF0YS1jbG9zZT1cXFxcXCJcIikuY29uY2F0KGlkLCBcIlxcXFxcIl0sIFtkYXRhLXRvZ2dsZT1cXFxcXCJcIikuY29uY2F0KGlkLCBcIlxcXFxcIl1cIikpLmF0dHIoe1xcbiAgICAgICAgXFwnYXJpYS1leHBhbmRlZFxcJzogaXNPbiA/IHRydWUgOiBmYWxzZVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBEZXN0cm95cyB0aGUgaW5zdGFuY2Ugb2YgVG9nZ2xlciBvbiB0aGUgZWxlbWVudC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFwiX2Rlc3Ryb3lcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKFxcJy56Zi50b2dnbGVyXFwnKTtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIFRvZ2dsZXI7XFxufShfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiUGx1Z2luXCJdKTtcXG5cXG5Ub2dnbGVyLmRlZmF1bHRzID0ge1xcbiAgLyoqXFxuICAgKiBUZWxscyB0aGUgcGx1Z2luIGlmIHRoZSBlbGVtZW50IHNob3VsZCBhbmltYXRlZCB3aGVuIHRvZ2dsZWQuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGFuaW1hdGU6IGZhbHNlXFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9qcy9mb3VuZGF0aW9uLnRvZ2dsZXIuanM/Jyl9LFwiLi9qcy9mb3VuZGF0aW9uLnRvb2x0aXAuanNcIjpmdW5jdGlvbihtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlRvb2x0aXBcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRvb2x0aXA7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGpxdWVyeSAqLyBcXFwianF1ZXJ5XFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUudXRpbHMgKi8gXFxcIi4vanMvZm91bmRhdGlvbi5jb3JlLnV0aWxzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeSAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX3RyaWdnZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC50cmlnZ2VycyAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fcG9zaXRpb25hYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24ucG9zaXRpb25hYmxlICovIFxcXCIuL2pzL2ZvdW5kYXRpb24ucG9zaXRpb25hYmxlLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxcblxcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XFxuXFxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxcblxcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cXFwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XFxuXFxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cXG5cXG5cXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBUb29sdGlwIG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24udG9vbHRpcFxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuYm94XFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5XFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xcbiAqL1xcblxcbnZhciBUb29sdGlwID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKF9Qb3NpdGlvbmFibGUpIHtcXG4gIF9pbmhlcml0cyhUb29sdGlwLCBfUG9zaXRpb25hYmxlKTtcXG5cXG4gIGZ1bmN0aW9uIFRvb2x0aXAoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb29sdGlwKTtcXG5cXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihUb29sdGlwKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhUb29sdGlwLCBbe1xcbiAgICBrZXk6IFxcXCJfc2V0dXBcXFwiLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIFRvb2x0aXAuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAbmFtZSBUb29sdGlwXFxuICAgICAqIEBmaXJlcyBUb29sdGlwI2luaXRcXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGF0dGFjaCBhIHRvb2x0aXAgdG8uXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb2JqZWN0IHRvIGV4dGVuZCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uLlxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XFxuICAgICAgdGhpcy5vcHRpb25zID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCh7fSwgVG9vbHRpcC5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1Rvb2x0aXAnOyAvLyBpZTkgYmFjayBjb21wYXRcXG5cXG4gICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XFxuICAgICAgdGhpcy5pc0NsaWNrID0gZmFsc2U7IC8vIFRyaWdnZXJzIGluaXQgaXMgaWRlbXBvdGVudCwganVzdCBuZWVkIHRvIG1ha2Ugc3VyZSBpdCBpcyBpbml0aWFsaXplZFxcblxcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfdHJpZ2dlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiVHJpZ2dlcnNcXFwiXS5pbml0KGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYSk7XFxuXFxuICAgICAgdGhpcy5faW5pdCgpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgdG9vbHRpcCBieSBzZXR0aW5nIHRoZSBjcmVhdGluZyB0aGUgdGlwIGVsZW1lbnQsIGFkZGluZyBpdCdzIHRleHQsIHNldHRpbmcgcHJpdmF0ZSB2YXJpYWJsZXMgYW5kIHNldHRpbmcgYXR0cmlidXRlcyBvbiB0aGUgYW5jaG9yLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2luaXRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIk1lZGlhUXVlcnlcXFwiXS5faW5pdCgpO1xcblxcbiAgICAgIHZhciBlbGVtSWQgPSB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtZGVzY3JpYmVkYnknKSB8fCBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJHZXRZb0RpZ2l0c1xcXCJdKSg2LCAndG9vbHRpcCcpO1xcbiAgICAgIHRoaXMub3B0aW9ucy50aXBUZXh0ID0gdGhpcy5vcHRpb25zLnRpcFRleHQgfHwgdGhpcy4kZWxlbWVudC5hdHRyKCd0aXRsZScpO1xcbiAgICAgIHRoaXMudGVtcGxhdGUgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGUgPyBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcy5vcHRpb25zLnRlbXBsYXRlKSA6IHRoaXMuX2J1aWxkVGVtcGxhdGUoZWxlbUlkKTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFsbG93SHRtbCkge1xcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KS5odG1sKHRoaXMub3B0aW9ucy50aXBUZXh0KS5oaWRlKCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMudGVtcGxhdGUuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSkudGV4dCh0aGlzLm9wdGlvbnMudGlwVGV4dCkuaGlkZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xcbiAgICAgICAgJ3RpdGxlJzogJycsXFxuICAgICAgICAnYXJpYS1kZXNjcmliZWRieSc6IGVsZW1JZCxcXG4gICAgICAgICdkYXRhLXlldGktYm94JzogZWxlbUlkLFxcbiAgICAgICAgJ2RhdGEtdG9nZ2xlJzogZWxlbUlkLFxcbiAgICAgICAgJ2RhdGEtcmVzaXplJzogZWxlbUlkXFxuICAgICAgfSkuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnRyaWdnZXJDbGFzcyk7XFxuXFxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoVG9vbHRpcC5wcm90b3R5cGUpLCBcXFwiX2luaXRcXFwiLCB0aGlzKS5jYWxsKHRoaXMpO1xcblxcbiAgICAgIHRoaXMuX2V2ZW50cygpO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9nZXREZWZhdWx0UG9zaXRpb25cXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERlZmF1bHRQb3NpdGlvbigpIHtcXG4gICAgICAvLyBoYW5kbGUgbGVnYWN5IGNsYXNzbmFtZXNcXG4gICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLiRlbGVtZW50WzBdLmNsYXNzTmFtZS5tYXRjaCgvXFxcXGIodG9wfGxlZnR8cmlnaHR8Ym90dG9tKVxcXFxiL2cpO1xcbiAgICAgIHJldHVybiBwb3NpdGlvbiA/IHBvc2l0aW9uWzBdIDogJ3RvcCc7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2dldERlZmF1bHRBbGlnbm1lbnRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERlZmF1bHRBbGlnbm1lbnQoKSB7XFxuICAgICAgcmV0dXJuICdjZW50ZXInO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9nZXRIT2Zmc2V0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRIT2Zmc2V0KCkge1xcbiAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09PSAnbGVmdCcgfHwgdGhpcy5wb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5oT2Zmc2V0ICsgdGhpcy5vcHRpb25zLnRvb2x0aXBXaWR0aDtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5oT2Zmc2V0O1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZ2V0Vk9mZnNldFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Vk9mZnNldCgpIHtcXG4gICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy5wb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudk9mZnNldCArIHRoaXMub3B0aW9ucy50b29sdGlwSGVpZ2h0O1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnZPZmZzZXQ7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBidWlsZHMgdGhlIHRvb2x0aXAgZWxlbWVudCwgYWRkcyBhdHRyaWJ1dGVzLCBhbmQgcmV0dXJucyB0aGUgdGVtcGxhdGUuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfYnVpbGRUZW1wbGF0ZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYnVpbGRUZW1wbGF0ZShpZCkge1xcbiAgICAgIHZhciB0ZW1wbGF0ZUNsYXNzZXMgPSBcXFwiXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLnRvb2x0aXBDbGFzcywgXFxcIiBcXFwiKS5jb25jYXQodGhpcy5vcHRpb25zLnRlbXBsYXRlQ2xhc3NlcykudHJpbSgpO1xcbiAgICAgIHZhciAkdGVtcGxhdGUgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3ModGVtcGxhdGVDbGFzc2VzKS5hdHRyKHtcXG4gICAgICAgICdyb2xlJzogJ3Rvb2x0aXAnLFxcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcXG4gICAgICAgICdkYXRhLWlzLWFjdGl2ZSc6IGZhbHNlLFxcbiAgICAgICAgJ2RhdGEtaXMtZm9jdXMnOiBmYWxzZSxcXG4gICAgICAgICdpZCc6IGlkXFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuICR0ZW1wbGF0ZTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogc2V0cyB0aGUgcG9zaXRpb24gY2xhc3Mgb2YgYW4gZWxlbWVudCBhbmQgcmVjdXJzaXZlbHkgY2FsbHMgaXRzZWxmIHVudGlsIHRoZXJlIGFyZSBubyBtb3JlIHBvc3NpYmxlIHBvc2l0aW9ucyB0byBhdHRlbXB0LCBvciB0aGUgdG9vbHRpcCBlbGVtZW50IGlzIG5vIGxvbmdlciBjb2xsaWRpbmcuXFxuICAgICAqIGlmIHRoZSB0b29sdGlwIGlzIGxhcmdlciB0aGFuIHRoZSBzY3JlZW4gd2lkdGgsIGRlZmF1bHQgdG8gZnVsbCB3aWR0aCAtIGFueSB1c2VyIHNlbGVjdGVkIG1hcmdpblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3NldFBvc2l0aW9uXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRQb3NpdGlvbigpIHtcXG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihUb29sdGlwLnByb3RvdHlwZSksIFxcXCJfc2V0UG9zaXRpb25cXFwiLCB0aGlzKS5jYWxsKHRoaXMsIHRoaXMuJGVsZW1lbnQsIHRoaXMudGVtcGxhdGUpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiByZXZlYWxzIHRoZSB0b29sdGlwLCBhbmQgZmlyZXMgYW4gZXZlbnQgdG8gY2xvc2UgYW55IG90aGVyIG9wZW4gdG9vbHRpcHMgb24gdGhlIHBhZ2VcXG4gICAgICogQGZpcmVzIFRvb2x0aXAjY2xvc2VtZVxcbiAgICAgKiBAZmlyZXMgVG9vbHRpcCNzaG93XFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwic2hvd1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KCkge1xcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd09uICE9PSAnYWxsJyAmJiAhX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIk1lZGlhUXVlcnlcXFwiXS5pcyh0aGlzLm9wdGlvbnMuc2hvd09uKSkge1xcbiAgICAgICAgLy8gY29uc29sZS5lcnJvcignVGhlIHNjcmVlbiBpcyB0b28gc21hbGwgdG8gZGlzcGxheSB0aGlzIHRvb2x0aXAnKTtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLnRlbXBsYXRlLmNzcygndmlzaWJpbGl0eScsICdoaWRkZW4nKS5zaG93KCk7XFxuXFxuICAgICAgdGhpcy5fc2V0UG9zaXRpb24oKTtcXG5cXG4gICAgICB0aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKCd0b3AgYm90dG9tIGxlZnQgcmlnaHQnKS5hZGRDbGFzcyh0aGlzLnBvc2l0aW9uKTtcXG4gICAgICB0aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKCdhbGlnbi10b3AgYWxpZ24tYm90dG9tIGFsaWduLWxlZnQgYWxpZ24tcmlnaHQgYWxpZ24tY2VudGVyJykuYWRkQ2xhc3MoJ2FsaWduLScgKyB0aGlzLmFsaWdubWVudCk7XFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgdG8gY2xvc2UgYWxsIG90aGVyIG9wZW4gdG9vbHRpcHMgb24gdGhlIHBhZ2VcXG4gICAgICAgKiBAZXZlbnQgQ2xvc2VtZSN0b29sdGlwXFxuICAgICAgICovXFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjbG9zZW1lLnpmLnRvb2x0aXAnLCB0aGlzLnRlbXBsYXRlLmF0dHIoJ2lkJykpO1xcbiAgICAgIHRoaXMudGVtcGxhdGUuYXR0cih7XFxuICAgICAgICAnZGF0YS1pcy1hY3RpdmUnOiB0cnVlLFxcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogZmFsc2VcXG4gICAgICB9KTtcXG4gICAgICBfdGhpcy5pc0FjdGl2ZSA9IHRydWU7IC8vIGNvbnNvbGUubG9nKHRoaXMudGVtcGxhdGUpO1xcblxcbiAgICAgIHRoaXMudGVtcGxhdGUuc3RvcCgpLmhpZGUoKS5jc3MoJ3Zpc2liaWxpdHknLCAnJykuZmFkZUluKHRoaXMub3B0aW9ucy5mYWRlSW5EdXJhdGlvbiwgZnVuY3Rpb24gKCkgey8vbWF5YmUgZG8gc3R1ZmY/XFxuICAgICAgfSk7XFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgdG9vbHRpcCBpcyBzaG93blxcbiAgICAgICAqIEBldmVudCBUb29sdGlwI3Nob3dcXG4gICAgICAgKi9cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3Nob3cuemYudG9vbHRpcCcpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBIaWRlcyB0aGUgY3VycmVudCB0b29sdGlwLCBhbmQgcmVzZXRzIHRoZSBwb3NpdGlvbmluZyBjbGFzcyBpZiBpdCB3YXMgY2hhbmdlZCBkdWUgdG8gY29sbGlzaW9uXFxuICAgICAqIEBmaXJlcyBUb29sdGlwI2hpZGVcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJoaWRlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUoKSB7XFxuICAgICAgLy8gY29uc29sZS5sb2coJ2hpZGluZycsIHRoaXMuJGVsZW1lbnQuZGF0YSgneWV0aS1ib3gnKSk7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLnRlbXBsYXRlLnN0b3AoKS5hdHRyKHtcXG4gICAgICAgICdhcmlhLWhpZGRlbic6IHRydWUsXFxuICAgICAgICAnZGF0YS1pcy1hY3RpdmUnOiBmYWxzZVxcbiAgICAgIH0pLmZhZGVPdXQodGhpcy5vcHRpb25zLmZhZGVPdXREdXJhdGlvbiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgX3RoaXMuaXNBY3RpdmUgPSBmYWxzZTtcXG4gICAgICAgIF90aGlzLmlzQ2xpY2sgPSBmYWxzZTtcXG4gICAgICB9KTtcXG4gICAgICAvKipcXG4gICAgICAgKiBmaXJlcyB3aGVuIHRoZSB0b29sdGlwIGlzIGhpZGRlblxcbiAgICAgICAqIEBldmVudCBUb29sdGlwI2hpZGVcXG4gICAgICAgKi9cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2hpZGUuemYudG9vbHRpcCcpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBhZGRzIGV2ZW50IGxpc3RlbmVycyBmb3IgdGhlIHRvb2x0aXAgYW5kIGl0cyBhbmNob3JcXG4gICAgICogVE9ETyBjb21iaW5lIHNvbWUgb2YgdGhlIGxpc3RlbmVycyBsaWtlIGZvY3VzIGFuZCBtb3VzZWVudGVyLCBldGMuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZXZlbnRzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB2YXIgJHRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZTtcXG4gICAgICB2YXIgaXNGb2N1cyA9IGZhbHNlO1xcblxcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVIb3Zlcikge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbignbW91c2VlbnRlci56Zi50b29sdGlwJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgaWYgKCFfdGhpcy5pc0FjdGl2ZSkge1xcbiAgICAgICAgICAgIF90aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIF90aGlzLnNob3coKTtcXG4gICAgICAgICAgICB9LCBfdGhpcy5vcHRpb25zLmhvdmVyRGVsYXkpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KS5vbignbW91c2VsZWF2ZS56Zi50b29sdGlwJywgT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiaWdub3JlTW91c2VkaXNhcHBlYXJcXFwiXSkoZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXQpO1xcblxcbiAgICAgICAgICBpZiAoIWlzRm9jdXMgfHwgX3RoaXMuaXNDbGljayAmJiAhX3RoaXMub3B0aW9ucy5jbGlja09wZW4pIHtcXG4gICAgICAgICAgICBfdGhpcy5oaWRlKCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbGlja09wZW4pIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ21vdXNlZG93bi56Zi50b29sdGlwJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG5cXG4gICAgICAgICAgaWYgKF90aGlzLmlzQ2xpY2spIHsvL190aGlzLmhpZGUoKTtcXG4gICAgICAgICAgICAvLyBfdGhpcy5pc0NsaWNrID0gZmFsc2U7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgX3RoaXMuaXNDbGljayA9IHRydWU7XFxuXFxuICAgICAgICAgICAgaWYgKChfdGhpcy5vcHRpb25zLmRpc2FibGVIb3ZlciB8fCAhX3RoaXMuJGVsZW1lbnQuYXR0cigndGFiaW5kZXgnKSkgJiYgIV90aGlzLmlzQWN0aXZlKSB7XFxuICAgICAgICAgICAgICBfdGhpcy5zaG93KCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbignbW91c2Vkb3duLnpmLnRvb2x0aXAnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgICBfdGhpcy5pc0NsaWNrID0gdHJ1ZTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNhYmxlRm9yVG91Y2gpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ3RhcC56Zi50b29sdGlwIHRvdWNoZW5kLnpmLnRvb2x0aXAnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICBfdGhpcy5pc0FjdGl2ZSA/IF90aGlzLmhpZGUoKSA6IF90aGlzLnNob3coKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKHtcXG4gICAgICAgIC8vICd0b2dnbGUuemYudHJpZ2dlcic6IHRoaXMudG9nZ2xlLmJpbmQodGhpcyksXFxuICAgICAgICAvLyAnY2xvc2UuemYudHJpZ2dlcic6IHRoaXMuaGlkZS5iaW5kKHRoaXMpXFxuICAgICAgICAnY2xvc2UuemYudHJpZ2dlcic6IHRoaXMuaGlkZS5iaW5kKHRoaXMpXFxuICAgICAgfSk7XFxuICAgICAgdGhpcy4kZWxlbWVudC5vbignZm9jdXMuemYudG9vbHRpcCcsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBpc0ZvY3VzID0gdHJ1ZTtcXG5cXG4gICAgICAgIGlmIChfdGhpcy5pc0NsaWNrKSB7XFxuICAgICAgICAgIC8vIElmIHdlJ3JlIG5vdCBzaG93aW5nIG9wZW4gb24gY2xpY2tzLCB3ZSBuZWVkIHRvIHByZXRlbmQgYSBjbGljay1sYXVuY2hlZCBmb2N1cyBpc24ndFxcbiAgICAgICAgICAvLyBhIHJlYWwgZm9jdXMsIG90aGVyd2lzZSBvbiBob3ZlciBhbmQgY29tZSBiYWNrIHdlIGdldCBiYWQgYmVoYXZpb3JcXG4gICAgICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLmNsaWNrT3Blbikge1xcbiAgICAgICAgICAgIGlzRm9jdXMgPSBmYWxzZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBfdGhpcy5zaG93KCk7XFxuICAgICAgICB9XFxuICAgICAgfSkub24oJ2ZvY3Vzb3V0LnpmLnRvb2x0aXAnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgaXNGb2N1cyA9IGZhbHNlO1xcbiAgICAgICAgX3RoaXMuaXNDbGljayA9IGZhbHNlO1xcblxcbiAgICAgICAgX3RoaXMuaGlkZSgpO1xcbiAgICAgIH0pLm9uKCdyZXNpemVtZS56Zi50cmlnZ2VyJywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKF90aGlzLmlzQWN0aXZlKSB7XFxuICAgICAgICAgIF90aGlzLl9zZXRQb3NpdGlvbigpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBhZGRzIGEgdG9nZ2xlIG1ldGhvZCwgaW4gYWRkaXRpb24gdG8gdGhlIHN0YXRpYyBzaG93KCkgJiBoaWRlKCkgZnVuY3Rpb25zXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidG9nZ2xlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcXG4gICAgICBpZiAodGhpcy5pc0FjdGl2ZSkge1xcbiAgICAgICAgdGhpcy5oaWRlKCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuc2hvdygpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgdG9vbHRpcCwgcmVtb3ZlcyB0ZW1wbGF0ZSBlbGVtZW50IGZyb20gdGhlIHZpZXcuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2Rlc3Ryb3lcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCd0aXRsZScsIHRoaXMudGVtcGxhdGUudGV4dCgpKS5vZmYoJy56Zi50cmlnZ2VyIC56Zi50b29sdGlwJykucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLnRyaWdnZXJDbGFzcykucmVtb3ZlQ2xhc3MoJ3RvcCByaWdodCBsZWZ0IGJvdHRvbScpLnJlbW92ZUF0dHIoJ2FyaWEtZGVzY3JpYmVkYnkgZGF0YS1kaXNhYmxlLWhvdmVyIGRhdGEtcmVzaXplIGRhdGEtdG9nZ2xlIGRhdGEtdG9vbHRpcCBkYXRhLXlldGktYm94Jyk7XFxuICAgICAgdGhpcy50ZW1wbGF0ZS5yZW1vdmUoKTtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIFRvb2x0aXA7XFxufShfZm91bmRhdGlvbl9wb3NpdGlvbmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiUG9zaXRpb25hYmxlXFxcIl0pO1xcblxcblRvb2x0aXAuZGVmYXVsdHMgPSB7XFxuICBkaXNhYmxlRm9yVG91Y2g6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBUaW1lLCBpbiBtcywgYmVmb3JlIGEgdG9vbHRpcCBzaG91bGQgb3BlbiBvbiBob3Zlci5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAyMDBcXG4gICAqL1xcbiAgaG92ZXJEZWxheTogMjAwLFxcblxcbiAgLyoqXFxuICAgKiBUaW1lLCBpbiBtcywgYSB0b29sdGlwIHNob3VsZCB0YWtlIHRvIGZhZGUgaW50byB2aWV3LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDE1MFxcbiAgICovXFxuICBmYWRlSW5EdXJhdGlvbjogMTUwLFxcblxcbiAgLyoqXFxuICAgKiBUaW1lLCBpbiBtcywgYSB0b29sdGlwIHNob3VsZCB0YWtlIHRvIGZhZGUgb3V0IG9mIHZpZXcuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgMTUwXFxuICAgKi9cXG4gIGZhZGVPdXREdXJhdGlvbjogMTUwLFxcblxcbiAgLyoqXFxuICAgKiBEaXNhYmxlcyBob3ZlciBldmVudHMgZnJvbSBvcGVuaW5nIHRoZSB0b29sdGlwIGlmIHNldCB0byB0cnVlXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGRpc2FibGVIb3ZlcjogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIE9wdGlvbmFsIGFkZHRpb25hbCBjbGFzc2VzIHRvIGFwcGx5IHRvIHRoZSB0b29sdGlwIHRlbXBsYXRlIG9uIGluaXQuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJydcXG4gICAqL1xcbiAgdGVtcGxhdGVDbGFzc2VzOiAnJyxcXG5cXG4gIC8qKlxcbiAgICogTm9uLW9wdGlvbmFsIGNsYXNzIGFkZGVkIHRvIHRvb2x0aXAgdGVtcGxhdGVzLiBGb3VuZGF0aW9uIGRlZmF1bHQgaXMgJ3Rvb2x0aXAnLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICd0b29sdGlwJ1xcbiAgICovXFxuICB0b29sdGlwQ2xhc3M6ICd0b29sdGlwJyxcXG5cXG4gIC8qKlxcbiAgICogQ2xhc3MgYXBwbGllZCB0byB0aGUgdG9vbHRpcCBhbmNob3IgZWxlbWVudC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnaGFzLXRpcCdcXG4gICAqL1xcbiAgdHJpZ2dlckNsYXNzOiAnaGFzLXRpcCcsXFxuXFxuICAvKipcXG4gICAqIE1pbmltdW0gYnJlYWtwb2ludCBzaXplIGF0IHdoaWNoIHRvIG9wZW4gdGhlIHRvb2x0aXAuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ3NtYWxsJ1xcbiAgICovXFxuICBzaG93T246ICdzbWFsbCcsXFxuXFxuICAvKipcXG4gICAqIEN1c3RvbSB0ZW1wbGF0ZSB0byBiZSB1c2VkIHRvIGdlbmVyYXRlIG1hcmt1cCBmb3IgdG9vbHRpcC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnJ1xcbiAgICovXFxuICB0ZW1wbGF0ZTogJycsXFxuXFxuICAvKipcXG4gICAqIFRleHQgZGlzcGxheWVkIGluIHRoZSB0b29sdGlwIHRlbXBsYXRlIG9uIG9wZW4uXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJydcXG4gICAqL1xcbiAgdGlwVGV4dDogJycsXFxuICB0b3VjaENsb3NlVGV4dDogJ1RhcCB0byBjbG9zZS4nLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvd3MgdGhlIHRvb2x0aXAgdG8gcmVtYWluIG9wZW4gaWYgdHJpZ2dlcmVkIHdpdGggYSBjbGljayBvciB0b3VjaCBldmVudC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgdHJ1ZVxcbiAgICovXFxuICBjbGlja09wZW46IHRydWUsXFxuXFxuICAvKipcXG4gICAqIFBvc2l0aW9uIG9mIHRvb2x0aXAuIENhbiBiZSBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG9yIGF1dG8uXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ2F1dG8nXFxuICAgKi9cXG4gIHBvc2l0aW9uOiAnYXV0bycsXFxuXFxuICAvKipcXG4gICAqIEFsaWdubWVudCBvZiB0b29sdGlwIHJlbGF0aXZlIHRvIGFuY2hvci4gQ2FuIGJlIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgY2VudGVyLCBvciBhdXRvLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICdhdXRvJ1xcbiAgICovXFxuICBhbGlnbm1lbnQ6ICdhdXRvJyxcXG5cXG4gIC8qKlxcbiAgICogQWxsb3cgb3ZlcmxhcCBvZiBjb250YWluZXIvd2luZG93LiBJZiBmYWxzZSwgdG9vbHRpcCB3aWxsIGZpcnN0IHRyeSB0b1xcbiAgICogcG9zaXRpb24gYXMgZGVmaW5lZCBieSBkYXRhLXBvc2l0aW9uIGFuZCBkYXRhLWFsaWdubWVudCwgYnV0IHJlcG9zaXRpb24gaWZcXG4gICAqIGl0IHdvdWxkIGNhdXNlIGFuIG92ZXJmbG93LiAgQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBhbGxvd092ZXJsYXA6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvdyBvdmVybGFwIG9mIG9ubHkgdGhlIGJvdHRvbSBvZiB0aGUgY29udGFpbmVyLiBUaGlzIGlzIHRoZSBtb3N0IGNvbW1vblxcbiAgICogYmVoYXZpb3IgZm9yIGRyb3Bkb3ducywgYWxsb3dpbmcgdGhlIGRyb3Bkb3duIHRvIGV4dGVuZCB0aGUgYm90dG9tIG9mIHRoZVxcbiAgICogc2NyZWVuIGJ1dCBub3Qgb3RoZXJ3aXNlIGluZmx1ZW5jZSBvciBicmVhayBvdXQgb2YgdGhlIGNvbnRhaW5lci5cXG4gICAqIExlc3MgY29tbW9uIGZvciB0b29sdGlwcy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgYWxsb3dCb3R0b21PdmVybGFwOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogRGlzdGFuY2UsIGluIHBpeGVscywgdGhlIHRlbXBsYXRlIHNob3VsZCBwdXNoIGF3YXkgZnJvbSB0aGUgYW5jaG9yIG9uIHRoZSBZIGF4aXMuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgMFxcbiAgICovXFxuICB2T2Zmc2V0OiAwLFxcblxcbiAgLyoqXFxuICAgKiBEaXN0YW5jZSwgaW4gcGl4ZWxzLCB0aGUgdGVtcGxhdGUgc2hvdWxkIHB1c2ggYXdheSBmcm9tIHRoZSBhbmNob3Igb24gdGhlIFggYXhpc1xcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDBcXG4gICAqL1xcbiAgaE9mZnNldDogMCxcXG5cXG4gIC8qKlxcbiAgICogRGlzdGFuY2UsIGluIHBpeGVscywgdGhlIHRlbXBsYXRlIHNwYWNpbmcgYXV0by1hZGp1c3QgZm9yIGEgdmVydGljYWwgdG9vbHRpcFxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDE0XFxuICAgKi9cXG4gIHRvb2x0aXBIZWlnaHQ6IDE0LFxcblxcbiAgLyoqXFxuICAgKiBEaXN0YW5jZSwgaW4gcGl4ZWxzLCB0aGUgdGVtcGxhdGUgc3BhY2luZyBhdXRvLWFkanVzdCBmb3IgYSBob3Jpem9udGFsIHRvb2x0aXBcXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAxMlxcbiAgICovXFxuICB0b29sdGlwV2lkdGg6IDEyLFxcblxcbiAgLyoqXFxuICAqIEFsbG93IEhUTUwgaW4gdG9vbHRpcC4gV2FybmluZzogSWYgeW91IGFyZSBsb2FkaW5nIHVzZXItZ2VuZXJhdGVkIGNvbnRlbnQgaW50byB0b29sdGlwcyxcXG4gICogYWxsb3dpbmcgSFRNTCBtYXkgb3BlbiB5b3Vyc2VsZiB1cCB0byBYU1MgYXR0YWNrcy5cXG4gICogQG9wdGlvblxcbiAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICogQGRlZmF1bHQgZmFsc2VcXG4gICovXFxuICBhbGxvd0h0bWw6IGZhbHNlXFxufTtcXG4vKipcXG4gKiBUT0RPIHV0aWxpemUgcmVzaXplIGV2ZW50IHRyaWdnZXJcXG4gKi9cXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9qcy9mb3VuZGF0aW9uLnRvb2x0aXAuanM/XCIpfSxcIi4vanMvZm91bmRhdGlvbi51dGlsLmJveC5qc1wiOmZ1bmN0aW9uKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiQm94XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBCb3g7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uY29yZS51dGlscyAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUudXRpbHMuanNcXFwiKTtcXG5cXG5cXG5cXG52YXIgQm94ID0ge1xcbiAgSW1Ob3RUb3VjaGluZ1lvdTogSW1Ob3RUb3VjaGluZ1lvdSxcXG4gIE92ZXJsYXBBcmVhOiBPdmVybGFwQXJlYSxcXG4gIEdldERpbWVuc2lvbnM6IEdldERpbWVuc2lvbnMsXFxuICBHZXRPZmZzZXRzOiBHZXRPZmZzZXRzLFxcbiAgR2V0RXhwbGljaXRPZmZzZXRzOiBHZXRFeHBsaWNpdE9mZnNldHNcXG4gIC8qKlxcbiAgICogQ29tcGFyZXMgdGhlIGRpbWVuc2lvbnMgb2YgYW4gZWxlbWVudCB0byBhIGNvbnRhaW5lciBhbmQgZGV0ZXJtaW5lcyBjb2xsaXNpb24gZXZlbnRzIHdpdGggY29udGFpbmVyLlxcbiAgICogQGZ1bmN0aW9uXFxuICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gdGVzdCBmb3IgY29sbGlzaW9ucy5cXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSBwYXJlbnQgLSBqUXVlcnkgb2JqZWN0IHRvIHVzZSBhcyBib3VuZGluZyBjb250YWluZXIuXFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGxyT25seSAtIHNldCB0byB0cnVlIHRvIGNoZWNrIGxlZnQgYW5kIHJpZ2h0IHZhbHVlcyBvbmx5LlxcbiAgICogQHBhcmFtIHtCb29sZWFufSB0Yk9ubHkgLSBzZXQgdG8gdHJ1ZSB0byBjaGVjayB0b3AgYW5kIGJvdHRvbSB2YWx1ZXMgb25seS5cXG4gICAqIEBkZWZhdWx0IGlmIG5vIHBhcmVudCBvYmplY3QgcGFzc2VkLCBkZXRlY3RzIGNvbGxpc2lvbnMgd2l0aCBgd2luZG93YC5cXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSAtIHRydWUgaWYgY29sbGlzaW9uIGZyZWUsIGZhbHNlIGlmIGEgY29sbGlzaW9uIGluIGFueSBkaXJlY3Rpb24uXFxuICAgKi9cXG5cXG59O1xcblxcbmZ1bmN0aW9uIEltTm90VG91Y2hpbmdZb3UoZWxlbWVudCwgcGFyZW50LCBsck9ubHksIHRiT25seSwgaWdub3JlQm90dG9tKSB7XFxuICByZXR1cm4gT3ZlcmxhcEFyZWEoZWxlbWVudCwgcGFyZW50LCBsck9ubHksIHRiT25seSwgaWdub3JlQm90dG9tKSA9PT0gMDtcXG59XFxuXFxuO1xcblxcbmZ1bmN0aW9uIE92ZXJsYXBBcmVhKGVsZW1lbnQsIHBhcmVudCwgbHJPbmx5LCB0Yk9ubHksIGlnbm9yZUJvdHRvbSkge1xcbiAgdmFyIGVsZURpbXMgPSBHZXREaW1lbnNpb25zKGVsZW1lbnQpLFxcbiAgICAgIHRvcE92ZXIsXFxuICAgICAgYm90dG9tT3ZlcixcXG4gICAgICBsZWZ0T3ZlcixcXG4gICAgICByaWdodE92ZXI7XFxuXFxuICBpZiAocGFyZW50KSB7XFxuICAgIHZhciBwYXJEaW1zID0gR2V0RGltZW5zaW9ucyhwYXJlbnQpO1xcbiAgICBib3R0b21PdmVyID0gcGFyRGltcy5oZWlnaHQgKyBwYXJEaW1zLm9mZnNldC50b3AgLSAoZWxlRGltcy5vZmZzZXQudG9wICsgZWxlRGltcy5oZWlnaHQpO1xcbiAgICB0b3BPdmVyID0gZWxlRGltcy5vZmZzZXQudG9wIC0gcGFyRGltcy5vZmZzZXQudG9wO1xcbiAgICBsZWZ0T3ZlciA9IGVsZURpbXMub2Zmc2V0LmxlZnQgLSBwYXJEaW1zLm9mZnNldC5sZWZ0O1xcbiAgICByaWdodE92ZXIgPSBwYXJEaW1zLndpZHRoICsgcGFyRGltcy5vZmZzZXQubGVmdCAtIChlbGVEaW1zLm9mZnNldC5sZWZ0ICsgZWxlRGltcy53aWR0aCk7XFxuICB9IGVsc2Uge1xcbiAgICBib3R0b21PdmVyID0gZWxlRGltcy53aW5kb3dEaW1zLmhlaWdodCArIGVsZURpbXMud2luZG93RGltcy5vZmZzZXQudG9wIC0gKGVsZURpbXMub2Zmc2V0LnRvcCArIGVsZURpbXMuaGVpZ2h0KTtcXG4gICAgdG9wT3ZlciA9IGVsZURpbXMub2Zmc2V0LnRvcCAtIGVsZURpbXMud2luZG93RGltcy5vZmZzZXQudG9wO1xcbiAgICBsZWZ0T3ZlciA9IGVsZURpbXMub2Zmc2V0LmxlZnQgLSBlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LmxlZnQ7XFxuICAgIHJpZ2h0T3ZlciA9IGVsZURpbXMud2luZG93RGltcy53aWR0aCAtIChlbGVEaW1zLm9mZnNldC5sZWZ0ICsgZWxlRGltcy53aWR0aCk7XFxuICB9XFxuXFxuICBib3R0b21PdmVyID0gaWdub3JlQm90dG9tID8gMCA6IE1hdGgubWluKGJvdHRvbU92ZXIsIDApO1xcbiAgdG9wT3ZlciA9IE1hdGgubWluKHRvcE92ZXIsIDApO1xcbiAgbGVmdE92ZXIgPSBNYXRoLm1pbihsZWZ0T3ZlciwgMCk7XFxuICByaWdodE92ZXIgPSBNYXRoLm1pbihyaWdodE92ZXIsIDApO1xcblxcbiAgaWYgKGxyT25seSkge1xcbiAgICByZXR1cm4gbGVmdE92ZXIgKyByaWdodE92ZXI7XFxuICB9XFxuXFxuICBpZiAodGJPbmx5KSB7XFxuICAgIHJldHVybiB0b3BPdmVyICsgYm90dG9tT3ZlcjtcXG4gIH0gLy8gdXNlIHN1bSBvZiBzcXVhcmVzIGIvYyB3ZSBjYXJlIGFib3V0IG92ZXJsYXAgYXJlYS5cXG5cXG5cXG4gIHJldHVybiBNYXRoLnNxcnQodG9wT3ZlciAqIHRvcE92ZXIgKyBib3R0b21PdmVyICogYm90dG9tT3ZlciArIGxlZnRPdmVyICogbGVmdE92ZXIgKyByaWdodE92ZXIgKiByaWdodE92ZXIpO1xcbn1cXG4vKipcXG4gKiBVc2VzIG5hdGl2ZSBtZXRob2RzIHRvIHJldHVybiBhbiBvYmplY3Qgb2YgZGltZW5zaW9uIHZhbHVlcy5cXG4gKiBAZnVuY3Rpb25cXG4gKiBAcGFyYW0ge2pRdWVyeSB8fCBIVE1MfSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCBvciBET00gZWxlbWVudCBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBkaW1lbnNpb25zLiBDYW4gYmUgYW55IGVsZW1lbnQgb3RoZXIgdGhhdCBkb2N1bWVudCBvciB3aW5kb3cuXFxuICogQHJldHVybnMge09iamVjdH0gLSBuZXN0ZWQgb2JqZWN0IG9mIGludGVnZXIgcGl4ZWwgdmFsdWVzXFxuICogVE9ETyAtIGlmIGVsZW1lbnQgaXMgd2luZG93LCByZXR1cm4gb25seSB0aG9zZSB2YWx1ZXMuXFxuICovXFxuXFxuXFxuZnVuY3Rpb24gR2V0RGltZW5zaW9ucyhlbGVtKSB7XFxuICBlbGVtID0gZWxlbS5sZW5ndGggPyBlbGVtWzBdIDogZWxlbTtcXG5cXG4gIGlmIChlbGVtID09PSB3aW5kb3cgfHwgZWxlbSA9PT0gZG9jdW1lbnQpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKFxcXCJJJ20gc29ycnksIERhdmUuIEknbSBhZnJhaWQgSSBjYW4ndCBkbyB0aGF0LlxcXCIpO1xcbiAgfVxcblxcbiAgdmFyIHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxcbiAgICAgIHBhclJlY3QgPSBlbGVtLnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXFxuICAgICAgd2luUmVjdCA9IGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXFxuICAgICAgd2luWSA9IHdpbmRvdy5wYWdlWU9mZnNldCxcXG4gICAgICB3aW5YID0gd2luZG93LnBhZ2VYT2Zmc2V0O1xcbiAgcmV0dXJuIHtcXG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHQsXFxuICAgIG9mZnNldDoge1xcbiAgICAgIHRvcDogcmVjdC50b3AgKyB3aW5ZLFxcbiAgICAgIGxlZnQ6IHJlY3QubGVmdCArIHdpblhcXG4gICAgfSxcXG4gICAgcGFyZW50RGltczoge1xcbiAgICAgIHdpZHRoOiBwYXJSZWN0LndpZHRoLFxcbiAgICAgIGhlaWdodDogcGFyUmVjdC5oZWlnaHQsXFxuICAgICAgb2Zmc2V0OiB7XFxuICAgICAgICB0b3A6IHBhclJlY3QudG9wICsgd2luWSxcXG4gICAgICAgIGxlZnQ6IHBhclJlY3QubGVmdCArIHdpblhcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHdpbmRvd0RpbXM6IHtcXG4gICAgICB3aWR0aDogd2luUmVjdC53aWR0aCxcXG4gICAgICBoZWlnaHQ6IHdpblJlY3QuaGVpZ2h0LFxcbiAgICAgIG9mZnNldDoge1xcbiAgICAgICAgdG9wOiB3aW5ZLFxcbiAgICAgICAgbGVmdDogd2luWFxcbiAgICAgIH1cXG4gICAgfVxcbiAgfTtcXG59XFxuLyoqXFxuICogUmV0dXJucyBhbiBvYmplY3Qgb2YgdG9wIGFuZCBsZWZ0IGludGVnZXIgcGl4ZWwgdmFsdWVzIGZvciBkeW5hbWljYWxseSByZW5kZXJlZCBlbGVtZW50cyxcXG4gKiBzdWNoIGFzOiBUb29sdGlwLCBSZXZlYWwsIGFuZCBEcm9wZG93bi4gTWFpbnRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGFuZCB3aGVyZVxcbiAqIHlvdSBkb24ndCBrbm93IGFsaWdubWVudCwgYnV0IGdlbmVyYWxseSBmcm9tXFxuICogNi40IGZvcndhcmQgeW91IHNob3VsZCB1c2UgR2V0RXhwbGljaXRPZmZzZXRzLCBhcyBHZXRPZmZzZXRzIGNvbmZsYXRlcyBwb3NpdGlvbiBhbmQgYWxpZ25tZW50LlxcbiAqIEBmdW5jdGlvblxcbiAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCBmb3IgdGhlIGVsZW1lbnQgYmVpbmcgcG9zaXRpb25lZC5cXG4gKiBAcGFyYW0ge2pRdWVyeX0gYW5jaG9yIC0galF1ZXJ5IG9iamVjdCBmb3IgdGhlIGVsZW1lbnQncyBhbmNob3IgcG9pbnQuXFxuICogQHBhcmFtIHtTdHJpbmd9IHBvc2l0aW9uIC0gYSBzdHJpbmcgcmVsYXRpbmcgdG8gdGhlIGRlc2lyZWQgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQsIHJlbGF0aXZlIHRvIGl0J3MgYW5jaG9yXFxuICogQHBhcmFtIHtOdW1iZXJ9IHZPZmZzZXQgLSBpbnRlZ2VyIHBpeGVsIHZhbHVlIG9mIGRlc2lyZWQgdmVydGljYWwgc2VwYXJhdGlvbiBiZXR3ZWVuIGFuY2hvciBhbmQgZWxlbWVudC5cXG4gKiBAcGFyYW0ge051bWJlcn0gaE9mZnNldCAtIGludGVnZXIgcGl4ZWwgdmFsdWUgb2YgZGVzaXJlZCBob3Jpem9udGFsIHNlcGFyYXRpb24gYmV0d2VlbiBhbmNob3IgYW5kIGVsZW1lbnQuXFxuICogQHBhcmFtIHtCb29sZWFufSBpc092ZXJmbG93IC0gaWYgYSBjb2xsaXNpb24gZXZlbnQgaXMgZGV0ZWN0ZWQsIHNldHMgdG8gdHJ1ZSB0byBkZWZhdWx0IHRoZSBlbGVtZW50IHRvIGZ1bGwgd2lkdGggLSBhbnkgZGVzaXJlZCBvZmZzZXQuXFxuICogVE9ETyBhbHRlci9yZXdyaXRlIHRvIHdvcmsgd2l0aCBgZW1gIHZhbHVlcyBhcyB3ZWxsL2luc3RlYWQgb2YgcGl4ZWxzXFxuICovXFxuXFxuXFxuZnVuY3Rpb24gR2V0T2Zmc2V0cyhlbGVtZW50LCBhbmNob3IsIHBvc2l0aW9uLCB2T2Zmc2V0LCBoT2Zmc2V0LCBpc092ZXJmbG93KSB7XFxuICBjb25zb2xlLmxvZyhcXFwiTk9URTogR2V0T2Zmc2V0cyBpcyBkZXByZWNhdGVkIGluIGZhdm9yIG9mIEdldEV4cGxpY2l0T2Zmc2V0cyBhbmQgd2lsbCBiZSByZW1vdmVkIGluIDYuNVxcXCIpO1xcblxcbiAgc3dpdGNoIChwb3NpdGlvbikge1xcbiAgICBjYXNlICd0b3AnOlxcbiAgICAgIHJldHVybiBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJydGxcXFwiXSkoKSA/IEdldEV4cGxpY2l0T2Zmc2V0cyhlbGVtZW50LCBhbmNob3IsICd0b3AnLCAnbGVmdCcsIHZPZmZzZXQsIGhPZmZzZXQsIGlzT3ZlcmZsb3cpIDogR2V0RXhwbGljaXRPZmZzZXRzKGVsZW1lbnQsIGFuY2hvciwgJ3RvcCcsICdyaWdodCcsIHZPZmZzZXQsIGhPZmZzZXQsIGlzT3ZlcmZsb3cpO1xcblxcbiAgICBjYXNlICdib3R0b20nOlxcbiAgICAgIHJldHVybiBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJydGxcXFwiXSkoKSA/IEdldEV4cGxpY2l0T2Zmc2V0cyhlbGVtZW50LCBhbmNob3IsICdib3R0b20nLCAnbGVmdCcsIHZPZmZzZXQsIGhPZmZzZXQsIGlzT3ZlcmZsb3cpIDogR2V0RXhwbGljaXRPZmZzZXRzKGVsZW1lbnQsIGFuY2hvciwgJ2JvdHRvbScsICdyaWdodCcsIHZPZmZzZXQsIGhPZmZzZXQsIGlzT3ZlcmZsb3cpO1xcblxcbiAgICBjYXNlICdjZW50ZXIgdG9wJzpcXG4gICAgICByZXR1cm4gR2V0RXhwbGljaXRPZmZzZXRzKGVsZW1lbnQsIGFuY2hvciwgJ3RvcCcsICdjZW50ZXInLCB2T2Zmc2V0LCBoT2Zmc2V0LCBpc092ZXJmbG93KTtcXG5cXG4gICAgY2FzZSAnY2VudGVyIGJvdHRvbSc6XFxuICAgICAgcmV0dXJuIEdldEV4cGxpY2l0T2Zmc2V0cyhlbGVtZW50LCBhbmNob3IsICdib3R0b20nLCAnY2VudGVyJywgdk9mZnNldCwgaE9mZnNldCwgaXNPdmVyZmxvdyk7XFxuXFxuICAgIGNhc2UgJ2NlbnRlciBsZWZ0JzpcXG4gICAgICByZXR1cm4gR2V0RXhwbGljaXRPZmZzZXRzKGVsZW1lbnQsIGFuY2hvciwgJ2xlZnQnLCAnY2VudGVyJywgdk9mZnNldCwgaE9mZnNldCwgaXNPdmVyZmxvdyk7XFxuXFxuICAgIGNhc2UgJ2NlbnRlciByaWdodCc6XFxuICAgICAgcmV0dXJuIEdldEV4cGxpY2l0T2Zmc2V0cyhlbGVtZW50LCBhbmNob3IsICdyaWdodCcsICdjZW50ZXInLCB2T2Zmc2V0LCBoT2Zmc2V0LCBpc092ZXJmbG93KTtcXG5cXG4gICAgY2FzZSAnbGVmdCBib3R0b20nOlxcbiAgICAgIHJldHVybiBHZXRFeHBsaWNpdE9mZnNldHMoZWxlbWVudCwgYW5jaG9yLCAnYm90dG9tJywgJ2xlZnQnLCB2T2Zmc2V0LCBoT2Zmc2V0LCBpc092ZXJmbG93KTtcXG5cXG4gICAgY2FzZSAncmlnaHQgYm90dG9tJzpcXG4gICAgICByZXR1cm4gR2V0RXhwbGljaXRPZmZzZXRzKGVsZW1lbnQsIGFuY2hvciwgJ2JvdHRvbScsICdyaWdodCcsIHZPZmZzZXQsIGhPZmZzZXQsIGlzT3ZlcmZsb3cpO1xcbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4uLiB0aGlzIGFsb25nIHdpdGggdGhlIHJldmVhbCBhbmQgcmV2ZWFsIGZ1bGxcXG4gICAgLy8gY2xhc3NlcyBhcmUgdGhlIG9ubHkgb25lcyB0aGF0IGRpZG4ndCByZWZlcmVuY2UgYW5jaG9yXFxuXFxuICAgIGNhc2UgJ2NlbnRlcic6XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIGxlZnQ6ICRlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LmxlZnQgKyAkZWxlRGltcy53aW5kb3dEaW1zLndpZHRoIC8gMiAtICRlbGVEaW1zLndpZHRoIC8gMiArIGhPZmZzZXQsXFxuICAgICAgICB0b3A6ICRlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LnRvcCArICRlbGVEaW1zLndpbmRvd0RpbXMuaGVpZ2h0IC8gMiAtICgkZWxlRGltcy5oZWlnaHQgLyAyICsgdk9mZnNldClcXG4gICAgICB9O1xcblxcbiAgICBjYXNlICdyZXZlYWwnOlxcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBsZWZ0OiAoJGVsZURpbXMud2luZG93RGltcy53aWR0aCAtICRlbGVEaW1zLndpZHRoKSAvIDIgKyBoT2Zmc2V0LFxcbiAgICAgICAgdG9wOiAkZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC50b3AgKyB2T2Zmc2V0XFxuICAgICAgfTtcXG5cXG4gICAgY2FzZSAncmV2ZWFsIGZ1bGwnOlxcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBsZWZ0OiAkZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC5sZWZ0LFxcbiAgICAgICAgdG9wOiAkZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC50b3BcXG4gICAgICB9O1xcbiAgICAgIGJyZWFrO1xcblxcbiAgICBkZWZhdWx0OlxcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBsZWZ0OiBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJydGxcXFwiXSkoKSA/ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0IC0gJGVsZURpbXMud2lkdGggKyAkYW5jaG9yRGltcy53aWR0aCAtIGhPZmZzZXQgOiAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCArIGhPZmZzZXQsXFxuICAgICAgICB0b3A6ICRhbmNob3JEaW1zLm9mZnNldC50b3AgKyAkYW5jaG9yRGltcy5oZWlnaHQgKyB2T2Zmc2V0XFxuICAgICAgfTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gR2V0RXhwbGljaXRPZmZzZXRzKGVsZW1lbnQsIGFuY2hvciwgcG9zaXRpb24sIGFsaWdubWVudCwgdk9mZnNldCwgaE9mZnNldCwgaXNPdmVyZmxvdykge1xcbiAgdmFyICRlbGVEaW1zID0gR2V0RGltZW5zaW9ucyhlbGVtZW50KSxcXG4gICAgICAkYW5jaG9yRGltcyA9IGFuY2hvciA/IEdldERpbWVuc2lvbnMoYW5jaG9yKSA6IG51bGw7XFxuICB2YXIgdG9wVmFsLCBsZWZ0VmFsOyAvLyBzZXQgcG9zaXRpb24gcmVsYXRlZCBhdHRyaWJ1dGVcXG5cXG4gIHN3aXRjaCAocG9zaXRpb24pIHtcXG4gICAgY2FzZSAndG9wJzpcXG4gICAgICB0b3BWYWwgPSAkYW5jaG9yRGltcy5vZmZzZXQudG9wIC0gKCRlbGVEaW1zLmhlaWdodCArIHZPZmZzZXQpO1xcbiAgICAgIGJyZWFrO1xcblxcbiAgICBjYXNlICdib3R0b20nOlxcbiAgICAgIHRvcFZhbCA9ICRhbmNob3JEaW1zLm9mZnNldC50b3AgKyAkYW5jaG9yRGltcy5oZWlnaHQgKyB2T2Zmc2V0O1xcbiAgICAgIGJyZWFrO1xcblxcbiAgICBjYXNlICdsZWZ0JzpcXG4gICAgICBsZWZ0VmFsID0gJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgLSAoJGVsZURpbXMud2lkdGggKyBoT2Zmc2V0KTtcXG4gICAgICBicmVhaztcXG5cXG4gICAgY2FzZSAncmlnaHQnOlxcbiAgICAgIGxlZnRWYWwgPSAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCArICRhbmNob3JEaW1zLndpZHRoICsgaE9mZnNldDtcXG4gICAgICBicmVhaztcXG4gIH0gLy8gc2V0IGFsaWdubWVudCByZWxhdGVkIGF0dHJpYnV0ZVxcblxcblxcbiAgc3dpdGNoIChwb3NpdGlvbikge1xcbiAgICBjYXNlICd0b3AnOlxcbiAgICBjYXNlICdib3R0b20nOlxcbiAgICAgIHN3aXRjaCAoYWxpZ25tZW50KSB7XFxuICAgICAgICBjYXNlICdsZWZ0JzpcXG4gICAgICAgICAgbGVmdFZhbCA9ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0ICsgaE9mZnNldDtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlICdyaWdodCc6XFxuICAgICAgICAgIGxlZnRWYWwgPSAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCAtICRlbGVEaW1zLndpZHRoICsgJGFuY2hvckRpbXMud2lkdGggLSBoT2Zmc2V0O1xcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XFxuICAgICAgICAgIGxlZnRWYWwgPSBpc092ZXJmbG93ID8gaE9mZnNldCA6ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0ICsgJGFuY2hvckRpbXMud2lkdGggLyAyIC0gJGVsZURpbXMud2lkdGggLyAyICsgaE9mZnNldDtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcblxcbiAgICAgIGJyZWFrO1xcblxcbiAgICBjYXNlICdyaWdodCc6XFxuICAgIGNhc2UgJ2xlZnQnOlxcbiAgICAgIHN3aXRjaCAoYWxpZ25tZW50KSB7XFxuICAgICAgICBjYXNlICdib3R0b20nOlxcbiAgICAgICAgICB0b3BWYWwgPSAkYW5jaG9yRGltcy5vZmZzZXQudG9wIC0gdk9mZnNldCArICRhbmNob3JEaW1zLmhlaWdodCAtICRlbGVEaW1zLmhlaWdodDtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlICd0b3AnOlxcbiAgICAgICAgICB0b3BWYWwgPSAkYW5jaG9yRGltcy5vZmZzZXQudG9wICsgdk9mZnNldDtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlICdjZW50ZXInOlxcbiAgICAgICAgICB0b3BWYWwgPSAkYW5jaG9yRGltcy5vZmZzZXQudG9wICsgdk9mZnNldCArICRhbmNob3JEaW1zLmhlaWdodCAvIDIgLSAkZWxlRGltcy5oZWlnaHQgLyAyO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICB9XFxuXFxuICAgICAgYnJlYWs7XFxuICB9XFxuXFxuICByZXR1cm4ge1xcbiAgICB0b3A6IHRvcFZhbCxcXG4gICAgbGVmdDogbGVmdFZhbFxcbiAgfTtcXG59XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi51dGlsLmJveC5qcz9cIil9LFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwuaW1hZ2VMb2FkZXIuanNcIjpmdW5jdGlvbihtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIm9uSW1hZ2VzTG9hZGVkXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBvbkltYWdlc0xvYWRlZDsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganF1ZXJ5ICovIFxcXCJqcXVlcnlcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcblxcblxcblxcbi8qKlxcbiAqIFJ1bnMgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIGltYWdlcyBhcmUgZnVsbHkgbG9hZGVkLlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZXMgLSBJbWFnZShzKSB0byBjaGVjayBpZiBsb2FkZWQuXFxuICogQHBhcmFtIHtGdW5jfSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiBpbWFnZSBpcyBmdWxseSBsb2FkZWQuXFxuICovXFxuXFxuZnVuY3Rpb24gb25JbWFnZXNMb2FkZWQoaW1hZ2VzLCBjYWxsYmFjaykge1xcbiAgdmFyIHNlbGYgPSB0aGlzLFxcbiAgICAgIHVubG9hZGVkID0gaW1hZ2VzLmxlbmd0aDtcXG5cXG4gIGlmICh1bmxvYWRlZCA9PT0gMCkge1xcbiAgICBjYWxsYmFjaygpO1xcbiAgfVxcblxcbiAgaW1hZ2VzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAvLyBDaGVjayBpZiBpbWFnZSBpcyBsb2FkZWRcXG4gICAgaWYgKHRoaXMuY29tcGxldGUgJiYgdHlwZW9mIHRoaXMubmF0dXJhbFdpZHRoICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgIHNpbmdsZUltYWdlTG9hZGVkKCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gSWYgdGhlIGFib3ZlIGNoZWNrIGZhaWxlZCwgc2ltdWxhdGUgbG9hZGluZyBvbiBkZXRhY2hlZCBlbGVtZW50LlxcbiAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpOyAvLyBTdGlsbCBjb3VudCBpbWFnZSBhcyBsb2FkZWQgaWYgaXQgZmluYWxpemVzIHdpdGggYW4gZXJyb3IuXFxuXFxuICAgICAgdmFyIGV2ZW50cyA9IFxcXCJsb2FkLnpmLmltYWdlcyBlcnJvci56Zi5pbWFnZXNcXFwiO1xcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShpbWFnZSkub25lKGV2ZW50cywgZnVuY3Rpb24gbWUoZXZlbnQpIHtcXG4gICAgICAgIC8vIFVuYmluZCB0aGUgZXZlbnQgbGlzdGVuZXJzLiBXZSdyZSB1c2luZyAnb25lJyBidXQgb25seSBvbmUgb2YgdGhlIHR3byBldmVudHMgd2lsbCBoYXZlIGZpcmVkLlxcbiAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLm9mZihldmVudHMsIG1lKTtcXG4gICAgICAgIHNpbmdsZUltYWdlTG9hZGVkKCk7XFxuICAgICAgfSk7XFxuICAgICAgaW1hZ2Uuc3JjID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLmF0dHIoJ3NyYycpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIGZ1bmN0aW9uIHNpbmdsZUltYWdlTG9hZGVkKCkge1xcbiAgICB1bmxvYWRlZC0tO1xcblxcbiAgICBpZiAodW5sb2FkZWQgPT09IDApIHtcXG4gICAgICBjYWxsYmFjaygpO1xcbiAgICB9XFxuICB9XFxufVxcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL2pzL2ZvdW5kYXRpb24udXRpbC5pbWFnZUxvYWRlci5qcz9cIil9LFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmQuanNcIjpmdW5jdGlvbihtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIktleWJvYXJkXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBLZXlib2FyZDsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganF1ZXJ5ICovIFxcXCJqcXVlcnlcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uY29yZS51dGlscyAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUudXRpbHMuanNcXFwiKTtcXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXFxuICogVGhpcyB1dGlsIHdhcyBjcmVhdGVkIGJ5IE1hcml1cyBPbGJlcnR6ICpcXG4gKiBQbGVhc2UgdGhhbmsgTWFyaXVzIG9uIEdpdEh1YiAvb3dsYmVydHogKlxcbiAqIG9yIHRoZSB3ZWIgaHR0cDovL3d3dy5tYXJpdXNvbGJlcnR6LmRlLyAqXFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcblxcblxcblxcblxcbnZhciBrZXlDb2RlcyA9IHtcXG4gIDk6ICdUQUInLFxcbiAgMTM6ICdFTlRFUicsXFxuICAyNzogJ0VTQ0FQRScsXFxuICAzMjogJ1NQQUNFJyxcXG4gIDM1OiAnRU5EJyxcXG4gIDM2OiAnSE9NRScsXFxuICAzNzogJ0FSUk9XX0xFRlQnLFxcbiAgMzg6ICdBUlJPV19VUCcsXFxuICAzOTogJ0FSUk9XX1JJR0hUJyxcXG4gIDQwOiAnQVJST1dfRE9XTidcXG59O1xcbnZhciBjb21tYW5kcyA9IHt9OyAvLyBGdW5jdGlvbnMgcHVsbGVkIG91dCB0byBiZSByZWZlcmVuY2VhYmxlIGZyb20gaW50ZXJuYWxzXFxuXFxuZnVuY3Rpb24gZmluZEZvY3VzYWJsZSgkZWxlbWVudCkge1xcbiAgaWYgKCEkZWxlbWVudCkge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICByZXR1cm4gJGVsZW1lbnQuZmluZCgnYVtocmVmXSwgYXJlYVtocmVmXSwgaW5wdXQ6bm90KFtkaXNhYmxlZF0pLCBzZWxlY3Q6bm90KFtkaXNhYmxlZF0pLCB0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksIGJ1dHRvbjpub3QoW2Rpc2FibGVkXSksIGlmcmFtZSwgb2JqZWN0LCBlbWJlZCwgKlt0YWJpbmRleF0sICpbY29udGVudGVkaXRhYmxlXScpLmZpbHRlcihmdW5jdGlvbiAoKSB7XFxuICAgIGlmICghanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLmlzKCc6dmlzaWJsZScpIHx8IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS5hdHRyKCd0YWJpbmRleCcpIDwgMCkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfSAvL29ubHkgaGF2ZSB2aXNpYmxlIGVsZW1lbnRzIGFuZCB0aG9zZSB0aGF0IGhhdmUgYSB0YWJpbmRleCBncmVhdGVyIG9yIGVxdWFsIDBcXG5cXG5cXG4gICAgcmV0dXJuIHRydWU7XFxuICB9KTtcXG59XFxuXFxuZnVuY3Rpb24gcGFyc2VLZXkoZXZlbnQpIHtcXG4gIHZhciBrZXkgPSBrZXlDb2Rlc1tldmVudC53aGljaCB8fCBldmVudC5rZXlDb2RlXSB8fCBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2ZW50LndoaWNoKS50b1VwcGVyQ2FzZSgpOyAvLyBSZW1vdmUgdW4tcHJpbnRhYmxlIGNoYXJhY3RlcnMsIGUuZy4gZm9yIGBmcm9tQ2hhckNvZGVgIGNhbGxzIGZvciBDVFJMIG9ubHkgZXZlbnRzXFxuXFxuICBrZXkgPSBrZXkucmVwbGFjZSgvXFxcXFcrLywgJycpO1xcbiAgaWYgKGV2ZW50LnNoaWZ0S2V5KSBrZXkgPSBcXFwiU0hJRlRfXFxcIi5jb25jYXQoa2V5KTtcXG4gIGlmIChldmVudC5jdHJsS2V5KSBrZXkgPSBcXFwiQ1RSTF9cXFwiLmNvbmNhdChrZXkpO1xcbiAgaWYgKGV2ZW50LmFsdEtleSkga2V5ID0gXFxcIkFMVF9cXFwiLmNvbmNhdChrZXkpOyAvLyBSZW1vdmUgdHJhaWxpbmcgdW5kZXJzY29yZSwgaW4gY2FzZSBvbmx5IG1vZGlmaWVycyB3ZXJlIHVzZWQgKGUuZy4gb25seSBgQ1RSTF9BTFRgKVxcblxcbiAga2V5ID0ga2V5LnJlcGxhY2UoL18kLywgJycpO1xcbiAgcmV0dXJuIGtleTtcXG59XFxuXFxudmFyIEtleWJvYXJkID0ge1xcbiAga2V5czogZ2V0S2V5Q29kZXMoa2V5Q29kZXMpLFxcblxcbiAgLyoqXFxuICAgKiBQYXJzZXMgdGhlIChrZXlib2FyZCkgZXZlbnQgYW5kIHJldHVybnMgYSBTdHJpbmcgdGhhdCByZXByZXNlbnRzIGl0cyBrZXlcXG4gICAqIENhbiBiZSB1c2VkIGxpa2UgRm91bmRhdGlvbi5wYXJzZUtleShldmVudCkgPT09IEZvdW5kYXRpb24ua2V5cy5TUEFDRVxcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSB0aGUgZXZlbnQgZ2VuZXJhdGVkIGJ5IHRoZSBldmVudCBoYW5kbGVyXFxuICAgKiBAcmV0dXJuIFN0cmluZyBrZXkgLSBTdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSBrZXkgcHJlc3NlZFxcbiAgICovXFxuICBwYXJzZUtleTogcGFyc2VLZXksXFxuXFxuICAvKipcXG4gICAqIEhhbmRsZXMgdGhlIGdpdmVuIChrZXlib2FyZCkgZXZlbnRcXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gdGhlIGV2ZW50IGdlbmVyYXRlZCBieSB0aGUgZXZlbnQgaGFuZGxlclxcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudCAtIEZvdW5kYXRpb24gY29tcG9uZW50J3MgbmFtZSwgZS5nLiBTbGlkZXIgb3IgUmV2ZWFsXFxuICAgKiBAcGFyYW0ge09iamVjdHN9IGZ1bmN0aW9ucyAtIGNvbGxlY3Rpb24gb2YgZnVuY3Rpb25zIHRoYXQgYXJlIHRvIGJlIGV4ZWN1dGVkXFxuICAgKi9cXG4gIGhhbmRsZUtleTogZnVuY3Rpb24gaGFuZGxlS2V5KGV2ZW50LCBjb21wb25lbnQsIGZ1bmN0aW9ucykge1xcbiAgICB2YXIgY29tbWFuZExpc3QgPSBjb21tYW5kc1tjb21wb25lbnRdLFxcbiAgICAgICAga2V5Q29kZSA9IHRoaXMucGFyc2VLZXkoZXZlbnQpLFxcbiAgICAgICAgY21kcyxcXG4gICAgICAgIGNvbW1hbmQsXFxuICAgICAgICBmbjtcXG4gICAgaWYgKCFjb21tYW5kTGlzdCkgcmV0dXJuIGNvbnNvbGUud2FybignQ29tcG9uZW50IG5vdCBkZWZpbmVkIScpO1xcblxcbiAgICBpZiAodHlwZW9mIGNvbW1hbmRMaXN0Lmx0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAvLyB0aGlzIGNvbXBvbmVudCBkb2VzIG5vdCBkaWZmZXJlbnRpYXRlIGJldHdlZW4gbHRyIGFuZCBydGxcXG4gICAgICBjbWRzID0gY29tbWFuZExpc3Q7IC8vIHVzZSBwbGFpbiBsaXN0XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gbWVyZ2UgbHRyIGFuZCBydGw6IGlmIGRvY3VtZW50IGlzIHJ0bCwgcnRsIG92ZXJ3cml0ZXMgbHRyIGFuZCB2aWNlIHZlcnNhXFxuICAgICAgaWYgKE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcInJ0bFxcXCJdKSgpKSBjbWRzID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCh7fSwgY29tbWFuZExpc3QubHRyLCBjb21tYW5kTGlzdC5ydGwpO2Vsc2UgY21kcyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoe30sIGNvbW1hbmRMaXN0LnJ0bCwgY29tbWFuZExpc3QubHRyKTtcXG4gICAgfVxcblxcbiAgICBjb21tYW5kID0gY21kc1trZXlDb2RlXTtcXG4gICAgZm4gPSBmdW5jdGlvbnNbY29tbWFuZF07XFxuXFxuICAgIGlmIChmbiAmJiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAvLyBleGVjdXRlIGZ1bmN0aW9uICBpZiBleGlzdHNcXG4gICAgICB2YXIgcmV0dXJuVmFsdWUgPSBmbi5hcHBseSgpO1xcblxcbiAgICAgIGlmIChmdW5jdGlvbnMuaGFuZGxlZCB8fCB0eXBlb2YgZnVuY3Rpb25zLmhhbmRsZWQgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIC8vIGV4ZWN1dGUgZnVuY3Rpb24gd2hlbiBldmVudCB3YXMgaGFuZGxlZFxcbiAgICAgICAgZnVuY3Rpb25zLmhhbmRsZWQocmV0dXJuVmFsdWUpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBpZiAoZnVuY3Rpb25zLnVuaGFuZGxlZCB8fCB0eXBlb2YgZnVuY3Rpb25zLnVuaGFuZGxlZCA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgLy8gZXhlY3V0ZSBmdW5jdGlvbiB3aGVuIGV2ZW50IHdhcyBub3QgaGFuZGxlZFxcbiAgICAgICAgZnVuY3Rpb25zLnVuaGFuZGxlZCgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogRmluZHMgYWxsIGZvY3VzYWJsZSBlbGVtZW50cyB3aXRoaW4gdGhlIGdpdmVuIGAkZWxlbWVudGBcXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gc2VhcmNoIHdpdGhpblxcbiAgICogQHJldHVybiB7alF1ZXJ5fSAkZm9jdXNhYmxlIC0gYWxsIGZvY3VzYWJsZSBlbGVtZW50cyB3aXRoaW4gYCRlbGVtZW50YFxcbiAgICovXFxuICBmaW5kRm9jdXNhYmxlOiBmaW5kRm9jdXNhYmxlLFxcblxcbiAgLyoqXFxuICAgKiBSZXR1cm5zIHRoZSBjb21wb25lbnQgbmFtZSBuYW1lXFxuICAgKiBAcGFyYW0ge09iamVjdH0gY29tcG9uZW50IC0gRm91bmRhdGlvbiBjb21wb25lbnQsIGUuZy4gU2xpZGVyIG9yIFJldmVhbFxcbiAgICogQHJldHVybiBTdHJpbmcgY29tcG9uZW50TmFtZVxcbiAgICovXFxuICByZWdpc3RlcjogZnVuY3Rpb24gcmVnaXN0ZXIoY29tcG9uZW50TmFtZSwgY21kcykge1xcbiAgICBjb21tYW5kc1tjb21wb25lbnROYW1lXSA9IGNtZHM7XFxuICB9LFxcbiAgLy8gVE9ETzk0Mzg6IFRoZXNlIHJlZmVyZW5jZXMgdG8gS2V5Ym9hcmQgbmVlZCB0byBub3QgcmVxdWlyZSBnbG9iYWwuIFdpbGwgJ3RoaXMnIHdvcmsgaW4gdGhpcyBjb250ZXh0P1xcbiAgLy9cXG5cXG4gIC8qKlxcbiAgICogVHJhcHMgdGhlIGZvY3VzIGluIHRoZSBnaXZlbiBlbGVtZW50LlxcbiAgICogQHBhcmFtICB7alF1ZXJ5fSAkZWxlbWVudCAgalF1ZXJ5IG9iamVjdCB0byB0cmFwIHRoZSBmb3VjcyBpbnRvLlxcbiAgICovXFxuICB0cmFwRm9jdXM6IGZ1bmN0aW9uIHRyYXBGb2N1cygkZWxlbWVudCkge1xcbiAgICB2YXIgJGZvY3VzYWJsZSA9IGZpbmRGb2N1c2FibGUoJGVsZW1lbnQpLFxcbiAgICAgICAgJGZpcnN0Rm9jdXNhYmxlID0gJGZvY3VzYWJsZS5lcSgwKSxcXG4gICAgICAgICRsYXN0Rm9jdXNhYmxlID0gJGZvY3VzYWJsZS5lcSgtMSk7XFxuICAgICRlbGVtZW50Lm9uKCdrZXlkb3duLnpmLnRyYXBmb2N1cycsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgIGlmIChldmVudC50YXJnZXQgPT09ICRsYXN0Rm9jdXNhYmxlWzBdICYmIHBhcnNlS2V5KGV2ZW50KSA9PT0gJ1RBQicpIHtcXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAkZmlyc3RGb2N1c2FibGUuZm9jdXMoKTtcXG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LnRhcmdldCA9PT0gJGZpcnN0Rm9jdXNhYmxlWzBdICYmIHBhcnNlS2V5KGV2ZW50KSA9PT0gJ1NISUZUX1RBQicpIHtcXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAkbGFzdEZvY3VzYWJsZS5mb2N1cygpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9LFxcblxcbiAgLyoqXFxuICAgKiBSZWxlYXNlcyB0aGUgdHJhcHBlZCBmb2N1cyBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxcbiAgICogQHBhcmFtICB7alF1ZXJ5fSAkZWxlbWVudCAgalF1ZXJ5IG9iamVjdCB0byByZWxlYXNlIHRoZSBmb2N1cyBmb3IuXFxuICAgKi9cXG4gIHJlbGVhc2VGb2N1czogZnVuY3Rpb24gcmVsZWFzZUZvY3VzKCRlbGVtZW50KSB7XFxuICAgICRlbGVtZW50Lm9mZigna2V5ZG93bi56Zi50cmFwZm9jdXMnKTtcXG4gIH1cXG59O1xcbi8qXFxuICogQ29uc3RhbnRzIGZvciBlYXNpZXIgY29tcGFyaW5nLlxcbiAqIENhbiBiZSB1c2VkIGxpa2UgRm91bmRhdGlvbi5wYXJzZUtleShldmVudCkgPT09IEZvdW5kYXRpb24ua2V5cy5TUEFDRVxcbiAqL1xcblxcbmZ1bmN0aW9uIGdldEtleUNvZGVzKGtjcykge1xcbiAgdmFyIGsgPSB7fTtcXG5cXG4gIGZvciAodmFyIGtjIGluIGtjcykge1xcbiAgICBrW2tjc1trY11dID0ga2NzW2tjXTtcXG4gIH1cXG5cXG4gIHJldHVybiBrO1xcbn1cXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9qcy9mb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmQuanM/XCIpfSxcIi4vanMvZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnkuanNcIjpmdW5jdGlvbihtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIk1lZGlhUXVlcnlcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIE1lZGlhUXVlcnk7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGpxdWVyeSAqLyBcXFwianF1ZXJ5XFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG5cXG5cXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cXG5cXG4gLy8gRGVmYXVsdCBzZXQgb2YgbWVkaWEgcXVlcmllc1xcblxcbnZhciBkZWZhdWx0UXVlcmllcyA9IHtcXG4gICdkZWZhdWx0JzogJ29ubHkgc2NyZWVuJyxcXG4gIGxhbmRzY2FwZTogJ29ubHkgc2NyZWVuIGFuZCAob3JpZW50YXRpb246IGxhbmRzY2FwZSknLFxcbiAgcG9ydHJhaXQ6ICdvbmx5IHNjcmVlbiBhbmQgKG9yaWVudGF0aW9uOiBwb3J0cmFpdCknLFxcbiAgcmV0aW5hOiAnb25seSBzY3JlZW4gYW5kICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCcgKyAnb25seSBzY3JlZW4gYW5kIChtaW4tLW1vei1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCcgKyAnb25seSBzY3JlZW4gYW5kICgtby1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyLzEpLCcgKyAnb25seSBzY3JlZW4gYW5kIChtaW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwnICsgJ29ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDE5MmRwaSksJyArICdvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAyZHBweCknXFxufTsgLy8gbWF0Y2hNZWRpYSgpIHBvbHlmaWxsIC0gVGVzdCBhIENTUyBtZWRpYSB0eXBlL3F1ZXJ5IGluIEpTLlxcbi8vIEF1dGhvcnMgJiBjb3B5cmlnaHQoYykgMjAxMjogU2NvdHQgSmVobCwgUGF1bCBJcmlzaCwgTmljaG9sYXMgWmFrYXMsIERhdmlkIEtuaWdodC4gTUlUIGxpY2Vuc2VcXG5cXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xcblxcbndpbmRvdy5tYXRjaE1lZGlhIHx8ICh3aW5kb3cubWF0Y2hNZWRpYSA9IGZ1bmN0aW9uICgpIHtcXG4gIFxcXCJ1c2Ugc3RyaWN0XFxcIjsgLy8gRm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBtYXRjaE1lZGl1bSBhcGkgc3VjaCBhcyBJRSA5IGFuZCB3ZWJraXRcXG5cXG4gIHZhciBzdHlsZU1lZGlhID0gd2luZG93LnN0eWxlTWVkaWEgfHwgd2luZG93Lm1lZGlhOyAvLyBGb3IgdGhvc2UgdGhhdCBkb24ndCBzdXBwb3J0IG1hdGNoTWVkaXVtXFxuXFxuICBpZiAoIXN0eWxlTWVkaWEpIHtcXG4gICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKSxcXG4gICAgICAgIHNjcmlwdCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXSxcXG4gICAgICAgIGluZm8gPSBudWxsO1xcbiAgICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJztcXG4gICAgc3R5bGUuaWQgPSAnbWF0Y2htZWRpYWpzLXRlc3QnO1xcblxcbiAgICBpZiAoIXNjcmlwdCkge1xcbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHNjcmlwdC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzdHlsZSwgc2NyaXB0KTtcXG4gICAgfSAvLyAnc3R5bGUuY3VycmVudFN0eWxlJyBpcyB1c2VkIGJ5IElFIDw9IDggYW5kICd3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZScgZm9yIGFsbCBvdGhlciBicm93c2Vyc1xcblxcblxcbiAgICBpbmZvID0gJ2dldENvbXB1dGVkU3R5bGUnIGluIHdpbmRvdyAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzdHlsZSwgbnVsbCkgfHwgc3R5bGUuY3VycmVudFN0eWxlO1xcbiAgICBzdHlsZU1lZGlhID0ge1xcbiAgICAgIG1hdGNoTWVkaXVtOiBmdW5jdGlvbiBtYXRjaE1lZGl1bShtZWRpYSkge1xcbiAgICAgICAgdmFyIHRleHQgPSAnQG1lZGlhICcgKyBtZWRpYSArICd7ICNtYXRjaG1lZGlhanMtdGVzdCB7IHdpZHRoOiAxcHg7IH0gfSc7IC8vICdzdHlsZS5zdHlsZVNoZWV0JyBpcyB1c2VkIGJ5IElFIDw9IDggYW5kICdzdHlsZS50ZXh0Q29udGVudCcgZm9yIGFsbCBvdGhlciBicm93c2Vyc1xcblxcbiAgICAgICAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcXG4gICAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gdGV4dDtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gdGV4dDtcXG4gICAgICAgIH0gLy8gVGVzdCBpZiBtZWRpYSBxdWVyeSBpcyB0cnVlIG9yIGZhbHNlXFxuXFxuXFxuICAgICAgICByZXR1cm4gaW5mby53aWR0aCA9PT0gJzFweCc7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIGZ1bmN0aW9uIChtZWRpYSkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIG1hdGNoZXM6IHN0eWxlTWVkaWEubWF0Y2hNZWRpdW0obWVkaWEgfHwgJ2FsbCcpLFxcbiAgICAgIG1lZGlhOiBtZWRpYSB8fCAnYWxsJ1xcbiAgICB9O1xcbiAgfTtcXG59KCkpO1xcbi8qIGVzbGludC1lbmFibGUgKi9cXG5cXG52YXIgTWVkaWFRdWVyeSA9IHtcXG4gIHF1ZXJpZXM6IFtdLFxcbiAgY3VycmVudDogJycsXFxuXFxuICAvKipcXG4gICAqIEluaXRpYWxpemVzIHRoZSBtZWRpYSBxdWVyeSBoZWxwZXIsIGJ5IGV4dHJhY3RpbmcgdGhlIGJyZWFrcG9pbnQgbGlzdCBmcm9tIHRoZSBDU1MgYW5kIGFjdGl2YXRpbmcgdGhlIGJyZWFrcG9pbnQgd2F0Y2hlci5cXG4gICAqIEBmdW5jdGlvblxcbiAgICogQHByaXZhdGVcXG4gICAqL1xcbiAgX2luaXQ6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuICAgIHZhciAkbWV0YSA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnbWV0YS5mb3VuZGF0aW9uLW1xJyk7XFxuXFxuICAgIGlmICghJG1ldGEubGVuZ3RoKSB7XFxuICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCc8bWV0YSBjbGFzcz1cXFwiZm91bmRhdGlvbi1tcVxcXCI+JykuYXBwZW5kVG8oZG9jdW1lbnQuaGVhZCk7XFxuICAgIH1cXG5cXG4gICAgdmFyIGV4dHJhY3RlZFN0eWxlcyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnLmZvdW5kYXRpb24tbXEnKS5jc3MoJ2ZvbnQtZmFtaWx5Jyk7XFxuICAgIHZhciBuYW1lZFF1ZXJpZXM7XFxuICAgIG5hbWVkUXVlcmllcyA9IHBhcnNlU3R5bGVUb09iamVjdChleHRyYWN0ZWRTdHlsZXMpO1xcblxcbiAgICBmb3IgKHZhciBrZXkgaW4gbmFtZWRRdWVyaWVzKSB7XFxuICAgICAgaWYgKG5hbWVkUXVlcmllcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XFxuICAgICAgICBzZWxmLnF1ZXJpZXMucHVzaCh7XFxuICAgICAgICAgIG5hbWU6IGtleSxcXG4gICAgICAgICAgdmFsdWU6IFxcXCJvbmx5IHNjcmVlbiBhbmQgKG1pbi13aWR0aDogXFxcIi5jb25jYXQobmFtZWRRdWVyaWVzW2tleV0sIFxcXCIpXFxcIilcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLl9nZXRDdXJyZW50U2l6ZSgpO1xcblxcbiAgICB0aGlzLl93YXRjaGVyKCk7XFxuICB9LFxcblxcbiAgLyoqXFxuICAgKiBDaGVja3MgaWYgdGhlIHNjcmVlbiBpcyBhdCBsZWFzdCBhcyB3aWRlIGFzIGEgYnJlYWtwb2ludC5cXG4gICAqIEBmdW5jdGlvblxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNpemUgLSBOYW1lIG9mIHRoZSBicmVha3BvaW50IHRvIGNoZWNrLlxcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgYnJlYWtwb2ludCBtYXRjaGVzLCBgZmFsc2VgIGlmIGl0J3Mgc21hbGxlci5cXG4gICAqL1xcbiAgYXRMZWFzdDogZnVuY3Rpb24gYXRMZWFzdChzaXplKSB7XFxuICAgIHZhciBxdWVyeSA9IHRoaXMuZ2V0KHNpemUpO1xcblxcbiAgICBpZiAocXVlcnkpIHtcXG4gICAgICByZXR1cm4gd2luZG93Lm1hdGNoTWVkaWEocXVlcnkpLm1hdGNoZXM7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogQ2hlY2tzIGlmIHRoZSBzY3JlZW4gbWF0Y2hlcyB0byBhIGJyZWFrcG9pbnQuXFxuICAgKiBAZnVuY3Rpb25cXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzaXplIC0gTmFtZSBvZiB0aGUgYnJlYWtwb2ludCB0byBjaGVjaywgZWl0aGVyICdzbWFsbCBvbmx5JyBvciAnc21hbGwnLiBPbWl0dGluZyAnb25seScgZmFsbHMgYmFjayB0byB1c2luZyBhdExlYXN0KCkgbWV0aG9kLlxcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgYnJlYWtwb2ludCBtYXRjaGVzLCBgZmFsc2VgIGlmIGl0IGRvZXMgbm90LlxcbiAgICovXFxuICBpczogZnVuY3Rpb24gaXMoc2l6ZSkge1xcbiAgICBzaXplID0gc2l6ZS50cmltKCkuc3BsaXQoJyAnKTtcXG5cXG4gICAgaWYgKHNpemUubGVuZ3RoID4gMSAmJiBzaXplWzFdID09PSAnb25seScpIHtcXG4gICAgICBpZiAoc2l6ZVswXSA9PT0gdGhpcy5fZ2V0Q3VycmVudFNpemUoKSkgcmV0dXJuIHRydWU7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuIHRoaXMuYXRMZWFzdChzaXplWzBdKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9LFxcblxcbiAgLyoqXFxuICAgKiBHZXRzIHRoZSBtZWRpYSBxdWVyeSBvZiBhIGJyZWFrcG9pbnQuXFxuICAgKiBAZnVuY3Rpb25cXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzaXplIC0gTmFtZSBvZiB0aGUgYnJlYWtwb2ludCB0byBnZXQuXFxuICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IC0gVGhlIG1lZGlhIHF1ZXJ5IG9mIHRoZSBicmVha3BvaW50LCBvciBgbnVsbGAgaWYgdGhlIGJyZWFrcG9pbnQgZG9lc24ndCBleGlzdC5cXG4gICAqL1xcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoc2l6ZSkge1xcbiAgICBmb3IgKHZhciBpIGluIHRoaXMucXVlcmllcykge1xcbiAgICAgIGlmICh0aGlzLnF1ZXJpZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgIHZhciBxdWVyeSA9IHRoaXMucXVlcmllc1tpXTtcXG4gICAgICAgIGlmIChzaXplID09PSBxdWVyeS5uYW1lKSByZXR1cm4gcXVlcnkudmFsdWU7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBudWxsO1xcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogR2V0cyB0aGUgY3VycmVudCBicmVha3BvaW50IG5hbWUgYnkgdGVzdGluZyBldmVyeSBicmVha3BvaW50IGFuZCByZXR1cm5pbmcgdGhlIGxhc3Qgb25lIHRvIG1hdGNoICh0aGUgYmlnZ2VzdCBvbmUpLlxcbiAgICogQGZ1bmN0aW9uXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQHJldHVybnMge1N0cmluZ30gTmFtZSBvZiB0aGUgY3VycmVudCBicmVha3BvaW50LlxcbiAgICovXFxuICBfZ2V0Q3VycmVudFNpemU6IGZ1bmN0aW9uIF9nZXRDdXJyZW50U2l6ZSgpIHtcXG4gICAgdmFyIG1hdGNoZWQ7XFxuXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5xdWVyaWVzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyaWVzW2ldO1xcblxcbiAgICAgIGlmICh3aW5kb3cubWF0Y2hNZWRpYShxdWVyeS52YWx1ZSkubWF0Y2hlcykge1xcbiAgICAgICAgbWF0Y2hlZCA9IHF1ZXJ5O1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAoX3R5cGVvZihtYXRjaGVkKSA9PT0gJ29iamVjdCcpIHtcXG4gICAgICByZXR1cm4gbWF0Y2hlZC5uYW1lO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBtYXRjaGVkO1xcbiAgICB9XFxuICB9LFxcblxcbiAgLyoqXFxuICAgKiBBY3RpdmF0ZXMgdGhlIGJyZWFrcG9pbnQgd2F0Y2hlciwgd2hpY2ggZmlyZXMgYW4gZXZlbnQgb24gdGhlIHdpbmRvdyB3aGVuZXZlciB0aGUgYnJlYWtwb2ludCBjaGFuZ2VzLlxcbiAgICogQGZ1bmN0aW9uXFxuICAgKiBAcHJpdmF0ZVxcbiAgICovXFxuICBfd2F0Y2hlcjogZnVuY3Rpb24gX3dhdGNoZXIoKSB7XFxuICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLm9mZigncmVzaXplLnpmLm1lZGlhcXVlcnknKS5vbigncmVzaXplLnpmLm1lZGlhcXVlcnknLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIG5ld1NpemUgPSBfdGhpcy5fZ2V0Q3VycmVudFNpemUoKSxcXG4gICAgICAgICAgY3VycmVudFNpemUgPSBfdGhpcy5jdXJyZW50O1xcblxcbiAgICAgIGlmIChuZXdTaXplICE9PSBjdXJyZW50U2l6ZSkge1xcbiAgICAgICAgLy8gQ2hhbmdlIHRoZSBjdXJyZW50IG1lZGlhIHF1ZXJ5XFxuICAgICAgICBfdGhpcy5jdXJyZW50ID0gbmV3U2l6ZTsgLy8gQnJvYWRjYXN0IHRoZSBtZWRpYSBxdWVyeSBjaGFuZ2Ugb24gdGhlIHdpbmRvd1xcblxcbiAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykudHJpZ2dlcignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgW25ld1NpemUsIGN1cnJlbnRTaXplXSk7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH1cXG59OyAvLyBUaGFuayB5b3U6IGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvcXVlcnktc3RyaW5nXFxuXFxuZnVuY3Rpb24gcGFyc2VTdHlsZVRvT2JqZWN0KHN0cikge1xcbiAgdmFyIHN0eWxlT2JqZWN0ID0ge307XFxuXFxuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcXG4gICAgcmV0dXJuIHN0eWxlT2JqZWN0O1xcbiAgfVxcblxcbiAgc3RyID0gc3RyLnRyaW0oKS5zbGljZSgxLCAtMSk7IC8vIGJyb3dzZXJzIHJlLXF1b3RlIHN0cmluZyBzdHlsZSB2YWx1ZXNcXG5cXG4gIGlmICghc3RyKSB7XFxuICAgIHJldHVybiBzdHlsZU9iamVjdDtcXG4gIH1cXG5cXG4gIHN0eWxlT2JqZWN0ID0gc3RyLnNwbGl0KCcmJykucmVkdWNlKGZ1bmN0aW9uIChyZXQsIHBhcmFtKSB7XFxuICAgIHZhciBwYXJ0cyA9IHBhcmFtLnJlcGxhY2UoL1xcXFwrL2csICcgJykuc3BsaXQoJz0nKTtcXG4gICAgdmFyIGtleSA9IHBhcnRzWzBdO1xcbiAgICB2YXIgdmFsID0gcGFydHNbMV07XFxuICAgIGtleSA9IGRlY29kZVVSSUNvbXBvbmVudChrZXkpOyAvLyBtaXNzaW5nIGA9YCBzaG91bGQgYmUgYG51bGxgOlxcbiAgICAvLyBodHRwOi8vdzMub3JnL1RSLzIwMTIvV0QtdXJsLTIwMTIwNTI0LyNjb2xsZWN0LXVybC1wYXJhbWV0ZXJzXFxuXFxuICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IGRlY29kZVVSSUNvbXBvbmVudCh2YWwpO1xcblxcbiAgICBpZiAoIXJldC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XFxuICAgICAgcmV0W2tleV0gPSB2YWw7XFxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXRba2V5XSkpIHtcXG4gICAgICByZXRba2V5XS5wdXNoKHZhbCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0W2tleV0gPSBbcmV0W2tleV0sIHZhbF07XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHJldDtcXG4gIH0sIHt9KTtcXG4gIHJldHVybiBzdHlsZU9iamVjdDtcXG59XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnkuanM/XCIpfSxcIi4vanMvZm91bmRhdGlvbi51dGlsLm1vdGlvbi5qc1wiOmZ1bmN0aW9uKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiTW92ZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTW92ZTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiTW90aW9uXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBNb3Rpb247IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGpxdWVyeSAqLyBcXFwianF1ZXJ5XFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUudXRpbHMgKi8gXFxcIi4vanMvZm91bmRhdGlvbi5jb3JlLnV0aWxzLmpzXFxcIik7XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogTW90aW9uIG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24ubW90aW9uXFxuICovXFxuXFxudmFyIGluaXRDbGFzc2VzID0gWydtdWktZW50ZXInLCAnbXVpLWxlYXZlJ107XFxudmFyIGFjdGl2ZUNsYXNzZXMgPSBbJ211aS1lbnRlci1hY3RpdmUnLCAnbXVpLWxlYXZlLWFjdGl2ZSddO1xcbnZhciBNb3Rpb24gPSB7XFxuICBhbmltYXRlSW46IGZ1bmN0aW9uIGFuaW1hdGVJbihlbGVtZW50LCBhbmltYXRpb24sIGNiKSB7XFxuICAgIGFuaW1hdGUodHJ1ZSwgZWxlbWVudCwgYW5pbWF0aW9uLCBjYik7XFxuICB9LFxcbiAgYW5pbWF0ZU91dDogZnVuY3Rpb24gYW5pbWF0ZU91dChlbGVtZW50LCBhbmltYXRpb24sIGNiKSB7XFxuICAgIGFuaW1hdGUoZmFsc2UsIGVsZW1lbnQsIGFuaW1hdGlvbiwgY2IpO1xcbiAgfVxcbn07XFxuXFxuZnVuY3Rpb24gTW92ZShkdXJhdGlvbiwgZWxlbSwgZm4pIHtcXG4gIHZhciBhbmltLFxcbiAgICAgIHByb2csXFxuICAgICAgc3RhcnQgPSBudWxsOyAvLyBjb25zb2xlLmxvZygnY2FsbGVkJyk7XFxuXFxuICBpZiAoZHVyYXRpb24gPT09IDApIHtcXG4gICAgZm4uYXBwbHkoZWxlbSk7XFxuICAgIGVsZW0udHJpZ2dlcignZmluaXNoZWQuemYuYW5pbWF0ZScsIFtlbGVtXSkudHJpZ2dlckhhbmRsZXIoJ2ZpbmlzaGVkLnpmLmFuaW1hdGUnLCBbZWxlbV0pO1xcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICBmdW5jdGlvbiBtb3ZlKHRzKSB7XFxuICAgIGlmICghc3RhcnQpIHN0YXJ0ID0gdHM7IC8vIGNvbnNvbGUubG9nKHN0YXJ0LCB0cyk7XFxuXFxuICAgIHByb2cgPSB0cyAtIHN0YXJ0O1xcbiAgICBmbi5hcHBseShlbGVtKTtcXG5cXG4gICAgaWYgKHByb2cgPCBkdXJhdGlvbikge1xcbiAgICAgIGFuaW0gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1vdmUsIGVsZW0pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShhbmltKTtcXG4gICAgICBlbGVtLnRyaWdnZXIoJ2ZpbmlzaGVkLnpmLmFuaW1hdGUnLCBbZWxlbV0pLnRyaWdnZXJIYW5kbGVyKCdmaW5pc2hlZC56Zi5hbmltYXRlJywgW2VsZW1dKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgYW5pbSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobW92ZSk7XFxufVxcbi8qKlxcbiAqIEFuaW1hdGVzIGFuIGVsZW1lbnQgaW4gb3Igb3V0IHVzaW5nIGEgQ1NTIHRyYW5zaXRpb24gY2xhc3MuXFxuICogQGZ1bmN0aW9uXFxuICogQHByaXZhdGVcXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzSW4gLSBEZWZpbmVzIGlmIHRoZSBhbmltYXRpb24gaXMgaW4gb3Igb3V0LlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9yIEhUTUwgb2JqZWN0IHRvIGFuaW1hdGUuXFxuICogQHBhcmFtIHtTdHJpbmd9IGFuaW1hdGlvbiAtIENTUyBjbGFzcyB0byB1c2UuXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBDYWxsYmFjayB0byBydW4gd2hlbiBhbmltYXRpb24gaXMgZmluaXNoZWQuXFxuICovXFxuXFxuXFxuZnVuY3Rpb24gYW5pbWF0ZShpc0luLCBlbGVtZW50LCBhbmltYXRpb24sIGNiKSB7XFxuICBlbGVtZW50ID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGVsZW1lbnQpLmVxKDApO1xcbiAgaWYgKCFlbGVtZW50Lmxlbmd0aCkgcmV0dXJuO1xcbiAgdmFyIGluaXRDbGFzcyA9IGlzSW4gPyBpbml0Q2xhc3Nlc1swXSA6IGluaXRDbGFzc2VzWzFdO1xcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNJbiA/IGFjdGl2ZUNsYXNzZXNbMF0gOiBhY3RpdmVDbGFzc2VzWzFdOyAvLyBTZXQgdXAgdGhlIGFuaW1hdGlvblxcblxcbiAgcmVzZXQoKTtcXG4gIGVsZW1lbnQuYWRkQ2xhc3MoYW5pbWF0aW9uKS5jc3MoJ3RyYW5zaXRpb24nLCAnbm9uZScpO1xcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcXG4gICAgZWxlbWVudC5hZGRDbGFzcyhpbml0Q2xhc3MpO1xcbiAgICBpZiAoaXNJbikgZWxlbWVudC5zaG93KCk7XFxuICB9KTsgLy8gU3RhcnQgdGhlIGFuaW1hdGlvblxcblxcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcXG4gICAgZWxlbWVudFswXS5vZmZzZXRXaWR0aDtcXG4gICAgZWxlbWVudC5jc3MoJ3RyYW5zaXRpb24nLCAnJykuYWRkQ2xhc3MoYWN0aXZlQ2xhc3MpO1xcbiAgfSk7IC8vIENsZWFuIHVwIHRoZSBhbmltYXRpb24gd2hlbiBpdCBmaW5pc2hlc1xcblxcbiAgZWxlbWVudC5vbmUoT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwidHJhbnNpdGlvbmVuZFxcXCJdKShlbGVtZW50KSwgZmluaXNoKTsgLy8gSGlkZXMgdGhlIGVsZW1lbnQgKGZvciBvdXQgYW5pbWF0aW9ucyksIHJlc2V0cyB0aGUgZWxlbWVudCwgYW5kIHJ1bnMgYSBjYWxsYmFja1xcblxcbiAgZnVuY3Rpb24gZmluaXNoKCkge1xcbiAgICBpZiAoIWlzSW4pIGVsZW1lbnQuaGlkZSgpO1xcbiAgICByZXNldCgpO1xcbiAgICBpZiAoY2IpIGNiLmFwcGx5KGVsZW1lbnQpO1xcbiAgfSAvLyBSZXNldHMgdHJhbnNpdGlvbnMgYW5kIHJlbW92ZXMgbW90aW9uLXNwZWNpZmljIGNsYXNzZXNcXG5cXG5cXG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xcbiAgICBlbGVtZW50WzBdLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IDA7XFxuICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcIlxcXCIuY29uY2F0KGluaXRDbGFzcywgXFxcIiBcXFwiKS5jb25jYXQoYWN0aXZlQ2xhc3MsIFxcXCIgXFxcIikuY29uY2F0KGFuaW1hdGlvbikpO1xcbiAgfVxcbn1cXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9qcy9mb3VuZGF0aW9uLnV0aWwubW90aW9uLmpzP1wiKX0sXCIuL2pzL2ZvdW5kYXRpb24udXRpbC5uZXN0LmpzXCI6ZnVuY3Rpb24obW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJOZXN0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBOZXN0OyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBqcXVlcnkgKi8gXFxcImpxdWVyeVxcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuXFxuXFxuXFxudmFyIE5lc3QgPSB7XFxuICBGZWF0aGVyOiBmdW5jdGlvbiBGZWF0aGVyKG1lbnUpIHtcXG4gICAgdmFyIHR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICd6Zic7XFxuICAgIG1lbnUuYXR0cigncm9sZScsICdtZW51YmFyJyk7XFxuICAgIHZhciBpdGVtcyA9IG1lbnUuZmluZCgnbGknKS5hdHRyKHtcXG4gICAgICAncm9sZSc6ICdtZW51aXRlbSdcXG4gICAgfSksXFxuICAgICAgICBzdWJNZW51Q2xhc3MgPSBcXFwiaXMtXFxcIi5jb25jYXQodHlwZSwgXFxcIi1zdWJtZW51XFxcIiksXFxuICAgICAgICBzdWJJdGVtQ2xhc3MgPSBcXFwiXFxcIi5jb25jYXQoc3ViTWVudUNsYXNzLCBcXFwiLWl0ZW1cXFwiKSxcXG4gICAgICAgIGhhc1N1YkNsYXNzID0gXFxcImlzLVxcXCIuY29uY2F0KHR5cGUsIFxcXCItc3VibWVudS1wYXJlbnRcXFwiKSxcXG4gICAgICAgIGFwcGx5QXJpYSA9IHR5cGUgIT09ICdhY2NvcmRpb24nOyAvLyBBY2NvcmRpb25zIGhhbmRsZSB0aGVpciBvd24gQVJJQSBhdHRyaXV0ZXMuXFxuXFxuICAgIGl0ZW1zLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciAkaXRlbSA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKSxcXG4gICAgICAgICAgJHN1YiA9ICRpdGVtLmNoaWxkcmVuKCd1bCcpO1xcblxcbiAgICAgIGlmICgkc3ViLmxlbmd0aCkge1xcbiAgICAgICAgJGl0ZW0uYWRkQ2xhc3MoaGFzU3ViQ2xhc3MpO1xcbiAgICAgICAgJHN1Yi5hZGRDbGFzcyhcXFwic3VibWVudSBcXFwiLmNvbmNhdChzdWJNZW51Q2xhc3MpKS5hdHRyKHtcXG4gICAgICAgICAgJ2RhdGEtc3VibWVudSc6ICcnXFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIGlmIChhcHBseUFyaWEpIHtcXG4gICAgICAgICAgJGl0ZW0uYXR0cih7XFxuICAgICAgICAgICAgJ2FyaWEtaGFzcG9wdXAnOiB0cnVlLFxcbiAgICAgICAgICAgICdhcmlhLWxhYmVsJzogJGl0ZW0uY2hpbGRyZW4oJ2E6Zmlyc3QnKS50ZXh0KClcXG4gICAgICAgICAgfSk7IC8vIE5vdGU6ICBEcmlsbGRvd25zIGJlaGF2ZSBkaWZmZXJlbnRseSBpbiBob3cgdGhleSBoaWRlLCBhbmQgc28gbmVlZFxcbiAgICAgICAgICAvLyBhZGRpdGlvbmFsIGF0dHJpYnV0ZXMuICBXZSBzaG91bGQgbG9vayBpZiB0aGlzIHBvc3NpYmx5IG92ZXItZ2VuZXJhbGl6ZWRcXG4gICAgICAgICAgLy8gdXRpbGl0eSAoTmVzdCkgaXMgYXBwcm9wcmlhdGUgd2hlbiB3ZSByZXdvcmsgbWVudXMgaW4gNi40XFxuXFxuICAgICAgICAgIGlmICh0eXBlID09PSAnZHJpbGxkb3duJykge1xcbiAgICAgICAgICAgICRpdGVtLmF0dHIoe1xcbiAgICAgICAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBmYWxzZVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICAkc3ViLmFkZENsYXNzKFxcXCJzdWJtZW51IFxcXCIuY29uY2F0KHN1Yk1lbnVDbGFzcykpLmF0dHIoe1xcbiAgICAgICAgICAnZGF0YS1zdWJtZW51JzogJycsXFxuICAgICAgICAgICdyb2xlJzogJ21lbnViYXInXFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIGlmICh0eXBlID09PSAnZHJpbGxkb3duJykge1xcbiAgICAgICAgICAkc3ViLmF0dHIoe1xcbiAgICAgICAgICAgICdhcmlhLWhpZGRlbic6IHRydWVcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmICgkaXRlbS5wYXJlbnQoJ1tkYXRhLXN1Ym1lbnVdJykubGVuZ3RoKSB7XFxuICAgICAgICAkaXRlbS5hZGRDbGFzcyhcXFwiaXMtc3VibWVudS1pdGVtIFxcXCIuY29uY2F0KHN1Ykl0ZW1DbGFzcykpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICAgIHJldHVybjtcXG4gIH0sXFxuICBCdXJuOiBmdW5jdGlvbiBCdXJuKG1lbnUsIHR5cGUpIHtcXG4gICAgdmFyIC8vaXRlbXMgPSBtZW51LmZpbmQoJ2xpJyksXFxuICAgIHN1Yk1lbnVDbGFzcyA9IFxcXCJpcy1cXFwiLmNvbmNhdCh0eXBlLCBcXFwiLXN1Ym1lbnVcXFwiKSxcXG4gICAgICAgIHN1Ykl0ZW1DbGFzcyA9IFxcXCJcXFwiLmNvbmNhdChzdWJNZW51Q2xhc3MsIFxcXCItaXRlbVxcXCIpLFxcbiAgICAgICAgaGFzU3ViQ2xhc3MgPSBcXFwiaXMtXFxcIi5jb25jYXQodHlwZSwgXFxcIi1zdWJtZW51LXBhcmVudFxcXCIpO1xcbiAgICBtZW51LmZpbmQoJz5saSwgPiBsaSA+IHVsLCAubWVudSwgLm1lbnUgPiBsaSwgW2RhdGEtc3VibWVudV0gPiBsaScpLnJlbW92ZUNsYXNzKFxcXCJcXFwiLmNvbmNhdChzdWJNZW51Q2xhc3MsIFxcXCIgXFxcIikuY29uY2F0KHN1Ykl0ZW1DbGFzcywgXFxcIiBcXFwiKS5jb25jYXQoaGFzU3ViQ2xhc3MsIFxcXCIgaXMtc3VibWVudS1pdGVtIHN1Ym1lbnUgaXMtYWN0aXZlXFxcIikpLnJlbW92ZUF0dHIoJ2RhdGEtc3VibWVudScpLmNzcygnZGlzcGxheScsICcnKTtcXG4gIH1cXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL2pzL2ZvdW5kYXRpb24udXRpbC5uZXN0LmpzP1wiKX0sXCIuL2pzL2ZvdW5kYXRpb24udXRpbC50aW1lci5qc1wiOmZ1bmN0aW9uKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiVGltZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRpbWVyOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBqcXVlcnkgKi8gXFxcImpxdWVyeVxcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuXFxuXFxuXFxuXFxuZnVuY3Rpb24gVGltZXIoZWxlbSwgb3B0aW9ucywgY2IpIHtcXG4gIHZhciBfdGhpcyA9IHRoaXMsXFxuICAgICAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uLFxcbiAgICAgIC8vb3B0aW9ucyBpcyBhbiBvYmplY3QgZm9yIGVhc2lseSBhZGRpbmcgZmVhdHVyZXMgbGF0ZXIuXFxuICBuYW1lU3BhY2UgPSBPYmplY3Qua2V5cyhlbGVtLmRhdGEoKSlbMF0gfHwgJ3RpbWVyJyxcXG4gICAgICByZW1haW4gPSAtMSxcXG4gICAgICBzdGFydCxcXG4gICAgICB0aW1lcjtcXG5cXG4gIHRoaXMuaXNQYXVzZWQgPSBmYWxzZTtcXG5cXG4gIHRoaXMucmVzdGFydCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgcmVtYWluID0gLTE7XFxuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XFxuICAgIHRoaXMuc3RhcnQoKTtcXG4gIH07XFxuXFxuICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xcbiAgICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7IC8vIGlmKCFlbGVtLmRhdGEoJ3BhdXNlZCcpKXsgcmV0dXJuIGZhbHNlOyB9Ly9tYXliZSBpbXBsZW1lbnQgdGhpcyBzYW5pdHkgY2hlY2sgaWYgdXNlZCBmb3Igb3RoZXIgdGhpbmdzLlxcblxcbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xcbiAgICByZW1haW4gPSByZW1haW4gPD0gMCA/IGR1cmF0aW9uIDogcmVtYWluO1xcbiAgICBlbGVtLmRhdGEoJ3BhdXNlZCcsIGZhbHNlKTtcXG4gICAgc3RhcnQgPSBEYXRlLm5vdygpO1xcbiAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgIGlmIChvcHRpb25zLmluZmluaXRlKSB7XFxuICAgICAgICBfdGhpcy5yZXN0YXJ0KCk7IC8vcmVydW4gdGhlIHRpbWVyLlxcblxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoY2IgJiYgdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICBjYigpO1xcbiAgICAgIH1cXG4gICAgfSwgcmVtYWluKTtcXG4gICAgZWxlbS50cmlnZ2VyKFxcXCJ0aW1lcnN0YXJ0LnpmLlxcXCIuY29uY2F0KG5hbWVTcGFjZSkpO1xcbiAgfTtcXG5cXG4gIHRoaXMucGF1c2UgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHRoaXMuaXNQYXVzZWQgPSB0cnVlOyAvL2lmKGVsZW0uZGF0YSgncGF1c2VkJykpeyByZXR1cm4gZmFsc2U7IH0vL21heWJlIGltcGxlbWVudCB0aGlzIHNhbml0eSBjaGVjayBpZiB1c2VkIGZvciBvdGhlciB0aGluZ3MuXFxuXFxuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XFxuICAgIGVsZW0uZGF0YSgncGF1c2VkJywgdHJ1ZSk7XFxuICAgIHZhciBlbmQgPSBEYXRlLm5vdygpO1xcbiAgICByZW1haW4gPSByZW1haW4gLSAoZW5kIC0gc3RhcnQpO1xcbiAgICBlbGVtLnRyaWdnZXIoXFxcInRpbWVycGF1c2VkLnpmLlxcXCIuY29uY2F0KG5hbWVTcGFjZSkpO1xcbiAgfTtcXG59XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi51dGlsLnRpbWVyLmpzP1wiKX0sXCIuL2pzL2ZvdW5kYXRpb24udXRpbC50b3VjaC5qc1wiOmZ1bmN0aW9uKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiVG91Y2hcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRvdWNoOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBqcXVlcnkgKi8gXFxcImpxdWVyeVxcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXG4vLyoqV29yayBpbnNwaXJlZCBieSBtdWx0aXBsZSBqcXVlcnkgc3dpcGUgcGx1Z2lucyoqXFxuLy8qKkRvbmUgYnkgWW9oYWkgQXJhcmF0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKlxcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXG5cXG52YXIgVG91Y2ggPSB7fTtcXG52YXIgc3RhcnRQb3NYLFxcbiAgICBzdGFydFBvc1ksXFxuICAgIHN0YXJ0VGltZSxcXG4gICAgZWxhcHNlZFRpbWUsXFxuICAgIHN0YXJ0RXZlbnQsXFxuICAgIGlzTW92aW5nID0gZmFsc2UsXFxuICAgIGRpZE1vdmVkID0gZmFsc2U7XFxuXFxuZnVuY3Rpb24gb25Ub3VjaEVuZChlKSB7XFxuICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlKTtcXG4gIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblRvdWNoRW5kKTsgLy8gSWYgdGhlIHRvdWNoIGRpZCBub3QgbW92ZSwgY29uc2lkZXIgaXQgYXMgYSBcXFwidGFwXFxcIlxcblxcbiAgaWYgKCFkaWRNb3ZlZCkge1xcbiAgICB2YXIgdGFwRXZlbnQgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuRXZlbnQoJ3RhcCcsIHN0YXJ0RXZlbnQgfHwgZSk7XFxuICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS50cmlnZ2VyKHRhcEV2ZW50KTtcXG4gIH1cXG5cXG4gIHN0YXJ0RXZlbnQgPSBudWxsO1xcbiAgaXNNb3ZpbmcgPSBmYWxzZTtcXG4gIGRpZE1vdmVkID0gZmFsc2U7XFxufVxcblxcbmZ1bmN0aW9uIG9uVG91Y2hNb3ZlKGUpIHtcXG4gIGlmIChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuc3BvdFN3aXBlLnByZXZlbnREZWZhdWx0KSB7XFxuICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gIH1cXG5cXG4gIGlmIChpc01vdmluZykge1xcbiAgICB2YXIgeCA9IGUudG91Y2hlc1swXS5wYWdlWDtcXG4gICAgdmFyIHkgPSBlLnRvdWNoZXNbMF0ucGFnZVk7XFxuICAgIHZhciBkeCA9IHN0YXJ0UG9zWCAtIHg7XFxuICAgIHZhciBkeSA9IHN0YXJ0UG9zWSAtIHk7XFxuICAgIHZhciBkaXI7XFxuICAgIGRpZE1vdmVkID0gdHJ1ZTtcXG4gICAgZWxhcHNlZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VGltZTtcXG5cXG4gICAgaWYgKE1hdGguYWJzKGR4KSA+PSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuc3BvdFN3aXBlLm1vdmVUaHJlc2hvbGQgJiYgZWxhcHNlZFRpbWUgPD0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLnNwb3RTd2lwZS50aW1lVGhyZXNob2xkKSB7XFxuICAgICAgZGlyID0gZHggPiAwID8gJ2xlZnQnIDogJ3JpZ2h0JztcXG4gICAgfSAvLyBlbHNlIGlmKE1hdGguYWJzKGR5KSA+PSAkLnNwb3RTd2lwZS5tb3ZlVGhyZXNob2xkICYmIGVsYXBzZWRUaW1lIDw9ICQuc3BvdFN3aXBlLnRpbWVUaHJlc2hvbGQpIHtcXG4gICAgLy8gICBkaXIgPSBkeSA+IDAgPyAnZG93bicgOiAndXAnO1xcbiAgICAvLyB9XFxuXFxuXFxuICAgIGlmIChkaXIpIHtcXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgb25Ub3VjaEVuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS50cmlnZ2VyKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5FdmVudCgnc3dpcGUnLCBlKSwgZGlyKS50cmlnZ2VyKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5FdmVudChcXFwic3dpcGVcXFwiLmNvbmNhdChkaXIpLCBlKSk7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGUpIHtcXG4gIGlmIChlLnRvdWNoZXMubGVuZ3RoID09IDEpIHtcXG4gICAgc3RhcnRQb3NYID0gZS50b3VjaGVzWzBdLnBhZ2VYO1xcbiAgICBzdGFydFBvc1kgPSBlLnRvdWNoZXNbMF0ucGFnZVk7XFxuICAgIHN0YXJ0RXZlbnQgPSBlO1xcbiAgICBpc01vdmluZyA9IHRydWU7XFxuICAgIGRpZE1vdmVkID0gZmFsc2U7XFxuICAgIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlLCBmYWxzZSk7XFxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblRvdWNoRW5kLCBmYWxzZSk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGluaXQoKSB7XFxuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgJiYgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0LCBmYWxzZSk7XFxufVxcblxcbmZ1bmN0aW9uIHRlYXJkb3duKCkge1xcbiAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0KTtcXG59XFxuXFxudmFyIFNwb3RTd2lwZSA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uICgpIHtcXG4gIGZ1bmN0aW9uIFNwb3RTd2lwZSgkKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTcG90U3dpcGUpO1xcblxcbiAgICB0aGlzLnZlcnNpb24gPSAnMS4wLjAnO1xcbiAgICB0aGlzLmVuYWJsZWQgPSAnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XFxuICAgIHRoaXMucHJldmVudERlZmF1bHQgPSBmYWxzZTtcXG4gICAgdGhpcy5tb3ZlVGhyZXNob2xkID0gNzU7XFxuICAgIHRoaXMudGltZVRocmVzaG9sZCA9IDIwMDtcXG4gICAgdGhpcy4kID0gJDtcXG5cXG4gICAgdGhpcy5faW5pdCgpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKFNwb3RTd2lwZSwgW3tcXG4gICAga2V5OiBcXFwiX2luaXRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgdmFyICQgPSB0aGlzLiQ7XFxuICAgICAgJC5ldmVudC5zcGVjaWFsLnN3aXBlID0ge1xcbiAgICAgICAgc2V0dXA6IGluaXRcXG4gICAgICB9O1xcbiAgICAgICQuZXZlbnQuc3BlY2lhbC50YXAgPSB7XFxuICAgICAgICBzZXR1cDogaW5pdFxcbiAgICAgIH07XFxuICAgICAgJC5lYWNoKFsnbGVmdCcsICd1cCcsICdkb3duJywgJ3JpZ2h0J10sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICQuZXZlbnQuc3BlY2lhbFtcXFwic3dpcGVcXFwiLmNvbmNhdCh0aGlzKV0gPSB7XFxuICAgICAgICAgIHNldHVwOiBmdW5jdGlvbiBzZXR1cCgpIHtcXG4gICAgICAgICAgICAkKHRoaXMpLm9uKCdzd2lwZScsICQubm9vcCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH07XFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBTcG90U3dpcGU7XFxufSgpO1xcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxuICogQXMgZmFyIGFzIEkgY2FuIHRlbGwsIGJvdGggc2V0dXBTcG90U3dpcGUgYW5kICAgICpcXG4gKiBzZXR1cFRvdWNoSGFuZGxlciBzaG91bGQgYmUgaWRlbXBvdGVudCwgICAgICAgICAgKlxcbiAqIGJlY2F1c2UgdGhleSBkaXJlY3RseSByZXBsYWNlIGZ1bmN0aW9ucyAmICAgICAgICAqXFxuICogdmFsdWVzLCBhbmQgZG8gbm90IGFkZCBldmVudCBoYW5kbGVycyBkaXJlY3RseS4gICpcXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG5cXG5cXG5Ub3VjaC5zZXR1cFNwb3RTd2lwZSA9IGZ1bmN0aW9uICgkKSB7XFxuICAkLnNwb3RTd2lwZSA9IG5ldyBTcG90U3dpcGUoJCk7XFxufTtcXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcbiAqIE1ldGhvZCBmb3IgYWRkaW5nIHBzZXVkbyBkcmFnIGV2ZW50cyB0byBlbGVtZW50cyAqXFxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG5cXG5cXG5Ub3VjaC5zZXR1cFRvdWNoSGFuZGxlciA9IGZ1bmN0aW9uICgkKSB7XFxuICAkLmZuLmFkZFRvdWNoID0gZnVuY3Rpb24gKCkge1xcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGksIGVsKSB7XFxuICAgICAgJChlbCkuYmluZCgndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgIC8vd2UgcGFzcyB0aGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0IGJlY2F1c2UgdGhlIGpRdWVyeSBldmVudFxcbiAgICAgICAgLy9vYmplY3QgaXMgbm9ybWFsaXplZCB0byB3M2Mgc3BlY3MgYW5kIGRvZXMgbm90IHByb3ZpZGUgdGhlIFRvdWNoTGlzdFxcbiAgICAgICAgaGFuZGxlVG91Y2goZXZlbnQpO1xcbiAgICAgIH0pO1xcbiAgICB9KTtcXG5cXG4gICAgdmFyIGhhbmRsZVRvdWNoID0gZnVuY3Rpb24gaGFuZGxlVG91Y2goZXZlbnQpIHtcXG4gICAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxcbiAgICAgICAgICBmaXJzdCA9IHRvdWNoZXNbMF0sXFxuICAgICAgICAgIGV2ZW50VHlwZXMgPSB7XFxuICAgICAgICB0b3VjaHN0YXJ0OiAnbW91c2Vkb3duJyxcXG4gICAgICAgIHRvdWNobW92ZTogJ21vdXNlbW92ZScsXFxuICAgICAgICB0b3VjaGVuZDogJ21vdXNldXAnXFxuICAgICAgfSxcXG4gICAgICAgICAgdHlwZSA9IGV2ZW50VHlwZXNbZXZlbnQudHlwZV0sXFxuICAgICAgICAgIHNpbXVsYXRlZEV2ZW50O1xcblxcbiAgICAgIGlmICgnTW91c2VFdmVudCcgaW4gd2luZG93ICYmIHR5cGVvZiB3aW5kb3cuTW91c2VFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgc2ltdWxhdGVkRXZlbnQgPSBuZXcgd2luZG93Lk1vdXNlRXZlbnQodHlwZSwge1xcbiAgICAgICAgICAnYnViYmxlcyc6IHRydWUsXFxuICAgICAgICAgICdjYW5jZWxhYmxlJzogdHJ1ZSxcXG4gICAgICAgICAgJ3NjcmVlblgnOiBmaXJzdC5zY3JlZW5YLFxcbiAgICAgICAgICAnc2NyZWVuWSc6IGZpcnN0LnNjcmVlblksXFxuICAgICAgICAgICdjbGllbnRYJzogZmlyc3QuY2xpZW50WCxcXG4gICAgICAgICAgJ2NsaWVudFknOiBmaXJzdC5jbGllbnRZXFxuICAgICAgICB9KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc2ltdWxhdGVkRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudCcpO1xcbiAgICAgICAgc2ltdWxhdGVkRXZlbnQuaW5pdE1vdXNlRXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSwgd2luZG93LCAxLCBmaXJzdC5zY3JlZW5YLCBmaXJzdC5zY3JlZW5ZLCBmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMFxcbiAgICAgICAgLypsZWZ0Ki9cXG4gICAgICAgICwgbnVsbCk7XFxuICAgICAgfVxcblxcbiAgICAgIGZpcnN0LnRhcmdldC5kaXNwYXRjaEV2ZW50KHNpbXVsYXRlZEV2ZW50KTtcXG4gICAgfTtcXG4gIH07XFxufTtcXG5cXG5Ub3VjaC5pbml0ID0gZnVuY3Rpb24gKCQpIHtcXG4gIGlmICh0eXBlb2YgJC5zcG90U3dpcGUgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgIFRvdWNoLnNldHVwU3BvdFN3aXBlKCQpO1xcbiAgICBUb3VjaC5zZXR1cFRvdWNoSGFuZGxlcigkKTtcXG4gIH1cXG59O1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL2pzL2ZvdW5kYXRpb24udXRpbC50b3VjaC5qcz9cIil9LFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnMuanNcIjpmdW5jdGlvbihtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlRyaWdnZXJzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUcmlnZ2VyczsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganF1ZXJ5ICovIFxcXCJqcXVlcnlcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uY29yZS51dGlscyAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUudXRpbHMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF9tb3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi51dGlsLm1vdGlvbiAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwubW90aW9uLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuXFxuXFxuXFxuXFxudmFyIE11dGF0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgcHJlZml4ZXMgPSBbJ1dlYktpdCcsICdNb3onLCAnTycsICdNcycsICcnXTtcXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgaWYgKFxcXCJcXFwiLmNvbmNhdChwcmVmaXhlc1tpXSwgXFxcIk11dGF0aW9uT2JzZXJ2ZXJcXFwiKSBpbiB3aW5kb3cpIHtcXG4gICAgICByZXR1cm4gd2luZG93W1xcXCJcXFwiLmNvbmNhdChwcmVmaXhlc1tpXSwgXFxcIk11dGF0aW9uT2JzZXJ2ZXJcXFwiKV07XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBmYWxzZTtcXG59KCk7XFxuXFxudmFyIHRyaWdnZXJzID0gZnVuY3Rpb24gdHJpZ2dlcnMoZWwsIHR5cGUpIHtcXG4gIGVsLmRhdGEodHlwZSkuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xcbiAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoXFxcIiNcXFwiLmNvbmNhdChpZCkpW3R5cGUgPT09ICdjbG9zZScgPyAndHJpZ2dlcicgOiAndHJpZ2dlckhhbmRsZXInXShcXFwiXFxcIi5jb25jYXQodHlwZSwgXFxcIi56Zi50cmlnZ2VyXFxcIiksIFtlbF0pO1xcbiAgfSk7XFxufTtcXG5cXG52YXIgVHJpZ2dlcnMgPSB7XFxuICBMaXN0ZW5lcnM6IHtcXG4gICAgQmFzaWM6IHt9LFxcbiAgICBHbG9iYWw6IHt9XFxuICB9LFxcbiAgSW5pdGlhbGl6ZXJzOiB7fVxcbn07XFxuVHJpZ2dlcnMuTGlzdGVuZXJzLkJhc2ljID0ge1xcbiAgb3Blbkxpc3RlbmVyOiBmdW5jdGlvbiBvcGVuTGlzdGVuZXIoKSB7XFxuICAgIHRyaWdnZXJzKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKSwgJ29wZW4nKTtcXG4gIH0sXFxuICBjbG9zZUxpc3RlbmVyOiBmdW5jdGlvbiBjbG9zZUxpc3RlbmVyKCkge1xcbiAgICB2YXIgaWQgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykuZGF0YSgnY2xvc2UnKTtcXG5cXG4gICAgaWYgKGlkKSB7XFxuICAgICAgdHJpZ2dlcnMoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLCAnY2xvc2UnKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykudHJpZ2dlcignY2xvc2UuemYudHJpZ2dlcicpO1xcbiAgICB9XFxuICB9LFxcbiAgdG9nZ2xlTGlzdGVuZXI6IGZ1bmN0aW9uIHRvZ2dsZUxpc3RlbmVyKCkge1xcbiAgICB2YXIgaWQgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykuZGF0YSgndG9nZ2xlJyk7XFxuXFxuICAgIGlmIChpZCkge1xcbiAgICAgIHRyaWdnZXJzKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKSwgJ3RvZ2dsZScpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS50cmlnZ2VyKCd0b2dnbGUuemYudHJpZ2dlcicpO1xcbiAgICB9XFxuICB9LFxcbiAgY2xvc2VhYmxlTGlzdGVuZXI6IGZ1bmN0aW9uIGNsb3NlYWJsZUxpc3RlbmVyKGUpIHtcXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgdmFyIGFuaW1hdGlvbiA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS5kYXRhKCdjbG9zYWJsZScpO1xcblxcbiAgICBpZiAoYW5pbWF0aW9uICE9PSAnJykge1xcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfbW90aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIk1vdGlvblxcXCJdLmFuaW1hdGVPdXQoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLCBhbmltYXRpb24sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS50cmlnZ2VyKCdjbG9zZWQuemYnKTtcXG4gICAgICB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykuZmFkZU91dCgpLnRyaWdnZXIoJ2Nsb3NlZC56ZicpO1xcbiAgICB9XFxuICB9LFxcbiAgdG9nZ2xlRm9jdXNMaXN0ZW5lcjogZnVuY3Rpb24gdG9nZ2xlRm9jdXNMaXN0ZW5lcigpIHtcXG4gICAgdmFyIGlkID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLmRhdGEoJ3RvZ2dsZS1mb2N1cycpO1xcbiAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoXFxcIiNcXFwiLmNvbmNhdChpZCkpLnRyaWdnZXJIYW5kbGVyKCd0b2dnbGUuemYudHJpZ2dlcicsIFtqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcyldKTtcXG4gIH1cXG59OyAvLyBFbGVtZW50cyB3aXRoIFtkYXRhLW9wZW5dIHdpbGwgcmV2ZWFsIGEgcGx1Z2luIHRoYXQgc3VwcG9ydHMgaXQgd2hlbiBjbGlja2VkLlxcblxcblRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRPcGVuTGlzdGVuZXIgPSBmdW5jdGlvbiAoJGVsZW0pIHtcXG4gICRlbGVtLm9mZignY2xpY2suemYudHJpZ2dlcicsIFRyaWdnZXJzLkxpc3RlbmVycy5CYXNpYy5vcGVuTGlzdGVuZXIpO1xcbiAgJGVsZW0ub24oJ2NsaWNrLnpmLnRyaWdnZXInLCAnW2RhdGEtb3Blbl0nLCBUcmlnZ2Vycy5MaXN0ZW5lcnMuQmFzaWMub3Blbkxpc3RlbmVyKTtcXG59OyAvLyBFbGVtZW50cyB3aXRoIFtkYXRhLWNsb3NlXSB3aWxsIGNsb3NlIGEgcGx1Z2luIHRoYXQgc3VwcG9ydHMgaXQgd2hlbiBjbGlja2VkLlxcbi8vIElmIHVzZWQgd2l0aG91dCBhIHZhbHVlIG9uIFtkYXRhLWNsb3NlXSwgdGhlIGV2ZW50IHdpbGwgYnViYmxlLCBhbGxvd2luZyBpdCB0byBjbG9zZSBhIHBhcmVudCBjb21wb25lbnQuXFxuXFxuXFxuVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZENsb3NlTGlzdGVuZXIgPSBmdW5jdGlvbiAoJGVsZW0pIHtcXG4gICRlbGVtLm9mZignY2xpY2suemYudHJpZ2dlcicsIFRyaWdnZXJzLkxpc3RlbmVycy5CYXNpYy5jbG9zZUxpc3RlbmVyKTtcXG4gICRlbGVtLm9uKCdjbGljay56Zi50cmlnZ2VyJywgJ1tkYXRhLWNsb3NlXScsIFRyaWdnZXJzLkxpc3RlbmVycy5CYXNpYy5jbG9zZUxpc3RlbmVyKTtcXG59OyAvLyBFbGVtZW50cyB3aXRoIFtkYXRhLXRvZ2dsZV0gd2lsbCB0b2dnbGUgYSBwbHVnaW4gdGhhdCBzdXBwb3J0cyBpdCB3aGVuIGNsaWNrZWQuXFxuXFxuXFxuVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZFRvZ2dsZUxpc3RlbmVyID0gZnVuY3Rpb24gKCRlbGVtKSB7XFxuICAkZWxlbS5vZmYoJ2NsaWNrLnpmLnRyaWdnZXInLCBUcmlnZ2Vycy5MaXN0ZW5lcnMuQmFzaWMudG9nZ2xlTGlzdGVuZXIpO1xcbiAgJGVsZW0ub24oJ2NsaWNrLnpmLnRyaWdnZXInLCAnW2RhdGEtdG9nZ2xlXScsIFRyaWdnZXJzLkxpc3RlbmVycy5CYXNpYy50b2dnbGVMaXN0ZW5lcik7XFxufTsgLy8gRWxlbWVudHMgd2l0aCBbZGF0YS1jbG9zYWJsZV0gd2lsbCByZXNwb25kIHRvIGNsb3NlLnpmLnRyaWdnZXIgZXZlbnRzLlxcblxcblxcblRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRDbG9zZWFibGVMaXN0ZW5lciA9IGZ1bmN0aW9uICgkZWxlbSkge1xcbiAgJGVsZW0ub2ZmKCdjbG9zZS56Zi50cmlnZ2VyJywgVHJpZ2dlcnMuTGlzdGVuZXJzLkJhc2ljLmNsb3NlYWJsZUxpc3RlbmVyKTtcXG4gICRlbGVtLm9uKCdjbG9zZS56Zi50cmlnZ2VyJywgJ1tkYXRhLWNsb3NlYWJsZV0sIFtkYXRhLWNsb3NhYmxlXScsIFRyaWdnZXJzLkxpc3RlbmVycy5CYXNpYy5jbG9zZWFibGVMaXN0ZW5lcik7XFxufTsgLy8gRWxlbWVudHMgd2l0aCBbZGF0YS10b2dnbGUtZm9jdXNdIHdpbGwgcmVzcG9uZCB0byBjb21pbmcgaW4gYW5kIG91dCBvZiBmb2N1c1xcblxcblxcblRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRUb2dnbGVGb2N1c0xpc3RlbmVyID0gZnVuY3Rpb24gKCRlbGVtKSB7XFxuICAkZWxlbS5vZmYoJ2ZvY3VzLnpmLnRyaWdnZXIgYmx1ci56Zi50cmlnZ2VyJywgVHJpZ2dlcnMuTGlzdGVuZXJzLkJhc2ljLnRvZ2dsZUZvY3VzTGlzdGVuZXIpO1xcbiAgJGVsZW0ub24oJ2ZvY3VzLnpmLnRyaWdnZXIgYmx1ci56Zi50cmlnZ2VyJywgJ1tkYXRhLXRvZ2dsZS1mb2N1c10nLCBUcmlnZ2Vycy5MaXN0ZW5lcnMuQmFzaWMudG9nZ2xlRm9jdXNMaXN0ZW5lcik7XFxufTsgLy8gTW9yZSBHbG9iYWwvY29tcGxleCBsaXN0ZW5lcnMgYW5kIHRyaWdnZXJzXFxuXFxuXFxuVHJpZ2dlcnMuTGlzdGVuZXJzLkdsb2JhbCA9IHtcXG4gIHJlc2l6ZUxpc3RlbmVyOiBmdW5jdGlvbiByZXNpemVMaXN0ZW5lcigkbm9kZXMpIHtcXG4gICAgaWYgKCFNdXRhdGlvbk9ic2VydmVyKSB7XFxuICAgICAgLy9mYWxsYmFjayBmb3IgSUUgOVxcbiAgICAgICRub2Rlcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS50cmlnZ2VySGFuZGxlcigncmVzaXplbWUuemYudHJpZ2dlcicpO1xcbiAgICAgIH0pO1xcbiAgICB9IC8vdHJpZ2dlciBhbGwgbGlzdGVuaW5nIGVsZW1lbnRzIGFuZCBzaWduYWwgYSByZXNpemUgZXZlbnRcXG5cXG5cXG4gICAgJG5vZGVzLmF0dHIoJ2RhdGEtZXZlbnRzJywgXFxcInJlc2l6ZVxcXCIpO1xcbiAgfSxcXG4gIHNjcm9sbExpc3RlbmVyOiBmdW5jdGlvbiBzY3JvbGxMaXN0ZW5lcigkbm9kZXMpIHtcXG4gICAgaWYgKCFNdXRhdGlvbk9ic2VydmVyKSB7XFxuICAgICAgLy9mYWxsYmFjayBmb3IgSUUgOVxcbiAgICAgICRub2Rlcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS50cmlnZ2VySGFuZGxlcignc2Nyb2xsbWUuemYudHJpZ2dlcicpO1xcbiAgICAgIH0pO1xcbiAgICB9IC8vdHJpZ2dlciBhbGwgbGlzdGVuaW5nIGVsZW1lbnRzIGFuZCBzaWduYWwgYSBzY3JvbGwgZXZlbnRcXG5cXG5cXG4gICAgJG5vZGVzLmF0dHIoJ2RhdGEtZXZlbnRzJywgXFxcInNjcm9sbFxcXCIpO1xcbiAgfSxcXG4gIGNsb3NlTWVMaXN0ZW5lcjogZnVuY3Rpb24gY2xvc2VNZUxpc3RlbmVyKGUsIHBsdWdpbklkKSB7XFxuICAgIHZhciBwbHVnaW4gPSBlLm5hbWVzcGFjZS5zcGxpdCgnLicpWzBdO1xcbiAgICB2YXIgcGx1Z2lucyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShcXFwiW2RhdGEtXFxcIi5jb25jYXQocGx1Z2luLCBcXFwiXVxcXCIpKS5ub3QoXFxcIltkYXRhLXlldGktYm94PVxcXFxcXFwiXFxcIi5jb25jYXQocGx1Z2luSWQsIFxcXCJcXFxcXFxcIl1cXFwiKSk7XFxuICAgIHBsdWdpbnMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIF90aGlzID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpO1xcblxcbiAgICAgIF90aGlzLnRyaWdnZXJIYW5kbGVyKCdjbG9zZS56Zi50cmlnZ2VyJywgW190aGlzXSk7XFxuICAgIH0pO1xcbiAgfSAvLyBHbG9iYWwsIHBhcnNlcyB3aG9sZSBkb2N1bWVudC5cXG5cXG59O1xcblxcblRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRDbG9zZW1lTGlzdGVuZXIgPSBmdW5jdGlvbiAocGx1Z2luTmFtZSkge1xcbiAgdmFyIHlldGlCb3hlcyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnW2RhdGEteWV0aS1ib3hdJyksXFxuICAgICAgcGx1Z05hbWVzID0gWydkcm9wZG93bicsICd0b29sdGlwJywgJ3JldmVhbCddO1xcblxcbiAgaWYgKHBsdWdpbk5hbWUpIHtcXG4gICAgaWYgKHR5cGVvZiBwbHVnaW5OYW1lID09PSAnc3RyaW5nJykge1xcbiAgICAgIHBsdWdOYW1lcy5wdXNoKHBsdWdpbk5hbWUpO1xcbiAgICB9IGVsc2UgaWYgKF90eXBlb2YocGx1Z2luTmFtZSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwbHVnaW5OYW1lWzBdID09PSAnc3RyaW5nJykge1xcbiAgICAgIHBsdWdOYW1lcy5jb25jYXQocGx1Z2luTmFtZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgY29uc29sZS5lcnJvcignUGx1Z2luIG5hbWVzIG11c3QgYmUgc3RyaW5ncycpO1xcbiAgICB9XFxuICB9XFxuXFxuICBpZiAoeWV0aUJveGVzLmxlbmd0aCkge1xcbiAgICB2YXIgbGlzdGVuZXJzID0gcGx1Z05hbWVzLm1hcChmdW5jdGlvbiAobmFtZSkge1xcbiAgICAgIHJldHVybiBcXFwiY2xvc2VtZS56Zi5cXFwiLmNvbmNhdChuYW1lKTtcXG4gICAgfSkuam9pbignICcpO1xcbiAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS5vZmYobGlzdGVuZXJzKS5vbihsaXN0ZW5lcnMsIFRyaWdnZXJzLkxpc3RlbmVycy5HbG9iYWwuY2xvc2VNZUxpc3RlbmVyKTtcXG4gIH1cXG59O1xcblxcbmZ1bmN0aW9uIGRlYm91bmNlR2xvYmFsTGlzdGVuZXIoZGVib3VuY2UsIHRyaWdnZXIsIGxpc3RlbmVyKSB7XFxuICB2YXIgdGltZXIsXFxuICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XFxuICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS5vZmYodHJpZ2dlcikub24odHJpZ2dlciwgZnVuY3Rpb24gKGUpIHtcXG4gICAgaWYgKHRpbWVyKSB7XFxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcXG4gICAgfVxcblxcbiAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgIGxpc3RlbmVyLmFwcGx5KG51bGwsIGFyZ3MpO1xcbiAgICB9LCBkZWJvdW5jZSB8fCAxMCk7IC8vZGVmYXVsdCB0aW1lIHRvIGVtaXQgc2Nyb2xsIGV2ZW50XFxuICB9KTtcXG59XFxuXFxuVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZFJlc2l6ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGRlYm91bmNlKSB7XFxuICB2YXIgJG5vZGVzID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCdbZGF0YS1yZXNpemVdJyk7XFxuXFxuICBpZiAoJG5vZGVzLmxlbmd0aCkge1xcbiAgICBkZWJvdW5jZUdsb2JhbExpc3RlbmVyKGRlYm91bmNlLCAncmVzaXplLnpmLnRyaWdnZXInLCBUcmlnZ2Vycy5MaXN0ZW5lcnMuR2xvYmFsLnJlc2l6ZUxpc3RlbmVyLCAkbm9kZXMpO1xcbiAgfVxcbn07XFxuXFxuVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZFNjcm9sbExpc3RlbmVyID0gZnVuY3Rpb24gKGRlYm91bmNlKSB7XFxuICB2YXIgJG5vZGVzID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCdbZGF0YS1zY3JvbGxdJyk7XFxuXFxuICBpZiAoJG5vZGVzLmxlbmd0aCkge1xcbiAgICBkZWJvdW5jZUdsb2JhbExpc3RlbmVyKGRlYm91bmNlLCAnc2Nyb2xsLnpmLnRyaWdnZXInLCBUcmlnZ2Vycy5MaXN0ZW5lcnMuR2xvYmFsLnNjcm9sbExpc3RlbmVyLCAkbm9kZXMpO1xcbiAgfVxcbn07XFxuXFxuVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZE11dGF0aW9uRXZlbnRzTGlzdGVuZXIgPSBmdW5jdGlvbiAoJGVsZW0pIHtcXG4gIGlmICghTXV0YXRpb25PYnNlcnZlcikge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICB2YXIgJG5vZGVzID0gJGVsZW0uZmluZCgnW2RhdGEtcmVzaXplXSwgW2RhdGEtc2Nyb2xsXSwgW2RhdGEtbXV0YXRlXScpOyAvL2VsZW1lbnQgY2FsbGJhY2tcXG5cXG4gIHZhciBsaXN0ZW5pbmdFbGVtZW50c011dGF0aW9uID0gZnVuY3Rpb24gbGlzdGVuaW5nRWxlbWVudHNNdXRhdGlvbihtdXRhdGlvblJlY29yZHNMaXN0KSB7XFxuICAgIHZhciAkdGFyZ2V0ID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKG11dGF0aW9uUmVjb3Jkc0xpc3RbMF0udGFyZ2V0KTsgLy90cmlnZ2VyIHRoZSBldmVudCBoYW5kbGVyIGZvciB0aGUgZWxlbWVudCBkZXBlbmRpbmcgb24gdHlwZVxcblxcbiAgICBzd2l0Y2ggKG11dGF0aW9uUmVjb3Jkc0xpc3RbMF0udHlwZSkge1xcbiAgICAgIGNhc2UgXFxcImF0dHJpYnV0ZXNcXFwiOlxcbiAgICAgICAgaWYgKCR0YXJnZXQuYXR0cihcXFwiZGF0YS1ldmVudHNcXFwiKSA9PT0gXFxcInNjcm9sbFxcXCIgJiYgbXV0YXRpb25SZWNvcmRzTGlzdFswXS5hdHRyaWJ1dGVOYW1lID09PSBcXFwiZGF0YS1ldmVudHNcXFwiKSB7XFxuICAgICAgICAgICR0YXJnZXQudHJpZ2dlckhhbmRsZXIoJ3Njcm9sbG1lLnpmLnRyaWdnZXInLCBbJHRhcmdldCwgd2luZG93LnBhZ2VZT2Zmc2V0XSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoJHRhcmdldC5hdHRyKFxcXCJkYXRhLWV2ZW50c1xcXCIpID09PSBcXFwicmVzaXplXFxcIiAmJiBtdXRhdGlvblJlY29yZHNMaXN0WzBdLmF0dHJpYnV0ZU5hbWUgPT09IFxcXCJkYXRhLWV2ZW50c1xcXCIpIHtcXG4gICAgICAgICAgJHRhcmdldC50cmlnZ2VySGFuZGxlcigncmVzaXplbWUuemYudHJpZ2dlcicsIFskdGFyZ2V0XSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAobXV0YXRpb25SZWNvcmRzTGlzdFswXS5hdHRyaWJ1dGVOYW1lID09PSBcXFwic3R5bGVcXFwiKSB7XFxuICAgICAgICAgICR0YXJnZXQuY2xvc2VzdChcXFwiW2RhdGEtbXV0YXRlXVxcXCIpLmF0dHIoXFxcImRhdGEtZXZlbnRzXFxcIiwgXFxcIm11dGF0ZVxcXCIpO1xcbiAgICAgICAgICAkdGFyZ2V0LmNsb3Nlc3QoXFxcIltkYXRhLW11dGF0ZV1cXFwiKS50cmlnZ2VySGFuZGxlcignbXV0YXRlbWUuemYudHJpZ2dlcicsIFskdGFyZ2V0LmNsb3Nlc3QoXFxcIltkYXRhLW11dGF0ZV1cXFwiKV0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgY2FzZSBcXFwiY2hpbGRMaXN0XFxcIjpcXG4gICAgICAgICR0YXJnZXQuY2xvc2VzdChcXFwiW2RhdGEtbXV0YXRlXVxcXCIpLmF0dHIoXFxcImRhdGEtZXZlbnRzXFxcIiwgXFxcIm11dGF0ZVxcXCIpO1xcbiAgICAgICAgJHRhcmdldC5jbG9zZXN0KFxcXCJbZGF0YS1tdXRhdGVdXFxcIikudHJpZ2dlckhhbmRsZXIoJ211dGF0ZW1lLnpmLnRyaWdnZXInLCBbJHRhcmdldC5jbG9zZXN0KFxcXCJbZGF0YS1tdXRhdGVdXFxcIildKTtcXG4gICAgICAgIGJyZWFrO1xcblxcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgLy9ub3RoaW5nXFxuICAgIH1cXG4gIH07XFxuXFxuICBpZiAoJG5vZGVzLmxlbmd0aCkge1xcbiAgICAvL2ZvciBlYWNoIGVsZW1lbnQgdGhhdCBuZWVkcyB0byBsaXN0ZW4gZm9yIHJlc2l6aW5nLCBzY3JvbGxpbmcsIG9yIG11dGF0aW9uIGFkZCBhIHNpbmdsZSBvYnNlcnZlclxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSAkbm9kZXMubGVuZ3RoIC0gMTsgaSsrKSB7XFxuICAgICAgdmFyIGVsZW1lbnRPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGxpc3RlbmluZ0VsZW1lbnRzTXV0YXRpb24pO1xcbiAgICAgIGVsZW1lbnRPYnNlcnZlci5vYnNlcnZlKCRub2Rlc1tpXSwge1xcbiAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcXG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcXG4gICAgICAgIGNoYXJhY3RlckRhdGE6IGZhbHNlLFxcbiAgICAgICAgc3VidHJlZTogdHJ1ZSxcXG4gICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogW1xcXCJkYXRhLWV2ZW50c1xcXCIsIFxcXCJzdHlsZVxcXCJdXFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH1cXG59O1xcblxcblRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRTaW1wbGVMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgJGRvY3VtZW50ID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGRvY3VtZW50KTtcXG4gIFRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRPcGVuTGlzdGVuZXIoJGRvY3VtZW50KTtcXG4gIFRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRDbG9zZUxpc3RlbmVyKCRkb2N1bWVudCk7XFxuICBUcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkVG9nZ2xlTGlzdGVuZXIoJGRvY3VtZW50KTtcXG4gIFRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRDbG9zZWFibGVMaXN0ZW5lcigkZG9jdW1lbnQpO1xcbiAgVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZFRvZ2dsZUZvY3VzTGlzdGVuZXIoJGRvY3VtZW50KTtcXG59O1xcblxcblRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRHbG9iYWxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgJGRvY3VtZW50ID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGRvY3VtZW50KTtcXG4gIFRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRNdXRhdGlvbkV2ZW50c0xpc3RlbmVyKCRkb2N1bWVudCk7XFxuICBUcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkUmVzaXplTGlzdGVuZXIoKTtcXG4gIFRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRTY3JvbGxMaXN0ZW5lcigpO1xcbiAgVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZENsb3NlbWVMaXN0ZW5lcigpO1xcbn07XFxuXFxuVHJpZ2dlcnMuaW5pdCA9IGZ1bmN0aW9uICgkLCBGb3VuZGF0aW9uKSB7XFxuICBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJvbkxvYWRcXFwiXSkoJCh3aW5kb3cpLCBmdW5jdGlvbiAoKSB7XFxuICAgIGlmICgkLnRyaWdnZXJzSW5pdGlhbGl6ZWQgIT09IHRydWUpIHtcXG4gICAgICBUcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkU2ltcGxlTGlzdGVuZXJzKCk7XFxuICAgICAgVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZEdsb2JhbExpc3RlbmVycygpO1xcbiAgICAgICQudHJpZ2dlcnNJbml0aWFsaXplZCA9IHRydWU7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgaWYgKEZvdW5kYXRpb24pIHtcXG4gICAgRm91bmRhdGlvbi5UcmlnZ2VycyA9IFRyaWdnZXJzOyAvLyBMZWdhY3kgaW5jbHVkZWQgdG8gYmUgYmFja3dhcmRzIGNvbXBhdGlibGUgZm9yIG5vdy5cXG5cXG4gICAgRm91bmRhdGlvbi5JSGVhcllvdSA9IFRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRHbG9iYWxMaXN0ZW5lcnM7XFxuICB9XFxufTtcXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9qcy9mb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnMuanM/XCIpfSxqcXVlcnk6ZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMpe2V2YWwoXCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfanF1ZXJ5X187XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vL2V4dGVybmFsXyU3QiUyMnJvb3QlMjI6JTVCJTIyalF1ZXJ5JTIyJTVELCUyMmFtZCUyMjolMjJqcXVlcnklMjIsJTIyY29tbW9uanMlMjI6JTIyanF1ZXJ5JTIyLCUyMmNvbW1vbmpzMiUyMjolMjJqcXVlcnklMjIlN0Q/XCIpfX0pfSk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar $ = __webpack_require__(0);\n$(document).foundation();\n(function () {\n  emailjs.init(\"user_sa0pTGfc3hpt7Sp6Iv7nw\");\n})();\n$(\"#email_form\").on('formvalid.zf.abide', function (e) {\n  e.preventDefault();\n  emailjs.sendForm('yahoo', 'template_contacto', '#email_form').then(function (response) {\n    console.log('SUCCESS!', response.status, response.text);\n    Swal.fire({\n      title: 'Mensaje enviado!',\n      message: 'Haga clic en el boton OK para continuar',\n      timer: 3000,\n      type: 'success'\n    }).then(function (value) {\n      console.log('hola');\n      document.getElementById(\"from_name\").value = \"\";\n      document.getElementById(\"email\").value = \"\";\n      document.getElementById(\"phone\").value = \"\";\n      document.getElementById(\"message_html\").value = \"\";\n      setTimeout(function () {\n        document.location = \"gracias.html\";\n      }, 3100);\n    });\n  }, function (error) {\n    console.log('FAILED...', error);\n    Swal.fire({\n      title: 'Mensaje no enviado!',\n      message: 'Haga clic en el boton OK para continuar',\n      type: 'error',\n      timer: 3000\n    });\n  });\n});\n$(document)\n// field element is invalid\n.on(\"invalid.zf.abide\", function (ev, elem) {\n  document.getElementById(ev.target.id + 'Error').classList.add('is-visible');\n}).on(\"valid.zf.abide\", function (ev, elem) {\n  var idName = ev.target.id;\n  if (document.getElementById(idName).checkValidity() && document.getElementById(idName + 'Error')) document.getElementById(idName + 'Error').classList.remove('is-visible');\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvYXBwLmpzPzllMGUiXSwibmFtZXMiOlsiJCIsInJlcXVpcmUiLCJkb2N1bWVudCIsImZvdW5kYXRpb24iLCJlbWFpbGpzIiwiaW5pdCIsIm9uIiwiZSIsInByZXZlbnREZWZhdWx0Iiwic2VuZEZvcm0iLCJ0aGVuIiwicmVzcG9uc2UiLCJjb25zb2xlIiwibG9nIiwic3RhdHVzIiwidGV4dCIsIlN3YWwiLCJmaXJlIiwidGl0bGUiLCJtZXNzYWdlIiwidGltZXIiLCJ0eXBlIiwidmFsdWUiLCJnZXRFbGVtZW50QnlJZCIsInNldFRpbWVvdXQiLCJsb2NhdGlvbiIsImVycm9yIiwiZXYiLCJlbGVtIiwidGFyZ2V0IiwiaWQiLCJjbGFzc0xpc3QiLCJhZGQiLCJpZE5hbWUiLCJjaGVja1ZhbGlkaXR5IiwicmVtb3ZlIl0sIm1hcHBpbmdzIjoiOztBQUFBLElBQU1BLElBQUlDLG1CQUFPQSxDQUFDLENBQVIsQ0FBVjtBQUNBRCxFQUFFRSxRQUFGLEVBQVlDLFVBQVo7QUFDQSxDQUFDLFlBQVU7QUFDVEMsVUFBUUMsSUFBUixDQUFhLDRCQUFiO0FBQ0QsQ0FGRDtBQUdBTCxFQUFFLGFBQUYsRUFBaUJNLEVBQWpCLENBQW9CLG9CQUFwQixFQUEwQyxVQUFTQyxDQUFULEVBQVk7QUFDcERBLElBQUVDLGNBQUY7QUFDQUosVUFBUUssUUFBUixDQUFpQixPQUFqQixFQUEwQixtQkFBMUIsRUFBK0MsYUFBL0MsRUFDQ0MsSUFERCxDQUNNLFVBQVNDLFFBQVQsRUFBbUI7QUFDdEJDLFlBQVFDLEdBQVIsQ0FBWSxVQUFaLEVBQXdCRixTQUFTRyxNQUFqQyxFQUF5Q0gsU0FBU0ksSUFBbEQ7QUFDQUMsU0FBS0MsSUFBTCxDQUFVO0FBQ1RDLGFBQU0sa0JBREc7QUFFVEMsZUFBUSx5Q0FGQztBQUdUQyxhQUFPLElBSEU7QUFJVEMsWUFBSztBQUpJLEtBQVYsRUFLR1gsSUFMSCxDQUtRLFVBQUNZLEtBQUQsRUFBUztBQUNmVixjQUFRQyxHQUFSLENBQVksTUFBWjtBQUNBWCxlQUFTcUIsY0FBVCxDQUF3QixXQUF4QixFQUFxQ0QsS0FBckMsR0FBMkMsRUFBM0M7QUFDQXBCLGVBQVNxQixjQUFULENBQXdCLE9BQXhCLEVBQWlDRCxLQUFqQyxHQUF1QyxFQUF2QztBQUNBcEIsZUFBU3FCLGNBQVQsQ0FBd0IsT0FBeEIsRUFBaUNELEtBQWpDLEdBQXVDLEVBQXZDO0FBQ0FwQixlQUFTcUIsY0FBVCxDQUF3QixjQUF4QixFQUF3Q0QsS0FBeEMsR0FBOEMsRUFBOUM7QUFDQUUsaUJBQVksWUFBSTtBQUNkdEIsaUJBQVN1QixRQUFULEdBQWtCLGNBQWxCO0FBQ0QsT0FGRCxFQUVFLElBRkY7QUFHRCxLQWREO0FBZUYsR0FsQkQsRUFrQkcsVUFBU0MsS0FBVCxFQUFnQjtBQUNoQmQsWUFBUUMsR0FBUixDQUFZLFdBQVosRUFBeUJhLEtBQXpCO0FBQ0FWLFNBQUtDLElBQUwsQ0FBVTtBQUNUQyxhQUFNLHFCQURHO0FBRVRDLGVBQVEseUNBRkM7QUFHVEUsWUFBSyxPQUhJO0FBSVRELGFBQU87QUFKRSxLQUFWO0FBTUYsR0ExQkQ7QUEyQkQsQ0E3QkQ7QUE4QkFwQixFQUFFRSxRQUFGO0FBQ0U7QUFERixDQUVHSSxFQUZILENBRU0sa0JBRk4sRUFFMEIsVUFBU3FCLEVBQVQsRUFBWUMsSUFBWixFQUFrQjtBQUN4QzFCLFdBQVNxQixjQUFULENBQXdCSSxHQUFHRSxNQUFILENBQVVDLEVBQVYsR0FBYSxPQUFyQyxFQUE4Q0MsU0FBOUMsQ0FBd0RDLEdBQXhELENBQTRELFlBQTVEO0FBQ0QsQ0FKSCxFQUtHMUIsRUFMSCxDQUtNLGdCQUxOLEVBS3dCLFVBQVNxQixFQUFULEVBQVlDLElBQVosRUFBa0I7QUFDdEMsTUFBTUssU0FBU04sR0FBR0UsTUFBSCxDQUFVQyxFQUF6QjtBQUNBLE1BQUc1QixTQUFTcUIsY0FBVCxDQUF3QlUsTUFBeEIsRUFBZ0NDLGFBQWhDLE1BQW1EaEMsU0FBU3FCLGNBQVQsQ0FBd0JVLFNBQU8sT0FBL0IsQ0FBdEQsRUFDRS9CLFNBQVNxQixjQUFULENBQXdCVSxTQUFPLE9BQS9CLEVBQXdDRixTQUF4QyxDQUFrREksTUFBbEQsQ0FBeUQsWUFBekQ7QUFDSCxDQVRIIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XHJcbiQoZG9jdW1lbnQpLmZvdW5kYXRpb24oKTtcclxuKGZ1bmN0aW9uKCl7XHJcbiAgZW1haWxqcy5pbml0KFwidXNlcl9zYTBwVEdmYzNocHQ3U3A2SXY3bndcIik7XHJcbn0pKCk7XHJcbiQoXCIjZW1haWxfZm9ybVwiKS5vbignZm9ybXZhbGlkLnpmLmFiaWRlJywgZnVuY3Rpb24oZSkge1xyXG4gIGUucHJldmVudERlZmF1bHQoKTtcclxuICBlbWFpbGpzLnNlbmRGb3JtKCd5YWhvbycsICd0ZW1wbGF0ZV9jb250YWN0bycsICcjZW1haWxfZm9ybScpXHJcbiAgLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICBjb25zb2xlLmxvZygnU1VDQ0VTUyEnLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnRleHQpO1xyXG4gICAgIFN3YWwuZmlyZSh7XHJcbiAgICAgIHRpdGxlOidNZW5zYWplIGVudmlhZG8hJyxcclxuICAgICAgbWVzc2FnZTonSGFnYSBjbGljIGVuIGVsIGJvdG9uIE9LIHBhcmEgY29udGludWFyJyxcclxuICAgICAgdGltZXI6IDMwMDAsXHJcbiAgICAgIHR5cGU6J3N1Y2Nlc3MnXHJcbiAgICAgfSkudGhlbigodmFsdWUpPT57XHJcbiAgICAgICBjb25zb2xlLmxvZygnaG9sYScpO1xyXG4gICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmcm9tX25hbWVcIikudmFsdWU9XCJcIjtcclxuICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZW1haWxcIikudmFsdWU9XCJcIjtcclxuICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGhvbmVcIikudmFsdWU9XCJcIjtcclxuICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibWVzc2FnZV9odG1sXCIpLnZhbHVlPVwiXCI7XHJcbiAgICAgICBzZXRUaW1lb3V0KCAoKT0+e1xyXG4gICAgICAgICBkb2N1bWVudC5sb2NhdGlvbj1cImdyYWNpYXMuaHRtbFwiO1xyXG4gICAgICAgfSwzMTAwKTtcclxuICAgICB9KTtcclxuICB9LCBmdW5jdGlvbihlcnJvcikge1xyXG4gICAgIGNvbnNvbGUubG9nKCdGQUlMRUQuLi4nLCBlcnJvcik7XHJcbiAgICAgU3dhbC5maXJlKHtcclxuICAgICAgdGl0bGU6J01lbnNhamUgbm8gZW52aWFkbyEnLFxyXG4gICAgICBtZXNzYWdlOidIYWdhIGNsaWMgZW4gZWwgYm90b24gT0sgcGFyYSBjb250aW51YXInLFxyXG4gICAgICB0eXBlOidlcnJvcicsXHJcbiAgICAgIHRpbWVyOiAzMDAwXHJcbiAgICAgfSk7XHJcbiAgfSk7XHJcbn0pO1xyXG4kKGRvY3VtZW50KVxyXG4gIC8vIGZpZWxkIGVsZW1lbnQgaXMgaW52YWxpZFxyXG4gIC5vbihcImludmFsaWQuemYuYWJpZGVcIiwgZnVuY3Rpb24oZXYsZWxlbSkge1xyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZXYudGFyZ2V0LmlkKydFcnJvcicpLmNsYXNzTGlzdC5hZGQoJ2lzLXZpc2libGUnKTtcclxuICB9KVxyXG4gIC5vbihcInZhbGlkLnpmLmFiaWRlXCIsIGZ1bmN0aW9uKGV2LGVsZW0pIHtcclxuICAgIGNvbnN0IGlkTmFtZSA9IGV2LnRhcmdldC5pZDtcclxuICAgIGlmKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkTmFtZSkuY2hlY2tWYWxpZGl0eSgpICYmIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkTmFtZSsnRXJyb3InKSlcclxuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWROYW1lKydFcnJvcicpLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLXZpc2libGUnKTtcclxuICB9KSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY3NzL2FwcC5zY3NzPzczNTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6\n")}]);